
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<div class="tt_article_useless_p_margin"><p></p><div class="txc-textbox" style="margin: 0px; padding: 10px; border: 1px solid rgb(254, 137, 67); line-height: 15px; font-family: '맑은 고딕', 돋움, Dotum, AppleGothic, sans-serif; color: rgb(0, 0, 0); background-color: rgb(254, 222, 199);"><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3; font-size: 12pt;"><span style="font-size: 12pt;">이 글은 http://ciere.com/cppnow12/lambda.pdf 에서 가져왔고 한국말로 번역되었습니다. 또한 저의 개인적인 C++ 능력 향상과 '</span><a title="[http://itguru.tistory.com/notice/107]로 이동합니다." target="_blank" href="http://itguru.tistory.com/notice/107" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3; text-decoration: underline; color: rgb(138, 138, 138);"><span style="font-size: 12pt;">저의 모토인 지식 전파</span></a><span style="font-size: 12pt;">'&nbsp;</span></span><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3; font-size: 12pt;">를 위해 모든 이들에게 공개하도록 하겠습니다.</span></div><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3; font-family: '맑은 고딕', 돋움, Dotum, AppleGothic, sans-serif; color: rgb(0, 0, 0); font-size: 18pt;"><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3; font-family: Verdana;"><br style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3; font-family: '맑은 고딕', 돋움, Dotum, AppleGothic, sans-serif;"><div class="txc-textbox" style="margin: 0px; padding: 10px; border: 1px solid rgb(159, 211, 49); line-height: 1.3; font-family: '맑은 고딕', 돋움, Dotum, AppleGothic, sans-serif; background-color: rgb(231, 253, 181);"><span style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3; font-size: 12pt;"><b style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3;"><span style="font-size: 12pt;">이 글을 이해하기 위해서는 초보 이상의 C++ 지식이 필요합니다.</span></b><p style="margin-right: 0px; margin-left: 0px; padding-right: 0px; padding-left: 0px; border: 0px; line-height: 1.3; padding-top: 0px !important; padding-bottom: 0px !important;"><span style="font-size: 12pt;">아직 C++ 에 친숙하지 않다면&nbsp;</span><a title="[http://itguru.tistory.com/135]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135" style="margin: 0px; padding: 0px; border: 0px; line-height: 1.3; text-decoration: underline; color: rgb(138, 138, 138);"><span style="font-size: 12pt;">씹어먹는 C++ 강좌</span></a><span style="font-size: 12pt;">는 어때요?</span></p></span></div></span></span><p></p><div><br></div><p><span style="font-size: 12pt;">안녕하세요? 이 글은 지난번에 우측값 레퍼런스에 관련한 글에 이어서 두 번째로 쓰는 C++ 토막글 입니다. C++ 토막글에서는 주로 C++ 11 에 추가된 최신 기술들을 다루고 있는데요, 아직 국내에 자료가 많이 부족하다 보니 체계적으로 쓰인 외국 자료들을 번역하는 형태로 제공하고 있습니다. 이 글은&nbsp;http://ciere.com/cppnow12/lambda.pdf 에 올라온 pdf 자료를 바탕으로 번역된 글입니다. 사실 이 pdf 는 내용은 없고 소스만 있는&nbsp;발표 자료이지만, 제가 발표자가 되었다고&nbsp;가정해서 내용을 소개해보고자 합니다. 이 글이 C++ 11 의 강력한 기술인 Lambda 를 이해하는데 많은 도움이 되기를 바라겠습니다&nbsp;:)&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><p><br></p><p></p><div><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p><span style="font-size: 12pt;">
</span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;서론</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">어떤 벡터의 원소들의 모든 곱을 계산하는 코드를 구성한다고 생각해봅시다. 아마 가장 초보적으로 이 코드를 구성하는 방법은 아마 아래와 같을 것입니다.&nbsp;</span><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p><br></p><p></p><p></p><p></p><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">vector&lt;int&gt;::const_iterator iter = cardinal.begin();</span></div><div><span style="font-size: 12pt;">vector&lt;int&gt;::const_iterator iter_end = cardinal.end();</span></div><div><span style="font-size: 12pt;">int total_elements = 1;</span></div><div><span style="font-size: 12pt;">while( iter != iter_end )</span></div><div><span style="font-size: 12pt;">{</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">total_elements *= *iter;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">++iter;</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">위는 반복자(iterator) 를 이용해서 cardinal 이라는 vector&lt;int&gt; 의 각 원소들을 순차적으로 참조해가며 total_elements 에 곱해나가는 코드입니다. 아주 직관적이고 단순하지만, C++ 을 처음 배우는, 아직 C++ 의 기능을 전부 접해보지 못한 초보자 수준의 코드이겠죠?&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">만일 "나는 C++ 쫌 해" 정도 되는 사람이라는 Functor 를 이용해서 아래와 같은 코드를 짜냈을 것입니다.</span></div><div><br></div><div><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">int total_elements = 1;</span></div><div><span style="font-size: 12pt;">for_each( cardinal.begin(), cardinal.end(), product&lt;int&gt;(total_elements) );</span></div><div><span style="font-size: 12pt;">template &lt;typename T&gt;</span></div><div><span style="font-size: 12pt;">struct product</span></div><div><span style="font-size: 12pt;">{</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">product( T &amp; storage ) : value(storage) {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template&lt; typename V&gt;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void operator()( V &amp; v )</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">value *= v;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T &amp; value;</span></div><div><span style="font-size: 12pt;">};</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">위 코드는 C++ 고수 답게 for_each 와&nbsp;Functor 를 이용한 코드를 짜냈습니다. for_each 를 사용해서 이전 코드의 while 문 부분을 싸그리 없앨 수 있지만, 이를 위해 필요한 Functor 를 구성하는 코드가 훨씬 깁니다. 마치 배보다 배꼽이 더 큰 격이군요.&nbsp;물론 전체적인 코드의 질이 높아졌다고 볼 수 있지만, Functor 을 이용하기 위해 product 라는 구조체를 생성하면서 구질구질하게 생성자도 만들고, 또 void operator() 도 정의해주어야겠죠. 상당히 귀찮은 일이 아닐 수 없습니다.</span></div><div><br></div><div><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">int total_elements = 1;</span></div><div><span style="font-size: 12pt;">for_each( cardinal.begin(), cardinal.end(), [&amp;total_elements](int i){total_elements *= i;} );</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">자. 그럼 위 코드를 한번 봅시다. 짧고 간결하며, 무엇 보다도 while 문이나 functor 와 같은 구질구질한 코드 없이 깔끔하게 for_each 의 특징을 그대로 살려주었다고 볼 수 있습니다. 즉 Functor 에 들어갈 내용을 product 라는 구조체를 정의하면서 쭉 써내려갈 내용을 한 번에 깔끔하게 정리해놓은 것이지요. 이것이 바로 Lambda 의 위력입니다.</span></div><div><br></div><p></p><p><span style="font-size: 12pt;">간단히 Functor 를 이용한 코드와 Lambda 를 이용한 코드를 비교해 보아도 그 차이를 실감할 수 있을 것입니다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">// Functor 사용</span></p><p></p><p><span style="font-size: 12pt;">struct mod</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">mod(int m) : modulus(m) {}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int operator()(int v){ return v % modulus; }</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int modulus;</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">int my_mod = 8;</span></p><p><span style="font-size: 12pt;">transform( in.begin(), in.end(), out.begin(),</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">mod(my_mod) );</span></p></div><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">// Lambda 사용</span></p><p><span style="font-size: 12pt;">int my_mod = 8;</span></p><p><span style="font-size: 12pt;">transform( in.begin(), in.end(), out.begin(),</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">[my_mod](int v) -&gt;int</span></p><p><span style="font-size: 12pt;">{ return v % my_mod; } );</span></p></div><p><br></p><p><br></p><p><span style="font-size: 12pt;">
</span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;람다(Lambda)&nbsp;의 구성</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><span style="font-size: 12pt;">
</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">자 그럼 Lambda 를 사용하기 위해 Lambda 를 어떻게 C++ 에서 정의하는지 살펴보도록 합시다.</span></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/1152175050EB03B514?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1152175050EB03B514EB55 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1152175050EB03B514EB55 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1152175050EB03B514EB55 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1152175050EB03B514EB55 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1152175050EB03B514EB55 480w" src="https://t1.daumcdn.net/cfile/tistory/1152175050EB03B514" style="cursor: pointer;max-width:100%;height:auto" width="730" height="120" filename="lam.1.png" filemime="image/png"></span></span></p><p><span style="font-size: 12pt;">람다는 위 그림과 같이 4 개의 부분으로 구성되어 있습니다. 그 4 개의 부분은 각각 개시자 (introducer), 인자(parameters), 반환 타입 (return type), 그리고 함수의 몸통 (statement) 라 합니다. 일단, 람다 맨 처음에 나타나는 [] 는 개시자로, 그 안에 어떤 외부 변수를 써 넣는다면 람다 함수가 이를 Capture 해서, 이 변수를 람다 내부에서 이용할 수 있게 됩니다 (이에 대한 이야기는 뒤에서...) 위 경우 my_mod 라는 변수를 람다 내부에서 이용할 수 있게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그 다음의 () 는 람다가 실행시 받을 인자들을 써 넣습니다. 위 람다는 int 형의 v_ 를 인자로 받는 군요.&nbsp;여기는 그냥 실제로 함수에서 사용하는 인자 리스트와 동일하게 적어주면 됩니다. 이제, 그 옆으로 보면 -&gt; 가 있고 반환 타입을 적어주시면 됩니다. 위 람다의 경우 int 를 리턴합니다. 마지막으로 람다 내부에서 실행할 내용을 적어주면 되는데, 위 람다의 경우 v_ 와 my_mod 를 모듈러 연산해서 그 결과를 리턴하네요.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">만일 우리가</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">[my_mod](int v_)-&gt;int{return v_ % my_mod;}</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같이 코드 상에 Lambda 를 썼다고 해봅시다. 그러면 런타임시&nbsp;이름은 없지만, 메모리 상에</span><b><span style="font-size: 12pt;"> 임시적으로 존재하는 클로져 (Closure) 객체</span></b><span style="font-size: 12pt;">가 생성됩니다. 이 클로져 객체는 </span><b><span style="font-size: 12pt;">함수 객체(function object)</span></b><span style="font-size: 12pt;"> 처럼 행동합니다. (이러한 연유로 람다를 람다 함수라고 부르는 경우가 있습니다 - 사실 엄밀히 말하면 클로져 객체지 함수는 아닙니다)</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">[](){ cout &lt;&lt; "foo" &lt;&lt; endl; }()</span></p></div><p><br></p><p><span style="font-size: 12pt;">를 실행하였을 때 어떠한 결과가 나올까요? 일단&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">[](){ cout &lt;&lt; "foo" &lt;&lt; endl; }</span></p></div><p><br></p><p><span style="font-size: 12pt;">로 임시적인 클로져 객체가 생성되었는데 () 를 붙여서 바로 이 임시 클로져 객체를 실행시켜 버리지요.&nbsp;위 람다는 Capture 하는 변수들도 없고, 인자로 받는 것도 없고 리턴 타입도 없고 (참고로 리턴 타입이 void 일 경우 -&gt; 를 생각 가능합니다) 함수 몸통만 덜렁 있기에 특별히 생각할 것도 없이&nbsp;함수 몸통만 덜렁 실행되서</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:329px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F21748B4950EB08B1045CC5 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F21748B4950EB08B1045CC5 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F21748B4950EB08B1045CC5 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F21748B4950EB08B1045CC5 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F21748B4950EB08B1045CC5 480w" src="https://t1.daumcdn.net/cfile/tistory/21748B4950EB08B104" style="max-width:100%;height:auto" width="329" height="77" filename="lam2.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">라고 나오게 됩니다.</span></p><p><br></p><p><span style="font-size: 12pt;">그러면 조금 더 복잡한 예제를 살펴볼까요?</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">[](int v){cout &lt;&lt; v &lt;&lt; "*6=" &lt;&lt; v*6 &lt;&lt; endl;} (7);</span></p></div><p><br></p><p><span style="font-size: 12pt;">는 어떨까요.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp; [](int v){cout &lt;&lt; v &lt;&lt; "*6=" &lt;&lt; v*6 &lt;&lt; endl;}</span></p></div><p><br></p><p><span style="font-size: 12pt;">부분에서 인자로 v 를 받는 클로져가 생성되었는데, (7) 로 이 클로져에 인자로 7 을 전달시키면서 실행시켜버립니다. 따라서 모두가 예상 하였던 결과인</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:345px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2018AC3850EB090B0AB195 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2018AC3850EB090B0AB195 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2018AC3850EB090B0AB195 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2018AC3850EB090B0AB195 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2018AC3850EB090B0AB195 480w" src="https://t1.daumcdn.net/cfile/tistory/2018AC3850EB090B0A" style="max-width:100%;height:auto" width="345" height="96" filename="lam3.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">가 나오겠네요.</span><br></p><p><br></p><p><span style="font-size: 12pt;">람다 자체가 함수 처럼 자유롭게 사용할 수 있는 것이기 때문에 인자로 (당연히) 레퍼런스 들도 전달 가능합니다. 예를 들어</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 7;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">[](int &amp; v){ v*= 6; } (i);</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "the correct value is: " &lt;&lt; i &lt;&lt; endl;</span></p></div><p><br></p><p><span style="font-size: 12pt;">를 실행해보면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:330px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1809903350EB09F003B36C 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1809903350EB09F003B36C 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1809903350EB09F003B36C 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1809903350EB09F003B36C 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1809903350EB09F003B36C 480w" src="https://t1.daumcdn.net/cfile/tistory/1809903350EB09F003" style="max-width:100%;height:auto" width="330" height="99" filename="lam4.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">가 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">참고로 받는 인자가 없을 경우, 예컨대&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">[](){ cout &lt;&lt; "foo" &lt;&lt; endl; }&nbsp;</span></p></div><p><br></p><p><span style="font-size: 12pt;">의 경우 인자 () 를 생략 할 수 있습니다. 즉,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">[]{ cout &lt;&lt; "foo" &lt;&lt; endl; }</span></p></div><p><br></p><p><span style="font-size: 12pt;">도 동일한 의미입니다. (하지만 [] 는 지울 수 없습니다! )&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">
</span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;Capture</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="color: rgb(48, 88, 210); font-size: 12pt;">&nbsp;</span><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><span style="font-size: 12pt;">
</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">사실 많은 경우 우리의 람다 안에서 람다 밖에 있는 변수들에게 접근하고 싶을 때가 있을 것입니다. 물론 "그렇다면 그 변수들을 그냥 인자로 받아버리면 되자나!" 라고 반문할 수 도 있겠지만, for_each 나 fill, transform 등의 C++ 의 파워풀한 STL 을 수행하기 위해서는 인자들을 맞추어 주어야 하는데 이 때문에 함수 내부로 전하고 싶어도 전달하지 못하는 인자들이 있기 마련 입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 이를 방지하기 위해, 람다 내부와 소통할 수 있는 또다른 문, Capture 를 제공하고 있습니다. Capture 하고자 하는 내용은 앞에서 말했듯이 [] 안에 들어오게 되는데, 대표적으로 아래의 4 개의 형태들이 있습니다.</span></p><p><span style="font-size: 12pt;"><br></span></p><ol style="list-style-type: decimal;"><li><span style="font-size: 12pt;">[&amp;]() { . . . } 외부의 모든 변수들을 레퍼런스로 가져온다. (함수의 Call - by - reference 를 생각)</span></li><li><span style="font-size: 12pt;">[=]() { . . . } 외부의 모든 변수들을 값으로 가져온다. (함수의 Call - by - value 를 생각)</span></li><li><span style="font-size: 12pt;">[=, &amp;x, &amp;y] { . . . },&nbsp;[&amp;, x, y] { . . . }&nbsp;외부의 모든 변수들을 값/레퍼런스로 가져오되, x 와 y 만 레퍼런스/값으로 가져온다</span></li><li><span style="font-size: 12pt;">[x, &amp;y, &amp;z] { . . . } 지정한 변수들을 지정한 바에 따라 가져온다.&nbsp;</span></li></ol><div><br></div><div><span style="font-size: 12pt;">그렇다면 한 번 예제를 살펴볼까요.</span></div><div><br></div><div><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int total_elements = 1;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; cardinal;</span></div><div><br></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cardinal.push_back(1);</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cardinal.push_back(2);</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cardinal.push_back(4);</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cardinal.push_back(8);</span></div><div><br></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for_each( cardinal.begin(), cardinal.end(),[&amp;](int i){ total_elements*= i; } );</span></div><div><br></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "total elements : " &lt;&lt; total_elements &lt;&lt; endl;</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">위 코드에서 cardinal 에는 1, 2, 4, 8 이라는 원소들이 들어있고 그것을 for_each 를 통해 순회하면서 total_elements 에 곱하게 됩니다. 이 때 Capture 는 &amp; 로 이므로 total_elements 를 Capture 할 수 있고, 람다 외부 변수인 total_elements 를 성공적으로 바꿀 수 있었던 것이죠. 위 코드를 실행하면 예상하던대로</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:342px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F225BF04D50EB0D6502D937 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F225BF04D50EB0D6502D937 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F225BF04D50EB0D6502D937 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F225BF04D50EB0D6502D937 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F225BF04D50EB0D6502D937 480w" src="https://t1.daumcdn.net/cfile/tistory/225BF04D50EB0D6502" style="max-width:100%;height:auto" width="342" height="118" filename="lam5.png" filemime="image/png"></span></p><p><br></p><br></div><div><span style="font-size: 12pt;">가 나오게 됩니다.</span></div><div><br></div><div><span style="font-size: 12pt;">이번에는 조금 더 복잡한 예제를 살펴보도록 합시다.&nbsp;</span></div><div><br></div><div><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">template&lt; typename T &gt;</span></div><div><span style="font-size: 12pt;">void fill( vector&lt;int&gt; &amp; v, T done )</span></div><div><span style="font-size: 12pt;">{</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 0;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while( !done() )</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">v.push_back( i++ );</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">}</span></div><div><br></div><div><span style="font-size: 12pt;">vector&lt;int&gt; stuff;</span></div><div><span style="font-size: 12pt;">fill( stuff,</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">[&amp;]()-&gt;bool{ return stuff.size() &gt;= 8; } );</span></div><div><br></div><div><span style="font-size: 12pt;">for_each (stuff.begin(), stuff.end(), [](int i) {cout &lt;&lt; i &lt;&lt; " " ;});</span></div></div><div><br></div></div><div><span style="font-size: 12pt;">참고로 클로져 객체는 분명 특정 타입의 객체 이므로 위와 같이 template 에서 typename T 로 받을 수 있습니다. 위의 fill 함수는 특정 타입 T 의 변수 done 으로 클로져 객체를 받았습니다. 이 때, 클로져 객체 자체는 이미 stuff 를 Capture 해서 stuff 에 대한 레퍼런스를 계속 가지고 있는 상태이고, fill 의 while 문에서 돌면서 stuff 의 크기가 8 이하 일 때 까지 수행되게 됩니다. 따라서</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:506px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1707A94C50EB0EA003B06B 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1707A94C50EB0EA003B06B 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1707A94C50EB0EA003B06B 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1707A94C50EB0EA003B06B 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1707A94C50EB0EA003B06B 480w" src="https://t1.daumcdn.net/cfile/tistory/1707A94C50EB0EA003" style="max-width:100%;height:auto" width="506" height="122" filename="lam6.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">로 출력됩니다.</span><br></p><p><br></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">void fill( vector&lt;int&gt; &amp; v, T done )</span></div><div><span style="font-size: 12pt;">{</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 0;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while( !done() )</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">v.push_back( i++ );</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">}</span></div><div><br></div><div><span style="font-size: 12pt;">vector&lt;int&gt; stuff;</span></div><div><br></div><div><span style="font-size: 12pt;">fill( stuff,</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">[&amp;]()-&gt;bool{ int sum=0;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for_each( stuff.begin(), stuff.end(),</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">[&amp;](int i){ sum += i; } );</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return sum &gt;= 10;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">);</span></div><div><span style="font-size: 12pt;">for_each (stuff.begin(), stuff.end(), [](int i) {cout &lt;&lt; i &lt;&lt; " " ;});</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">머리를 쫌만 굴려보면, 현재 stuff 의 원소 합이 10 이하일 때 까지 stuff 의 원소를 추가하는 람다라고 볼 수 있습니다.</span></div><div><span style="font-size: 12pt;">당연히 그 결과는</span></div><p></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:376px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1306BC4C50EB0FDD05EF5B 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1306BC4C50EB0FDD05EF5B 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1306BC4C50EB0FDD05EF5B 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1306BC4C50EB0FDD05EF5B 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1306BC4C50EB0FDD05EF5B 480w" src="https://t1.daumcdn.net/cfile/tistory/1306BC4C50EB0FDD05" style="max-width:100%;height:auto" width="376" height="83" filename="lam7.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">&nbsp;한 가지 흥미로운 점은 Capture 를 레퍼런스가 아닌 값으로 할 때 언제 Capture 가 되냐는 것입니다.</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int v = 42;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto func = [=]{ cout &lt;&lt; v &lt;&lt; endl; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">v = 8;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">func();</span><br></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">과연 위 소스에서 v 는 func 이 처음 정의될 때, 즉 클로져 객체가 생성될 때 Capture 될까요, 아니면 func 이 실행될 때 일까요? 만일 전자라면 42 가 출력될 것이고 후자라면 8 이 출력될 것입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">과연!</span></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:372px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1907E73550EB10780D78B0 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1907E73550EB10780D78B0 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1907E73550EB10780D78B0 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1907E73550EB10780D78B0 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1907E73550EB10780D78B0 480w" src="https://t1.daumcdn.net/cfile/tistory/1907E73550EB10780D" style="max-width:100%;height:auto" width="372" height="161" filename="lam8.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">&nbsp;</span></p><p></p><p><span style="font-size: 12pt;">흥미롭게도 람다는 클로져 객체가 처음 생성될때 변수들의 값을 Capture 합니다.</span></p><p><br></p><p><span style="font-size: 12pt;">Capture 를 값으로 할 때 주의점은 그 변수들에는 자동으로 const 속성이 붙는 다는 것입니다. 즉 값으로 Capture 시 그 변수들의 내용을 바꿀 수 없습니다. 따라서 아래와 같은 코드는</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 10;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto two_i = [=]()-&gt;int{ i*= 2; return i; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "2i:" &lt;&lt; two_i() &lt;&lt; " i:" &lt;&lt; i &lt;&lt; endl;</span></p></div><p><br></p><p><span style="font-size: 12pt;">컴파일 오류 " <i>'i': a by-value capture cannot be modified in a non-mutable lambda</i> " 가 나게 됩니다. 위 코드에서 i 는 분명히 값으로 받았으므로 const 인데, i *= 2 를 통해 i 의 값을 바꾸려 하고 있으니 오류가 발생한 것입니다. 하지만, 함수 내부에서 i 의 값을 바꾸고자 하면 어떨까요? (물론 실제 외부의 i 의 값은 바뀌지 않습니다... 함수 내부에서만 - 마치 지역 변수처럼 말이죠)&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">답은 간단합니다. 람다에 mutable 속성을 추가해주면 됩니다.</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 10;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto two_i = [=]() mutable -&gt;int{ i*= 2; return i; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "2i:" &lt;&lt; two_i() &lt;&lt; " i:" &lt;&lt; i &lt;&lt; endl;</span></p></div><p><br></p><p><span style="font-size: 12pt;">이로써 람다 내부에서 i 의 값을 변경할 수 있습니다. 물론, 다시 말하지만 외부의 i 의 값이 바뀌는 것이 아닙니다. 오직 람다 함수 내에서 &nbsp;'어떤 다른 i ' 의 값이 두 배가 되는 것이지요. 그 결과</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:402px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2464234B50EB12140C1189 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2464234B50EB12140C1189 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2464234B50EB12140C1189 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2464234B50EB12140C1189 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2464234B50EB12140C1189 480w" src="https://t1.daumcdn.net/cfile/tistory/2464234B50EB12140C" style="max-width:100%;height:auto" width="402" height="110" filename="lam9.png" filemime="image/png"></span></p><p><br></p><p></p><p></p><p><span style="font-size: 12pt;">로 나타남을 알 수 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">이제 그럼 조금 복잡한 코드를 살펴볼까요.</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">class gorp</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; values;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int m_;</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">gorp(int mod) : m_(mod) {}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">gorp&amp; put(int v){ values.push_back(v); return *this; }</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int extras()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">int count = 0;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for_each( values.begin(), values.end(),</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">[=,&amp;count](int v){ count += v % m_; } );</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return count;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">gorp g(4);</span></p><p><span style="font-size: 12pt;">g.put(3).put(7).put(8);</span></p><p><span style="font-size: 12pt;">cout &lt;&lt; "extras: " &lt;&lt; g.extras();</span></p></div><p></p><p></p><p><br></p><p><span style="font-size: 12pt;">사실 위 코드는 상당히 재미있는 코드입니다. extras 함수를 호출하면 람다가 각 원소를 4 로 나눈 나머지들의 합을 구해서 더해주는데요, 한 가지 궁금한점! 과연 람다에서 어떻게 m_ 을 capture 할 수 있었을까요? 람다는 여기서 암묵적으로 (implicit) 클래스의 this 를 Capture&nbsp;했기 때문에 m_ 을 접근할 수 있었던 것입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 위 코드는</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:435px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F027A864E50EB146609F056 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F027A864E50EB146609F056 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F027A864E50EB146609F056 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F027A864E50EB146609F056 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F027A864E50EB146609F056 480w" src="https://t1.daumcdn.net/cfile/tistory/027A864E50EB146609" style="max-width:100%;height:auto" width="435" height="103" filename="lam10.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">으로 성공적인 결과를 보여줍니다.</span></p><p><br></p><p><span style="font-size: 12pt;">이렇게 this 를 암묵적으로 Capture 할 수 있기에 아래와 같은 놀라운 일도 발생할 수 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">struct foo</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">foo() : i(0) {}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void amazing(){ [=]{ i=8; }(); }</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i;</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">foo f;</span></p><p><span style="font-size: 12pt;">f.amazing();</span></p><p><span style="font-size: 12pt;">cout &lt;&lt; "f.i : " &lt;&lt; f.i;</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 코드를 언뜻 보면 i 를 값으로 capture 햇는데 어떻게 8 을 대입할 수 있냐고 물을 수 있는데, 사실 this 를 Capture&nbsp;해서 this.i = 8 을 통해 mutable 없이도 값을 바꿀 수 있습니다. 왜냐하면 분명&nbsp;this.i = 8 에서 상수인 this 를 변경한 것은 아니기 때문이죠.</span><br></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">
</span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;Capture 의 범위</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><font face="굴림"></font><span style="font-size: 12pt;">
</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">Capture 되는 개체들은 모두 람다가 정의된 위치에서 접근 가능해야만&nbsp;합니다. 예를 들어</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 8;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">int j = 2;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">auto f = [=]{ cout &lt;&lt; i/j; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">f();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">의 코드는 람다의 위치에서 i, j 모두 접근 가능하기 때문에&nbsp;Capture 가능하므로 정상적으로</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:372px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 480w" src="https://t1.daumcdn.net/cfile/tistory/187C4C3650EB825320" style="max-width:100%;height:auto" width="372" height="80" filename="lam12.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">가 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 아래 코드는 어떨까요?</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int i = 8;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto f =</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[i]()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">int j = 2;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">auto m = [=]{ cout &lt;&lt; i/j; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">m();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">};</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">f();</span></p></div><p><br></p><p><span style="font-size: 12pt;">바깥의 람다에서 i 를 Capture 하였기에, 바깥의 람다 몸통 안에서 i 를 사용할 수 있겠지요. 따라서 내부의 람다는 i 를 Capture 할 수 있게 됩니다. 그렇기에, 위와 동일한 결과인</span><br></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:372px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728 480w" src="https://t1.daumcdn.net/cfile/tistory/187C4C3650EB825320" style="max-width:100%;height:auto" width="372" height="80" filename="lam12.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">가 나오게 됩니다. 하지만, 만일 바깥의 람다에서 i 를 Capture 하지 않았다면 어떨까요.</span><br></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 8;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto f =</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[]()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">int j = 2;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">auto m = [=]{ cout &lt;&lt; i/j; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">m();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">};</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">f();</span></p></div><p><br></p><p><span style="font-size: 12pt;">그러면 예상했던 대로 컴파일 오류<i>&nbsp;error C3493: 'i' cannot be implicitly captured because no default capture mode has been specified</i> 가 나오게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">조금 더 복잡한 예로 아래의 코드를 살펴봅시다.</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 8;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto f =</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[=]()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">int j = 2;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">auto m = [&amp;]{ i /= j; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">m();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">cout &lt;&lt; "inner: " &lt;&lt; i;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">};</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">f();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; " outer: " &lt;&lt; i;</span></p></div><p><br></p><p><span style="font-size: 12pt;">일단 바깥의 람다는 i 를 값으로 Capture 하였기 때문에 바깥의 람다(f) 몸통에서는 i 에 const 속성이 붙습니다. 그런데, 내부의 람다(m)&nbsp;가 그 i 를 레퍼런스로 Capture 해서 값을 변경하려고 했습니다. 그렇다면, 당연히 오류가 나겠지요. 실제로 컴파일 오류<i>&nbsp;'i': a by-value capture cannot be modified in a non-mutable lambda </i>가 발생하게 됩니다.</span></p><p><br></p><p><span style="font-size: 12pt;">이를 해결하려면, 당연히도 mutable 속성을 붙여주면 됩니다.&nbsp;</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 8;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto f =</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[i]() mutable</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">int j = 2;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">auto m = [&amp;, j]() mutable{ i /= j; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">m();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">cout &lt;&lt; "inner: " &lt;&lt; i;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">};</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">f();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; " outer: " &lt;&lt; i;</span></p></div><p><br></p><p><span style="font-size: 12pt;">i 자체가 값으로 입력 되었기 때문에 outer i 의 값은 바뀌지 않고 8 로 남아 있고, 값으로 받은 i 가 m 에 의해서 2 로 나눠지므로 4 가 됩니다. 따라서, 그 결과&nbsp;</span></p><p></p><p></p><p></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:466px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F131AC44150EB84D7352A7C 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F131AC44150EB84D7352A7C 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F131AC44150EB84D7352A7C 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F131AC44150EB84D7352A7C 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F131AC44150EB84D7352A7C 480w" src="https://t1.daumcdn.net/cfile/tistory/131AC44150EB84D735" style="max-width:100%;height:auto" width="466" height="136" filename="lam13.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">로 나오게 되죠.</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">
</span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;클로져 객체의 복사 생성자와 소멸자</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><font face="굴림"></font><span style="font-size: 12pt;">
</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">모든 클로져 객체들은 암묵적으로 정의된 복사 생성자(copy constructor)와 소멸자(destructor)를 가지고 있습니다. 이 때 클로져 객체가 복사 생성 될 때 값으로 Capture 된 것들의 복사 생성이 일어나겠지요. 아래의 예를 한번 보도록 하겠습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">일단&nbsp;</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">struct trace</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">trace() : i(0) { cout &lt;&lt; "construct\n"; }</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">trace(trace const &amp;) { cout &lt;&lt; "copy construct\n"; }</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~trace() { cout &lt;&lt; "destroy\n"; }</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">trace&amp; operator=(trace&amp;) { cout &lt;&lt; "assign\n"; return *this;}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같이 생성, 복사 생성, 소멸, 그리고 대입 연산을 확인할 수 있는 trace 라는 구조체를 정의해놓고&nbsp;</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">trace t;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 8;</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto f = [=]() { return i / 2; };</span></p></div><p><br></p><p><span style="font-size: 12pt;">를 한다면 어떻게 나올까요? f 에서 t 를 사용하지 않았으므로, t 를 Capture 하지 않게 됩니다. 따라서 그냥</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:334px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F261D453650EB88920DF3B7 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F261D453650EB88920DF3B7 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F261D453650EB88920DF3B7 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F261D453650EB88920DF3B7 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F261D453650EB88920DF3B7 480w" src="https://t1.daumcdn.net/cfile/tistory/261D453650EB88920D" style="max-width:100%;height:auto" width="334" height="121" filename="lam14.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">이 나오게 됩니다.</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 아래의 예는 어떨까요</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">trace t;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int i = 8;</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto m1 = [=]() { int i = t.i; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; " --- make copy --- " &lt;&lt; endl;</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto m2 = m1;</span></p></div><p><br></p><p><span style="font-size: 12pt;">먼저 m1 을 생성하면서, 람다가 t 를 Capture 하였으므로 t 의 복사 생성자가 호출되게 됩니다. 왜냐하면 값으로 받았기 때문이지요. 만일 레퍼런스로 받았다면 복사 생성자가 호출되지 않았을 것입니다 (확인해보세요!) 그리고 아래의 auto m2 = m1; 에서 클로져 객체의 복사 생성이 일어나는데, 이 때, 클로져 객체의 복사 생성자가 값으로 Capture 된 객체들을 똑같이 복사 생성 해주게 됩니다. 따라서 또 한번 t 의 복사 생성자가 호출되겠지요. 그 결과 아래와 같이 출력됩니다.</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:316px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197BFB3C50EB898B363D62 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197BFB3C50EB898B363D62 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197BFB3C50EB898B363D62 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197BFB3C50EB898B363D62 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197BFB3C50EB898B363D62 480w" src="https://t1.daumcdn.net/cfile/tistory/197BFB3C50EB898B36" style="max-width:100%;height:auto" width="316" height="197" filename="lam15.png" filemime="image/png"></span></p><p><br></p><p></p><p></p><p><br></p><p><br></p><p></p><div><span style="font-size: 12pt;">
</span><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;람다의 전달 및 저장</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><font face="굴림"></font><span style="font-size: 12pt;">
</span><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">람다를 저장 및 전달하는 방식으로 앞에서 두 가지 방법을 보았습니다. 바로</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template&lt;typename T&gt; void foo(T f)</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto f = []{};</span></p></div><p><br></p><p><span style="font-size: 12pt;">이지요. 우리가 만들어낸 클로져 객체의 타입이 정확히 무엇인지 몰라도 위와 같은 방법으로 성공적으로 처리할 수 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">또 다른 방법으로는 함수 포인터를 이용하는 방법이 있는데요, 이 경우 람다가 Capture 하는 것이 없어야만 합니다.&nbsp;</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef int(*f_type)(int);</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">f_type f = [](int i)-&gt;int{ return i+20; };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; f(8);</span></p></div><p><br></p><p><span style="font-size: 12pt;">(참고로 위 기능은 Visual Studio 2010 에서 지원되지 않습니다 - 그 후의 버전에서만 가능합니다)</span></p><p><br></p><p><span style="font-size: 12pt;">위 역시 성공적으로 28 을 출력함을 알 수 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">그런데, C++ 11 에서는 클로져 객체를 전달하고 또 저장할 수 있는 막강한 기능이 제공됩니다. 바로 std::function 인데요, 그 어떤 클로져 객체나 함수 등을 모두 보관할 수 있는 만능 저장소 입니다. (참고로 std::function 은 Visual Studio 2010 에서 &lt;functional&gt; 을 include 해야 합니다)</span></p><p></p><p><br></p><p></p></div><p></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">std::function&lt; int(std::string const &amp;) &gt; f;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">f = [](std::string const &amp; s)-&gt;int{ return s.size(); };</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int size = f("http://itguru.tistory.com");</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; size &lt;&lt; endl;&nbsp;</span></p></div><p><br></p><p><span style="font-size: 12pt;">std::function 은 위와 같이 std::function &lt; 반환 타입 ( 인자 ) &gt; 와 같은 형태로 쓰며, Capture 가 있어도 상관이 없습니다. 물론 위 코드는 실행하면&nbsp;</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:332px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1921313750EB9004276F3E 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1921313750EB9004276F3E 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1921313750EB9004276F3E 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1921313750EB9004276F3E 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1921313750EB9004276F3E 480w" src="https://t1.daumcdn.net/cfile/tistory/1921313750EB900427" style="max-width:100%;height:auto" width="332" height="113" filename="lam16.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 나오지요.</span></p><p><br></p><p><span style="font-size: 12pt;">이 std::function 을 통해 아래와 같이 재밌는 코드도 짤 수 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">std::function&lt;int(int)&gt; f1;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">std::function&lt;int(int)&gt; f2 =</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[&amp;](int i)-&gt;int</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">cout &lt;&lt; i &lt;&lt; " ";</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">if(i&gt;5) { return f1(i-2); }</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">};</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">f1 =</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[&amp;](int i)-&gt;int</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">cout &lt;&lt; i &lt;&lt; " ";</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return f2(++i);</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">};</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">f1(10);</span></p></div><p><br></p><p><span style="font-size: 12pt;">이것이 가능한 이유는 만일 auto 를 이용하였더라면 auto f1 을 한 시점에서 f1 이 명확히 구현이 되어야 컴파일러에서 타입을 추정할 수 있는데, 위와 같은 경우 f1 을 구현하려면 f2 를 먼저 구현해야 하고, 또 f2 를 구현하려면 다시 f1 을 먼저 구현해야 하는 순환적인 논리 딜레마에 빠지게 됩니다. 따라서 function 을 이용해서 f1 을 선언만 해 놓은 뒤, f2 를 구현하고, 다시 f1 을 구현하면 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">위 코드를 실행하면</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:427px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1507053350EB90CD276602 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1507053350EB90CD276602 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1507053350EB90CD276602 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1507053350EB90CD276602 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1507053350EB90CD276602 480w" src="https://t1.daumcdn.net/cfile/tistory/1507053350EB90CD27" style="max-width:100%;height:auto" width="427" height="121" filename="lam17.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 나옴을 알 수 있습니다.</span><br></p><p><br></p><p><span style="font-size: 12pt;">마찬가지로 아래와 같은 재귀 호출 함수도 구현할 수 있습니다.</span></p><p><br></p><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">std::function&lt;int(int)&gt; fact;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">fact =</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[&amp;fact](int n)-&gt;int</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">if(n==0){ return 1; }</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">else</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">				</span><span style="font-size: 12pt;">return (n *</span><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">fact(n-1));</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">};</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "factorial(4) : " &lt;&lt; fact(4) &lt;&lt; endl;</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 역시 auto 를 이용했더라면, 처음 Capture 부분에서 Capture 하는 대상의 타입이 명확히 정해지지 않은 상태이므로 컴파일러가 타입을 추정할 수 없게 됩니다. 하지만 function 을 이용해서 성공적으로 구현할 수 있습니다. 위 계산 결과는 당연히</span></p><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:314px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1309CB3950EB91601B0E2A 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1309CB3950EB91601B0E2A 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1309CB3950EB91601B0E2A 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1309CB3950EB91601B0E2A 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1309CB3950EB91601B0E2A 480w" src="https://t1.daumcdn.net/cfile/tistory/1309CB3950EB91601B" style="max-width:100%;height:auto" width="314" height="86" filename="lam18.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">가 나오겠지요.</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">
</span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;마치며</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><p></p><p><br></p><p><span style="font-size: 12pt;">C++ 에 새롭게 추가된 람다는 기존의 C++ 과 전혀 다른 새로운 개념 입니다. 하지만 람다를 이용하면 수십줄의 코드도 한 두 줄로 간추릴 수 있는, 엄청난 기능이 아닐 수 없습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이제 여러분들 손에는 람다라는 막강한 도구가 주어졌습니다. 이를 어떻게 사용하느냐는 여러분의 몫이지요 :)&nbsp;</span></p><p></p><p><br></p><p><span style="font-size: 12pt;">그리고 이런 훌륭한 강의를 제공해주신 Michael Caisse 님에게 감사의 말을 전합니다.&nbsp;</span></p><p></p><p></p><p></p><p><br></p><p><br></p><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_196" data-uoc-sc="" data-uoc-pcurl="http://itguru.tistory.com/196" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_196"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text screen_out">공감</span><span class="txt_like uoc-count">1</span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile6.uf.tistory.com/image/1152175050EB03B514EB55" data-title="씹어먹는 C++ 토막글 ② - 람다(lambda) 함수" data-description="이 글은 http://ciere.com/cppnow12/lambda.pdf 에서 가져왔고 한국말로 번역되었습니다. 또한 저의 개인적인 C++ 능력 향상과 '저의 모토인 지식 전파' 를 위해 모든 이들에게 공개하도록 하겠습니다. 이 글을 이.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/196" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="196"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/196&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++">C++</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/198?category=361027">씹어먹는 C++ - &lt;4 - 5. 내가 만드는 String 클래스&gt;</a>&nbsp;&nbsp;<span>(29)</span>
</th>
<td>
2013.08.15</td>
</tr>
<tr>
<th>
<a href="/197?category=361027">씹어먹는 C++ - &lt;4 - 4. 스타크래프트를 만들자 ② (const, static)&gt;</a>&nbsp;&nbsp;<span>(17)</span>
</th>
<td>
2013.05.26</td>
</tr>
<tr>
<th>
<a href="/196?category=361027" class="current">씹어먹는 C++ 토막글 ② - 람다(lambda) 함수</a>&nbsp;&nbsp;<span>(12)</span>
</th>
<td>
2013.01.08</td>
</tr>
<tr>
<th>
<a href="/188?category=361027">씹어먹는 C++ - &lt;4 - 3. 스타크래프트를 만들자 ① (복사 생성자, 소멸자)&gt;</a>&nbsp;&nbsp;<span>(41)</span>
</th>
<td>
2013.01.06</td>
</tr>
<tr>
<th>
<a href="/189?category=361027">씹어먹는 C++ 토막글 ① - Rvalue(우측값) 레퍼런스에 관해</a>&nbsp;&nbsp;<span>(6)</span>
</th>
<td>
2012.11.03</td>
</tr>
<tr>
<th>
<a href="/173?category=361027">씹어먹는 C++ - &lt;4 - 2. 클래스의 세계로 오신 것을 환영합니다. (함수의 오버로딩, 생성자) &gt;</a>&nbsp;&nbsp;<span>(42)</span>
</th>
<td>
2012.08.04</td>
</tr>
</tbody></table></div></div>
<br> <br>


					