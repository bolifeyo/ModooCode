
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<span style="font-size:14pt;"><span style="font-family: Verdana;"><div>
<div style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;" class="txc-textbox">
<span style="font-size: 12pt;">이 레퍼런스의 모든 내용은 <a title="[http://www.cplusplus.com/reference/iostream/]로 이동합니다." target="_blank" href="http://www.cplusplus.com/reference/iostream/">http://www.cplusplus.com/reference/</a> 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 &lt;&lt;The C++ 
Programming Language&gt;&gt; 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 '<a title="[http://itguru.tistory.com/notice/107]로 이동합니다." target="_blank" href="http://itguru.tistory.com/notice/107">저의 모토인 지식 전파</a>' </span><span style="font-size: 12pt;">를 위해 모든 이들에게 공개하도록 하겠습니다.</span>
</div>
<span style="font-size:18pt;"><span style="font-family: Verdana;"><br>
<div style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;" class="txc-textbox">
<span style="font-size: 12pt;">아직 C++ 에 친숙하지 않다면 <a title="[http://itguru.tistory.com/135]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135">씹어먹는 C++ 강좌</a>는 어때요?</span></div>
</span></span></div>
<br>
<span style="font-size: 18pt;">vector</span></span></span><br>
<div>
<div style="border-left: 200px solid rgb(0, 0, 0); padding: 3px 6px; background-color: rgb(232, 232, 232); width: 690px; font: bold 1pt/1 나눔고딕,Sans-serif; margin-bottom: 10px; height: 1px; color: rgb(255, 255, 255);">
<span style="font-size:10pt;"><span style="font-family: Batang;"></span></span></div>
<div style="line-height: 1.7;">
</div>
</div>
<br>
<span style="font-size: 12pt;">&nbsp;&nbsp; <span style="font-weight: bold;">벡터(vector) 는 헤더파일 &lt;vector&gt; 에 정의되어 있는 는 순차 컨테이너의 한 종류</span>로, 각각의 원소들이 선형으로 배열되어 있다.</span><br>
<br>
<span style="font-size: 12pt;">&nbsp; 벡터 컨테이너는 동적 배열로 구현되는데, 보통의 배열 처럼 벡터 컨테이너들도 각각의 원소들이 메모리 상에서 연속적으로 존재하게 된다. 이 때문에 벡터 컨테이너의 원소를 참조할 때 반복자(iterator) 을 이용해서 순차적으로 참조할 수 있고, 처음 원소의 부터의 상대적인 거리를 이용하여 접근할 수 도 있다. </span><br>
<br>
<span style="font-size: 12pt;">&nbsp; 하지만, 보통의 배열과는 달리 벡터 컨테이너는 스스로 공간을 할당하고, 크기를 확장할 수 있고, 또 줄일 수 도 있다. </span><br>
<br>
<span style="font-size: 12pt;">&nbsp; 벡터 컨테이너는 아래와 같은 장점을 가지고 있다. </span><br>
<br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">&nbsp;각각의 원소를 원소의 인덱스(index) 값으로 바로 참조 가능하다 (상수 시간이 소요)</span></li>
<li><span style="font-size: 12pt;">&nbsp;원소들을 임의의 순서로 접근할 수 있다. (선형 시간 소요)</span></li>
<li><span style="font-size: 12pt;">&nbsp;벡터 끝에 새로운 원소를 추가하거나 제거하기 (상수 시간 소요 - constant amortized time</span><span style="font-size: 12pt;"><sup class="footnote"><a id="footnote_link_175_1" href="#footnote_175_1" onmouseover="tistoryFootnote.show(this,175,1)" onmouseout="tistoryFootnote.hide(175,1)" style="color:#f9650d;font-family:Verdana,Sans-serif"><span style="display:none">[각주:</span>1<span style="display:none">]</span></a></sup></span><span style="font-size: 12pt;">)</span><br>
</li>
</ul>
<p><br>
</p>
<p><span style="font-size: 12pt;">&nbsp; 벡터는 배열이 제공하는 거의 모든 기능을 다 가지고 있다. 게다가, 벡터 컨테이너의 크기는 쉽게 조정될 수 있기 때문에 매우 용이하다. 하지만 이러한 장점들 때문에 보통의 배열보다 더 많은 메모리 공간을 필요로 한다는 단점이 있다. </span><br>
</p>
<span style="font-size: 12pt;">&nbsp; 다른 표준 순차 컨테이너 (<a title="[http://itguru.tistory.com/176]로 이동합니다." target="_blank" href="http://itguru.tistory.com/176">deque</a>, <a title="[http://itguru.tistory.com/177]로 이동합니다." target="_blank" href="http://itguru.tistory.com/177">list</a>) 와 비교해 볼 때, 벡터는 원소에 접근하는 시간이나, 컨테이너의 끝에 새로운 원소를 삽입/삭제 하는데 매우 효율적이다. 반면에 끝이 아닌 중간에 새로운 원소를 삽입하는 작업은 <a title="[http://itguru.tistory.com/176]로 이동합니다." target="_blank" href="http://itguru.tistory.com/176">deque </a>나 <a title="[http://itguru.tistory.com/177]로 이동합니다." target="_blank" href="http://itguru.tistory.com/177">list </a>에 비해 느리다. </span><br>
<br>
<span style="font-size: 12pt;">&nbsp; 벡터 컨테이너는 내부적으로 공간을 관리하기 위해 두 개의 변수를 사용한다. 하나는 size 로 vector::size 함수를 통해서 그 값을 얻을 수 있는데, 이는 현재 벡터에 보관되어 있는 원소의 개수를 의미한다. 다른 하나는 capacity 로 vector::capacity 함수를 통해서 그 값을 얻을 수 있는데, 이는 벡터에 할당된 공간의 크기를 의미한다. 따라서 당연하게도, capacity 의 크기는 항상 size 보다 크게 조정되며, 만일 원소를 추가해서 size 의 크기가 capacity 를 넘어가 버리면 벡터 내부적으로 추가적인 공간을 할당하게 된다. 이 때 추가적으로 할당되는 공간은 많은 경우 현재 벡터 capacity 만큼 할당되어서 (즉, 전체 할당 크기가 이전의 두 배가 됨) 메모리 할당을 빈번하게 하는 경우를 최대한 줄이고, 사용하는 메모리 양도 줄이도록 최적화되어 있다.</span><br>
<br>
<span style="font-size: 12pt;">&nbsp; 벡터의 capacity 를 확장하는 작업은 꽤 많은 시간을 필요로 하는 작업이기 때문에 (왜냐하면 일단 메모리를 새로 할당해야 하고, 벡터의 내용을 새로운 장소에 복사해야 하기 때문이다) 만일 최적화가 필요한 경우 사용자는 직접 vector::reserve 함수를 이용해서 capacity 를 미리 크게 할당해 놓을 수 있다. &nbsp; </span><br>
<br>
<span style="font-size: 12pt;">&nbsp; C++ 표준 템플릿 라이브러리 (STL) 에서는 벡터를 다음과 같이 두 개의 템플릿 인자를 가지도록 구현하였다.</span><br>
<br>
<div style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;" class="txc-textbox">
<span style="font-size: 12pt;">template &lt; class T, class Allocator = allocator&lt;T&gt; &gt; class vector;</span></div>
<br>
<br>
<span style="font-size: 12pt;">&nbsp; 이 때 각각의 템플릿 인자는 다음을 의미한다.</span><br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">T : (보관하려는) 원소의 타입</span></li>
<li><span style="font-size: 12pt;">Allocator : 어떠한 방식으로 메모리를 할당할지에 관련한 할당자(allocator) 타입을 나타낸다. 기본값으로 T 의 할당자 클래스 템플릿을 사용하며, Heap 에 할당하게 된다. 많은 경우 인자를 생략한다.&nbsp;</span></li>
</ul>
<p><br>
</p>
<div>
<table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" bgcolor="#ffffff" cellpadding="1" cellspacing="1">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;벡터의 멤버 함수</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br>
</span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim">&nbsp;</span></span></td>
</tr>
</tbody></table>
<br>
<font face="굴림"></font>

</div>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;"><a title="[http://itguru.tistory.com/178]로 이동합니다." target="_blank" href="http://itguru.tistory.com/178">생성자</a> : 벡터를 생성한다.</span></li>
<li><span style="font-size: 12pt;">소멸자 : 벡터를 소멸한다.&nbsp;</span></li>
<li><span style="font-size: 12pt;">operator= : 벡터의 내용을 복사한다. </span><br>
</li>
</ul>
<br>
<span style="font-size: 12pt; font-weight: bold;">반복자 (Iterators)</span><br>
<br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">begin : 시작 부분 (벡터의 첫번째 원소) 을 가리키는 반복자를 리턴한다. </span><br>
</li>
<li><span style="font-size: 12pt;">end : 끝 부분 (벡터의 마지막 원소 바로 다음) 을 가리키는 반복자를 리턴한다.&nbsp;</span></li>
<li><span style="font-size: 12pt;">rbegin : 역순으로 첫번째 (즉, 벡터의 마지막 원소) 를 가리키는 반복자를 리턴한다.&nbsp;</span></li>
<li><span style="font-size: 12pt;">rend : 역순으로 끝 부분 (즉, 벡터의 첫번째 원소 바로 이전) 을 가리키는 반복자를 리턴한다. </span><br>
</li>
</ul>
<br>
<span style="font-size: 12pt; font-weight: bold;">할당 관련</span><br>
<br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">size : 벡터의 size 를 리턴한다 (현재 원소의 개수)</span></li>
<li><span style="font-size: 12pt;">max_size : 벡터 최대 크기를 리턴한다.</span></li>
<li><span style="font-size: 12pt;">resize : 벡터가 size 개의 원소를 포함하도록 변경한다.</span></li>
<li><span style="font-size: 12pt;">capacity : 벡터에 할당된 전체 크기를 리턴한다.&nbsp;</span></li>
<li><span style="font-size: 12pt;">empty : 벡터가 비었는지 체크한다.&nbsp;</span></li>
<li><span style="font-size: 12pt;">reserve : 벡터에 할당된 크기를 변경한다.</span><br>
</li>
</ul>
<br>
<span style="font-size: 12pt; font-weight: bold;">원소 접근 관련</span><br>
<br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">operator[] : 원소에 접근한다.</span></li>
<li><span style="font-size: 12pt;">at : 원소에 접근한다.&nbsp;</span></li>
<li><span style="font-size: 12pt;">front : 첫번째 원소에 접근한다.</span></li>
<li><span style="font-size: 12pt;">back : 마지막 원소에 접근한다. </span><br>
</li>
</ul>
<br>
<span style="font-size: 12pt; font-weight: bold;">수정자 (Modifier)</span><br>
<br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;"><a title="[http://itguru.tistory.com/183]로 이동합니다." target="_blank" href="http://itguru.tistory.com/183">assign</a> : 벡터의 원소를 집어넣는다.&nbsp;</span></li>
<li><span style="font-size: 12pt;"><a href="http://itguru.tistory.com/185" target="_blank" class="tx-link">push_back</a> : 벡터 끝에 원소를 집어 넣는다.</span></li>
<li><span style="font-size: 12pt;">pop_back : 마지막 원소를 제거한다.&nbsp;</span></li>
<li><span style="font-size: 12pt;"><a href="http://itguru.tistory.com/186" target="_blank" class="tx-link">insert</a> : 벡터 중간에 원소를 추가한다.&nbsp;</span></li>
<li><span style="font-size: 12pt;">erase : 원소를 제거한다.</span></li>
<li><span style="font-size: 12pt;">swap : 다른 벡터와 원소를 바꿔치기 한다. </span><br>
</li>
<li><span style="font-size: 12pt;">clear : 원소를 모두 제거한다. </span><br>
</li>
</ul>
<span style="font-size: 12pt;"><br>
<span style="font-weight: bold;">할당자</span></span><br>
<br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">get_allocator : 할당자(allocator) 을 얻는다.</span></li>
</ul>
<p><br>
</p>
<br>
<div>
<table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" bgcolor="#ffffff" cellpadding="1" cellspacing="1">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;멤버 변수들</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br>
</span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim">&nbsp;</span></span></td>
</tr>
</tbody></table>
<br>
<font face="굴림"></font>
<div>
</div>
<div>
</div>
</div>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">reference : Allocator::reference</span></li>
</ul>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">const_reference :&nbsp; Allocator::const_reference</span></li>
</ul>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">iterator :&nbsp; 임의 접근 반복자(random access iterator)</span></li>
</ul>
<p><br>
</p>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">const_iterator : 상수 임의 접근 반복자 (즉, 접근하는 원소의 내용을 수정 못함)</span></li>
</ul>
<p><br>
</p>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">size_type : 벡터 size 를 나타내는 타입 (많은 경우 size_t 와 타입이 같으며 부호없는 정수이다)</span></li>
</ul>
<p><br>
</p>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">difference_type : 벡터 내의 두 원소 사이의 거리를 나타내는 타입 (많은 경우 ptfdiff_t 와 타입이 같으며 부호있는 정수) <br>
</span></li>
</ul>
<p><br>
</p>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">value_type : 원소 타입 (T)</span></li>
<li><span style="font-size: 12pt;">allocator_type : 할당자</span></li>
<li><span style="font-size: 12pt;">pointer : 포인터 (Allocator::pointer)</span></li>
<li><span style="font-size: 12pt;">const_pointer : 상수 포인터 (Allocator::const_pointer)</span></li>
<li><span style="font-size: 12pt;">reverse_iterator :&nbsp; 역 반복자 (끝에서 부터 참조해나간다) reverse_iterator&lt;iterator&gt;</span></li>
<li><span style="font-size: 12pt;">const_reverse_iterator :&nbsp; 상수 역 반복자 (reverse_iterator&lt;const_iterator&gt;)</span><br>
</li>
</ul>
<br>
<div>
<table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" bgcolor="#ffffff" cellpadding="1" cellspacing="1">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;템플릿 특수화 (template specialization)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br>
</span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim">&nbsp;</span></span></td>
</tr>
</tbody></table>
<br>
<font face="굴림"></font>
<div>
</div>
<div>
</div>
<br>
</div>
<span style="font-size: 12pt;">&nbsp; 벡터 템플릿 클래스는 특별히 bool 타입에 대한 템플릿 특수화(specialization)를 가지고 있다.</span><br>
<br>
<span style="font-size: 12pt;">&nbsp; bool 만 특별하게 특수화 시킨 이유는 메모리 공간을 최적화 하기 위해 bool 원소가 한 개의 비트만 사용하도록 설계하였기 때문이다. (C++ 에서 최소 자료형의 크기는 8 비트 이다 - 즉 실제 bool 객체는 8 비트를 차지한다. ) 따라서 bool 원소의 레퍼런스는 bool&amp; 가 아니라, 아래와 같이 vector&lt;bool&gt; 에 특별히 정의되어 있는 멤버 변수를 통해 vector&lt;bool&gt; 의 단일 비트에 대한 조작을 수행할 수 있게 된다.</span><br>
<br>
<br>
<div style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;" class="txc-textbox">
<span style="font-size: 12pt;">class vector&lt;bool&gt;::reference {</span><br>
<span style="font-size: 12pt;">&nbsp; friend class vector;</span><br>
<span style="font-size: 12pt;">&nbsp; reference();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // public 생성자가 아니다</span><br>
<span style="font-size: 12pt;">public:</span><br>
<span style="font-size: 12pt;">&nbsp; ~reference();</span><br>
<span style="font-size: 12pt;">&nbsp; operator bool () const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bool 로 캐스팅 한다. </span><br>
<span style="font-size: 12pt;">&nbsp; reference&amp; operator= ( const bool x );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // bool 을 대입</span><br>
<span style="font-size: 12pt;">&nbsp; reference&amp; operator= ( const reference&amp; x );&nbsp; // 비트로 대입</span><br>
<span style="font-size: 12pt;">&nbsp; void flip();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 비트값 반전 (0 -&gt; 1, 1 -&gt; 0)</span><br>
<span style="font-size: 12pt;">}</span></div>
<br>
<br>
<span style="font-size: 12pt;">&nbsp;&nbsp; 이와 비슷한 컨테이너로 bitset 이 있다.</span><br>
<br>
<br><div class="footnotes">
<ol class="footnotes">
<li id="footnote_175_1">동적 배열 끝에 새로운 원소를 추가하는 경우를 생각해보자. 만일 이미 공간 자체가 할당되어 있으면 새로운 원소를 추가하는 일은 O(1) 일 것이다. 하지만, 공간이 할당되어 있지 않다면, 보통 2 배의 공간으로 다시 할당하게 되는데 이 때 시간이 O(n) 정도 들어가게 된다. 따라서 전체 평균적으로 볼 때 O(1) 정도의 상수 시간이 걸린다고 볼 수 있고 이러한 형태의 소요 시간을 constant amortized time 이라고 부른다.  <a href="#footnote_link_175_1">[본문으로]</a></li>
</ol>
</div>
<script type="text/javascript">
tistoryFootnote.add(175,1,"\ub3d9\uc801 \ubc30\uc5f4 \ub05d\uc5d0 \uc0c8\ub85c\uc6b4 \uc6d0\uc18c\ub97c \ucd94\uac00\ud558\ub294 \uacbd\uc6b0\ub97c \uc0dd\uac01\ud574\ubcf4\uc790. \ub9cc\uc77c \uc774\ubbf8 \uacf5\uac04 \uc790\uccb4\uac00 \ud560\ub2f9\ub418\uc5b4 \uc788\uc73c\uba74 \uc0c8\ub85c\uc6b4 \uc6d0\uc18c\ub97c \ucd94\uac00\ud558\ub294 \uc77c\uc740 O(1) \uc77c \uac83\uc774\ub2e4. \ud558\uc9c0\ub9cc, \uacf5\uac04\uc774 \ud560\ub2f9\ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ubcf4\ud1b5 2 \ubc30\uc758 \uacf5\uac04\uc73c\ub85c \ub2e4\uc2dc \ud560\ub2f9\ud558\uac8c \ub418\ub294\ub370 \uc774 \ub54c \uc2dc\uac04\uc774 O(n) \uc815\ub3c4 \ub4e4\uc5b4\uac00\uac8c \ub41c\ub2e4. \ub530\ub77c\uc11c \uc804\uccb4 \ud3c9\uade0\uc801\uc73c\ub85c \ubcfc \ub54c O(1) \uc815\ub3c4\uc758 \uc0c1\uc218 \uc2dc\uac04\uc774 \uac78\ub9b0\ub2e4\uace0 \ubcfc \uc218 \uc788\uace0 \uc774\ub7ec\ud55c \ud615\ud0dc\uc758 \uc18c\uc694 \uc2dc\uac04\uc744 constant amortized time \uc774\ub77c\uace0 \ubd80\ub978\ub2e4. ");
</script><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_175" data-uoc-sc="" data-uoc-pcurl="http://itguru.tistory.com/175" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_175"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text">공감</span><span class="txt_like uoc-count" style="display: none;"></span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="https://t1.daumcdn.net/cssjs/icon/557567EA016E200001" data-title="C++ 레퍼런스 - STL 컨테이너 - vector" data-description="이 레퍼런스의 모든 내용은 http://www.cplusplus.com/reference/ 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/175" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="175"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/175&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++%20Reference">C++ Reference</a>&nbsp;&gt;&nbsp;<a href="/category/C++%20Reference/STL%20Container">STL Container</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/183?category=391550">C++ 레퍼런스 - STL 컨테이너 - vector::assign 함수</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2012.03.25</td>
</tr>
<tr>
<th>
<a href="/178?category=391550">C++ 레퍼런스 - STL 컨테이너 - vector 생성자</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2012.03.25</td>
</tr>
<tr>
<th>
<a href="/177?category=391550">C++ 레퍼런스 - STL 컨테이너 - list</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2012.03.24</td>
</tr>
<tr>
<th>
<a href="/176?category=391550">C++ 레퍼런스 - STL 컨테이너 - deque</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2012.03.24</td>
</tr>
<tr>
<th>
<a href="/175?category=391550" class="current">C++ 레퍼런스 - STL 컨테이너 - vector</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2012.03.24</td>
</tr>
<tr>
<th>
<a href="/174?category=391550">C++ 레퍼런스 - STL 컨테이너 (STL Container)</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2012.03.24</td>
</tr>
</tbody></table></div>
<br> <br>


					