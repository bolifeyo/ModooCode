
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<div class="tt_article_useless_p_margin"><p><span style="font-size: 8pt;">이번 강좌에서는</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 10.6667px;">람다 함수(lambda function)</span></li><li><span style="font-size: 8pt;">정렬 알고리즘</span></li><li><span style="font-size: 8pt;">원소 삭제 알고리즘</span></li><li><span style="font-size: 8pt;">원소 탐색 알고리즘</span></li></ul><p><span style="font-size: 8pt;">등등에 대해 다룹니다.</span></p><hr><p></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/252F423D5973CE8C02?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F252F423D5973CE8C02A9B7 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F252F423D5973CE8C02A9B7 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F252F423D5973CE8C02A9B7 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F252F423D5973CE8C02A9B7 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F252F423D5973CE8C02A9B7 480w" src="https://t1.daumcdn.net/cfile/tistory/252F423D5973CE8C02" style="cursor: pointer;max-width:100%;height:auto" width="730" height="158" filename="__CODE____C___by_webblaster48.jpg" filemime="image/jpeg"></span></span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 12pt;">안녕하세요 여러분! 이번 강좌에서는 STL 의 알고리즘(algorithm) 라이브러리에 대해서 알아보도록 하겠습니다. 알고리즘 라이브러리는 앞선 강좌에서 이야기 했었던 대로, 컨테이너에 반복자들을 가지고 이런 저런 작업을 쉽게 수행할 수 있도록 도와주는 라이브러리 입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">여기서 말하는 이런 저런 작업이란, 정렬이나 검색과 같이 단순한 작업들 말고도, '이런&nbsp;조건이 만족하면 컨테이너에서 지워줘' 나 '이런 조건이 만족하면 1 을 더해' 와 같은 복잡한 명령의 작업들도 알고리즘 라이브러리를 통해 수행할 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">우리는 알고리즘에 정의되어 있는 여러가지 함수들로 작업을 수행하게 됩니다. 이 때 이 함수들은 크게 아래와 같은 두 개의 형태를 가지고 있습니다.</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void do_something (Iter begin, Iter end);</span></p></div><p><br></p><p><span style="font-size: 12pt;">거나</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename Iter, typename Pred&gt;</span></p><p><span style="font-size: 12pt;">void do_something (Iter begin, Iter end, Pred pred)</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같은 꼴을 따르고 있습니다. 전자의 경우, 알고리즘을 수행할 반복자의 시작점과 끝점 바로 뒤를 받고, 후자의 경우 반복자는 동일하게 받되, '특정한 조건' 을 추가 인자로 받게 됩니다. 이러한 '특정한 조건'을 서술자(Predicate) 이라고 부르며&nbsp;저기&nbsp;Pred 에는 보통 bool 을 리턴하는 함수 객체(Functor) 를 전달하게 됩니다. (이번 강좌에서 함수 객체를 매우 편리하게 만들어주는&nbsp;람다 함수에 대해 다룰 것입니다!)</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><font color="#3058d2" face="Gulim"><span style="font-size: 13.3333px;"><b><span style="font-size: 12pt;">&nbsp;정렬 (sort, stable_sort, partial_sort)</span></b></span></font></p></td><td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">첫번째로 알고리즘 라이브러리에서 지원하는 정렬(sort) 에 대해서 알아보도록 하겠습니다. 사실 정렬이라 하면 한 가지 밖에 없을 것 같은데 정렬 알고리즘에서는 무려 3&nbsp;가지 종류의 함수를 지원하고 있습니다. 이를 살펴보자면 각각 다음과 같습니다.</span></p><p><br></p><ul style="list-style-type: disc;"><li><span style="font-size: 12pt;">sort : 일반적인 정렬 함수라 생각하시면 됩니다.</span></li><li><span style="font-size: 12pt;">stable_sort : 정렬을 하되 원소들 간의 순서를 보존합니다. 이 말이 무슨 말이냐면, 만약에 벡터에 [a, b] 순으로 있었는데, a 와 b 가 크기가 같다면 정렬을 [a,b] 혹은 [b,a] 로 할 수 있습니다. sort 의 경우 그 순서가 랜덤으로 정해집니다. 하지만 stable_sort 의 경우 그 순서를 반드시 보존합니다. 즉 컨테이너 상에서 [a,b] 순으로 있엇다면 정렬 시에도 (크기가 같다면) [a,b] 순으로 나오게 됩니다. 이 때문에 sort 보다 좀 더 느립니다.</span></li><li><span style="font-size: 12pt;">partial_sort : 배열의 일부분만 정렬합니다 (아래 자세히 설명하겠습니다)</span></li></ul><div><br></div><div><span style="font-size: 12pt;">그렇다면 각각의 함수들을 사용해보도록 하겠습니다!</span></div><div><br><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *begin &lt;&lt; " ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(6);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(7);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "정렬 전 ----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">sort(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "정렬 후 ----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:262px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F247F2434596A50D706E894 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F247F2434596A50D706E894 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F247F2434596A50D706E894 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F247F2434596A50D706E894 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F247F2434596A50D706E894 480w" src="https://t1.daumcdn.net/cfile/tistory/247F2434596A50D706" style="max-width:100%;height:auto" width="262" height="117" filename="10.3.1.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">위와 같이 잘 정렬되서 나옴을 알 수 있습니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">sort(vec.begin(), vec.end());</span></p></div><p><br></p><p><span style="font-size: 12pt;">sort 함수는 위와 같이 정렬할 원소의 시작 위치와, 마지막 위치 바로 뒤를 반복자로 받습니다. 참고로 sort 에 들어가는 반복자의 경우 반드시 임의접근 반복자(RandomAccessIterator)&nbsp;타입을 만족해야 하므로, 우리가 봐왔던 컨테이너들 중에서 벡터와 데크만 가능하고 나머지 컨테이너는 sort 함수를 적용할 수 었습니다. (예를 들어 리스트의 경우 반복자 타입이 양방향 반복자(BidirectionalIterator) 이므로 안됩니다)</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">list&lt;int&gt; l;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">sort(l.begin(), l.end());</span></p></div><p><br></p><p><span style="font-size: 12pt;">만약에 위 처럼 리스트를 정렬하려고 했다간;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="font-size: 12pt;">Error</span><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">C2784</span><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">'unknown-type std::operator -(const std::move_iterator&lt;_RanIt&gt; &amp;,const std::move_iterator&lt;_RanIt2&gt; &amp;)': could not deduce template argument for 'const std::move_iterator&lt;_RanIt&gt; &amp;' from 'std::_List_unchecked_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;int&gt;&gt;'</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같은 무지막지한 컴파일 오류를 맛보게 될 것입니다!</span></p><p><br></p><p><span style="font-size: 12pt;">sort 함수는 기본적으로 오름차순으로 정렬을 해줍니다. 그렇다면 만약에 내림 차순으로 정렬하고 싶다면 어떻게 할까요? 만약에 여러분이 직접 만든 타입이였다면 단순히 operator&lt; 를 반대로 바꿔준다면 오름차순에서 내림차순이 되었겠지만, 이 경우 int 이기 때문에 이는&nbsp;불가능 합니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 앞서 대부분의 알고리즘은 3 번째 인자로 특정한 조건을 전달한다고 하였는데, 여기에 우리가 비교를 어떻게 수행할 것인지에 대해 알려주면 됩니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *begin &lt;&lt; " ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">struct int_compare {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator()(const int&amp; a, const int&amp; b)&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">const {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return a &gt; b;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(6);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(7);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "정렬 전 ----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">sort(vec.begin(), vec.end(), int_compare());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "정렬 후 ----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:246px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F26787847596A53AF08DEF7 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F26787847596A53AF08DEF7 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F26787847596A53AF08DEF7 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F26787847596A53AF08DEF7 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F26787847596A53AF08DEF7 480w" src="https://t1.daumcdn.net/cfile/tistory/26787847596A53AF08" style="max-width:100%;height:auto" width="246" height="125" filename="10.3.2.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 내림 차순으로 정렬되서 나옵니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">struct int_compare {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator()(const int&amp; a, const int&amp; b)&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">const {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return a &gt; b;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">일단 위와 같이 함수 객체를 위한 구조체를 정의해주시고, 그 안에 operator() 함수를 만들어주면 함수 객체 준비는 땡입니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">sort(vec.begin(), vec.end(), int_compare());</span></p></div><p><br></p><p><span style="font-size: 12pt;">그리고 위와 같이 생성된 함수 객체를 전달하면 됩니다. 그런데 말입니다. 사실 int 나 string 과 같은 기본 타입들은 모두 &lt; 혹은 &gt; 연산자들이 기본으로 내장되어 있습니다. 그렇다면 굳이 그렇게 귀찮게 함수 객체를 만들 필요는 없을 것 같습니다. 템플릿도 배운 마당에 그냥</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template&lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">struct greater_comp {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator()(const T&amp; a, const T&amp; b)&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">const {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return a &gt; b;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">요런게 있어서 굳이 귀찮게 int 따로 string 따로 만들 필요가 없을 것 같습니다. 다행이도 functional 해더에 다음과 같은 템플릿 클래스가 존재합니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">sort(vec.begin(), vec.end(), greater&lt;int&gt;());</span></p></div><p><br></p><p><span style="font-size: 12pt;">저 greater 에 우리가 사용하고자 하는 타입을 넣게 되면 위와 같은&nbsp;함수 객체를 자동으로 만들어줍니다. 물론 그 해당하는 타입의 &gt; 연산자가 존재해야겠지요. int 의 경우 기본 타입이기 때문에 당연히 존재합니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">다음으로 살펴볼 함수는 partial_sort 함수 입니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *begin &lt;&lt; " ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(6);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(7);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "정렬 전 ----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">partial_sort(vec.begin(), vec.begin() + 3, vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "정렬 후 ----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span><br></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:248px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2303CE37596AC6E10EF012 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2303CE37596AC6E10EF012 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2303CE37596AC6E10EF012 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2303CE37596AC6E10EF012 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2303CE37596AC6E10EF012 480w" src="https://t1.daumcdn.net/cfile/tistory/2303CE37596AC6E10E" style="max-width:100%;height:auto" width="248" height="129" filename="10.3.3.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다. 앞서 partial_sort 함수는 일부만 정렬하는 함수라고 하였습니다. partial_sort 는 인자를 아래와 같이 3 개를 기본으로 받습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">partial_sort(start, middle, end)</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 때 정렬을 [stard, end) 전체 원소들 중에서 [start, middle) 까지&nbsp;원소들이 전체 원소들 중에서 제일 작은애들 순으로 정렬 시킵니다. 예를 들어서 위 경우</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">partial_sort(vec.begin(), vec.begin() + 3, vec.end());</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">위와 같이 vec.begin() 부터 vec.end() 까지 (즉 벡터 전체에서) 원소들 중에서, vec.begin() 부터 vec.begin() + 3 까지에 전체에서 가장 작은 애들만 순서대로 저장하고 나머지 위치는 상관 없다! 이런 식입니다. 따라서 위와 같이</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(243, 197, 52); background-color: rgb(254, 254, 184); padding: 10px;"><p><span style="font-size: 12pt;">5 3 1 6 4 7 2</span></p></div><p><br></p><p><span style="font-size: 12pt;">에서 가장 작은 3개 원소인 1, 2, 3 만이 정렬되어서</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(243, 197, 52); background-color: rgb(254, 254, 184); padding: 10px;"><p><span style="font-size: 12pt;">1 2 3 6 5 7 4</span></p></div><p></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">앞에 나타나게 되고 나머지 원소들은 그냥 랜덤하게 남아있게 됩니다. 전체 원소의 개수가 N 개이고, 정렬하려는 부분의 크기가 M 이라면 partial_sort 의 복잡도는 O(N log M) 가 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">만약에 우리가 전체 배열을 정렬할 필요가 없을 경우, 예를 들어서 100 명의 학생 중에서 상위 10 명의 학생의 성적순을 보고 싶다, 이런 식이면 굳이 sort 로 전체를 정렬 할 필요 없이 partial_sort 로 10 개만 정렬 하는 것이 더 빠르게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">마지막으로 stable_sort 에 대해 살펴보도록 하겠습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">struct User</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string name;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int age;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">User(string name, int age)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">: name(name), age(age) {}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator&lt; (const User&amp; u) const {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return age &lt; u.age;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">ostream&amp; operator&lt;&lt; (ostream&amp; o, const User&amp; u) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">o &lt;&lt; u.name &lt;&lt; " , " &lt;&lt; u.age;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return o;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;User&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; 100; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string name = "";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">name.push_back('a' + i / 26);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">name.push_back('a' + i % 26);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.push_back(User(name, static_cast&lt;int&gt;(rand() % 10)));</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;User&gt; vec2 = vec;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "정렬 전 ----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">sort(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "정렬 후 ----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "stable_sort 의 경우 ---" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">stable_sort(vec2.begin(), vec2.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec2.begin(), vec2.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/226EDD3B596B133809?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F226EDD3B596B1338093545 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F226EDD3B596B1338093545 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F226EDD3B596B1338093545 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F226EDD3B596B1338093545 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F226EDD3B596B1338093545 480w" src="https://t1.daumcdn.net/cfile/tistory/226EDD3B596B133809" style="cursor: pointer;max-width:100%;height:auto" width="730" height="384" filename="10.3.4.png" filemime="image/png"></span></span></p><p><br></p></div><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">앞서 stable_sort 는 원소가 삽입되어 있는 순서를 보존하는 정렬 방식이라고 하였습니다. stable_sort 가 확실히 어떻게 sort 와 다른지 보여주기 위해서 다음과 같은 클래스를 만들었습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">struct User</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string name;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int age;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">User(string name, int age)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">: name(name), age(age) {}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator&lt; (const User&amp; u) const {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return age &lt; u.age;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 User 클래스는 name 과 age 를 멤버로 갖는데, 크기 비교는 이름과 관계없이 모두 age 로 하게 됩니다. 즉 age 가 같다면 크기가 같다고 볼 수 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; 100; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string name = "";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">name.push_back('a' + i / 26);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">name.push_back('a' + i % 26);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.push_back(User(name, static_cast&lt;int&gt;(rand() % 10)));</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">처음에 벡터에 원소들을 쭈르륵 삽입하는 부분인데, 이름은 aa, ab, ac, ... 순으로 하되 age 의 경우 0 부터 10 사이의 랜덤한 값을 부여하였습니다. 즉 name 의 경우 string 순서대로 되어있고, age 의 경우 랜덤한 순서로 되어 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">앞서 말했듯이 stable_sort 는 삽입되어 있던 원소들 간의 순서를 보존한다고 하였습니다. 따라서 같은 age 라면 반드시 삽입된 순서, 즉 name 순으로 나올 것입니다. (왜냐하면 애초에 name 순으로 넣었기 때문!)</span></p><p><br></p><p><span style="font-size: 12pt;">그 결과를 살펴보면 확연히 다름을 알 수 있습니다. 먼저 sort 의 경우</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">dh, ck, cx, ad, cw, cu, co</span></p></div><p><br></p><p><span style="font-size: 12pt;">순으로 나와 있고 (age 가 0 일 때) stable_sort 의 경우 age 가 0 일 때</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">ad, ck, co, cu, cw, cx, dh&nbsp;</span></p></div><p><br></p><p><span style="font-size: 12pt;">순으로 나오게 됩니다. 다시 말해 sort 함수의 경우 정렬 과정에서 원소들 간의 상대적 위치를 랜덤하게 바꿔버리지만 stable_sort 의 경우 그 순서를 처음에 넣었던 상태 그대로 유지함을 알 수 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">당연히도 이러한 제약 조건 때문에 stable_sort 는 그냥 sort 보다 좀 더 오래걸립니다. C++ 표준에 따르면 sort 함수는 최악의 경우에서도 O(n log n) 이 보장되지만 stable_sort 의 경우 최악의 경우에서 O(n (log n)^2) 으로 작동하게 됩니다. 조금 더 느린 편이지요.</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;원소 제거 (remove, remove_if)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">다음으로 살펴볼 함수는 원소를 제거하는 함수 입니다. 사실 이미 대부분의 컨테이너에서는 원소를 제거하는 함수를 지원하고 있습니다. 예를 들어서,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="font-size: 12pt;">// ....</span></p><p><span style="font-size: 12pt;">vec.erase(vec.begin() + 3);</span></p></div><p><br></p><p><span style="font-size: 12pt;">을 하게 되면, vec[3] 에 해당하는 원소를 제거하게 됩니다.&nbsp;</span></p><p></p><p><br></p><p><span style="font-size: 12pt;">그런데 사실 이 함수 하나로는 많은 작업들을 처리하기에 부족합니다. 예를 들어서 벡터에서 값이 3 인 원소를 제거하려면 어떻게 해야 할까요? 이전 강좌에서 다루었지만 아마 아래와 같이 할 수 있을 것입니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::iterator itr = vec.begin();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (; itr != vec.end(); itr ++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 20) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">vec.erase(itr);</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">itr = vec.begin();</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">이렇게 했던 이유는 바로 원소가 제거될 때 마다 기존에 제거하였던 반복자들이 초기화 되기 때문입니다. 따라서 해당 위치를 가리키는 반복자를 다시 가져와야 되지요. 물론 굳이 반복자를 쓰지 않고 그냥 일반 변수를 이용해서 배열을 다루듯이 처리할 수 도 있겠지만 '원소 접근은 반복자로 수행한다' 에 따른 약속에는 충실한 방법이 아닙니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 어떻게 이를 해결할 수 있을까요?</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 vec 상태 ------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "벡터에서 값이 3 인 원소 제거 ---" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove(vec.begin(), vec.end(), 3), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:264px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F24655B33596D9F901A91A1 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F24655B33596D9F901A91A1 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F24655B33596D9F901A91A1 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F24655B33596D9F901A91A1 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F24655B33596D9F901A91A1 480w" src="https://t1.daumcdn.net/cfile/tistory/24655B33596D9F901A" style="max-width:100%;height:auto" width="264" height="122" filename="10.3.5.png" filemime="image/png"></span></p><p><br></p><br></div><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">위 코드가 어떻게 작동하는지 설명하기에 앞서 erase 함수를 살펴보도록 합시다. 벡터의 erase 함수는 2 가지 형태가 있는데, 하나는 우리가 잘 알고 있는</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">Iterator erase (Iterator pos);</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같은 형태가 있고, 다른 하나는</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">Iterator erase(Iterator first, Iterator last);</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같은 형태가 있습니다. 전자의 경우 그냥 pos 가 가리키는 원소를 벡터에서 지우지만 후자의 경우 first 부터 last 사이에 있는 모든 원소들을 지우는 형태 입니다. 물론 이 두 함수 모두 우리의 목표인 '값이 3 인 원소 제거' 를 수행하는데 부족함이 있습니다. 물론 후자의 함수를 사용하면 좋겠지만, 값이 3 인 원소들이 벡터에서 연속적으로 존재하지 않기 때문이지요.</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 어떤 편리한 함수가 있어서 값이 3 인 원소들을 벡터에서 연속적으로 존재할 수 있게 해주면 어떨까요?</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/274D394B596DAF0E38?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F274D394B596DAF0E3878BF 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F274D394B596DAF0E3878BF 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F274D394B596DAF0E3878BF 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F274D394B596DAF0E3878BF 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F274D394B596DAF0E3878BF 480w" src="https://t1.daumcdn.net/cfile/tistory/274D394B596DAF0E38" style="cursor: pointer;max-width:100%;height:auto" width="730" height="1474" filename="10.3.6.png" filemime="image/png"></span></span></p><p><span style="font-size: 12pt;">위와 같이, 만일 값이 3 인 원소를 만나면 그 뒤에 있는 원소들로 쭈르륵 쉬프트 해주게 됩니다. 따라서, 자연스럽게 알고리즘이 끝나게 되면은 해당하는 위치에서 전 까지 3 이 제외된 원소들로 쭈르륵 채워지게 되겠지요.</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:689px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F236E4B4E596DB71722C406 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F236E4B4E596DB71722C406 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F236E4B4E596DB71722C406 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F236E4B4E596DB71722C406 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F236E4B4E596DB71722C406 480w" src="https://t1.daumcdn.net/cfile/tistory/236E4B4E596DB71722" style="max-width:100%;height:auto" width="689" height="564" filename="10.3.7.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">다시말해, 반복이 끝나는 위치 부터 벡터 맨 뒤 까지 제거해버리면 3 이 싹 제거된 벡터만 남게 되지요. remove 함수는 원소의 이동만을 수행하지 실제로 원소를 삭제하는 연산을 수행하지는 않습니다. 따라서 벡터에서 실제로 원소를 지우기 위해서는 반드시 erase 함수를 호출하여 실제로 원소를 지워줘야만 합니다.</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove(vec.begin(), vec.end(), 3), vec.end());</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_5_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">따라서 위 처럼 remove 함수를 이용해서 값이 3 인 원소들을 뒤로 보내버리고, 그 원소들을 벡터에서 삭제해버리게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">참고로 말하자면 remove 함수의 경우 반복자의 타입이 ForwardIterator 입니다. 즉, 벡터 뿐만이 아니라, 리스트, 혹은 셋이나 맵에서도 모두 사용할 수 있습니다!</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 이번에는 값이 딱 얼마로 정해진 것이 아니라 특정한 조건을 만족하는 원소들을 제거하려면 어떻게 해야 할까요? 당연히도 이 원소가 그 조건을 만족하는지 아닌지를 판단할 함수를 전달해야 됩니다. 이를 위해선 remove_if 함수를 사용해야 합니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">struct is_odd {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator()(const int&amp; i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return i % 2 == 1;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 vec 상태 ------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "벡터에서 홀수 인 원소 제거 ---" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(), is_odd()), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><p><br></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:267px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F270A7D4F596DC13035CC07 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F270A7D4F596DC13035CC07 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F270A7D4F596DC13035CC07 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F270A7D4F596DC13035CC07 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F270A7D4F596DC13035CC07 480w" src="https://t1.daumcdn.net/cfile/tistory/270A7D4F596DC13035" style="max-width:100%;height:auto" width="267" height="123" filename="10.3.8.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(), is_odd()), vec.end());</span></p></div><p><br></p><p><span style="font-size: 12pt;">remove_if 함수는 세번째 인자로 조건을 설명할 함수 객체를 전달받습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">struct is_odd {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator()(const int&amp; i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return i % 2 == 1;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같이 is_odd 구조체에 operator() 를 만들어서 함수 객체를 전달하시면 됩니다. 당연히도, 함수 객체로 실제 함수를 전달할 수 도 있습니다. 이 경우&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template&lt;typename Iter, typename Pred&gt;</span></p><p><span style="font-size: 12pt;">remove_if(Iter first, Iter last, Pred pred)</span></p></div><p><br></p><p><span style="font-size: 12pt;">에서 Pred 가 함수 포인터 타입이 되겠지요.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">bool odd(const int&amp; i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return i % 2 == 1;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 vec 상태 ------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "벡터에서 홀수 인 원소 제거 ---" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(), odd), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">위와 같이 실제 함수를 전달한다면 앞서 만들었던 함수 객체와 정확히 동일하게 동작합니다. 그렇다면 굳이 귀찮게 위와 같이 함수 객체를 사용할 이유가 있을까요? 물론 있습니다.</span></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">예를 들어서 홀수인 원소들을 삭제하되 처음 2개만 삭제한다고 해봅시다. 함수 객체의 경우 사실 클래스의 객체이기 때문에 멤버 변수를 생각할 수 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">struct is_odd {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int num_delete;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">is_odd() : num_delete(0) {}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator()(const int&amp; i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (num_delete &gt;= 2) return false;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (i % 2 == 1) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">num_delete++;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 vec 상태 ------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "벡터에서 홀수인 원소 앞의 2개 제거 ---" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(), is_odd()), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:300px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F23445F3D596DC7D932E721 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F23445F3D596DC7D932E721 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F23445F3D596DC7D932E721 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F23445F3D596DC7D932E721 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F23445F3D596DC7D932E721 480w" src="https://t1.daumcdn.net/cfile/tistory/23445F3D596DC7D932" style="max-width:100%;height:auto" width="300" height="120" filename="10.3.9.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">struct is_odd {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int num_delete;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">is_odd() : num_delete(0) {}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator()(const int&amp; i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (num_delete &gt;= 2) return false;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (i % 2 == 1) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">num_delete++;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">이것이 가능한 이유는 위 처럼 num_delete 라는 멤버 변수를 만들어서 몇 개를 지웠는지 카운트 하기 때문이지요. 물론 함수의 경우에도 static 변수를 이용하면 위와 같은 효과를 낼 수 있습니다. 하지만 여러개의 벡터에 저 작업을 하게 된다면 꽤나 골치아프겠지요. (호출할 때 마다 static 변수의 값을 0 으로 초기화 해줘야 합니다)</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 함수 객체를 이용하면 위 처럼 함수만으로는 쉽게 하지 못했던 일들을 손쉽게 처리할 수 있게 됩니다.&nbsp;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_6_expand" style="display:inline-table;border:none;height:183px;margin:0;padding:0;position:relative;visibility:visible;width:730px;background-color:transparent;"><ins id="aswift_6_anchor" style="display:block;border:none;height:183px;margin:0;padding:0;position:relative;visibility:visible;width:730px;background-color:transparent;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_6" name="aswift_6" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">그런데 한 가지 안좋은 점은 이렇게 STL 을 사용할 때 마다 외부에 클래스나 함수를 하나 씩 만들어줘야 된다는 점입니다. 물론 프로젝트의 크기가 작다면 크게 문제가 되지는 않겠지만 프로젝트의 크기가 커진다면, 만약 다른 사람이 코드를 읽을 때 '이 클래스는 뭐하는 거지?' 혹은 '이 함수는 뭐하는 거지?' 와 같은 궁금증이 생길 수 도 있고 심지어 잘못 사용할 수 도 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 가장 이상적인 방법은 STL 알고리즘을 사용할 때 그 안에 직접 써놓는 것입니다. 마치</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(), bool is_odd(int i) { return i % 2 == 1; }), vec.end());</span></p></div><p><br></p><p><span style="font-size: 12pt;">뭐 이런 식으로 말이지요. 문제는 위 문법이&nbsp;C++ 에서 허용되지 않다는 점입니다. 하지만 놀랍게도 C++ 11 부터 위 문제를 해결할 방법이 나타났습니다.</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210); height: 30px;" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210); height: 30px;" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;람다 함수(lambda function)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210) rgb(48, 88, 210) rgb(255, 70, 197); height: 30px;" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">람다 함수는 C++ 에서는 C++ 11 에서 처음으로 도입되었습니다. 람다 함수를 통해 쉽게 이름이 없는 함수 객체를 만들수 없게 되었습니다. 그렇습니다. </span><b><span style="font-size: 12pt;">익명의 함수 객체 말입니다</span></b><span style="font-size: 12pt;">!</span></p><p><br></p><p><span style="font-size: 12pt;">람다 함수를 사용한 예제 부터 먼저 살펴보겠습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 vec 상태 ------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "벡터에서 홀수인 원소 제거 ---" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(), [](int i) -&gt; bool { return i % 2 == 1; }), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:267px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2577DF3359703AE92B620A 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2577DF3359703AE92B620A 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2577DF3359703AE92B620A 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2577DF3359703AE92B620A 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2577DF3359703AE92B620A 480w" src="https://t1.daumcdn.net/cfile/tistory/2577DF3359703AE92B" style="max-width:100%;height:auto" width="267" height="123" filename="10.3.10.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span><br></p><p><br></p><p><span style="font-size: 12pt;">람다 함수를 정의한 부분부터 살펴보도록 합시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">[](int i) -&gt; bool { return i % 2 == 1; }</span></p></div><p><br></p><p><span style="font-size: 12pt;">람다 함수는 위와 같은 꼴로 정의됩니다. 일반적인 꼴을 살펴보자면</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">[capture list] (받는 인자) -&gt; 리턴 타입 { 함수 본체 }</span></p></div><br></div><p></p><p><span style="font-size: 12pt;">와 같은 형태 입니다. capture_list 가 뭔지는 아래에서 설명하도록 하고, 위 함수 꼴을 살펴보자면 인자로 int i 를 받고, bool 을 리턴하는 람다 함수를 정의한 것입니다. 리턴 타입을 생략한다면 컴파일러가 알아서 함수 본체에서 return 문을 보고 리턴 타입을 추측해줍니다. (만약에 return 경로가 여러군데여서 추측할 수 없다면 컴파일 오류가 발생하지요)&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">리턴 타입을 생략할 경우</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">[capture list] ( 받는 인자) {함수 본체}</span></p></div><p><br></p><p><span style="font-size: 12pt;">이런 식으로 더 간단히 쓸 수 있습니다. 위 예제의 경우</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">[](int i) {return i % 2 == 1; }&nbsp;</span></p></div><p><br></p><p><span style="font-size: 12pt;">로 쓴다면 알아서 "아 bool 타입을 리턴하는 함수구나" 라고 컴파일러가 만들어줍니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">앞서 람다 함수가 이름이 없는 함수라 했는데 실제로 위를 보면 함수에 이름이 붙어 있지 않습니다! 즉 임시적으로 함수를 생성한 것이지요. 만약에 이 함수를 사용하고 싶다면</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">[](int i) {return i % 2 == 1; }(3); // true</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같이 그냥 바로 호출할 수 도 있고</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">auto func = [](int i) {return i % 2 == 1; };</span></p><p><span style="font-size: 12pt;">func(4); // false;</span></p></div><p><br></p><p><span style="font-size: 12pt;">람다 함수로&nbsp;func 이라는 함수 객체를 생성한&nbsp;후에 호출할 수 도 있지요.&nbsp;</span></p><div><br></div><p><span style="font-size: 12pt;">하지만 람다 함수도 말 그대로 함수 이기 때문에 자기 자신만의 스코프를 가집니다. 따라서 일반적인 상황이라면 함수 외부에서 정의된 변수들을 사용할 수 없겠지요. 예를 들어서 최대 2 개 원소만 지우고 싶은 경우</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "벡터에서 홀수인 원소 최대 2 개 제거 ---" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int num_erased = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(),</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[](int i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (num_erased &gt;= 2) return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">else if (i % 2 == 1) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">num_erased++;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같이 람다 함수 외부에 몇 개를 지웠는지 변수를 정의한 뒤에 사용해야만 하는데 (함수 안에 정의하면 함수 호출될 때 마다 새로 생성되니까요!) 문제는 그 변수에 접근할 수 없다는 점입니다. 하지만 놀랍게도 람다 함수의 경우 그 변수에 접근할 수 있습니다. 바로 캡쳐 목록(capture_list)을 사용하는 것입니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 vec 상태 ------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "벡터에서 홀수인 원소 ---" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int num_erased = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(),</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">[&amp;num_erased](int i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (num_erased &gt;= 2) return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">else if (i % 2 == 1) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">num_erased++;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:277px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2205F5485970470C1C5FA7 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2205F5485970470C1C5FA7 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2205F5485970470C1C5FA7 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2205F5485970470C1C5FA7 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2205F5485970470C1C5FA7 480w" src="https://t1.daumcdn.net/cfile/tistory/2205F5485970470C1C" style="max-width:100%;height:auto" width="277" height="121" filename="10.3.11.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">와 같이 잘 됨을 알 수 있습니다.</span><br></p><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp;[&amp;num_erased](int i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (num_erased &gt;= 2) return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">else if (i % 2 == 1) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">num_erased++;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">})</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같이 캡쳐 목록에는 어떤 변수를 캡쳐할 지 써주면 됩니다. 위 경우 num_erased 를 캡쳐하였습니다. 즉 람다 함수 내에서 num_erased 를 마치 같은 스코프 안에 있는 것 처럼 사용할 수 있게 됩니다.</span></p><p><br></p><p><span style="font-size: 12pt;">이 때 num_erased 앞에 &amp; 가 붙어있는데 이는 실제 num_erased 의 레퍼런스를 캡쳐한다는 의미입니다. 즉 함수 내부에서 num_erased 의 값을 바꿀 수 있게 되지요. 만약에 아래처럼</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">[num_erased](int i){</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (num_erased &gt;= 2) return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">else if (i % 2 == 1) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">num_erased++;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">})</span></p></div><p><br></p><p><span style="font-size: 12pt;">&amp; 를 앞에 붙이지 않는다면 num_erased 의 복사본을 얻게 되는데, 그 복사본의 형태는 const 입니다. 따라서 위 처럼 함수 내부에서 num_erased 의 값을 바꿀 수 없게 되지요. 그렇다면 클래스의 멤버 함수 안에서 람다를 사용할 때 멤버 변수들을 참조하려면 어떻게 해야 할까요?</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">class SomeClass {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int num_erased;</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">SomeClass() {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">num_erased = 1;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(), [&amp;num_erased](int i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">if (num_erased &gt;= 2) return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">else if (i % 2 == 1) {</span></p><p><span style="white-space: pre; font-size: 12pt;">				</span><span style="font-size: 12pt;">num_erased++;</span></p><p><span style="white-space: pre; font-size: 12pt;">				</span><span style="font-size: 12pt;">return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">예를 들어 위와 같은 예제를 생각해봅시다. 쉽게 생각해보면 그냥 똑같이 num_erased 를 &amp; 로 캡쳐해서 람다 함수 안에서 사용할 수 있을 것 같지만 실제로는 컴파일 되지 않습니다. 왜냐하면 num_erased 가 일반 변수가 아니라 객체에 종속되어 있는 멤버 변수 이기 때문이지요. 즉 람다 함수는 num_erased 를 캡쳐해! 라고 하면 이 num_erased 가 이 객체의 멤버 변수가 아니라 그냥 일반 변수라고 생각하게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이를 해결하기 위해선 직접 멤버 변수를 전달하기 보다는 this 를 전달해주면 됩니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">num_erased = 0;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">vec.erase(remove_if(vec.begin(), vec.end(), [this](int i) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">if (this-&gt;num_erased &gt;= 2) return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">else if (i % 2 == 1) {</span></p><p><span style="white-space: pre; font-size: 12pt;">				</span><span style="font-size: 12pt;">this-&gt;num_erased++;</span></p><p><span style="white-space: pre; font-size: 12pt;">				</span><span style="font-size: 12pt;">return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}), vec.end());</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같이 this 를 복사본으로 전달해서 (참고로 this 는&nbsp;레퍼런스로&nbsp;전달할 수 없습니다) 함수 안에서 this 를 이용해서 멤버 변수들을 참조해서 사용하면 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">위에 설명한 경우 말고도 캡쳐 리스트의 사용 방법은 꽤나 많은데 아래 간단히 정리해보도록 하겠습니다.</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 12pt;">[] : 아무것도 캡쳐 안함</span></li><li><span style="font-size: 12pt;">[&amp;a, b] : a 는 레퍼런스로 캡쳐하고 b 는 (변경 불가능한) 복사본으로 캡쳐</span></li><li><span style="font-size: 12pt;">[&amp;] : 외부의 모든 변수들을 레퍼런스로 캡쳐</span></li><li><span style="font-size: 12pt;">[=] : 외부의 모든 변수들을 복사본으로 캡쳐</span></li></ul><div><span style="font-size: 12pt;">와 같이 되겠습니다.</span></div><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><font color="#3058d2" face="Gulim"><span style="font-size: 13.3333px;"><b><span style="font-size: 12pt;">&nbsp;원소 수정하기 (transform)</span></b></span></font></p></td><td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">다음으로 살펴볼 함수는 원소들을 수정하는 함수들 입니다. 많은 경우 컨테이너 전체 혹은 일부를 순회하면서 값들을 수정하는 작업을 많이 할 것입니다. 예를 들어서 벡터의 모든 원소에 1 씩 더한다던지와 같은 작업들을 말이지요. 이러한 작업을 도와주는 함수는 바로 transform 함수 입니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 vec 상태 ------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "벡터 전체에 1 을 더한다" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">transform(vec.begin(), vec.end(), vec.begin(), [](int i) { return i + 1; });</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:275px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2423F74D5971875012B157 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2423F74D5971875012B157 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2423F74D5971875012B157 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2423F74D5971875012B157 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2423F74D5971875012B157 480w" src="https://t1.daumcdn.net/cfile/tistory/2423F74D5971875012" style="max-width:100%;height:auto" width="275" height="137" filename="10.3.12.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">transform 함수는 다음과 같은 꼴로 생겼습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">transform (시작 반복자, 끝 반복자, 결과를 저장할 컨테이너의 시작 반복자, Pred)</span></p></div><p><br></p><p><span style="font-size: 12pt;">우리가 사용한 예의 경우</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">transform(vec.begin(), vec.end(), vec.begin(), [](int i) { return i + 1; });</span></p></div><p><br></p><p><span style="font-size: 12pt;">로 하였으므로 vec 의 시작(begin) 부터 끝(end) 까지 각 원소에 [] (int i) {return i + 1} 함수를 적용시킨 결과를 vec.begin() 부터 저장하게 됩니다. 즉 결과적으로 각 원소에 1 을 더한 결과로 덮어 씌우게 되는 것이지요. 상당히 간단합니다. 한 가지 주의할 점은 값을 저장하는 컨테이너의 크기가 원래의 컨테이너보다 최소한 같거나 커야 된다는 점입니다. 예를 들어서 단순하게&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">transform(vec.begin(), vec.end(), vec.begin() + 1, [](int i) { return i + 1; });</span></p><p></p></div></div><p><br></p><p><span style="font-size: 12pt;">이렇게 썻다고 해봅시다. transform 함수는 vec 의 처음 부터 끝까지 쭈르륵 순회하지만 저장하는 쪽의 반복자는 vec 의 두 번째 원소 부터 저장하기 때문에 결과적으로 마지막에 한 칸이 모잘라서&nbsp;</span></p><p><br></p><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:452px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F24E5C63359718B1B071A2B 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F24E5C63359718B1B071A2B 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F24E5C63359718B1B071A2B 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F24E5C63359718B1B071A2B 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F24E5C63359718B1B071A2B 480w" src="https://t1.daumcdn.net/cfile/tistory/24E5C63359718B1B07" style="max-width:100%;height:auto" width="452" height="328" filename="10.3.13.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">위와 같은 오류를 발생하게 됩니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// vec2 에는 6 개의 0 으로 초기화 한다.</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec2(6, 0);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 vec 과 vec2 상태 ------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec2.begin(), vec2.end());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "vec 전체에 1 을 더한 것을 vec2 에 저장 -- " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">transform(vec.begin(), vec.end(), vec2.begin(), [](int i) { return i + 1; });</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec.begin(), vec.end());</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print(vec2.begin(), vec2.end());</span></p><p><span style="font-size: 12pt;">}</span></p></div></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였으면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:320px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2128514F59718DC02F2950 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2128514F59718DC02F2950 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2128514F59718DC02F2950 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2128514F59718DC02F2950 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2128514F59718DC02F2950 480w" src="https://t1.daumcdn.net/cfile/tistory/2128514F59718DC02F" style="max-width:100%;height:auto" width="320" height="138" filename="10.3.14.png" filemime="image/png"></span></p><p><br></p><br></div><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">transform(vec.begin(), vec.end(), vec2.begin(), [](int i) { return i + 1; });</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">위와 같이 vec 의 처음 부터 끝 까지 읽으면서 1 씩 더한 결과를 vec2 에 저장하게 됩니다. 간단하지요! 물론 저 transform 함수 하나 덕분에 귀찮에 for 문을 쓸 필요도 없어질 뿐더러, 내가 이 코드에서 무슨 일을 하는지 더 간단 명료하게 나타낼 수 도 있습니다.</span></p><p><br></p></div><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;원소를 탐색하는 함수(find, find_if, any_of, all_of 등등)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">마지막으로 살펴볼 함수들은 원소들을 탐색하는 계열의 함수들 입니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;functional&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;string&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename Iter&gt;</span></p><p><span style="font-size: 12pt;">void print(Iter begin, Iter end) {</span></p><p><span style="font-size: 12pt;">&nbsp; while (begin != end) {</span></p><p><span style="font-size: 12pt;">&nbsp; &nbsp; cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></p><p><span style="font-size: 12pt;">&nbsp; &nbsp; begin++;</span></p><p><span style="font-size: 12pt;">&nbsp; }</span></p><p><span style="font-size: 12pt;">&nbsp; cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main() {</span></p><p><span style="font-size: 12pt;">&nbsp; vector&lt;int&gt; vec;</span></p><p><span style="font-size: 12pt;">&nbsp; vec.push_back(5);</span></p><p><span style="font-size: 12pt;">&nbsp; vec.push_back(3);</span></p><p><span style="font-size: 12pt;">&nbsp; vec.push_back(1);</span></p><p><span style="font-size: 12pt;">&nbsp; vec.push_back(2);</span></p><p><span style="font-size: 12pt;">&nbsp; vec.push_back(3);</span></p><p><span style="font-size: 12pt;">&nbsp; vec.push_back(4);</span></p><p><br></p><p><span style="font-size: 12pt;">&nbsp; auto result = find(vec.begin(), vec.end(), 3);</span></p><p><span style="font-size: 12pt;">&nbsp; cout &lt;&lt; "3 은 " &lt;&lt; distance(vec.begin(), result) + 1 &lt;&lt; " 번째 원소" &lt;&lt; endl;&nbsp;</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였으면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:263px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2403B13A5973A8441A3B1E 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2403B13A5973A8441A3B1E 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2403B13A5973A8441A3B1E 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2403B13A5973A8441A3B1E 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2403B13A5973A8441A3B1E 480w" src="https://t1.daumcdn.net/cfile/tistory/2403B13A5973A8441A" style="max-width:100%;height:auto" width="263" height="83" filename="10.3.15.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">find 함수는 단순히</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template&lt;class InputIt, class T&gt;</span></p><p><span style="font-size: 12pt;">InputIt find(InputIt first, InputIt last, const T&amp; value)</span><br></p></div><p><br></p><p><span style="font-size: 12pt;">와 같이 생겼는데, first 부터 last 까지 쭈르륵 순회하면서 value 와 같은 원소가 있는지 확인하고 있으면 이를 가리키는 반복자를 리턴합니다. &nbsp;위 경우&nbsp;</span></p><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">auto result = find(vec.begin(), vec.end(), 3);</span></div></div><div><br></div><div><span style="font-size: 12pt;">vec 에서 값이 3 과 같은 원소를 찾아서 리턴하게 되지요. 반복자에 따라서 forward_iterator 면 앞에서 부터 찾고, reverse_iterator 이면 뒤에서 부터 거꾸로 찾게 됩니다. 물론 컨테이너에 중복되는 값이 있더라도 가장 먼저 찾은 것을 리턴합니다. 만약에 위 vec 에서 모든 3 을 찾고 싶다면 아래와 같이 하면 됩니다.</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;functional&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;string&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;vector&gt;</span></div><div><span style="font-size: 12pt;">using namespace std;</span></div><div><br></div><div><span style="font-size: 12pt;">template &lt;typename Iter&gt;</span></div><div><span style="font-size: 12pt;">void print(Iter begin, Iter end) {</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br></div><div><span style="font-size: 12pt;">int main() {</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto current = vec.begin();</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (true) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">current = find(current, vec.end(), 3);</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (current == vec.end()) break;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "3 은 " &lt;&lt; distance(vec.begin(), current) + 1 &lt;&lt; " 번째 원소"</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">&lt;&lt; endl;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">current++;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:268px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244C3D335973AC8A107754 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244C3D335973AC8A107754 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244C3D335973AC8A107754 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244C3D335973AC8A107754 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244C3D335973AC8A107754 480w" src="https://t1.daumcdn.net/cfile/tistory/244C3D335973AC8A10" style="max-width:100%;height:auto" width="268" height="91" filename="10.3.16.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">위와 같이 나옵니다.</span><br></p><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">current = find(current, vec.end(), 3);</span></div></div><div><br></div><div><span style="font-size: 12pt;">위 처럼 마지막으로 찾은 위치 바로 다음 부터 계속 순차적으로 탐색해 나간다면 컨테이너에서 값이 3 인 원소들을 모두 찾을 수 있게 됩니다.</span></div><div><br></div><div><span style="font-size: 12pt;">다만 find 계열의 함수들을 사용할 때 한 가지 주의해야 할 점은, 만약에 컨테이너에서 기본적으로 find 함수를 지원한다면 이를 사용하는 것이 훨씬 빠릅니다. 왜냐하면 알고리즘 라이브러리에서의 find 함수는 그 컨테이너가 어떠한 구조를 가지고 있는지에 대한 정보가 하나도 없기 때문입니다.</span><br><br></div><div><span style="font-size: 12pt;">예를 들어 set 의 경우, set 에서 사용하는 find 함수의 경우&nbsp;O(log n) 으로 수행될 수 있는데 그 이유는 셋 내부에서 원소들이 정렬되어 있기 때문입니다. 또 unordered_set 의 경우 find 함수가 O(1) 로 수행될 수 있는데 그 이유는 unordered_set 내부에서 자체적으로 해시 테이블을 이용해서 원소들을 빠르게 탐색해 나갈 수 있기 때문입니다.</span></div><div><br></div><div><span style="font-size: 12pt;">하지만 그냥 알고리즘 라이브러리의 find 함수의 경우 이러한 추가 정보가 있는 것을 하나도 모른채 우직하게 처음 부터 하나 씩 확인해 나가므로 평범한 O(n) 으로 처리됩니다. 따라서 알고리즘 라이브러리의 find 함수를 사용할 경우 벡터와 같이 기본적으로 find 함수를 지원하지 않는 컨테이너에 사용하시기 바랍니다!</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;functional&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;string&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;vector&gt;</span></div><div><span style="font-size: 12pt;">using namespace std;</span></div><div><br></div><div><span style="font-size: 12pt;">template &lt;typename Iter&gt;</span></div><div><span style="font-size: 12pt;">void print(Iter begin, Iter end) {</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br></div><div><span style="font-size: 12pt;">int main() {</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(5);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(1);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(2);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(3);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(4);</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto current = vec.begin();</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (true) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">current = find_if(current, vec.end(), [](int i) { return i % 3 == 2; });</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (current == vec.end()) break;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "3 으로 나눈 나머지가 2 인 원소는 : " &lt;&lt; *current &lt;&lt; " 이다 "</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">&lt;&lt; endl;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">current++;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:332px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2474D4335973AF631A1737 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2474D4335973AF631A1737 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2474D4335973AF631A1737 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2474D4335973AF631A1737 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2474D4335973AF631A1737 480w" src="https://t1.daumcdn.net/cfile/tistory/2474D4335973AF631A" style="max-width:100%;height:auto" width="332" height="95" filename="10.3.17.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span><br></p><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">current = find_if(current, vec.end(), [](int i) { return i % 3 == 2; });</span></div></div><div><br></div><div><span style="font-size: 12pt;">find 함수가 단순한 값을 받았다면 find_if 함수의 경우 함수 객체를 인자로 받아서 그 결과가 참인 원소들을 찾게 됩니다. 위 경우 3 으로 나눈 나머지가 2 인 원소들을 컨테이너에서 탐색하였습니다. 람다 함수로 사용하니 엄청 간결하지요?</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">#include &lt;algorithm&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;functional&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;string&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;vector&gt;</span></div><div><span style="font-size: 12pt;">using namespace std;</span></div><div><br></div><div><span style="font-size: 12pt;">template &lt;typename Iter&gt;</span></div><div><span style="font-size: 12pt;">void print(Iter begin, Iter end) {</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">while (begin != end) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "[" &lt;&lt; *begin &lt;&lt; "] ";</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">begin++;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br></div><div><span style="font-size: 12pt;">struct User {</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string name;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int level;</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">User(string name, int level) : name(name), level(level) {}</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool operator==(const User&amp; user) const {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (name == user.name &amp;&amp; level == user.level) return true;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return false;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">};</span></div><div><br></div><div><span style="font-size: 12pt;">class Party {</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;User&gt; users;</span></div><div><span style="font-size: 12pt;">public:</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool add_user(string name, int level) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">User new_user(name, level);</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (find(users.begin(), users.end(), new_user)&nbsp;</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">!= users.end()) {</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return false;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">users.push_back(new_user);</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return true;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 파티원 모두가 15 레벨 이상이여야지 던전 입장 가능</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool can_join_dungeon() {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return all_of(users.begin(), users.end(), [](User&amp; user) {</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return user.level &gt;= 15;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">});</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 파티원 중 한명 이라도 19렙 이상이면 특별 아이템 사용 가능</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool can_use_special_item() {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return any_of(users.begin(), users.end(), [](User&amp; user) {</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return user.level &gt;= 19;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">});</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;">int main() {</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Party party;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">party.add_user("철수", 15);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">party.add_user("영희", 18);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">party.add_user("민수", 12);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">party.add_user("수빈", 19);</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; boolalpha;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "던전 입장 가능 ? " &lt;&lt; party.can_join_dungeon() &lt;&lt; endl;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "특별 아이템 사용 가능 ? " &lt;&lt; party.can_use_special_item() &lt;&lt; endl;</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:266px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2581B7335973B48811EF46 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2581B7335973B48811EF46 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2581B7335973B48811EF46 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2581B7335973B48811EF46 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2581B7335973B48811EF46 480w" src="https://t1.daumcdn.net/cfile/tistory/2581B7335973B48811" style="max-width:100%;height:auto" width="266" height="83" filename="10.3.18.png" filemime="image/png"></span></p><p><br></p><span style="font-size: 12pt;">와 같이 나옵니다.</span></div><div><br></div><div><span style="font-size: 12pt;">마지막으로 살펴볼 함수들은 any_of 와 all_of 입니다. any_of 는 인자로 받은 범위안의 모든 원소들 중에서 조건을 하나라도 충족하는 것이 있다면 true 를 리턴하고 all_of 의 경우 모든 원소들이 전부 조건을 충족해야 true 를 리턴합니다. 즉 any_of 는 OR 연산과 비슷하고 any_of 는 AND 연산과 비슷하다고 볼 수 있지요.</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool add_user(string name, int level) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">User new_user(name, level);</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (find(users.begin(), users.end(), new_user)&nbsp;</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">!= users.end()) {</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return false;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">users.push_back(new_user);</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return true;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">먼저 간단히 유저들의 정보를 담고 있는 User 구조체를 정의하였고, 그 User 들이 파티를 이룰 때 만들어지는 Party 클래스를 정의하였습니다. 그리고 위 add_user 함수를 사용하면 파티원을 추가할 수 있지요. 물론 중복되는 파티원이 없도록 벡터에 원소를 추가하기 전에 확인합니다.&nbsp;</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 파티원 모두가 15 레벨 이상이여야지 던전 입장 가능</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool can_join_dungeon() {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return all_of(users.begin(), users.end(), [](User&amp; user) {</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return user.level &gt;= 15;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">});</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">따라서 이 파티가 어떤 던전에 참가하고 싶은 경우 모든 파티원의 레벨이 15 이상 이어야 하므로 위와 같이 all_of 함수를 사용해서 모든 원소들이 조건에 만족하는지 확인할 수 있습니다. 위 경우 민수가 12 레벨이여서 false 가 리턴되겠지요.</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 파티원 중 한명 이라도 19렙 이상이면 특별 아이템 사용 가능</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">bool can_use_special_item() {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return any_of(users.begin(), users.end(), [](User&amp; user) {</span></div><div><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">return user.level &gt;= 19;</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">});</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div></div></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">비슷하게도 한 명만 조건을 만족해도 되는 경우 위와 같이 any_of 함수를 사용하면 간단히 처리할 수 있습니다.&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">자 그러면 이번 강좌는 여기서 마치도록 하겠습니다. 사실 알고리즘 라이브러리를 &nbsp;살펴보면 이것 보다도 훨씬 많은 수의 여러가지 유용한 함수들이 정의되어 있습니다. 하지만 이 모든 함수들을 강좌에서 다루기에는 조금 무리가 있고, 이 정도 함수들만 알아놓아도 매우 편리하게 사용하실 수 있을 것이라 생각합니다!&nbsp;</span></div><div><span style="font-size: 12pt;"><br></span></div><div><div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox"><p>
<span style="font-size:12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 <span style="font-weight: bold;">꼭 댓글을 남겨주시기 바랍니다</span>. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span><br>
<br>
<span style="font-size:12pt;">현재 여러분이 보신 강좌는<span style="font-style: italic;">&lt;&lt;</span></span><span style="font-size: 16px;"><i>씹어먹는 C++ - &lt;10 - 3. C++ STL - 알고리즘(algorithm)&gt;</i></span><span style="font-size: 12pt; font-style: italic;">&gt;&gt;</span><span style="font-size: 12pt;"> 입니다. 이번 강좌의 </span><span style="font-size: 12pt; font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span><span style="font-size: 12pt;">까지 다음 강좌로 넘어가지 말아주세요&nbsp;</span></p><p style="font-size: 12pt;">
<br>
</p><div style="font-size: 12pt; text-align: right;">
<span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135">다음 강좌 보러가기</a><br>
</span>
</div>
</div>
<br></div><p></p><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_225" data-uoc-sc="" data-uoc-pcurl="http://itguru.tistory.com/225" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_225"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text">공감</span><span class="txt_like uoc-count" style="display: none;"></span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile25.uf.tistory.com/image/247F2434596A50D706E894" data-title="씹어먹는 C++ - <10 - 3. C++ STL - 알고리즘(algorithm)>" data-description="이번 강좌에서는 람다 함수(lambda function) 정렬 알고리즘 원소 삭제 알고리즘 원소 탐색 알고리즘 등등에 대해 다룹니다.  안녕하세요 여러분! 이번 강좌에서는 STL 의 알고리즘(algorithm) 라이브러리에 대해.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/225" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="225"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/225&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++">C++</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/228?category=361027">씹어먹는 C++ - &lt;11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)&gt;</a>&nbsp;&nbsp;<span>(7)</span>
</th>
<td>
2018.03.27</td>
</tr>
<tr>
<th>
<a href="/227?category=361027">씹어먹는 C++ - &lt;11 - 1. 우측값 레퍼런스와 이동 생성자&gt;</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2018.03.24</td>
</tr>
<tr>
<th>
<a href="/225?category=361027" class="current">씹어먹는 C++ - &lt;10 - 3. C++ STL - 알고리즘(algorithm)&gt;</a>&nbsp;&nbsp;<span>(16)</span>
</th>
<td>
2017.07.09</td>
</tr>
<tr>
<th>
<a href="/224?category=361027">씹어먹는 C++ - &lt;10 - 2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map&gt;</a>&nbsp;&nbsp;<span>(5)</span>
</th>
<td>
2017.07.08</td>
</tr>
<tr>
<th>
<a href="/223?category=361027">씹어먹는 C++ - &lt;10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.07.04</td>
</tr>
<tr>
<th>
<a href="/222?category=361027">씹어먹는 C++ - &lt;9 - 3. 템플릿 메타 프로그래밍 2&gt;</a>&nbsp;&nbsp;<span>(8)</span>
</th>
<td>
2017.07.02</td>
</tr>
</tbody></table></div></div>
<br> <br>


					