
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<div class="tt_article_useless_p_margin"><p><span style="font-size: 8pt;">이번 강좌에서는</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 8pt;">C++ 표준 템플릿 라이브러리 개요</span></li><li><span style="font-size: 8pt;">시퀀스 컨테이너(sequence container)</span></li><li><span style="font-size: 8pt;">반복자 (iterator)</span></li></ul><div><span style="font-size: 8pt;">에 대해 배웁니다.</span></div><div><span style="font-size: 16px;"><hr><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/242D6B46595B6DA41B?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F242D6B46595B6DA41B4BCE 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F242D6B46595B6DA41B4BCE 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F242D6B46595B6DA41B4BCE 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F242D6B46595B6DA41B4BCE 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F242D6B46595B6DA41B4BCE 480w" src="https://t1.daumcdn.net/cfile/tistory/242D6B46595B6DA41B" style="cursor: pointer;max-width:100%;height:auto" width="730" height="158" filename="__CODE____C___by_webblaster48.jpg" filemime="image/jpeg"></span></span></p><p><br></p></span></div><p><span style="font-size: 12pt;">안녕하세요 여러분! 지난번 템플릿 메타프로그래밍 강좌는 어떠셨나요? TMP 를 활용해서 프로그래밍을 하는 것은 엄청 머리아픈 일이지만 적당히 잘 쓰면 꽤 괜찮은 도구입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 이번 강좌는 조금 다룹니다. 이번 강좌에서 배우게 될 C++ 의 표준 템플릿 라이브러리 (STL) 은 사용하는 것도 엄청 간단한데, 여러분이 하는 프로그래밍 능률을 100% 향상 시킬 수 있는 엄청난 도구 입니다. 사실 이 STL 의 도입으로 C++ 이 한발 더 도약한 것도 과언이 아니라 볼 수 있습니다.</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><font color="#3058d2" face="Gulim"><span style="font-size: 13.3333px;"><b><span style="font-size: 12pt;">&nbsp;C++ 표준 템플릿 라이브러리 (Standard Template Library - STL)</span></b></span></font></p></td><td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">사실 C++ 표준 라이브러리를 보면 꽤나 많은 종류의 라이브러리들이 있습니다. 예를 들어서, 대표적으로 입출력 라이브러리 (iostream 등등), 시간 관련 라이브러리 (chrono), 정규표현식 라이브러리 (regex) 등등 들이 있지요. 하지만 보통 C++ 템플릿 라이브러리(STL)를 일컫는다면 다음과 같은 세 개의 라이브러리들을 의미합니다.</span></p><p><span style="font-size: 12pt;"><br></span></p><ul style="list-style-type: square;"><li><span style="font-size: 12pt;">임의 타입의 객체를 보관할 수 있는 컨테이너 (container)</span></li><li><span style="font-size: 12pt;">컨테이너에 보관된 원소에 접근할 수 있는 반복자 (iterator)</span></li><li><span style="font-size: 12pt;">반복자들을 가지고 일련의 작업을 수행하는 알고리즘 (algorithm)</span><br></li></ul><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">각 라이브러리의 역할을 쉽게 생각하면 다음과 같이 볼 수 있습니다. 여러분이 우편 배달부가 되어서 편지들을 여러개의 편지함에 넣는다고 생각해봅시다. 편지를 보관하는 각각의 편지함들은 '컨테이너' 라고 생각하시면 됩니다. 그리고, 편지를 보고 원하는 편지함을 찾는 일은 '반복자' 들이 수행하지요. 마지막으로, 만일 편지들을 편지함에 날짜 순서로 정렬하여 넣는 일은 '알고리즘' 이 수행할 것입니다.&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">한 가지 주목할 만한 점은&nbsp;</span></div><div><span style="font-size: 12pt;"><br></span></div><div></div><p></p><ul style="list-style-type: square;"><li><b><span style="font-size: 12pt;">임의 타입의 객체</span></b><span style="font-size: 12pt;">를 보관할 수 있는 컨테이너 (container)</span></li></ul><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">에서 나타나 있듯이 우리가 다루려는 객체가 어떤 특성을 갖는지 무관하게 라이브러리를 자유롭게 사용할 수 있다는 것입니다 (바로 템플릿 덕분이죠!). 우리가 만일 사용하려는 자료형이 int 나 string 과 같은 평범한 애들이 아니라, 우리가 만든 임의이 클래스의 객체들이여도</span><b><span style="font-size: 12pt;">&nbsp;자유롭게 위 라이브러리의 기능들을 모두 활용</span></b><span style="font-size: 12pt;">할 수 있습니다. 만일 C 였다면 불가능했을 일입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">또한 반복자의 도입으로 알고리즘 라이브러리에 필요한 최소한의 코드만을 작성할 수 있게 되었습니다. 다시 말하면, 기존의 경우 M 개 종류의 컨테이가 있고 N 종류의 알고리즘이 있다면 이 모든 것을 지원하려면 MN 개의 알고리즘 코드가 있어야만 했습니다.&nbsp;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_3_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_3_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_3" name="aswift_3" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">하지만 반복자를 이용해서 컨테이너를 추상화 시켜서 접근할 수 있기 때문에 N 개의 알고리즘 코드 만으로 M 종류의 컨테이너들을 모두 지원할 수 있게됩니다. (후에 알고리즘 라이브러리에 대해서 설명할 때 더 와닿을 것입니다)</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;C++ STL 컨테이너 - 벡터 (vector)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">C++ STL 에서 컨테이너는 크게 두 가지 종류가 있습니다. 먼저 배열 처럼 객체들을 순차적으로 보관하는 시퀀스 컨테이너 (sequence container) 와 키를 바탕으로 대응되는 값을 찾아주는 연관 컨테이너 (associative container) 가 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">먼저 시퀀스 컨테이너의 경우 vector, list, deque 이렇게 3 개가 정의되어 있습니다. 먼저 벡터(vector) 의 경우, 쉽게 생각하면 가변길이 배열이라 보시면 됩니다 (템플릿 강의에서 Vector 를 제작하신 것을 기억 하시나요?) 벡터에는 원소들이 메모리 상에서 실제로 순차적으로 저장되어 있고, 따라서 임의의 위치에 있는 원소를 접근하는 것을 매우 빠르게 수행할 수 있습니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;"></span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;<span style="font-size: 12pt;">정확히 얼마나 빠르다고?</span></span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br>
</span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim">&nbsp;</span></span></td></tr></tbody></table><br>

<p></p><div></div>
<div></div><p></p><p><span style="font-size: 12pt;">사실 '매우 빠르다' 라는 말은 주관적일 수 밖에 없습니다. 따라서 어떠한 작업의 수행 속도를 나타내기 위해선 수학적으로 나타내야 합니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">컴퓨터 공학에선&nbsp;어떠한 작업의 처리 속도를 '복잡도(complexity)' 라고 부르고, 그 복잡도를&nbsp;Big O 표기법이라는 것으로 나타냅니다. 이 표기법은, N 개의 데이터가 주어져 있을 때 그 작업을 수행하기 위해 몇 번의 작업을 필요로 하는지 N 에 대한 식으로 표현하는 방식입니다. (즉 복잡도가 클 수록 작업이 수행되는데 걸리는 시간이 늘어나겠지요)</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_4_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_4_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_4" name="aswift_4" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">예를 들어 가장 기초적인 버블 정렬을 생각해봅시다. 버블 정렬의 코드는 간단히 보자면 아래와 같습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; N; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int j = i + 1; j &lt; N; j++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">if (arr[i] &gt; arr[j]) {</span></p><p><span style="white-space: pre; font-size: 12pt;">				</span><span style="font-size: 12pt;">swap(arr, i, j)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><br></p><p><span style="font-size: 12pt;">따라서 N 개의 원소가 있는 arr 이라는 배열을 정렬하기 위해서는 일단 적어도</span></p><p style="text-align: center;"><span style="font-size: 12pt;">&nbsp;</span><img id="equationview" name="equationview" title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program." src="https://latex.codecogs.com/gif.latex?%5Cfrac%7BN%28N-1%29%7D%7B2%7D" style="margin: 10px; font-family: Arial, Helvetica, sans-serif; font-size: 12px; text-align: center;"><span style="font-size: 12pt;">&nbsp;</span></p><p><span style="font-size: 12pt;">번의 반복이 필요하지요 (N -1 + N- 2 + ... + 1) . 따라서 Big O 표현법으로 이 정렬이 얼마나 빠르게 수행될 수 있는지 나타내면&nbsp;</span></p><p><br></p><p style="text-align: center;"><img id="equationview" name="equationview" title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program." src="https://latex.codecogs.com/gif.latex?O%28%5Cfrac%7BN%28N-1%29%7D%7B2%7D%29" style="margin: 10px; font-family: Arial, Helvetica, sans-serif; font-size: 12px; text-align: center;"></p><p><br></p><p><span style="font-size: 12pt;">라고 볼 수 있습니다. 보통 Big O 표현법으로 나타낼 때, 최고차항만을 나타냅니다 (그리고 통상적으로 최고차항의 계수도 생략합니다). 왜냐하면 N 이 엄청 커지게 되면 최고 차항 말고는 그닥 의미가 없게 되버리기 때문이지요 (최고 차항에 비해 크기가 너무 작기 때문에). 따라서 최종적으로, 버블 정렬 알고리즘의 복잡도는&nbsp;</span></p><p style="text-align: center;"><img id="equationview" name="equationview" title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program." src="https://latex.codecogs.com/gif.latex?O%28N%5E2%29" style="margin: 10px; font-family: Arial, Helvetica, sans-serif; font-size: 12px; text-align: center;"></p><p><span style="font-size: 12pt;">라고 볼 수 있습니다. 일반적으로 어떠한 알고리즘이 O(N²) 꼴이면 그닥 좋은 편은 아닙니다. 왜냐하면 N 이 10000 만 되더라도, 10의 8 번의 작업을 처리해야 하기 때문이죠. 다행이도 정렬 알고리즘의 경우 퀵소트(Quicksort) 라는 알고리즘을 활용하면 아래와 같은 복잡도로 연산을 처리할 수 있습니다.</span></p><p style="text-align: center;"><img id="equationview" name="equationview" title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program." src="https://latex.codecogs.com/gif.latex?O%28N%5Clog%20N%29" style="margin: 10px; font-family: Arial, Helvetica, sans-serif; font-size: 12px; text-align: center;"></p><p><span style="font-size: 12pt;">물론 퀵소트 알고리즘을 사용했을 때 항상 버블 정렬 방식 보다 빠르게 정렬할 수 있다는 의미는 아닙니다. 왜냐하면 저 항 앞에 어떠한 계수가 붙어있는지 알 수 없기 때문이지요. 만약에 버블 정렬이 O(N²) 이고 퀵소트가 O(100000 N log N) 이였다면 N 이 1000 일 때 버블 정렬 이 더 빠르게 수행됩니다. &nbsp;(물론 이렇게 극단적이지 않습니다. 퀵소트가 거의 대부분 더 빠르게 됩니다!)</span></p><p><br></p><p><span style="font-size: 12pt;">하지만, N 이 정말 커진다면 언젠가는 퀵소트가 버블 정렬보다 더 빨리 수행되는 때가 발생합니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">아래 그림을 보면 각각의 O 에 대해 복잡도가 어떻게 증가하는지 볼 수 있습니다.</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/271D6B335959FB5316?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F271D6B335959FB53166AF4 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F271D6B335959FB53166AF4 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F271D6B335959FB53166AF4 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F271D6B335959FB53166AF4 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F271D6B335959FB53166AF4 480w" src="https://t1.daumcdn.net/cfile/tistory/271D6B335959FB5316" style="cursor: pointer;max-width:100%;height:auto" width="730" height="466" filename="complexity-types-codemio.png" filemime="image/png"></span></span></p><p><br></p><p><span style="font-size: 12pt;">가장 이상적인 복잡도는 O(1) 이지만 이는 거의 불가능하고 (이는 마치 전체 데이터를 채 보지 않은 채 작업을 끝낼 수 있다는 의미 입니다), 보통 O(log n) 이 알고리즘이 낼 수 있는 가장 빠른 속도를 의미합니다. 그 다음으로 좋은 것이 당연히 O(n) 이고, O(n log n) 순 입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 다시 벡터 자료형으로 돌아오겠습니다. vector 의 경우, 임의의 위치에 있는 원소에 접근을 O(1) 로 수행할 수 있습니다. 게다가 맨 뒤에 새로운 원소를 추가하거나 제거하는 것 역시 O(1) 에 수행합니다. vector 의 임의의 원소에 접근하는 것은 배열처럼 [] 를 이용하거나, at 함수를 이용하면 됩니다. 또한 맨 뒤에 원소를 추가하거나 제거하기 위해서는 push_back 혹은 pop_back 함수를 사용하면 됩니다. 아래 예를 보겠습니다.</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(10); // 맨 뒤에 10 추가</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(20); // 맨 뒤에 20 추가</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(30); // 맨 뒤에 30 추가</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(40); // 맨 뒤에 40 추가</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (vector&lt;int&gt;::size_type i = 0; i &lt; vec.size(); i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "vec 의 " &lt;&lt; i + 1 &lt;&lt; " 번째 원소 :: " &lt;&lt; vec[i] &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였으면&nbsp;</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:284px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F246C303C595A08BC167DA0 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F246C303C595A08BC167DA0 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F246C303C595A08BC167DA0 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F246C303C595A08BC167DA0 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F246C303C595A08BC167DA0 480w" src="https://t1.daumcdn.net/cfile/tistory/246C303C595A08BC16" style="max-width:100%;height:auto" width="284" height="124" filename="10.1.1.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 우리가 넣은 순서대로 잘 나옴을 알 수 있습니다.</span><br></p><p><br></p><p><span style="font-size: 12pt;">참고로 벡터의 크기를 리턴하는 함수인 size 의 경우, 그 </span><b><span style="font-size: 12pt;">리턴하는 값의 타입은 size_type 멤버 타입</span></b><span style="font-size: 12pt;">으로 정의되어 있습니다.&nbsp;</span></p></div><p><br></p><p><span style="font-size: 12pt;">참고로 맨 뒤에 원소를 추가하는 작업은 엄밀히 말하자면 amortized O(1) 이라고 합니다. (amortized 의 뜻은 분할상환이란 뜻인데, 아마 아래 설명을 읽으시면 왜 그런 이름을 붙였는지 이해하실 수 있을 것입니다)</span></p><p><br></p><p><span style="font-size: 12pt;">왜냐면 보통은 vector 의 경우 현재 가지고 있는 원소의 개수 보다 더 많은 공간을 할당해 놓고 있습니다. 예를 들어 현재 vector 에 있는 원소의 개수가 10 개라면 이미 20개를 저장할 수 있는 공간을 미리 할당해놓게됩니다. 따라서 만약에 뒤에 새로운 원소를 추가하게 된다면 새롭게 메모리를 할당할 필요가 없이, 그냥 이미 할당된 공간에 그 원소를 쓰기만 하면 됩니다. 따라서 대부분의 경우 O(1) 으로 vector 맨 뒤에 새로운 원소를 추가하거나 지울 수 있습니다.</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_5_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">문제가 되는 상황은 할당된 공간을 다 채웠을 때 입니다. 이 때는 어쩔 수 없이, 새로운 큰 공간을 다시 할당하고, 기존의 원소들을 복사하는 수 밖에 없습니다. 따라서 이 경우 n 개의 원소를 모두 복사해야 하기 때문에 O(n) 으로 수행됩니다.&nbsp;하지만 이 O(n) 으로 수행되는 경우가 매우 드물기 때문에, 전체적으로 평균을 내보았을 때 O(1) 으로 수행됨을 알 수 있습니다. 이렇기에 amortized O(1) 이라고 부르게 됩니다. 아래 그림에서 자세히 설명하고 있습니다.</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:626px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2124A44B595A137D239739 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2124A44B595A137D239739 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2124A44B595A137D239739 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2124A44B595A137D239739 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2124A44B595A137D239739 480w" src="https://t1.daumcdn.net/cfile/tistory/2124A44B595A137D23" style="max-width:100%;height:auto" width="626" height="1070" filename="10.1.2.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">물론 vector 라고 만능은 아닙니다. 맨 뒤에 원소를 추가하거나 제거하는 것은 빠르지만,</span><b><span style="font-size: 12pt;"> 임의의 위치에 원소를 추가하거나 제거하는 것은 O(n) 으로 느립니다</span></b><span style="font-size: 12pt;">. 왜냐하면 어떤 자리에 새로운 원소를 추가하거나 뺄 경우 그 뒤에 오는 원소들을 한 칸 씩 이동시켜 주어야만 하기 때문이지요. 따라서 이는 n 번의 복사가 필요로 합니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 만일 맨 뒤가 아닌 위치에 데이터를 추가하거나 제거하는 작업이 많은 일일 경우 vector 를 사용하면 안되겠지요. 결과적으로 vector 의 복잡도를 정리해보자면 아래와 같습니다.</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 12pt;">임의의 위치 원소 접근 ([], at) : O(1)</span></li><li><span style="font-size: 12pt;">맨 뒤에 원소 추가 및 제거 (push_back/pop_back) : amortized O(1); (평균적으로 O(1) 이지만 최악의 경우 O(n) )</span></li><li><span style="font-size: 12pt;">임의의 위치 원소 추가 및 제거 (insert, erase) : O(n)</span></li></ul><p><span style="font-size: 12pt;">위 처럼 어떠한 작업을 하냐에 따라서 속도차가 매우 크기 때문에, C++ 표준 라이브러리를 잘 사용하기 위해서는 내가 이 컨테이너를 어떠한 작업을 위해 사용하는지 정확히 인지하고, 적절한 컨테이너를 골라야 합니다. 후에 설명할 다른 자료 구조를 사용하면 vector 가 빠른 작업이 느릴 수 도 있고, vector 가 느린 작업을 빠르게 할 수 도 있습니다.</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;반복자 (iterator)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="color: rgb(48, 88, 210); font-size: 12pt;">&nbsp;</span><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">앞서 반복자는 컨테이너에 원소에 접근할 수 있는 포인터와 같은 객체라고 하였습니다. 물론 벡터의 경우 [ ] 를 이용해서 정수형 변수로 마치 배열 처럼 임의의 위치에 접근할 수 있지만, 반복자를 사용해서도 마찬가지 작업을 수행할 수 있습니다. 특히 후에 배울 알고리즘 라이브러리의 경우 대부분이 반복자를 인자로 받아서 알고리즘을 수행합니다.</span></p><p><br></p><p><span style="font-size: 12pt;">반복자는 컨테이너에 iterator 멤버 타입으로 정의되어 있습니다.&nbsp;vector 의 경우 반복자를 얻기 위해서는 begin() 함수와 end() 함수를 사용할 수 있는데 이는 다음과 같은 위치를 리턴합니다.&nbsp;</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/2165E44C595A970A16?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2165E44C595A970A1676B5 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2165E44C595A970A1676B5 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2165E44C595A970A1676B5 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2165E44C595A970A1676B5 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2165E44C595A970A1676B5 480w" src="https://t1.daumcdn.net/cfile/tistory/2165E44C595A970A16" style="cursor: pointer;max-width:100%;height:auto" width="730" height="332" filename="10.1.3.png" filemime="image/png"></span></span></p><p><span style="font-size: 12pt;">begin() 함수는 예상했던 대로, vector 의 첫번째 원소를 가리키는 반복자를 리턴합니다. 그런데, 흥미롭게도 end() 의 경우 vector 의 마지막 원소 한 칸 뒤를 가리키는 반복자를 리턴하게 됩니다. 왜 end 의 경우 vector 의 마지막 원소를 가리것이 아니라, 마지막 원소의 뒤를 가리키는 반복자를 리턴할까요?&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이에 여러가지 이유가 있겠지만, 가장 중요한 점이 이를 통해 빈 벡터를 표현할 수 있다는 점입니다. 만일 begin() == end() 라면 원소가 없는 벡터를 의미하겠지요. 만약에 vec.end() 가 마지막 원소를 가리킨다면 비어있는 벡터를 표현할 수 없게 됩니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">// 반복자 사용 예시</span></p><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(20);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(30);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(40);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 전체 벡터를 출력하기</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (vector&lt;int&gt;::iterator itr = vec.begin(); itr != vec.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// int arr[4] = {10, 20, 30, 40}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// *(arr + 2) == arr[2] == 30;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// *(itr + 2) == vec[2] == 30;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::iterator itr = vec.begin() + 2;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "3 번째 원소 :: " &lt;&lt; *itr &lt;&lt; endl;</span></p><p><br></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:275px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F26198938595A9B06322904 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F26198938595A9B06322904 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F26198938595A9B06322904 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F26198938595A9B06322904 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F26198938595A9B06322904 480w" src="https://t1.daumcdn.net/cfile/tistory/26198938595A9B0632" style="max-width:100%;height:auto" width="275" height="140" filename="10.1.4.png" filemime="image/png"></span></p><p><br></p><br></div><p><span style="font-size: 12pt;">와 같이 잘 수행됨을 알 수 있습니다.</span><br><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 전체 벡터를 출력하기</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (vector&lt;int&gt;::iterator itr = vec.begin(); itr != vec.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">vector 의 반복자의 타입은 위 처럼 vector&lt;&gt;::iterator 멤버 타입으로 정의되어 있고, vec.begin() 이나 vec.end() 함수가 이를 리턴합니다. end() 가 vector 의 마지막 원소 바로 뒤를 가리키기 때문에 for 문에서 vector 전체 원소를 보고 싶다면 vec.end() 가 아닐 때 까지 반복하면 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">앞서 반복자를 마치 포인터 처럼 사용한다고 하였는데, 실제로 현재 반복자가 가리키는 원소의 값을 보고 싶다면;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; endl;</span></p></div><p><br></p><p><span style="font-size: 12pt;">포인터로 * 를 해서 가리키는 주소값의 값을 보았던 것처럼, * 연산자를 이용해서 itr 이 가리키는 원소를 볼 수 있습니다. 물론&nbsp;itr 은 실제 포인터가 아니고 * 연산자를 오버로딩해서 마치 포인터 처럼 동작하게 만든 것입니다. * 연산자는 itr 이 가리키는 원소의 레퍼런스를 리턴합니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::iterator itr = vec.begin() + 2;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "3 번째 원소 :: " &lt;&lt; *itr &lt;&lt; endl;</span></p></div><p><br></p><p><span style="font-size: 12pt;">또한 반복자 역시 + 연산자를 통해서 그 만큼 떨어져 있는 원소를 가리키게 할 수 도 있습니다. (그냥 배열을 가리키는 포인터와 정확히 똑같이 동작한다고 생각하시면 됩니다!)</span></p><p><br></p><p><span style="font-size: 12pt;">반복자를 이용하면 아래와 같이 insert 와 erase 함수도 사용할 수 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void print_vector(vector&lt;T&gt;&amp; vec)&nbsp;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 전체 벡터를 출력하기</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (typename vector&lt;T&gt;::iterator itr = vec.begin(); itr != vec.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(20);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(30);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(40);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 벡터 상태" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "----------------------------" &lt;&lt; endl;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// vec[2] 앞에 15 추가</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.insert(vec.begin() + 2, 15);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "----------------------------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// vec[3] 제거</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(vec.begin() + 3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></p><p><br></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:264px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F277A2D4D595B000F1BBEBF 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F277A2D4D595B000F1BBEBF 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F277A2D4D595B000F1BBEBF 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F277A2D4D595B000F1BBEBF 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F277A2D4D595B000F1BBEBF 480w" src="https://t1.daumcdn.net/cfile/tistory/277A2D4D595B000F1B" style="max-width:100%;height:auto" width="264" height="277" filename="10.1.5.png" filemime="image/png"></span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 나옵니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 16px;">참고로 템플릿 버전의 경우,&nbsp;</span></p><p><span style="font-size: 16px;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 16px;">for (typename vector&lt;T&gt;::iterator itr = vec.begin(); itr != vec.end(); itr++) {</span></p></div><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">와 같이 앞에 typename 을 추가해줘야만 합니다. 그 이유는, iterator 가 vector&lt;T&gt; 의 의존 타입이기 때문입니다. <a href="http://itguru.tistory.com/222?category=361027" target="_blank" class="tx-link">의존 타입이 무엇인지 기억 안나시는 분은 이 강좌를 참조하시기 바랍니다</a>.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// vec[2] 앞에 15 추가</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.insert(vec.begin() + 2, 15);</span></p></div><p><br></p><p><span style="font-size: 12pt;">앞서 insert 함수를 소개하였는데, 위 처럼 인자로 반복자를 받고, 그 반복자 앞에 원소를 추가해줍니다. 위 경우 vec.begin() + 2, 앞에 15 를 추가하므로 10, 20, 30, 40 에서 10, 20, 15, 30, 40 이 됩니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.erase(vec.begin() + 3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></p></div><p><br></p><p><span style="font-size: 12pt;">또 아까전에 언급하였던 erase 도 인자로 반복자를 받고, 그 반복자가 가리키는 원소를 제거합니다. 위 경우 4번째 원소인 30이 지워지겠지요. 물론 insert 과 erase 함수 모두 O(n) 으로 느린편입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">참고로 vector 에서 반복자로 erase 나 insert 함수를 사용할 때 주의해야할 점이 있습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void print_vector(vector&lt;T&gt;&amp; vec)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 전체 벡터를 출력하기</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "[ ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (</span><span style="font-size: 16px;">typename</span><span style="font-size: 16px;">&nbsp;</span><span style="font-size: 12pt;">vector&lt;T&gt;::iterator itr = vec.begin(); itr != vec.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; " ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "]";</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(20);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(30);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(40);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(20);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 벡터 상태" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::iterator itr = vec.begin();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::iterator end_itr = vec.end();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (; itr != end_itr; itr ++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 20) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">vec.erase(itr);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "값이 20 인 원소를 지운다!" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></p><p><br></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">컴파일 후 실행하였다면 아래와 같은 오류가 발생합니다.</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:452px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2554D949595B4BB61B3489 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2554D949595B4BB61B3489 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2554D949595B4BB61B3489 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2554D949595B4BB61B3489 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2554D949595B4BB61B3489 480w" src="https://t1.daumcdn.net/cfile/tistory/2554D949595B4BB61B" style="max-width:100%;height:auto" width="452" height="328" filename="10.1.11.png" filemime="image/png"></span></p><p style="text-align: center; clear: none; float: none;"><br></p><p><br></p><p><span style="font-size: 12pt;">왜 이런 오류가 발생하는 것일까요?</span></p><p><br></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (; itr != end_itr; itr ++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 20) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">vec.erase(itr);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">문제는 바로 위 코드에서 발생합니다. </span><b><span style="font-size: 12pt;">컨테이너에 원소를 추가하거나 제거하게 되면 기존에 사용하였던 모든 반복자들을 사용할 수 없게됩니다</span></b><span style="font-size: 12pt;">. 다시 말해 위 경우 vec.erase(itr) 을 수행하게 되면 더이상 itr 은 유효한 반복자가 아니게 되는 것이지요. 또한 end_itr 역시 무효화 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 itr != end_itr 이 영원히 성립되며&nbsp;무한 루프에 빠지게되어 위와 같은 오류가 발생합니다.</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::iterator itr = vec.begin();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (; itr != vec.end(); itr ++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 20) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">vec.erase(itr);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같이 코드를 고치면 오류가 없어질까요? 실행해보시면 알겠지만 여전히 위와 같은 오류가 발생합니다. 왜냐하면 itr 이 유효한 반복자가 아니기 때문에 vec.end() 로 올바른 end 반복자 값을 매번 가지고 와도 for 문이 끝나지 않게 되는 것입니다. 결과적으로 코드를 제대로 고치려면 다음과 같이 해야 합니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::iterator itr = vec.begin();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (; itr != vec.end(); itr ++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 20) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">vec.erase(itr);</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">itr = vec.begin();</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:241px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F277A6C33595B4E5831E24D 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F277A6C33595B4E5831E24D 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F277A6C33595B4E5831E24D 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F277A6C33595B4E5831E24D 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F277A6C33595B4E5831E24D 480w" src="https://t1.daumcdn.net/cfile/tistory/277A6C33595B4E5831" style="max-width:100%;height:auto" width="241" height="133" filename="10.1.12.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 제대로 값이 20 인 원소만 지워졌음을 알 수 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">사실 생각해보면 위 바뀐 코드는 꽤나 비효율적임을 알 수 있습니다. 왜냐하면 20 인 원소를 지우고, 다시 처음으로 돌아가서 원소들을 찾고 있기 때문이지요. 그냥 20 인 원소 바로 다음 위치 부터 찾아나가면 될 텐데 말입니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (vector&lt;int&gt;::size_type i = 0; i != vec.size(); i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (vec[i] == 20) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">vec.erase(vec.begin() + i);</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">i--;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">그렇다면 아예 위 처럼 굳이 반복자를 쓰지 않고 erase 함수에만 반복자를 바로 만들어서 전달하면 됩니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">vec.erase(vec.begin() + i);</span></p></div><p><br></p><p><span style="font-size: 12pt;">를 하게 되면 vec[i] 를 가리키는 반복자를 erase 에 전달할 수 있습니다. 하지만 사실 위 방법은 그리 권장하는 방법은 아닙니다. 기껏 원소에 접근하는 방식은 반복자를 사용하는 것으로 통일하였는데,&nbsp;위 방법은 이를 모두 깨버리고 그냥 기존의 배열 처럼 정수형 변수 i 로 원소에 접근하는 것이기 때문입니다.</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 후에&nbsp;C++ 알고리즘 라이브러리에 대해&nbsp;배우면서 이 문제를 깔끔하게 해결 하는 방법에 대해 다루도록 할 것입니다. 일단 임시로는 위 방법 처럼 처리하도록 하세요 :)</span></p><p><br></p><p><span style="font-size: 12pt;">vector 에서 지원하는 반복자로 const_iterator 가 있습니다. 이는 마치 const 포인터를 생각하시면 됩니다. 즉, const_iterator 의 경우 가리키고 있는 원소의 값을 바꿀 수 없습니다. 예를 들어서</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void print_vector(vector&lt;T&gt;&amp; vec)&nbsp;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 전체 벡터를 출력하기</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (</span><span style="font-size: 16px;">typename</span><span style="font-size: 16px;">&nbsp;</span><span style="font-size: 12pt;">vector&lt;T&gt;::iterator itr = vec.begin(); itr != vec.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(20);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(30);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(40);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "초기 vec 상태" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// itr 은 vec[2] 를 가리킨다.&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::iterator itr = vec.begin() + 2;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// vec[2] 의 값을 50으로 바꾼다.</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">*itr = 50;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "---------------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::const_iterator citr = vec.cbegin() + 2;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 상수 반복자가 가리키는 값은 바꿀수 없다. 불가능!</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">*citr = 30;</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">컴파일 하였다면&nbsp;</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><div><span style="font-size: 12pt;">'citr': you cannot assign to a variable that is const</span></div></div><div><br></div><div><span style="font-size: 12pt;">와 같이, const 반복자가 가리키고 있는 값은 바꿀 수 없다고 오류가 발생합니다. 주의할 점은, const 반복자의 경우</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::const_iterator citr = vec.cbegin() + 2;</span></div></div><div><br></div><div><span style="font-size: 12pt;">와 같이 cbegin() 과 cend() 함수를 이용하여 얻을 수 있습니다. 많은 경우 반복자의 값을 바꾸지 않고 참조만 하는 경우가 많으므로, const iterator 를 적절히 이용하는 것이 좋습니다.&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">vector 에서 지원하는 반복자 중 마지막 종류로 역반복자 (reverse iterator) 가 있습니다. 이는 반복자와 똑같지만 벡터 뒤에서 부터 앞으로 거꾸로 간다는 특징이 있습니다. 아래 예제를 살펴볼까요.</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></div><div><span style="font-size: 12pt;">#include &lt;vector&gt;</span></div><div><span style="font-size: 12pt;">using namespace std;</span></div><div><br></div><div><span style="font-size: 12pt;">template &lt;typename T&gt;</span></div><div><span style="font-size: 12pt;">void print_vector(vector&lt;T&gt;&amp; vec)&nbsp;</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 전체 벡터를 출력하기</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (</span><span style="font-size: 16px;">typename</span><span style="font-size: 16px;">&nbsp;</span><span style="font-size: 12pt;">vector&lt;T&gt;::iterator itr = vec.begin(); itr != vec.end(); itr++) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; endl;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">int main()</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt; vec;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(10);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(20);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(30);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vec.push_back(40);</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "초기 vec 상태" &lt;&lt; endl;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_vector(vec);</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "역으로 vec 출력하기!" &lt;&lt; endl;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// itr 은 vec[2] 를 가리킨다.&nbsp;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">vector&lt;int&gt;::reverse_iterator r_iter = vec.rbegin();</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (; r_iter != vec.rend(); r_iter++) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *r_iter &lt;&lt; endl;</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:253px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F216F123F595B2E522A9968 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F216F123F595B2E522A9968 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F216F123F595B2E522A9968 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F216F123F595B2E522A9968 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F216F123F595B2E522A9968 480w" src="https://t1.daumcdn.net/cfile/tistory/216F123F595B2E522A" style="max-width:100%;height:auto" width="253" height="208" filename="10.1.6.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 역으로 벡터의 원소들을 출력할 수 있습니다.&nbsp;</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/275B1D3D595B2F4011?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F275B1D3D595B2F4011531A 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F275B1D3D595B2F4011531A 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F275B1D3D595B2F4011531A 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F275B1D3D595B2F4011531A 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F275B1D3D595B2F4011531A 480w" src="https://t1.daumcdn.net/cfile/tistory/275B1D3D595B2F4011" style="cursor: pointer;max-width:100%;height:auto" width="730" height="325" filename="10.1.7.png" filemime="image/png"></span></span></p><p><span style="font-size: 12pt;">이전에 반복자의 end() 가 맨 마지막 원소의 바로 뒤를 가리켰던 것처럼, 역반복자의 rend() 역시 맨 앞 원소의 바로 앞을 가리키게 됩니다. 또한 반복자의 경우 값이 증가하면 뒤쪽 원소로 가는 것처럼, 역반복자의 경우 값이 증가하면 앞쪽 원소로 가게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">또 반복자가 상수 반복자가 있는 것 처럼 역반복자 역시 상수 역반복자가 있습니다. 그 타입은 const_reverse_iterator 타입이고, crbegin(), crend() 로 얻을 수 있습니다. </span></p><br></div><div><span style="font-size: 12pt;">앞서 설명한 함수들 말고도 vector 에는 수 많은 함수들이 있고, 또 오버로드 되는 여러가지 버전들이 있습니다. 예를 들어 insert 함수만 해도 5 개의 오버로드 되는 버전들이 있습니다 (물론 하는 역할은 똑같지만 편의를 위해 여러가지 방식으로 사용할 수 있게 만들어 놓은것입니다). 이 모든 것들을 강좌에서 소개하는 것은 시간 낭비이고, </span><a href="http://en.cppreference.com/w/cpp/container/vector" target="_blank" class="tx-link"><span style="font-size: 12pt;">C++ 레퍼런스를 보면 잘 정리</span></a><span style="font-size: 12pt;">되어 있으니 이를 참조하시기 바랍니다.</span></div><div><br></div><div><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;리스트 - list</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">리스트(list) 의 경우 양방향 연결 구조를 가진 자료형이라 볼 수 있습니다.&nbsp;</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/246A0A4B595B396939?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F246A0A4B595B396939AF3D 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F246A0A4B595B396939AF3D 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F246A0A4B595B396939AF3D 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F246A0A4B595B396939AF3D 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F246A0A4B595B396939AF3D 480w" src="https://t1.daumcdn.net/cfile/tistory/246A0A4B595B396939" style="cursor: pointer;max-width:100%;height:auto" width="730" height="285" filename="10.1.8.png" filemime="image/png"></span></span></p><p><span style="font-size: 12pt;">따라서 vector 와는 달리 임의의 위치에 있는 원소에 접근을 바로 할 수 없습니다. list 컨테이너 자체에서는 시작 원소와 마지막 원소의 위치만을 기억하기 때문에, 임의의 위치에 있는 원소에 접근하기 위해서는 하나씩 링크를 따라가야 합니다.</span></p><p><br></p><p><span style="font-size: 12pt;">그래서 리스트에는 아예 [] 나 at 함수가 아예 정의되어 있지 않습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">물론 리스트의 장점이 없는 것은 아닙니다. vector 의 경우 맨 뒤를 제외하고는 임의의 위치에 원소를 추가하거나 제거하는 작업이 O(n) 이였지만 리스트의 경우 O(1) 으로 매우 빠르게 수행될 수 있습니다. 왜냐하면 원하는 위치 앞과 뒤에 있는 링크값만 바꿔주면 되기 때문입니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;list&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">list&lt;int&gt; lst;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">lst.push_back(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">lst.push_back(20);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">lst.push_back(30);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">lst.push_back(40);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (list&lt;int&gt;::iterator itr = lst.begin(); itr != lst.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:277px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F26612B43595B40EF10724A 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F26612B43595B40EF10724A 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F26612B43595B40EF10724A 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F26612B43595B40EF10724A 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F26612B43595B40EF10724A 480w" src="https://t1.daumcdn.net/cfile/tistory/26612B43595B40EF10" style="max-width:100%;height:auto" width="277" height="135" filename="10.1.9.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 나옵니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">한 가지 재미있는점은 리스트의 반복자의 경우 다음과 같은 연산밖에 수행할 수 없습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">itr ++ // ++itr</span></p><p><span style="font-size: 12pt;">itr -- // --itr 도 됩니다.</span><br></p></div><p><br></p><p><span style="font-size: 12pt;">다시말해</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="font-size: 12pt;">itr + 5 // 불가능!</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같이 </span><b><span style="font-size: 12pt;">임의의 위치에 있는 원소를 가리킬 수 없다</span></b><span style="font-size: 12pt;">는 것입니다. 반복자는 오직 한 칸 씩 밖에 움직일 수 없습니다. 이와 같은 이유는 list 의 구조를 생각해보면 알 수 있습니다. 앞서 말했듯이 리스트는 왼쪽 혹은 오른쪽을 가리키고 있는 원소들의 모임으로 이루어져 있기 때문에, 한 번에 한 칸 씩 밖에 이동할 수 없습니다. 즉, 메모리 상에서 원소들이 연속적으로 존재하지 않을 수 있다는 뜻입니다. 반면에 벡터의 경우 메모리 상에서 연속적으로 존재하기 때문에 쉽게 임의의 위치에 있는 원소를 참조할 수 있습니다.&nbsp;</span><br><br></p><p><span style="font-size: 12pt;">이렇게 리스트&nbsp;에서 정의되는 반복자의 타입을 보면 BidirectionalIterator 타입임을 알 수 있습니다. 이름에서도 알 수 있듯이 양방향으로 이동할 수 있되,&nbsp;한 칸 씩 밖에 이동할 수 없습니다. 반면에 벡터에서 정의되는 반복자의 타입은 RandomAccessIterator 타입 입니다. 즉, 임의의 위치에 접근할 수 있는 반복자 입니다 (참고로 RandomAccessIterator 는 BidirectionalIterator&nbsp;를 상속받고 있습니다)</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;list&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void print_list(list&lt;T&gt;&amp; lst)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "[";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 전체 리스트를 출력하기</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (list&lt;T&gt;::iterator itr = lst.begin(); itr != lst.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; " ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "]" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">list&lt;int&gt; lst;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">lst.push_back(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">lst.push_back(20);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">lst.push_back(30);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">lst.push_back(40);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "처음 리스트의 상태 " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_list(lst);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (list&lt;int&gt;::iterator itr = lst.begin(); itr != lst.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">// 만일 현재 원소가 20 이라면</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">// 그 앞에 50 을 집어넣는다.</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 20) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">lst.insert(itr, 50);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "값이 20 인 원소 앞에 50을 추가 " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_list(lst);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (list&lt;int&gt;::iterator itr = lst.begin(); itr != lst.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">// 값이 30 인 원소를 삭제한다.</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 30) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">lst.erase(itr);</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">break;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "값이 30 인 원소를 제거한다" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_list(lst);</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:295px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F27012E3A595B49D938EB89 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F27012E3A595B49D938EB89 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F27012E3A595B49D938EB89 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F27012E3A595B49D938EB89 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F27012E3A595B49D938EB89 480w" src="https://t1.daumcdn.net/cfile/tistory/27012E3A595B49D938" style="max-width:100%;height:auto" width="295" height="161" filename="10.1.10.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 나옵니다.</span><br></p><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (list&lt;int&gt;::iterator itr = lst.begin(); itr != lst.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">// 만일 현재 원소가 20 이라면</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">// 그 앞에 50 을 집어넣는다.</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 20) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">lst.insert(itr, 50);</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">앞서 설명하였지만 리스트의 반복자는 BidirectionalIterator 이기 때문에 ++ 과 -- 연산만 사용 가능합니다. 따라서 위 처럼 for 문으로 하나 하나 원소를 확인해보는것은 가능하지요. vector 와는 다르게 insert 작업은 O(1) 으로 매우 빠르게 실행됩니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (list&lt;int&gt;::iterator itr = lst.begin(); itr != lst.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">// 값이 30 인 원소를 삭제한다.</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (*itr == 30) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">lst.erase(itr);</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">break;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">마찬가지로 erase 함수를 이용하여 원하는 위치에 있는 원소를 지울 수 도 있습니다. 물론 리스트의&nbsp;경우도 벡터와 마찬가지로 한 번 원소를 지우거나 추가하면 기존의 모든 반복자들이 무효화 됨을 생각해야 합니다.</span></p></div><p><br></p></div><div><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;덱 (deque - double ended queue)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">마지막으로 살펴볼 컨테이너는 덱(deque - deck 이라고 발음합니다) 이라고 불리는 자료형 입니다. 덱은 벡터와 비슷하게 O(1) 으로 임의의 위치의 원소에 접근할 수 있으며 맨 뒤에 원소를 추가/제거 하는 작업도 O(1) 으로 수행할 수 있습니다. 뿐만아니라 벡터와는 다르게 맨 앞에 원소를 추가/제거 하는 작업 까지도 O(1) 으로 수행 가능합니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">임의의 위치에 있는 원소를 제거/추가 하는 작업은 벡터와 마찬가지로 O(n) 으로 수행 가능합니다. 뿐만 아니라 그 속도도 벡터 보다 더 빠릅니다 (이 부분은&nbsp;아래 덱이 어떻게 구현되어 있는지 설명하면서 살펴보겠습니다.)&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 덱이 벡터에 비해 모든 면에서 비교 우위에 있는 걸까요? 안타깝게도 벡터와는 다르게 덱의 경우 원소들이 실제로 메모리 상에서 연속적으로 존재하지는 않습니다. 이 때문에 원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리가 더 필요로 합니다. (실제 예로, 64 비트 libc++ 라이브러리의 경우 1 개의 원소를 보관하는 덱은 그 원소 크기에 비해 8 배나 더 많은 메모리를 필요로 합니다).</span></p><p><br></p><p><span style="font-size: 12pt;">즉 덱은 실행 속도를 위해 메모리를 (많이) 희생하는 컨테이너라 보면 됩니다.&nbsp;</span></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/245FC94C595B5F9B13?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F245FC94C595B5F9B133E4E 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F245FC94C595B5F9B133E4E 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F245FC94C595B5F9B133E4E 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F245FC94C595B5F9B133E4E 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F245FC94C595B5F9B133E4E 480w" src="https://t1.daumcdn.net/cfile/tistory/245FC94C595B5F9B13" style="cursor: pointer;max-width:100%;height:auto" width="730" height="468" filename="10.1.13.png" filemime="image/png"></span></span></p><p><span style="font-size: 12pt;">위 그림은 덱이 어떠한 구조를 가지는지 보여줍니다. 일단, 벡터와는 다르게 원소들이 메모리에 연속되어 존재하는 것이 아니라 일정 크기로 잘려서 각각의 블록 속에 존재합니다. 따라서 이 블록들이 메모리 상에 어느 곳에 위치하여 있는지 저장하기 위해서 각각의 블록들의 주소를 저장하는 벡터가 필요로 합니다.</span><br></p><p><br></p><p><span style="font-size: 12pt;">참고로 이 벡터는 기존의 벡터와는 조금 다르게, 새로 할당 시에 앞쪽 및 뒤쪽 모두에&nbsp;공간을 남겨놓게 됩니다. (벡터의 경우 뒤쪽에만 공간이 남았지요) 따라서 이를 통해 맨 앞과 맨 뒤에 O(1) 의 속도로 insert 및 erase 를 수행할 수 있는 것입니다. 그렇다면 왜 덱이 벡터 보다 원소를 삽입하는 작업이 더 빠른 것일까요?&nbsp;</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/236D8137595B617B02?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F236D8137595B617B02463F 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F236D8137595B617B02463F 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F236D8137595B617B02463F 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F236D8137595B617B02463F 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F236D8137595B617B02463F 480w" src="https://t1.daumcdn.net/cfile/tistory/236D8137595B617B02" style="cursor: pointer;max-width:100%;height:auto" width="730" height="485" filename="10.1.14.png" filemime="image/png"></span></span></p><p><br></p><p><span style="font-size: 12pt;">위와 같은&nbsp;상황에서 deq.push_back(10) 을 수행하였다고 생각해봅시다.&nbsp;</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/244E834B595B642028?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244E834B595B642028B977 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244E834B595B642028B977 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244E834B595B642028B977 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244E834B595B642028B977 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244E834B595B642028B977 480w" src="https://t1.daumcdn.net/cfile/tistory/244E834B595B642028" style="cursor: pointer;max-width:100%;height:auto" width="730" height="467" filename="10.1.15.png" filemime="image/png"></span></span></p><p><span style="font-size: 12pt;">그렇다면 단순히 새로운 블록을 만들어서 뒤에 추가되는 원소를 넣어주면 됩니다. 즉 기존의 원소들을 복사할 필요가 전혀 없다는 의미 입니다. 반면에 벡터의 경우</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/23015636595B647418?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F23015636595B647418F5CE 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F23015636595B647418F5CE 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F23015636595B647418F5CE 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F23015636595B647418F5CE 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F23015636595B647418F5CE 480w" src="https://t1.daumcdn.net/cfile/tistory/23015636595B647418" style="cursor: pointer;max-width:100%;height:auto" width="730" height="352" filename="10.1.16.png" filemime="image/png"></span></span></p><p style="text-align: center; clear: none; float: none;"><br></p><p><span style="font-size: 12pt;">위 그림에서도 잘 알 수 있듯이, 만약에 기존에 할당한 메모리가 꽉 차면 모든 원소들을 새로운 공간에 복사해야 합니다. 따라서 평균적으로 덱이 벡터보다 더 빠르게 작동합니다. (물론 덱의 경우 블록 주소를 보관하는 벡터가 꽉 차게 되면 새로운 공간에 모두 복사해야 합니다. 하지만 블록 주소의 개수는 </span><b><span style="font-size: 12pt;">전체 원소 개수 보다 적고</span></b><span style="font-size: 12pt;"> ( 위 경우 N / 5 가 되겠네요. 왜냐하면 각 블록에 원소가 5개 씩 있으므로), 대체로 벡터에 저장되는 </span><b><span style="font-size: 12pt;">객체들의 크기가 주소값의 크기보다 크기 때문에</span></b><span style="font-size: 12pt;"> 복사 속도가 훨씬 빠릅니다.)</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;deque&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void print_deque(deque&lt;T&gt;&amp; dq)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 전체 덱을 출력하기</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "[ ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (deque&lt;T&gt;::iterator itr = dq.begin(); itr != dq.end(); itr++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; *itr &lt;&lt; " ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; " ] " &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">deque&lt;int&gt; dq;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.push_back(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.push_back(20);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.push_front(30);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.push_front(40);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "초기 dq 상태" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_deque(dq);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "맨 앞의 원소 제거" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.pop_front();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">print_deque(dq);</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:245px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F22224A3B595B66C807172A 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F22224A3B595B66C807172A 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F22224A3B595B66C807172A 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F22224A3B595B66C807172A 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F22224A3B595B66C807172A 480w" src="https://t1.daumcdn.net/cfile/tistory/22224A3B595B66C807" style="max-width:100%;height:auto" width="245" height="128" filename="10.1.17.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 수행됩니다. </span><br></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.push_back(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.push_back(20);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.push_front(30);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.push_front(40);</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같이 push_back 과 push_front 를 이용해서 맨 앞과 뒤에 원소들을 추가하였고,</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dq.pop_front();</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">pop_front 함수를 이용해서 맨 앞의 원소를 제거할 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">앞서 말했듯이 덱 역시 벡터 처럼 임의의 위치에 원소에 접근할 수 있으므로 [] 와 at 함수를 제공하고 있고, 반복자 역시 RandomAccessIterator 타입 이고 벡터랑 정확히 동일한 방식으로 작동합니다.</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;그래서 어떤 컨테이너를 사용해야돼?</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p></p><p><span style="font-size: 12pt;">어떠한 컨테이너를 사용할지는 전적으로 이 컨테이너를 가지고 어떠한 작업들을 많이 하냐에 달려있습니다.</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 12pt;">일반적인 상황에서는 그냥 벡터를 사용한다 (거의 만능이다!)</span></li><li><span style="font-size: 12pt;">만약에 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 일을 많이 하고, </span><b><span style="font-size: 12pt;">원소들을 순차적으로만 접근</span></b><span style="font-size: 12pt;">한다면 리스트를 사용한다.&nbsp;</span></li><li><span style="font-size: 12pt;">만약에 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이하면 덱을 사용한다.</span></li></ul></div><div><br></div><div><span style="font-size: 12pt;">자 이번 강좌는 이것으로 마치도록 하겠습니다. 다음 강좌에서는 다른 종류의 컨테이너인 연관 컨테이너에 대해서 배웁니다.</span></div><div><br></div><div><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;생각 해보기</span><span style="font-size: 12pt;">&nbsp;</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="color: rgb(48, 88, 210); font-size: 12pt;">&nbsp;</span><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><p><br><span style="font-size: 12pt;">1. deque 를 구현해보세요. (난이도 : 중)</span><br></p></div><div><br></div><div><span style="font-size: 12pt;">2. </span><a href="http://en.cppreference.com/w/cpp/container" target="_blank" class="tx-link"><span style="font-size: 12pt;">여기에서 시퀀스 컨테이너들의 모든 함수들을 찾아볼 수 있습니다.</span></a><span style="font-size: 12pt;"> 한 번 읽어보세요!</span></div><div><br></div><div><div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox"><span style="font-size: 12pt;">
</span><span style="font-size:12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 </span><span style="font-weight: bold; font-size: 12pt;">꼭 댓글을 남겨주시기 바랍니다</span><span style="font-size: 12pt;">. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span><br><span style="font-size: 12pt;">
</span><br><span style="font-size: 12pt;">
</span><span style="font-size:12pt;">현재 여러분이 보신 강좌는</span><i><span style="font-size: 12pt;">&lt;&lt;</span></i><span style="font-size: 16px;"><i><span style="font-size: 12pt;">씹어먹는 C++ - &lt;10 - 1. C++ 의 표준 템플릿 라이브러리 (STL) - 시퀀스 컨테이너&gt;</span></i></span><span style="font-size: 12pt;"><i><span style="font-size: 12pt;">&gt;&gt;</span></i><span style="font-size: 12pt;"> 입니다. 이번 강좌의 </span><span style="font-size: 12pt; font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span><span style="font-size: 12pt;">까지 다음 강좌로 넘어가지 말아주세요 </span><br><span style="font-size: 12pt;">
</span><br><span style="font-size: 12pt;">
</span><div style="text-align: right;"><span style="font-size: 12pt;">
</span><span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135"><span style="font-size: 12pt;">다음 강좌 보러가기</span></a><br><span style="font-size: 12pt;">
</span></span><span style="font-size: 12pt;">
</span></div><span style="font-size: 12pt;">
</span></span></div><span style="font-size: 12pt;">
</span><br></div><p></p><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_223" data-uoc-sc="401" data-uoc-pcurl="http://itguru.tistory.com/223" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_223"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text screen_out">공감</span><span class="txt_like uoc-count">1</span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile5.uf.tistory.com/image/242D6B46595B6DA41B4BCE" data-title="씹어먹는 C++ - <10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)>" data-description="이번 강좌에서는 C++ 표준 템플릿 라이브러리 개요 시퀀스 컨테이너(sequence container) 반복자 (iterator) 에 대해 배웁니다.  안녕하세요 여러분! 지난번 템플릿 메타프로그래밍 강좌는 어떠셨나요? TMP 를 활.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/223" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="223"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/223&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++">C++</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/225?category=361027">씹어먹는 C++ - &lt;10 - 3. C++ STL - 알고리즘(algorithm)&gt;</a>&nbsp;&nbsp;<span>(16)</span>
</th>
<td>
2017.07.09</td>
</tr>
<tr>
<th>
<a href="/224?category=361027">씹어먹는 C++ - &lt;10 - 2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map&gt;</a>&nbsp;&nbsp;<span>(5)</span>
</th>
<td>
2017.07.08</td>
</tr>
<tr>
<th>
<a href="/223?category=361027" class="current">씹어먹는 C++ - &lt;10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.07.04</td>
</tr>
<tr>
<th>
<a href="/222?category=361027">씹어먹는 C++ - &lt;9 - 3. 템플릿 메타 프로그래밍 2&gt;</a>&nbsp;&nbsp;<span>(8)</span>
</th>
<td>
2017.07.02</td>
</tr>
<tr>
<th>
<a href="/221?category=361027">씹어먹는 C++ - &lt;9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.06.26</td>
</tr>
<tr>
<th>
<a href="/219?category=361027">씹어먹는 C++ - &lt;9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)&gt;</a>&nbsp;&nbsp;<span>(10)</span>
</th>
<td>
2017.04.07</td>
</tr>
</tbody></table></div></div>
<br> <br>


					