
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<div class="tt_article_useless_p_margin"><p></p><div></div>
<div></div><p><span style="font-size: 8pt;">이번 강좌에서는</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 8pt;">move 문법 (move semantics)</span></li><li><span style="font-size: 8pt;">완벽한 전달 (perfect forwarding)</span></li><li><span style="font-size: 8pt;">레퍼런스 겹침 (reference collapsing)</span></li></ul><div><span style="font-size: 8pt;">등에 대해 다룹니다.</span></div><div><span style="font-size: 16px;"><hr><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/999F4B3D5ABA197911?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F999F4B3D5ABA1979118454 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F999F4B3D5ABA1979118454 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F999F4B3D5ABA1979118454 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F999F4B3D5ABA1979118454 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F999F4B3D5ABA1979118454 480w" src="https://t1.daumcdn.net/cfile/tistory/999F4B3D5ABA197911" style="cursor: pointer;max-width:100%;height:auto" width="730" height="158" filename="__CODE____C___by_webblaster48.jpg" filemime="image/jpeg"></span></span></p><p><br></p></span></div><p><span style="font-size: 12pt;">안녕하세요 여러분! 지난번의 우측값 레퍼런스 강의는 어떠셨나요? 우측값 레퍼런스를 통해서, 기존에는 불가능하였던 우측값에 대한 복사가 아닌 이동의 구현이 가능하게 되었습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">하지만, 만약에&nbsp;좌측값도 이동을 시키고 싶다면 어떨까요? 예를 들어서 아래와 같이 두 변수의 값을 바꾸는 swap 함수를 생각해보세요.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void my_swap(T &amp;a, T &amp;b)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T tmp(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">a = b;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">b = tmp;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 my_swap 함수에서 tmp 라는 임시 객체를 생성한 뒤에, b&nbsp;를 a 에 복사하고, b 에 a 를 복사하게 됩니다. 문제는 무려 복사를 쓸데없이 3 번이나 한다는 점입니다. 예를 들어서 T 가 MyString 인 경우를 생각해봅시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class MyString</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">char *string_content; // 문자열 데이터를 가리키는 포인터</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int string_length; // 문자열 길이</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int memory_capacity; // 현재 할당된 용량</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 문자열로 부터 생성</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const char* str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 복사 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const MyString &amp;str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 이동 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(MyString&amp;&amp; str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void reserve(int size);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString operator+ (const MyString &amp;s);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString&amp; operator= (const MyString &amp;s);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int length() const;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void println();</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = NULL;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString(const char* str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = strlen(str);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(const MyString &amp;str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "복사 생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str.string_content[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(MyString&amp;&amp; str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동 생성자 호출 !" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = str.string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = str.memory_capacity;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 임시 객체 소멸 시에 메모리를 해제하지</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 못하게 한다.&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_content = nullptr;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::~MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (string_content)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete[] string_content;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::reserve(int size)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (size &gt; memory_capacity) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">char *prev_string_content = string_content;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content = new char[size];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">memory_capacity = size;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">string_content[i] = prev_string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (prev_string_content != NULL)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">delete[] prev_string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString MyString::operator+ (const MyString &amp;s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.reserve(string_length + s.string_length);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[i] = string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; s.string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[string_length + i] = s.string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_length = string_length + s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return str;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString&amp; MyString::operator= (const MyString &amp;s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "복사!" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (s.string_length &gt; memory_capacity) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete[] string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content = new char [s.string_length];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">memory_capacity = s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = s.string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return *this;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int MyString::length() const</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return string_length;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::println()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void my_swap(T &amp;a, T &amp;b)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T tmp(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">a = b;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">b = tmp;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str1("abc");</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str2("def");</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Swap 전 -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str1.println();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str2.println();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Swap 후 -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">my_swap(str1, str2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str1.println();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str2.println();</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:334px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99115F3E5AB8FD86061B59 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99115F3E5AB8FD86061B59 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99115F3E5AB8FD86061B59 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99115F3E5AB8FD86061B59 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99115F3E5AB8FD86061B59 480w" src="https://t1.daumcdn.net/cfile/tistory/99115F3E5AB8FD8606" style="max-width:100%;height:auto" width="334" height="255" filename="11.2.1.png" filemime="image/png" ""=""></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void my_swap(T &amp;a, T &amp;b)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T tmp(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">a = b;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">b = tmp;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 my_swap 함수를 살펴봅시다. 일단, 첫번째 줄에서, a 가 좌측값이기 때문에 tmp 의 복사 생성자가 호출됩니다. 따라서 1 차적으로 a 가 차지하는 공간 만큼 메모리 할당이 발생한 후 a 의 데이터가 복사됩니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">a = b;</span></p></div><p style="margin-left: 2em;"><br></p><p><span style="font-size: 12pt;">두 번째로 a = b; 에서 2 차적으로 복사가 발생합니다. 그리고 마지막으로,</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">b = tmp;</span></p></div><p style="margin-left: 2em;"><br></p><p><span style="font-size: 12pt;">에서 또 한번 문자열 전체의 복사가 이루어지게 됩니다. 무려 swap 을 하기 위해 문자열 전체 복사를 3번이나 해야 합니다. 아래 그림처럼 말입니다.&nbsp;</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:555px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F9960ED4D5AB96B7D09D8A7 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F9960ED4D5AB96B7D09D8A7 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F9960ED4D5AB96B7D09D8A7 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F9960ED4D5AB96B7D09D8A7 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F9960ED4D5AB96B7D09D8A7 480w" src="https://t1.daumcdn.net/cfile/tistory/9960ED4D5AB96B7D09" style="max-width:100%;height:auto" width="555" height="676" filename="11.2.2.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">하지만 우리는 굳이 문자열 내용을 복사할 필요 없이 각 MyString 객체의 string_content 주소값만 서로 바꿔주면 되는 것을 알고 있습니다. (물론 string_length 와 memory_capacity 도 바꿔야겠지만, 이들은 단순히 4바이트 int 복사 이기 때문에 속도에 영향을 주지는 않습니다).</span></p><br></div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:515px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F997263435AB96BB9085570 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F997263435AB96BB9085570 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F997263435AB96BB9085570 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F997263435AB96BB9085570 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F997263435AB96BB9085570 480w" src="https://t1.daumcdn.net/cfile/tistory/997263435AB96BB908" style="max-width:100%;height:auto" width="515" height="657" filename="11.2.3.png" filemime="image/png"></span></p><p></p><p><span style="font-size: 12pt;">하지만 위를 my_swap 에서 구현하기 위해서는 여러가지 문제가 있습니다. 일단 첫번째로 my_swap 함수는 generic 한 함수 입니다. 다시 말해,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void my_swap(T &amp;a, T &amp;b)</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 함수가 일반적인 타입 T 에 대해 작동해야 한다는 의미이지요. 하지만 위 string_content 의 경우 MyString 에만 존재하는 필드이기 때문에 일반적인 타입 T 에 대해서는 작동하지 않습니다. 물론 그렇다고 해서 불가능 한 것은 아닙니다. 아래 처럼 템플릿 특수화를 이용하면 되기 때문이죠.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;&gt;</span></p><p><span style="font-size: 12pt;">void my_swap(MyString &amp;a, MyString &amp;b)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">문제는 string_content 가 private 이기 때문에, 이를 위해 MyString 내부에 swap 관련한 함수를 만들어야 된다는 것입니다. 사실 이렇게 된다면 굳이 my_swap 이라는 함수를 정의할 필요가 없게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">위 문제를 원래의 my_swap 함수를 사용하면서&nbsp;좀 더 깔끔하게 해결할 수 있는 방법은 없을까요?</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T tmp(a);</span></p></div><p><br></p><p><span style="font-size: 12pt;">먼저 기존의 my_swap 함수를 다시 살펴봅시다. 우리는 위 문장이 복사 생성자 대신에, 이동 생성자가 되기를 원합니다. 왜냐하면 tmp 를 복사생성 할 필요 없이, 단순히 a 를 잠깐 옮겨놓기만 하면 되기 때문이지요. 하지만 문제는 a 가 좌측값이라는 점입니다 ('a' 라는 실체가 있으므로). 따라서 지금 이 상태로는 우리가 무얼 해도 이동 생성자는 오버로딩 되지 않습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면, 좌측값이&nbsp;우측값으로 취급될 수 있게 바꿔주는 함수 같은 것이 있을까요? 즉, 어떠한 좌측값이 이동 될 수 있도록 말이죠.&nbsp;</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;move 문법 (move semantics)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><span style="font-size: 12pt;">
</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class MyString</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">char *string_content; // 문자열 데이터를 가리키는 포인터</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int string_length; // 문자열 길이</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int memory_capacity; // 현재 할당된 용량</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 문자열로 부터 생성</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const char* str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 복사 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const MyString &amp;str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 이동 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(MyString&amp;&amp; str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void reserve(int size);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString operator+ (const MyString &amp;s);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString&amp; operator= (const MyString &amp;s);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int length() const;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void println();</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = NULL;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString(const char* str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = strlen(str);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(const MyString &amp;str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "복사 생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str.string_content[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(MyString&amp;&amp; str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동 생성자 호출 !" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = str.string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = str.memory_capacity;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 임시 객체 소멸 시에 메모리를 해제하지</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 못하게 한다.&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_content = nullptr;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_length = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.memory_capacity = 0;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::~MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (string_content)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete[] string_content;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::reserve(int size)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (size &gt; memory_capacity) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">char *prev_string_content = string_content;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content = new char[size];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">memory_capacity = size;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">string_content[i] = prev_string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (prev_string_content != NULL)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">delete[] prev_string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString MyString::operator+ (const MyString &amp;s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.reserve(string_length + s.string_length);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[i] = string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; s.string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[string_length + i] = s.string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_length = string_length + s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return str;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int MyString::length() const</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return string_length;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::println()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str1("abc");</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동 전 -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str1 : ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str1.println();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동 후 -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str2(move(str1));</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str1 : ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str1.println();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str2 : ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str2.println();</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:315px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99BE55345AB99D231E151B 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99BE55345AB99D231E151B 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99BE55345AB99D231E151B 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99BE55345AB99D231E151B 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99BE55345AB99D231E151B 480w" src="https://t1.daumcdn.net/cfile/tistory/99BE55345AB99D231E" style="max-width:100%;height:auto" width="315" height="191" filename="11.2.4.png" filemime="image/png"></span></p><p><br></p></div><p><span style="font-size: 12pt;">와 같이 나옵니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동 후 -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str2(move(str1));</span></p></div><p><br></p><p><span style="font-size: 12pt;">부분을 살펴보도록 합시다. 놀랍게도 str2 의 복사 생성자가 아닌 이동 생성자가 호출되었습니다. C++ 11 에 새롭게 추가된 move 함수는 입력받은 좌측값을 이동 가능한 값으로 캐스팅 해줍니다. </span><b><span style="font-size: 12pt;">사실 move 함수가 수정하는 것은 아무 것도 없습니다. 다만 컴파일러가 move 함수가 리턴하는 값을 '이동 가능 하구나' 라고 생각하게 해주지요.&nbsp;</span></b></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str1 : ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str1.println();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str2 : ";</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str2.println();</span></p></div><p><br></p><p><span style="font-size: 12pt;">그렇게 이동 된 후에 문자열들을 출력해보면 str1 에는 빈 문자열이, str2 에는 원래의 str1 의 문자열이 들어있음을 알 수 있습니다. 이 과정에서 문자열 전체 복사는 한 번도 발생하지 않고 단순히 string_content 의 값만 복사되었을 뿐입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">자 이제 이 새로운 move 를 이용해서 위 my_swap 함수를 수정해보도록 합시다.&nbsp;&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class MyString</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">char *string_content; // 문자열 데이터를 가리키는 포인터</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int string_length; // 문자열 길이</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int memory_capacity; // 현재 할당된 용량</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 문자열로 부터 생성</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const char* str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 복사 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const MyString &amp;str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 이동 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(MyString&amp;&amp; str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void reserve(int size);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString operator+ (const MyString &amp;s);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString&amp; operator= (const MyString &amp;s);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int length() const;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void println();</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = NULL;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString(const char* str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = strlen(str);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(const MyString &amp;str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "복사 생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str.string_content[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(MyString&amp;&amp; str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동 생성자 호출 !" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = str.string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = str.memory_capacity;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 임시 객체 소멸 시에 메모리를 해제하지</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 못하게 한다.&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_content = nullptr;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_length = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.memory_capacity = 0;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::~MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (string_content)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete[] string_content;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::reserve(int size)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (size &gt; memory_capacity) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">char *prev_string_content = string_content;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content = new char[size];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">memory_capacity = size;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">string_content[i] = prev_string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (prev_string_content != NULL)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">delete[] prev_string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString MyString::operator+ (const MyString &amp;s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.reserve(string_length + s.string_length);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[i] = string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; s.string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[string_length + i] = s.string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_length = string_length + s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return str;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString&amp; MyString::operator= (const MyString &amp;s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "복사!" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (s.string_length &gt; memory_capacity) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete[] string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content = new char [s.string_length];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">memory_capacity = s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = s.string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return *this;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int MyString::length() const</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return string_length;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::println()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void my_swap(T &amp;a, T &amp;b)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T tmp(move(a));</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">a = move(b);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">b = move(tmp);</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str1("abc");</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str2("def");</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Swap 전 -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str1 : "; str1.println();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str2 : "; str2.println();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Swap 후 -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">my_swap(str1, str2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str1 : "; str1.println();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "str2 : "; str2.println();</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:331px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BA0F435AB9A114146E55 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BA0F435AB9A114146E55 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BA0F435AB9A114146E55 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BA0F435AB9A114146E55 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BA0F435AB9A114146E55 480w" src="https://t1.daumcdn.net/cfile/tistory/99BA0F435AB9A11414" style="max-width:100%;height:auto" width="331" height="273" filename="11.2.5.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">위에서 보시다싶이 swap 은 잘 되었지만, 공교롭게도 두 번의 복사를 수행하였습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">a = move(b);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">b = move(tmp);</span></p></div><p><br></p><p><span style="font-size: 12pt;">왜냐하면 바로 위 두 줄 때문이지요. 비록 move 를 시키고자 하였지만, 오버로딩 된 operator= 가 복사를 수행하였습니다. 그 이유는 현재 정의된 operator= 가</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">MyString&amp; MyString::operator= (const MyString &amp;s)</span></p></div><p><br></p><p><span style="font-size: 12pt;">꼴 이므로, s 를 그대로 복사하기 때문이지요. 따라서 우리는 우측값에만 특이적으로 오버로딩 되는 operator= 를 정의해줘야만 합니다. 아래와 같이 말이지요.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">MyString&amp; MyString::operator= (MyString&amp;&amp; s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동!" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = s.string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = s.memory_capacity;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = s.string_length;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">s.string_content = nullptr;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">s.memory_capacity = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">s.string_length = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return *this;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">그리고 성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:316px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F99ABCE4F5AB9A225263122 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F99ABCE4F5AB9A225263122 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F99ABCE4F5AB9A225263122 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F99ABCE4F5AB9A225263122 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F99ABCE4F5AB9A225263122 480w" src="https://t1.daumcdn.net/cfile/tistory/99ABCE4F5AB9A22526" style="max-width:100%;height:auto" width="316" height="254" filename="11.2.6.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 제대로 이동을 시키고 있음을 알 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">새롭게 정의한 operator= 를 살펴보면 매우 간단합니다. 굳이 문자열 전체를 복사할 필요가 없이, 단순히 string_content 값만 복사해주면 되기 때문이지요. 물론&nbsp;s 에 있던 문자열은 사라지게 됩니다. 하지만 상관 없습니다. 어차피 우측값 이니까요!</span><br></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;완벽한 전달</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="color: rgb(48, 88, 210); font-size: 12pt;">&nbsp;(perfect forwarding)</span><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">C++ 11 에 우측값 레퍼런스가 도입되기 전 까지 해결할 수 없었던 문제가 있었습니다. 예를 들어서 아래와 같은 wrapper 함수를 생각해봅시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T u)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u);</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 함수는 인자로 받은 u 를 그대로 g 라는 함수에 인자로 '전달' 해줍니다. 물론 왜 저런 함수가 필요하나고 생각할 수 있습니다. 그냥 저런 wrapper 함수를 만들지 말고 그냥 g(u) 를 호출하면 되잖아요?&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 실제로 저러한 형태의 전달 방식이 사용되는 경우가 종종 있습니다. 예를 들어 STL 의 vector 에는 emplace_back 이라는 함수가 있습니다. 예를 들어서 클래스 A 를 원소로 가지는&nbsp;벡터의 뒤에 원소를 추가하기 위해서는</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">vec.push_back(A(1, 2, 3));</span></p></div><p><br></p><p><span style="font-size: 12pt;">과 같이 객체를 생성한 뒤에 인자로 전달해줘야만 합니다. 하지만 이 과정에서 불필요한 이동 혹은 복사가&nbsp;발생하게 됩니다. 그렇다면, 아예 벡터에 인자를 전달해준 다음, 벡터 내부에서 자체적으로 객체를 생성한 뒤에 벡터 뒤에 추가하면 어떨까요? 이를 가능하게 하는게 emplace_back 함수 입니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">vec.emplace_back(1,2,3); // 위와 동일한 작업을 수행한다.</span></p></div><p><br></p><p><span style="font-size: 12pt;">emplace_back 함수는 인자를 직접 전달받아서, 내부에서 A 의 생성자를 호출한 뒤에 이를 벡터 원소 뒤에 추가하게 되지요. 이 과정에서 불필요한 이동/복사 모두 발생하지 않습니다. 참고로 새로 생성한 객체를 벡터 뒤에 추가할 경우 위와 같이 push_back 을 이용하는 것 보다 emplace_back 을 이용하는 것이 권장되는 방식입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 문제는 emplace_back 함수가 받은 인자들을 A 의 생성자에 제대로 전달해야 합니다. 그렇지 않을 경우 사용자가&nbsp;의도하지 않은 생성자가 호출될 수 있기 때문입니다. 그렇다면 위와 같은 wrapper 함수를 어떻게 하면 잘 정의할 수 있을까요?</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T u)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u);</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">class A {};</span></p><p><br></p><p><span style="font-size: 12pt;">void g(A&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "좌측값 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void g(const A&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "좌측값 상수 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void g(A&amp;&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "우측값 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A a;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">const A ca;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "원본 --------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(ca);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(A());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Wrapper -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(ca);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(A());</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:293px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99ADBC435AB9C1621B4011 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99ADBC435AB9C1621B4011 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99ADBC435AB9C1621B4011 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99ADBC435AB9C1621B4011 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99ADBC435AB9C1621B4011 480w" src="https://t1.daumcdn.net/cfile/tistory/99ADBC435AB9C1621B" style="max-width:100%;height:auto" width="293" height="204" filename="11.2.7.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "원본 --------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(ca);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(A());</span></p></div><p><br></p><p><span style="font-size: 12pt;">먼저 위 경우 우리의 예상대로 좌측값 레퍼런스, 좌측값 상수 레퍼런스, 우측값 레퍼런스가 각각 호출되었습니다. 반면에 wrapper 함수를 거쳐갔을 경우, 공교롭게도 위 세 경우 모두 좌측값 레퍼런스를 받는 g 함수가 호출되었습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이러한 일이 발생한 이유는 C++ 컴파일러가 템플릿 타입을 추론할 때, </span><b><span style="font-size: 12pt;">템플릿 인자 T 가 레퍼런스가 아닌 일반적인 타입이라면 const 를 무시하기 때문</span><sup class="footnote"><a id="footnote_link_228_1" href="#footnote_228_1" onmouseover="tistoryFootnote.show(this,228,1)" onmouseout="tistoryFootnote.hide(228,1)" style="color:#f9650d;font-family:Verdana,Sans-serif"><span style="display:none">[각주:</span>1<span style="display:none">]</span></a></sup></b><span style="font-size: 12pt;">입니다. 다시 말해,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T u)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u);</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">에서 T 가 전부 다 class A 로 추론됩니다. 따라서 위 세 경우 전부 다 좌측값 레퍼런스를 호출하는 g 를 호출하였습니다.&nbsp;</span></p><p><br></p><p></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T&amp; u)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u);</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">그렇다면 위 경우는 어떨까요?&nbsp;</span></div><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="font-size: 12pt;">error: cannot bind non-const lvalue reference of type 'A&amp;' to an rvalue of type 'A'</span></p><p><span style="font-size: 12pt;">&nbsp; wrapper(A());</span></p><p><span style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^~~</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같은 컴파일 오류가&nbsp;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(A());</span></p><div><br></div><p><span style="font-size: 12pt;">에서 발생합니다. (<span style="color: rgb(255, 0, 0);"><b>참고로 이 오류는 gcc 와 clang 컴파일러에서 모두 발생하는데, 비주얼 스튜디오에서는 발생하지 않습니다. 하지만 원칙적으로 위와 같은 오류를 발생시켜야 하는 것이 맞습니다</b></span>).&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">왜 위와 같은 오류가 발생하는지 생각해보자면 다음과 같습니다. 일단, A() 자체는 const 속성이 없으므로 템플릿 인자 추론에서 T 가 class A 로 추론됩니다. 하지만 A&amp; 는 우측값의 레퍼런스가 될 수 없기 때문에 컴파일 오류가 발생하는 것입니다.&nbsp;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_5_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">그렇다면 아예 우측값을 레퍼런스로 받을 수 있도록 const A&amp; 와 A&amp; 따로 만들어주는 방법이 있습니다. 아래와 같이 말이지요.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;vector&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T&amp; u)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "T&amp; 로 추론됨" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u);</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(const T&amp; u)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "const T&amp; 로 추론됨" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u);</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">class A {};</span></p><p><br></p><p><span style="font-size: 12pt;">void g(A&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "좌측값 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void g(const A&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "좌측값 상수 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void g(A&amp;&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "우측값 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A a;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">const A ca;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "원본 --------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(ca);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(A());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Wrapper -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(ca);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(A());</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:317px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99DB5A3A5ABA0364292293 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99DB5A3A5ABA0364292293 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99DB5A3A5ABA0364292293 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99DB5A3A5ABA0364292293 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99DB5A3A5ABA0364292293 480w" src="https://t1.daumcdn.net/cfile/tistory/99DB5A3A5ABA036429" style="max-width:100%;height:auto" width="317" height="251" filename="11.2.8.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">일단 a 와 ca 의 경우 각각 T&amp; 와 const T&amp; 로 잘 추론되서 올바른 함수를 호출하고 있음을 알 수 있습니다. 반면에 A() 의 경우 const T&amp; 로 추론되면서 g(const T&amp;) 함수를 호출하게 됩니다. 물론 이는 예상했던 일입니다. 우리가 무엇을 해도 wrapper 안에 u 가 좌측값이라는 사실은 변하지 않고 이에 언제나 좌측값 레퍼런스를 받는 함수들이 오버로딩 되겠지요.</span><br></p><p><br></p><p><span style="font-size: 12pt;">뿐만이 아니라 다음과 같은 문제가 있습니다. 예를 들어서 함수 g 가 인자를 한 개가 아니라 2 개를 받는다고 가정합니다. 그렇다면 우리는 다음과 같은 모든 조합의 템플릿 함수들을 정의해야합니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T&amp; u, T &amp;v)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u, v);</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(const T&amp; u, T &amp;v)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u, v);</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T&amp; u, const T &amp;v)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u, v);</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(const T&amp; u, const T &amp;v)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(u, v);</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">매우 귀찮은 일입니다. 위와 같이 짜야하는 이유는 단순히 일반적인 레퍼런스가 우측값을 받을 수 없기 때문입니다. 그렇다고 해서 디폴트로 상수 레퍼런스만 받게 된다면, 상수가 아닌&nbsp;레퍼런스도 상수 레퍼런스로 캐스팅되서 들어간다는 점이지요.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 놀랍게도 C++ 11 에서는 이를 간단하게 해결할 수 있습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T&amp;&amp; u)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(forward&lt;T&gt;(u));</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">class A {};</span></p><p><br></p><p><span style="font-size: 12pt;">void g(A&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "좌측값 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void g(const A&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "좌측값 상수 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void g(A&amp;&amp; a) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "우측값 레퍼런스 호출" &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A a;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">const A ca;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "원본 --------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(ca);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(A());</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Wrapper -----" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(ca);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(A());</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:289px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99772B4C5ABA05F832FD06 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99772B4C5ABA05F832FD06 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99772B4C5ABA05F832FD06 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99772B4C5ABA05F832FD06 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99772B4C5ABA05F832FD06 480w" src="https://t1.daumcdn.net/cfile/tistory/99772B4C5ABA05F832" style="max-width:100%;height:auto" width="289" height="197" filename="11.2.9.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 작동함을 알 수 있습니다.</span><br></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T&gt;</span></p><p><span style="font-size: 12pt;">void wrapper(T&amp;&amp; u)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(forward&lt;T&gt;(u));</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">일단 우리의 wrapper 함수는 인자로 아예 T&amp;&amp; 를 받아버리고 있습니다. 아니 이렇게 된다면 도대체 좌측값은 어떻게 받겠다는 것일까요? 사실 C++ 11 에서 템플릿 인자들 간에 다음과 같은 레퍼런스 겹침&nbsp;규칙 (reference collapsing rule) 을 정하였습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">typedef int&amp; T;</span></p><p><span style="font-size: 12pt;">T&amp; r1; // int&amp; &amp;; r1 은 int&amp;</span></p><p><span style="font-size: 12pt;">T&amp;&amp; r2; // int &amp; &amp;&amp;;&nbsp; r2 는 int&amp;</span></p><p><br></p><p><span style="font-size: 12pt;">typedef int&amp;&amp; U</span></p><p><span style="font-size: 12pt;">U&amp; r3; // int &amp;&amp; &amp;; r3 는 int&amp;</span></p><p><span style="font-size: 12pt;">U&amp;&amp; r4; // int &amp;&amp; &amp;&amp;; r4 는 int&amp;&amp;</span></p></div><p><br></p><p><span style="font-size: 12pt;">즉 쉽게 생각하면 &amp; 는 1 이고 &amp;&amp; 은 0 이라 둔 뒤에, OR 연산을 한다고 보면 됩니다.&nbsp;그렇다면,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(a);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(ca);</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 두 개의 호출의 경우 T 가 각각 A&amp; 와 const A&amp; 로 추론될 것이고,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">wrapper(A());</span></p></div><div><br></div><div><span style="font-size: 12pt;">의 경우에는 T 가 단순히 A&amp;&amp; 로 추론되겠지요.&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">그런데 문제는 이제 직접 g 에 이 인자를 전달하는 방법입니다. 왜 그냥</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div style="margin-left: 2em;"><span style="font-size: 12pt;">g(u)</span></div></div><div><br></div><div><span style="font-size: 12pt;">로 하지 않았는지 생각해봅시다. 앞서도 말했듯이 여기서 u 는 좌측값 입니다. u 가 우측값 레퍼런스임에도 불구하고,&nbsp;const int&amp; 를 오버로딩하는 g 가 호출되게 됩니다. 물론 우리는 좌측값을 어떻게 하면 우측값으로 캐스팅&nbsp;시킬지 알고 있습니다. 바로 move 를 이용하는 것입니다.</span></div><div><br></div><div><span style="font-size: 12pt;">하지만 위 경우 아무때나 move 를 하면 안됩니다. 인자로 받은 u 가 우측값 레퍼런스 일 때 에만 move 를 해줘야만 하는 것입니다. 만일 좌측값 레퍼런스일 때 move 를 해버린다면 좌측값에 오버로딩 되는 g 가 아닌 우측값에 오버로딩 되는 g 가 호출되겠지요.&nbsp;</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">g(forward&lt;T&gt;(u));</span></p></div></div><div><br></div><div><span style="font-size: 12pt;">이 문제를 해결해주는 것이 forward 함수&nbsp;입니다. 이 함수는 u 가 우측값 레퍼런스 일 때 에만 마치 move 를 적용한 것 처럼 작동합니다. 실제로 forward 가 어떻게 생겼나면,</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">template&lt;class S&gt;</span></div><div><span style="font-size: 12pt;">S&amp;&amp; forward(typename remove_reference&lt;S&gt;::type&amp; a) noexcept</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">&nbsp; return static_cast&lt;S&amp;&amp;&gt;(a);</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">와 같이 생겼는데, S 가 A&amp; 라면 (참고로 remove_reference 는 타입의&nbsp;레퍼런스를 지워주는 템플릿 메타 함수 입니다)</span></div><div><br></div><div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">A&amp; &amp;&amp; forward(typename remove_reference&lt;A&amp;&gt;::type&amp; a) noexcept</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">&nbsp; return static_cast&lt;A&amp; &amp;&amp;&gt;(a);</span></div><div><span style="font-size: 12pt;">}</span></div></div></div></div><div><br></div><div><span style="font-size: 12pt;">가 되어 레퍼런스 겹침 규칙에 따라</span></div><div><br></div><div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">A&amp; forward(A&amp; a) noexcept</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">&nbsp; return static_cast&lt;A&amp;&gt;(a);</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div><br></div></div><div><span style="font-size: 12pt;">가 되버리고, S 가 그냥 A 라면, (퀴즈! 여기서 왜 forward 의 인자가 A&amp;&amp; 가 아니라 A&amp;&nbsp;일까요?)</span></div><div><br></div><div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">A&amp;&amp; forward(A&amp; a) noexcept</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">&nbsp; return static_cast&lt;A&amp;&amp;&gt;(a);</span></div><div><span style="font-size: 12pt;">}</span></div></div></div></div><div><br></div><div><span style="font-size: 12pt;">가 되어 성공적으로 우측값으로 캐스팅해줍니다. 따라서 결과적으로 위 그림 처럼 원본과 Wrapper 을 사용했을 때 모두 호출되는 함수가 동일함을 알 수 있습니다. 성공적으로 인자를 전달한 것이지요!</span></div><p><br></p><p><span style="font-size: 12pt;">자 그럼 이것으로 이번 강좌를 마치도록 하겠습니다. 다음 강좌에서는 여태까지 배운 내용을 바탕으로 스마트 포인터를 사용하는 방법에 대해서 다루어보도록 하겠습니다.&nbsp;</span></p><p><br></p><p></p><p></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><font color="#3058d2" face="Gulim"><span style="font-size: 13.3333px;"><b><span style="font-size: 12pt;">&nbsp;생각 해보기</span></b></span></font></td><td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">1. 실제로 move 와 forward 가 어떠한 방식으로 구현되어 있는지 궁금하신 분들은 </span><a href="https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-api-4.5/a00936_source.html" target="_blank" class="tx-link"><span style="font-size: 12pt;">여기를 참고하시면 됩니다</span></a><span style="font-size: 12pt;">. 한 번 코드를 보시고 왜 이런 방식으로 구현되어 있는지 생각해보세요. (난이도 : 중)</span><p></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;"><br></span></p><p></p><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox">
<span style="font-size:12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 <span style="font-weight: bold;">꼭 댓글을 남겨주시기 바랍니다</span>. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span><span style="font-size: 11pt;"></span><br>
<br>
<span style="font-size: 12pt;">현재 여러분이 보신 강좌는<i>&lt;&lt;</i></span><span style="font-size: 16px;"><i>씹어먹는 C++ - &lt;11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)&gt;</i></span><span style="font-size: 12pt;"><i>&gt;&gt;</i> 입니다. 이번 강좌의 </span><span style="font-size: 12pt; font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span><span style="font-size: 12pt;">까지 다음 강좌로 넘어가지 말아주세요 </span><br>
<br>
<div style="text-align: right;">
<span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135">다음 강좌 보러가기</a><br>
</span>
</div>
</div>
<br><br><p></p><div class="footnotes">
<ol class="footnotes">
<li id="footnote_228_1">http://en.cppreference.com/w/cpp/language/template_argument_deduction

에서 Deduction from a function call 의 첫번째 항목을 읽어보세요.  <a href="#footnote_link_228_1">[본문으로]</a></li>
</ol>
</div>
<script type="text/javascript">
tistoryFootnote.add(228,1,"http:\/\/en.cppreference.com\/w\/cpp\/language\/template_argument_deduction\n\n\uc5d0\uc11c Deduction from a function call \uc758 \uccab\ubc88\uc9f8 \ud56d\ubaa9\uc744 \uc77d\uc5b4\ubcf4\uc138\uc694. ");
</script><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_228" data-uoc-sc="401" data-uoc-pcurl="http://itguru.tistory.com/228" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_228"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text screen_out">공감</span><span class="txt_like uoc-count">2</span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile7.uf.tistory.com/image/99596D425AB96B7D0A976B" data-title="씹어먹는 C++ - <11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)>" data-description="이번 강좌에서는 move 문법 (move semantics) 완벽한 전달 (perfect forwarding) 레퍼런스 겹침 (reference collapsing) 등에 대해 다룹니다.  안녕하세요 여러분! 지난번의 우측값 레퍼런스 강의는 어떠셨나요?.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/228" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="228"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/228&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++">C++</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/228?category=361027" class="current">씹어먹는 C++ - &lt;11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)&gt;</a>&nbsp;&nbsp;<span>(7)</span>
</th>
<td>
2018.03.27</td>
</tr>
<tr>
<th>
<a href="/227?category=361027">씹어먹는 C++ - &lt;11 - 1. 우측값 레퍼런스와 이동 생성자&gt;</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2018.03.24</td>
</tr>
<tr>
<th>
<a href="/225?category=361027">씹어먹는 C++ - &lt;10 - 3. C++ STL - 알고리즘(algorithm)&gt;</a>&nbsp;&nbsp;<span>(16)</span>
</th>
<td>
2017.07.09</td>
</tr>
<tr>
<th>
<a href="/224?category=361027">씹어먹는 C++ - &lt;10 - 2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map&gt;</a>&nbsp;&nbsp;<span>(5)</span>
</th>
<td>
2017.07.08</td>
</tr>
<tr>
<th>
<a href="/223?category=361027">씹어먹는 C++ - &lt;10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.07.04</td>
</tr>
<tr>
<th>
<a href="/222?category=361027">씹어먹는 C++ - &lt;9 - 3. 템플릿 메타 프로그래밍 2&gt;</a>&nbsp;&nbsp;<span>(8)</span>
</th>
<td>
2017.07.02</td>
</tr>
</tbody></table></div></div>
<br> <br>


					