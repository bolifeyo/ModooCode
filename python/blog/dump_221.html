
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<div class="tt_article_useless_p_margin"><p><span style="font-size: 8pt;">이번 강좌에서는</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 8pt;">타입이 아닌 템플릿 인자</span></li><li><span style="font-size: 8pt;">템플릿 메타 프로그래밍의 시작</span></li><li><span style="font-size: 8pt;">using 키워드 사용</span></li></ul><div><span style="font-size: 16px;"><hr><p></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/2154D04A5950B93618?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2154D04A5950B93618C72A 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2154D04A5950B93618C72A 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2154D04A5950B93618C72A 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2154D04A5950B93618C72A 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2154D04A5950B93618C72A 480w" src="https://t1.daumcdn.net/cfile/tistory/2154D04A5950B93618" style="cursor: pointer;max-width:100%;height:auto" width="730" height="158" filename="__CODE____C___by_webblaster48.jpg" filemime="image/jpeg"></span></span></p><p><br></p></span></div><p><span style="font-size: 12pt;">안녕하세요 여러분! 지난번 강좌에서 template 을 처음으로 소개하였는데 어떠하셨나요? 템플릿을 통해서 프로그래밍이 좀 더 편해진 것 같나요? 이렇게 템플릿을 통해서 타입이 마치 인자 인것 처럼 사용하는 것을 바로 일반화 프로그래밍 (generic programming) 혹은 그냥 제너릭 프로그래밍 이라고 부릅니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">앞선 강좌에서는 템플릿 인자로 타입들만 전달하였지만, 실제로는 일반적인 값들도 인자로 전달할 수 있습니다.&nbsp;아래의 예제를 살펴보겠습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">/* 템플릿 인자로 값을 받기 */</span></p><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T, unsigned int N&gt;</span></p><p><span style="font-size: 12pt;">class Array</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T data[N];</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 배열을 받는 레퍼런스 arr</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Array(T (&amp;arr)[N]) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i &lt; N; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">data[i] = arr[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T* get_array() {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return data;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">unsigned int size() {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return N;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void print_all() {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i &lt; N; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">cout &lt;&lt; data[i] &lt;&lt; ", ";</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">int main()&nbsp;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int arr[3] = { 1,2,3 };</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 배열 wrapper 클래스</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Array&lt;int, 3&gt; arr_w (arr);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">arr_w.print_all();</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:369px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27754F3B594C979F2AF4C4 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27754F3B594C979F2AF4C4 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27754F3B594C979F2AF4C4 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27754F3B594C979F2AF4C4 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27754F3B594C979F2AF4C4 480w" src="https://t1.daumcdn.net/cfile/tistory/27754F3B594C979F2A" style="max-width:100%;height:auto" width="369" height="176" filename="9.2.1.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T, int N&gt;</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">템플릿 정의 부분을 살펴보면 바로 알겠지만, 템플릿 역시 마치 함수의 인자에 값을 받는 것 처럼 템플릿에도 값을 전달 할 수 있습니다. 다만 함수 처럼 임의의 객체를 인자로 받을 수 있는 것은 아니고, 위 처럼 정수 타입이나, 레퍼런스 혹은 포인터 만을 받을 수 있습니다. 그 이유는 잘 생각해보면 당연한데, 템플릿이 인스턴스화 되는 과정은 컴파일 시에 일어나는데, 만약에 객체를 직접 받는다면, 컴파일을 하기 전에 컴파일을 해야되는 모순적인 상황이 발생하게 되기 때문이지요.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">아무튼, 템플릿 인자로는 단순한 정수타입이나, 레퍼런스, 포인터만 받을 수 있다고 생각하시면 됩니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 배열 wrapper 클래스</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Array&lt;int, 3&gt; arr_w (arr);</span></p></div><p><br></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">위와 같이 템플릿 인스턴스화를 하게 되면, 템플릿에 T 자리에는 int 가, N 자리에는 3 이 들어가겠지요. 그렇다면 컴파일러는</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">T data[N];</span></p></div><div><br></div><div><span style="font-size: 12pt;">를</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int data[3];</span></p></div></div><div><br></div><p><span style="font-size: 12pt;">으로 대체해서 코드를 생성하게 되고, 마찬가지로</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp; // 배열을 받는 레퍼런스 arr</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Array(T (&amp;arr)[N]) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i &lt; N; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">data[i] = arr[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">생성자 역시</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp; // 배열을 받는 레퍼런스 arr</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Array(int&nbsp;(&amp;arr)[3]) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i &lt; 3; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">data[i] = arr[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">로 아예 코드가 생성되어 실행됩니다. 참고로 이 처럼 배열을 감싸는 wrapper 클래스를 만들어서 마치 배열 처럼 사용한다면 (물론 그러기 위해서는 [] 연산자도 오버로드 해야겠죠?) 배열을 사용함으로써 발생하는 문제들을 많이 해결할 수 있게 됩니다. 예를 들어서, 일반 배열은 배열 범위가 넘어가도 알 수 없지만, 위 Array 클래스는 index 범위가 넘어가는 곳을 가리키면 뭔가 메세지를 띄우든 오류를 발생 시키든 해서 사용자에게 알려 줄 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그런데, 과연 아래 두 개 클래스는 같은 클래스 일까요? 다른 클래스 일까요?</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">Array&lt;int, 5&gt;</span></p><p><span style="font-size: 12pt;">Array&lt;int, 3&gt;</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">간단히 아래 코드로 확인해 볼 수 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">cout &lt;&lt; (typeid(Array&lt;int, 3&gt;) == typeid(Array&lt;int, 5&gt;)) &lt;&lt; endl;</span></p></div><p><br></p><p><span style="font-size: 12pt;">참고로 typeid 를 사용하려면 &lt;typeinfo&gt; 헤더파일을 추가해주시면 됩니다. 그 결과는 당연하게도</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:300px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2649724B594CB13D2F1774 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2649724B594CB13D2F1774 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2649724B594CB13D2F1774 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2649724B594CB13D2F1774 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2649724B594CB13D2F1774 480w" src="https://t1.daumcdn.net/cfile/tistory/2649724B594CB13D2F" style="max-width:100%;height:auto" width="300" height="96" filename="9.2.2.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 다르다고 나옵니다. 왜 다르냐면 당연히, 다른 템플릿 인자로 인스턴스화 되었기 때문이지요. 컴파일러는 Array&lt;int, 5&gt; 와 Array&lt;int, 3&gt; 를 위해&nbsp;각기 다른 코드를 생성하며 다른 클래스의 객체들을 만들게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 아래와 같이 정의된 Int&nbsp;클래스를 생각해봅시다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;int N&gt;</span></p><p><span style="font-size: 12pt;">struct Int {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int num = N;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 클래스는 템플릿 인자로 int 값을 받습니다. 참고로, 왜 static const 에 값을 저장하냐면, 첫 번째로 C++ 클래스 멤버 중에서 클래스 자체에서 저런 식으로 초기화를 할 수 있는 멤버의 타입은 static const 밖에 없고, 두 번째로 static const 야 말로 '이 클래스는 이 것이다' 라는 의미를 가장 잘 나타내기 때문입니다. 왜냐하면 static 타입 멤버의 특성 상, 이 클래스가 생성한 객체들 사이에서 공유되는 값이기 때문에</span><b><span style="font-size: 12pt;"> '이 타입이면 이 값을 나타낸다' </span></b><span style="font-size: 12pt;">라고 볼 수 있습니다. 또한 const 이므로, 그 나타내는 값이 변하지 않게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 아래 처럼 마치 객체를 생성하듯 타입들을 생성할 수 있습니다.&nbsp;&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">typedef Int&lt;1&gt; one;</span></p><p><span style="font-size: 12pt;">typedef Int&lt;2&gt; two;</span></p></div><p><br></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">그렇다면 저 one 타입과 two 타입은 1 과 2 의 값을 나타내는 타입이 됩니다. (one 과 two 는 객체가 아닙니다!)</span></p><p><br></p><p><span style="font-size: 12pt;">그럼 이제 one 과 two 를 가지고 무엇을 할 수 있을까요? 재미있게도 마치 int 변수를 다루는 것 처럼 연산자를 만들 수 있습니다. 아래 예제를 살펴볼까요.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;typeinfo&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int N&gt;</span></p><p><span style="font-size: 12pt;">struct Int {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int num = N;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T, typename U&gt;</span></p><p><span style="font-size: 12pt;">struct add {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Int &lt;T::num + U::num&gt; result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Int&lt;1&gt; one;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Int&lt;2&gt; two;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef add&lt;one, two&gt;::result three;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Addtion result : " &lt;&lt; three::num &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:312px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F215FB037594F3E06197C17 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F215FB037594F3E06197C17 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F215FB037594F3E06197C17 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F215FB037594F3E06197C17 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F215FB037594F3E06197C17 480w" src="https://t1.daumcdn.net/cfile/tistory/215FB037594F3E0619" style="max-width:100%;height:auto" width="312" height="120" filename="9.2.3.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 실제 계산 결과가 잘 나오게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">덧셈을 수행하는 템플릿 클래스를 살펴봅시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T, typename U&gt;</span></p><p><span style="font-size: 12pt;">struct add {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Int&lt;T::num + U::num&gt; result;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 add 클래스의 템플릿은 인자로 두 개의 타입을 받아서 그 타입의 num 멤버를 더해서 새로운 타입인 result 를 만들어 내게 됩니다.&nbsp;</span><br></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">typedef add&lt;one, two&gt;::result three;</span></p></div><div><br></div><div><span style="font-size: 12pt;">위 부분은 실제 덧셈을 수행하는 부분입니다. add 클래스를 함수라고 생각한다면 그 계산 결과를 내부 result 타입으로 반환한다고 보면 됩니다. 아무튼 one 과 two 를 더한 것을 나타내는 타입이&nbsp;result 로 정의되고, 이를 three 라고 부르겠습니다.&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">실제로, 그 결과를 보면&nbsp;</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">cout &lt;&lt; "Addtion result : " &lt;&lt; three::num &lt;&lt; endl;</span></div></div><div><br></div><div><span style="font-size: 12pt;">를 통해서 3 이 잘 출력됨을 알 수 있습니다. &nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">한 가지 흥미로운 점은 </span><b><span style="font-size: 12pt;">저 3 이라는 값이 프로그램이 실행되면서 계산되는 것이 아니라는 점</span></b><span style="font-size: 12pt;">입니다. 컴파일 시에, 컴파일러가 three::num 을 3 으로 치환 해버립니다.</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:558px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F23499834594F45E110436F 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F23499834594F45E110436F 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F23499834594F45E110436F 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F23499834594F45E110436F 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F23499834594F45E110436F 480w" src="https://t1.daumcdn.net/cfile/tistory/23499834594F45E110" style="max-width:100%;height:auto" width="558" height="162" filename="9.2.4.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">실제로 마우스를 올려보면 저 값이 3 이란 사실을 알 수 있습니다. </span><br></p><br></div><div><span style="font-size: 12pt;">다시 말해, 저 덧셈이 수행 되는 시기는 컴파일 타임이고, 런타임 시에는 단순히 그 결과를 보여주게 되는 것입니다.&nbsp;</span></div><div><br></div><div><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;템플릿 메타 프로그래밍</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="color: rgb(48, 88, 210); font-size: 12pt;">&nbsp;(Template Meta Programming - TMP)</span><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">여태까지 </span><b><span style="font-size: 12pt;">타입은 어떠한 객체에 무엇을 저장하느냐를 지정</span></b><span style="font-size: 12pt;">하는데 사용해 왔지, 타입 자체가 어떠한 값을 가지지는&nbsp;않았습니다. 하지만, 바로 위 예제를 통해서 알 수 있듯이, 템플릿을 사용하면 객체를 생성하지 않더라도,</span><b><span style="font-size: 12pt;"> 타입에 어떠한 '값' 을 부여</span></b><span style="font-size: 12pt;">할 수 있고, 또 그 </span><b><span style="font-size: 12pt;">타입들을 가지고 '연산' 을 할 수 있다</span></b><span style="font-size: 12pt;">는 점 입니다. 또한&nbsp;타입은 반드시 컴파일 타임에 확정되어야 하므로, 컴파일 타임에 모든 연산이 끝나게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이렇게 타입을 가지고 </span><b><span style="font-size: 12pt;">컴파일 타임에 생성되는 '코드'로 프로그래밍</span></b><span style="font-size: 12pt;">을 하는 것을 메타 프로그래밍(meta programming) 이라고 합니다. C++ 의 경우 템플릿을 가지고 이러한 작업을 하기 때문에 </span><b><span style="font-size: 12pt;">템플릿 메타 프로그래밍, 줄여서 TMP </span></b><span style="font-size: 12pt;">라고 부릅니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">/* 컴파일 타임 팩토리얼 계산 */</span></p><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int N&gt;</span></p><p><span style="font-size: 12pt;">struct Factorial {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int result = N * Factorial&lt;N - 1&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;&gt;</span></p><p><span style="font-size: 12pt;">struct Factorial&lt;1&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int result = 1;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "6! = 1*2*3*4*5*6 = " &lt;&lt; Factorial&lt;6&gt;::result &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p></div></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:306px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F24481E4F595009FA13AE76 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F24481E4F595009FA13AE76 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F24481E4F595009FA13AE76 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F24481E4F595009FA13AE76 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F24481E4F595009FA13AE76 480w" src="https://t1.daumcdn.net/cfile/tistory/24481E4F595009FA13" style="max-width:100%;height:auto" width="306" height="90" filename="9.2.5.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 나옵니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">팩토리얼(factorial) 은 단순히 1 부터 &nbsp;n 까지 곱한 것이라 생각하면 됩니다. 예를 들어 3 팩토리얼 (3! 이라 씁니다) 은 1 * 2 * 3 이라 생각하면 됩니다. 이 팩토리얼을 어떻게 하면 이전 예제와 같은 템플릿을 사용한 구조로 나타낼 수 있을까요? 사실 아래와 같이 매우 단순합니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;int N&gt;</span></p><p><span style="font-size: 12pt;">struct Factorial {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int result = N * Factorial&lt;N - 1&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">만약에 저 Factorial 을 일반적인 함수로 구성하려고 했다면 아마 아래와 같은 재귀 함수 형태를 사용했겠지요.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int factorial(int n) {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (n == 1) return 1;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return n * factorial(n - 1);</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">따라서 우리는 위 처럼 재귀 함수 호출이 끝나게 하기 위해선, n 이 1 일 때 따로 처리를 해주어야 합니다. 템플릿 역시 마찬가지로 n = 1 일 때 따로 처리할 수 있는데 바로 아래 처럼 템플릿 특수화를 이용해주면 됩니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;&gt;</span></p><p><span style="font-size: 12pt;">struct Factorial&lt;1&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int result = 1;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">컴파일러는 Factorial&lt;1&gt; 타입의 경우만 따로 result = 1 로 만들어주게 되어서 재귀적 구조가 끝날 수 있게 해줍니다.</span></p><p><br></p><p><span style="font-size: 12pt;">위 예제에서 볼 수 있듯이, 저기서 실질적으로 값을 가지는 객체는 아무 것도 없습니다. 즉, '720' 이라는 값을 가지고 있는 변수는 메모리 상에서 없다는 뜻입니다 (물론 cout 에서 출력 할 때 빼고). 저 화면에 나타나는 720 이라는 값은, 단순히 컴파일러가 만들어낸 Factorial&lt;6&gt; 이라는 타입을 나타내고 있을 뿐입니다.&nbsp;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_5_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">사실 여러분 한테 factorial 을 계산하라는 함수를 만들라고 이야기 했다면 십중팔구 그냥 단순히 for 문으로 구현을 하였을 것입니다. 하지만 안타깝게도 템플릿으로는 for 문을 쓸 수 없기 때문에 위와 같은 재귀적 구조를 사용하였습니다. 한 가지 다행인 소식은 for 문으로 구현할 수 있는 모든 코드는 똑같이 템플릿 메타 프로그래밍을 이용해서 구현할 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">더군다나 위에서 보셨듯이 if 문 역시 템플릿 메타 프로그래밍으로 구현할 수 있습니다. 위 팩토리얼 예제에서도 알 수 있듯이,&nbsp;if 문 부분은 템플릿 특수화로 처리 가능합니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;"></span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="FONT-WEIGHT: bold">&nbsp;TMP 를 왜 쓰는가?</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br>
</span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim">&nbsp;</span></span></td></tr></tbody></table><p></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">한 가지 재미있는 사실은&nbsp;</span><b><span style="font-size: 12pt;">어떠한 C++ 코드도 템플릿 메타 프로그래밍 코드로 변환할 수 있다는 점입니다</span></b><span style="font-size: 12pt;"> (물론 엄청나게 코드가 길어지겠지만요). 게다가 템플릿 메타 프로그래밍으로 작성된 코드는 모두 컴파일 타임에 모든 연산이 끝나기 때문에 프로그램 실행 속도를 향상 시킬 수 있다는 장점이 있습니다 (당연히도 컴파일 시간은 엄청 늘어나게 됩니다).&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 그렇다고 해서 템플릿 메타 프로그래밍으로 프로그램 전체를 구현하는 일은 없습니다. 일단 템플릿 메타 프로그래밍은 매우 복잡합니다. 물론 위 Factorial 예제는 꽤 간단하였지만 아래 좀 더 복잡한 예제를 다루면서 왜 템플릿 메타 프로그래밍이 힘든 것인지 이야기 하겠습니다. 그 뿐만이 아니라, 템플릿 메타 프로그래밍으로 작성된 코드는 버그를 찾는 것이 매우 힘듭니다. 일단 기본적으로 '컴파일' 타임에 연산하는 것이기 때문에 디버깅이 불가능 하고, C++ 컴파일러에 특성 상 템플릿 오류 시에 엄청난 길이의 오류를 내뿜게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 TMP 를 이용하는 경우는 꽤나 제한적이지만, 많은 C++ 라이브러리들이 TMP 를 이용해서 구현되었고 (Boost 라이브러리), TMP 를 통해서 컴파일 타임에 여러 오류들을 잡아낼 수 도 있고 (Ex. 단위나 통화 일치 여부</span><span style="font-size: 12pt;">등등) 속도가 매우 중요한 프로그램의 경우 TMP 를 통해서 런타임 속도도 향상 시킬 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">아래에서 좀 더 복잡한 예제를 가지고 그렇다면 TMP 를 어떻게 사용할 지에 대해서 자세히 알아보도록 하겠습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">컴퓨터 상에서 두 수의 최대공약수를 구하기 위해선 보통 유클리드 호제법을 이용합니다. 이는 매우 간단한데, 이 알고리즘을 일반적인 함수로 나타내자면 아래와 같습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int gcd(int a, int b)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (b == 0) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return a;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return &nbsp;gcd(b, a % b);</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">따라서 이를 그대로 TMP 로 바꿔보면 아래와 같습니다. (여러분도 직접 해보세요!)</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int X, int Y&gt;</span></p><p><span style="font-size: 12pt;">struct GCD</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int value = GCD&lt;Y, X%Y&gt;::value;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int X&gt;</span></p><p><span style="font-size: 12pt;">struct GCD&lt;X, 0&gt;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int value = X;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "gcd (36, 24) :: " &lt;&lt; GCD&lt;36, 24&gt;::value &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:308px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23373A49595058531B9B43 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23373A49595058531B9B43 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23373A49595058531B9B43 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23373A49595058531B9B43 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23373A49595058531B9B43 480w" src="https://t1.daumcdn.net/cfile/tistory/23373A49595058531B" style="max-width:100%;height:auto" width="308" height="119" filename="9.2.6.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 계산됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이 최대 공약수 계산 클래스를 만든 이유는, 바로 Ratio 클래스를 만들기 위함입니다. Ratio 클래스는 유리수(p/q 꼴로 쓸 수 있는 수) 를 오차 없이 표현해 주는 클래스 입니다. 물론 TMP 를 사용하지 않고 간단하게 클래스를 사용해서도 만들 수 있습니다. 하지만 일단 연습 삼아서 한 번 TMP 를 사용해서&nbsp;만들어 보겠습니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><br></p><p><span style="font-size: 12pt;">template &lt;int N, int D = 1&gt;</span></p><p><span style="font-size: 12pt;">struct Ratio</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Ratio&lt;N, D&gt; type;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int num = N;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int den = D;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">먼저 Ratio 클래스는 위 처럼 정의할 수 있겠습니다. 위 처럼 분자와 분모를 템플릿 인자로 받고, 타입을 나타내게 됩니다. 참고로 편의상&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">typedef Ratio&lt;N, D&gt; type;</span></p></div><p><br></p><p><span style="font-size: 12pt;">typedef 로 '자기 자신을 가리키는 타입' 을 넣어 주었습니다. 이는 마치 클래스에서의 this 와 비슷한 역할입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 이 Ratio 로 덧셈을 수행하는 템플릿을 만들어보겠습니다. 상당히 직관적입니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_add</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>typedef&nbsp;Ratio &lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt; type;</span></p><p><span style="font-size: 16px;">};</span></p></div><div><br></div><div><span style="font-size: 16px;">두 분수의 더한 결과를 Ratio 에 분자 분모로 전달하면 알아서 기약분수로 만들어줍니다.&nbsp;</span></div><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 16px;"><span style="white-space: pre;">	</span>typedef&nbsp;Ratio &lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt; type;</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">그 후에, 그 덧셈 결과를 type 로 나타내게 됩니다. 따라서 덧셈을 수행하기 위해서는&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef _Ratio_add&lt;rat, rat2&gt;::type result;</span></p></div><div><br></div><div><span style="font-size: 12pt;">이런 식으로 사용하면 되겠지요. 하지만 한 발 더 나아가서, 귀찮게 ::type 를 치고 싶지 않다고 해 봅시다. 다시 말해 Ratio_add 를 하면 그 자체로 두 Ratio 가 더해진 타입이 되는 것이지요. 이는 아래와 같이 구현할 수 있습니다.&nbsp;</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 12pt;">struct Ratio_add : _Ratio_add&lt;R1, R2&gt;::type {};</span></div></div></div><p><br></p><p><span style="font-size: 12pt;">바로 _Ratio_add&lt;R1, R2&gt;::type 를 상속 받는 Ratio_add 클래스를 만들어 버리는 것입니다! 상당히 재미있는 아이디어입니다. 따라서 Ratio_add 는 마치 Ratio 타입 처럼 사용할 수 있게 됩니다. 전체 코드를 살펴 보자면 아래와 같습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;typeinfo&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int X, int Y&gt;</span></p><p><span style="font-size: 12pt;">struct GCD</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int value = GCD&lt;Y, X%Y&gt;::value;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int X&gt;</span></p><p><span style="font-size: 12pt;">struct GCD&lt;X, 0&gt;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int value = X;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int N, int D = 1&gt;</span></p><p><span style="font-size: 12pt;">struct Ratio</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Ratio&lt;N, D&gt; type;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int num = N; // 분자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int den = D; // 분모</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 12pt;">struct _Ratio_add</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Ratio &lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt; type;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 12pt;">struct Ratio_add : _Ratio_add&lt;R1, R2&gt;::type {};</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Ratio&lt;2, 3&gt; rat;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Ratio&lt;3, 2&gt; rat2;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Ratio_add&lt;rat, rat2&gt; rat3;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; rat3::num &lt;&lt; " / " &lt;&lt; rat3::den &lt;&lt; endl;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return 0;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><div><br></div><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:291px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2776165059506A812E3256 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2776165059506A812E3256 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2776165059506A812E3256 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2776165059506A812E3256 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2776165059506A812E3256 480w" src="https://t1.daumcdn.net/cfile/tistory/2776165059506A812E" style="max-width:100%;height:auto" width="291" height="86" filename="9.2.7.png" filemime="image/png"></span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 계산되서 나옵니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">참고로 C++11 부터 typedef 대신에 좀 더 직관적인 using 이라는 키워드를 사용할 수 있습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp; typedef Ratio_add&lt;rat, rat2&gt; rat3;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using rat3 = Ratio_add&lt;rat, rat2&gt;;</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 두 문장 모두 동일한 의미를 가집니다. 다만 using 을 사용하였을 경우 typedef 보다 좀 더 이해하기가 쉽습니다. 특히, 함수 포인터의 경우 만일 void 를 리턴하고 int, int 를 인자로 받는 함수의 포인터의 타입을 func 라고 정의하기 위해서는 typedef 로&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; typedef void (*func)(int, int);</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같이 사용해야 했지만 (놀랍게도 func 이 새로 정의된 타입 이름이 됩니다) using 키워드를 사용하면</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using func = void(*) (int, int);</span></p></div><p><br></p><p><span style="font-size: 12pt;">아래와 같이 매우 직관적으로 나타낼 수 있습니다. 따라서 위의 코드를 수정하자면;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using rat = Ratio&lt;2, 3&gt;;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using rat2 = Ratio&lt;3, 2&gt;;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using rat3 = Ratio_add&lt;rat, rat2&gt;;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; rat3::num &lt;&lt; " / " &lt;&lt; rat3::den &lt;&lt; endl;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return 0;</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">로 간단하고 좀 더 직관적으로 나타낼 수 있습니다. 다시 한 번 말하지만, 마치 Ratio 클래스의 객체를 생성한 것 같지만, 실제로 생성된 객체는 한 개도 없고, 단순히 타입들을 컴파일러가 만들어낸 것 뿐입니다.&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">마찬가지 방법으로 모든 사칙연산들을 구현하자면 아래와 같습니다.</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 16px;">#include &lt;iostream&gt;</span></div><div><span style="font-size: 16px;">using namespace std;</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;int X, int Y&gt;</span></div><div><span style="font-size: 16px;">struct GCD</span></div><div><span style="font-size: 16px;">{</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>static const int value = GCD&lt;Y, X%Y&gt;::value;</span></div><div><span style="font-size: 16px;">};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;int X&gt;</span></div><div><span style="font-size: 16px;">struct GCD&lt;X, 0&gt;</span></div><div><span style="font-size: 16px;">{</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>static const int value = X;</span></div><div><span style="font-size: 16px;">};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;int N, int D = 1&gt;</span></div><div><span style="font-size: 16px;">struct Ratio</span></div><div><span style="font-size: 16px;">{</span></div><div><span style="font-size: 16px;">private:</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>const static int _gcd = GCD&lt;N, D&gt;::value;</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">public:</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>typedef Ratio&lt;N / _gcd, D / _gcd&gt; type;</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>static const int num = N / _gcd;</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>static const int den = D / _gcd;</span></div><div><span style="font-size: 16px;">};</span></div><div><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 16px;">struct _Ratio_add</span></div><div><span style="font-size: 16px;">{</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;;</span></div><div><span style="font-size: 16px;">};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 16px;">struct Ratio_add : _Ratio_add&lt;R1, R2&gt;::type {};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 16px;">struct _Ratio_subtract</span></div><div><span style="font-size: 16px;">{</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;;</span></div><div><span style="font-size: 16px;">};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 16px;">struct Ratio_subtract : _Ratio_subtract&lt;R1, R2&gt;::type {};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 16px;">struct _Ratio_multiply</span></div><div><span style="font-size: 16px;">{</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::num , R1::den * R2::den&gt;;</span></div><div><span style="font-size: 16px;">};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 16px;">struct Ratio_multiply : _Ratio_multiply&lt;R1, R2&gt;::type {};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 16px;">struct _Ratio_divide</span></div><div><span style="font-size: 16px;">{</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt; R1::num * R2::den, R1::den * R2::num&gt;;</span></div><div><span style="font-size: 16px;">};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></div><div><span style="font-size: 16px;">struct Ratio_divide : _Ratio_divide&lt;R1, R2&gt;::type {};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">int main()</span></div><div><span style="font-size: 16px;">{</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>using r1 = Ratio&lt;2, 3&gt;;</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>using r2 = Ratio&lt;3, 2&gt;;</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>using r3 = Ratio_add&lt;r1, r2&gt;;</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>cout &lt;&lt; "2/3 + 3/2 = " &lt;&lt; r3::num &lt;&lt; " / " &lt;&lt; r3::den &lt;&lt; endl;</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>using r4 = Ratio_multiply&lt;r1, r3&gt;;</span></div><div><span style="font-size: 16px;"><span style="white-space:pre">	</span>cout &lt;&lt; "13 / 6 * 2 /3 = " &lt;&lt; r4::num &lt;&lt; " / " &lt;&lt; r4::den &lt;&lt; endl;</span></div><div><span style="font-size: 16px;">}</span></div></div></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><br></div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:307px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F237B10405950A66E12890D 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F237B10405950A66E12890D 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F237B10405950A66E12890D 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F237B10405950A66E12890D 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F237B10405950A66E12890D 480w" src="https://t1.daumcdn.net/cfile/tistory/237B10405950A66E12" style="max-width:100%;height:auto" width="307" height="99" filename="9.2.8.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">자 여기까지 따라 오셨다면 한 가지 궁금증이 들 것입니다.&nbsp;</span><br></p><p><br></p><p><span style="font-size: 12pt;">"음 그래. Ratio 로 이용해서 재미있는 것을 할 수 있는거 같애. 컴파일 타임에 유리수 사칙 연산을 계산할 수 있다는 것도 좋아. 근데 도대체 저게 왜 필요하지?"&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">바로 다음 강좌에서 알아 보도록 하겠습니다!</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;생각 해보기</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><p></p><p><br><span style="font-size:12pt;">1. N 번째 피보나치 수를 나타내는 TMP 를 만들어보세요. 참고로 피보나치 수는, N 번째 항이 N - 1 번째 항과 N - 2 번째 항의 합으로 정의되는 수 입니다. 참고로</span><span style="font-size: 12pt;">&nbsp;1, 1, 2, 3, 5, ... 로 진행됩니다. </span><span style="font-size: 12pt;">(난이도 : 하)</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int main()&nbsp;</span></p><p><span style="font-size: 12pt;">{</span></p><p style="margin-left: 2em;"><span style="font-size: 12pt;">cout &lt;&lt; "5 번째 피보나치 수 :: " &lt;&lt; fib&lt;5&gt;::result &lt;&lt; endl; // 5</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">2. TMP 를 사용해서 어떤 수가 소수인지 아닌지를 판별하는 프로그램을 만들어보세요. (난이도 : 상) <span style="color: rgb(255, 0, 0);">참고로 이 문제는 다음 강좌에서 다룰 예정입니다!</span></span></p><p></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; boolalpha;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is prime ? :: " &lt;&lt; is_prime&lt;2&gt;::result &lt;&lt; endl; // true</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is prime ? :: " &lt;&lt; is_prime&lt;10&gt;::result &lt;&lt; endl; // false</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_6_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 708px; background-color: transparent;"><ins id="aswift_6_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 708px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="708" height="177" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_6" name="aswift_6" style="left:0;position:absolute;top:0;width:708px;height:177px;"></iframe></ins></ins></ins></div><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is prime ? :: " &lt;&lt; is_prime&lt;11&gt;::result &lt;&lt; endl; // true</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is prime ? :: " &lt;&lt; is_prime&lt;61&gt;::result &lt;&lt; endl; // true</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><br></p><p></p><div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox">
<span style="font-size:12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 <span style="font-weight: bold;">꼭 댓글을 남겨주시기 바랍니다</span>. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span><br>
<br>
<span style="font-size: 12pt;">현재 여러분이 보신 강좌는<i>&lt;&lt;</i></span><span style="font-size: 16px;"><i>씹어먹는 C++ - &lt;9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)&gt;</i></span><span style="font-size: 12pt;"><i>&gt;&gt;</i> 입니다. 이번 강좌의 </span><span style="font-size: 12pt; font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span><span style="font-size: 12pt;">까지 다음 강좌로 넘어가지 말아주세요 </span><br>
<br>
<div style="text-align: right;">
<span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135">다음 강좌 보러가기</a><br>
</span>
</div>
</div>
<br><p></p><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_221" data-uoc-sc="401" data-uoc-pcurl="http://itguru.tistory.com/221" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_221"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text screen_out">공감</span><span class="txt_like uoc-count">1</span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile8.uf.tistory.com/image/27754F3B594C979F2AF4C4" data-title="씹어먹는 C++ - <9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)>" data-description="이번 강좌에서는 타입이 아닌 템플릿 인자 템플릿 메타 프로그래밍의 시작 using 키워드 사용  안녕하세요 여러분! 지난번 강좌에서 template 을 처음으로 소개하였는데 어떠하셨나요? 템플릿을 통해서 프로그래밍.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/221" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="221"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/221&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++">C++</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/223?category=361027">씹어먹는 C++ - &lt;10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.07.04</td>
</tr>
<tr>
<th>
<a href="/222?category=361027">씹어먹는 C++ - &lt;9 - 3. 템플릿 메타 프로그래밍 2&gt;</a>&nbsp;&nbsp;<span>(8)</span>
</th>
<td>
2017.07.02</td>
</tr>
<tr>
<th>
<a href="/221?category=361027" class="current">씹어먹는 C++ - &lt;9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.06.26</td>
</tr>
<tr>
<th>
<a href="/219?category=361027">씹어먹는 C++ - &lt;9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)&gt;</a>&nbsp;&nbsp;<span>(10)</span>
</th>
<td>
2017.04.07</td>
</tr>
<tr>
<th>
<a href="/218?category=361027">씹어먹는 C++ - &lt;8 - 2. Excel 만들기 프로젝트 2부&gt;</a>&nbsp;&nbsp;<span>(6)</span>
</th>
<td>
2016.07.19</td>
</tr>
<tr>
<th>
<a href="/217?category=361027">씹어먹는 C++ - &lt;8 - 1. Excel 만들기 프로젝트 1부&gt;</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2016.07.18</td>
</tr>
</tbody></table></div></div>
<br> <br>


					