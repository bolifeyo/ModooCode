
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 8pt;">이번 강좌에서는</span></span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><ul style="list-style-type: disc;">
<li><span style="font-size: 8pt;">구조체의 동적 할당</span></li>
<li><span style="font-size: 8pt;">노드의 이용</span></li>
<li><span style="font-size: 8pt;">메모리 관리 함수(memmove, memcpy, memcmp) 함수의 사용</span></li>
</ul>
<div>
<div>
<hr style="height: 1px; border-width: 1px 0px 0px; border-color: black; display: block;"></div>
<div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/1301BF0F4C8E236FAC?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1301BF0F4C8E236FAC6039 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1301BF0F4C8E236FAC6039 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1301BF0F4C8E236FAC6039 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1301BF0F4C8E236FAC6039 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1301BF0F4C8E236FAC6039 480w" src="https://t1.daumcdn.net/cfile/tistory/1301BF0F4C8E236FAC" style="cursor: pointer;max-width:100%;height:auto" width="730" height="548" alt="" filename="C-gods-programming-language.jpg" filemime="image/jpeg"></span></div><br>
&nbsp;&nbsp;안녕하세요 여러분. 메모리에 관해서 두 번째 이야기를 풀어 나가려고 합니다. 원래 메모리 동적 할당은 강의 한 개로 끝내려고 했는데 코이치 님이 무언가 조금 모자라다는 듯한 느낌이 든다고 하셔서 두 개의 강의로 이어 나가려고 합니다. 물론 동적 할당에 관한 기본 개념은 지난 강좌에서 모두 다루었지만 조금 보충 설명과 함께 새로운 것들을 이야기 하고자 합니다.</div>
</span></span></div>
</span></span>
<br>
<span style="font-size: 12pt;">
<div>
<table style="width: 634px; border-collapse: collapse; height: 31px;" bgcolor="#ffffff" cellpadding="1" cellspacing="1">
<tbody>
<tr>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210);" bgcolor="#3058d2" width="1%"><span style="font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-weight: bold;" class="Apple-style-span"><span style="font-size: 12pt;">&nbsp;</span></span></span></span></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210);" width="99%"><span style="color: rgb(48, 88, 210); font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-weight: bold;" class="Apple-style-span"><span style="font-size: 12pt;">&nbsp;구조체 동적 할당</span></span></span></span><font color="#c8056a"><strong><span style="font-size: 10pt;"><span style="font-family: Gulim;"><br>
</span></span></strong></font></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210) rgb(48, 88, 210) rgb(255, 70, 197);" width="100%"><span style="font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-size: 12pt;">&nbsp;</span></span></span></td>
</tr>
</tbody></table>
</div>
</span><span style="font-size: 12pt;"><div>
<span style="font-size: 12pt;"><br>
</span></div>
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">#include &lt;stdio.h&gt;<br>
#include &lt;stdlib.h&gt;<br>
struct Something<br>
{<br>
&nbsp;&nbsp;&nbsp; int a,b;<br>
};<br>
int main()<br>
{<br>
&nbsp;&nbsp;&nbsp; struct Something *arr;<br>
&nbsp;&nbsp;&nbsp; int size, i;<br>
<br>
&nbsp;&nbsp;&nbsp; printf("원하시는 구조체 배열의 크기 : ");<br>
&nbsp;&nbsp;&nbsp; scanf("%d", &amp;size);<br>
<br>
&nbsp;&nbsp;&nbsp; arr = (struct Something *)malloc(sizeof(struct Something) * size);<br>
<br>
&nbsp;&nbsp;&nbsp; for(i=0;i&lt;size;i++)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("arr[%d].a : ", i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d", &amp;arr[i].a);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("arr[%d].b : ", i);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scanf("%d", &amp;arr[i].b);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; for(i=0;i&lt;size;i++)<br>
&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("arr[%d].a : %d , arr[%d].b : %d \n", i, arr[i].a, i, arr[i].b);<br>
&nbsp;&nbsp;&nbsp; }<br>
<br>
&nbsp;&nbsp;&nbsp; free(arr);<br>
<br>
&nbsp;&nbsp;&nbsp; return 0;<br>
} </span></span><br>
</div>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
성공적으로 컴파일 했다면</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/121D49344D209B3754?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F121D49344D209B37546E36 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F121D49344D209B37546E36 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F121D49344D209B37546E36 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F121D49344D209B37546E36 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F121D49344D209B37546E36 480w" src="https://t1.daumcdn.net/cfile/tistory/121D49344D209B3754" style="cursor: pointer;max-width:100%;height:auto" width="677" height="442" alt="" filename="20.1.1.png" filemime="image/png"></span></div><br>
</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
와 같이 나옵니다.</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
저의 구조체 강좌를 여태까지 잘 보신 분들은 잘 아시겠지만 '구조체' 역시 특별하게 생각해야 될 것이 아니라 '사용자가 만든 하나의 데이터 타입' 이라고 보시면 된다고 했습니다. 다시 말해 구조체도 int 처럼 사용할 수 있다는 것이지요. 따라서 구조체 배열을 malloc 을 이용하여 지지고 볶는 일은 전혀 이상할 것이 없는 행동 입니다.</span></span><br>
<br>
<span style="font-size: 12pt;">
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; struct Something *arr;</span></div>
</span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
일단 1 차원 구조체 배열을 가리키기 위한 arr 을 선언하였습니다. int 형 배열을 만들기 위해 int *arr; 이라 했던 것과 정확히 일치 합니다. </span></span><br>
<br>
<span style="font-size: 12pt;">
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; arr = (struct Something *)malloc(sizeof(struct Something) * size);</span></div>
</span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
이제 malloc 함수를 이용하여 arr 을 위한 공간을 할당해줍니다. 이에 필요한 크기는 당연히도 sizeof(struct Something) * size 입니다. 만일 sizeof 대신에 구조체의 실제 크기를 계산해서 더하시는 분이 있는데 이는 오류를 발생 시킬 수 있습니다. 예를 들어 위 Somehting 구조체의 경우 1 개당 8 바이트를 차지한다고 볼 수 있는데 사실 그렇지 않을 수 도 있습니다. 물론 위 경우는 조금 특별하지만 예를 들어 구조체의 크기가 10 바이트일 경우 컴퓨터가 더블워드 경계(double word boundary) 에 놓음으로 속도를 향상시키는 경우가 있는데 이 경우 구조체의 크기는 12 바이트로 간주될 수 있습니다. 사실 자세한 내용은 여기서 생략하기로 하고 아무튼 기역해야 할 점은 언제나 sizeof 를 사용해야 한다는 점입니다. 무턱대고 크기를 추정하지 맙시다!</span></span><br>
<br>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; for(i=0;i&lt;size;i++)</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; {</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("arr[%d].a : ", i);</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; scanf("%d", &amp;arr[i].a);</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; printf("arr[%d].b : ", i);</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; scanf("%d", &amp;arr[i].b);</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; }</span></span></div>
<span style="font-size: 12pt;"></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
이렇게 할당을 하고 나면 입력을 받아야 겠지요? 위와 같은 for 문을 열심히 돌려서 입력을 받으면 됩니다. </span></span><br>
<br>
<span style="font-size: 12pt;">
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; free(arr);</span></div>
</span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
그리고 마지막에 위와 같이 free 로 깔끔하게 메모리를 정리해주는 것도 잊으면 안됩니다!</span></span><br>
<br>
<span style="font-size: 12pt;">
<div>
<table style="width: 634px; border-collapse: collapse; height: 31px;" bgcolor="#ffffff" cellpadding="1" cellspacing="1">
<tbody>
<tr>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210);" bgcolor="#3058d2" width="1%"><span style="font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-weight: bold;" class="Apple-style-span"><span style="font-size: 12pt;">&nbsp;</span></span></span></span></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210);" width="99%"><span style="color: rgb(48, 88, 210); font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-weight: bold;" class="Apple-style-span"><span style="font-size: 12pt;">&nbsp;노드</span></span></span></span><font color="#c8056a"><strong><span style="font-size: 10pt;"><span style="font-family: Gulim;"><br>
</span></span></strong></font></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210) rgb(48, 88, 210) rgb(255, 70, 197);" width="100%"><span style="font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-size: 12pt;">&nbsp;</span></span></span></td>
</tr>
</tbody></table>
<br>
<font face="굴림"><span style="font-size: 9pt;"><span style="color: rgb(92, 127, 176); font-weight: bold;"></span></span></font>
<div>
</div>
<div>
</div>
</div>
</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">여태까지 여러분들은 여러가지 자료형들을 배워왔습니다. 변수를 무식하게 나열하는 것을 막기 위해 배열을 이용하였고, 또 배열의 기능에 한계를 느낀 여러분은 구조체를 만들었습니다. 그리고 구조체 하나에 한 개 한 개를 다루는데 한계를 느낀 여러분은 구조체 배열을 이용해왔구요. 결국 배열로 다시 돌아왔습니다. 동적 할당을 함으로써 사용자가 원하는 크기의 입력을 다룰 수 있게 되었다고 하더라도 아직 많은 문제를 느끼고 있습니다. 만일 사용자가 마음이 변해서 한 개의 입력을 더 받고 싶다면 말이죠. 새롭게 동적할당을 하면 되지만 예컨대 1000 개 의 데이터가 있는데 1 개의 추가적인 데이터를 위해 1001 개를 위한 공간을 새로 잡으면 너무 아까운 것 같습니다.</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
이를 해결하는 것이 바로 '노드' 입니다. 노드는 이렇게 생겼습니다.</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/173659214C8DEDB426?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F173659214C8DEDB426E889 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F173659214C8DEDB426E889 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F173659214C8DEDB426E889 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F173659214C8DEDB426E889 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F173659214C8DEDB426E889 480w" src="https://t1.daumcdn.net/cfile/tistory/173659214C8DEDB426" style="cursor: pointer;max-width:100%;height:auto" width="561" height="325" alt="" filename="20.2.2.png" filemime="image/png"></span></div></span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
상당히 단순하지요? 이를 C 코드로 나타내면 다음과 같습니다.</span></span><br>
<br>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; int data; /* 데이터 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; struct Node* nextNode; /* 다음 노드를 가리키는 부분 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
};</span></span></div>
<span style="font-size: 12pt;"></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
아무튼 이렇게 생긴 노드를 어떻게 사용할까요?</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/155838374C8DEF1755?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F155838374C8DEF1755C838 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F155838374C8DEF1755C838 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F155838374C8DEF1755C838 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F155838374C8DEF1755C838 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F155838374C8DEF1755C838 480w" src="https://t1.daumcdn.net/cfile/tistory/155838374C8DEF1755" style="cursor: pointer;max-width:100%;height:auto" width="561" height="380" alt="" filename="20.2.3.png" filemime="image/png"></span></div></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt;">위와 같이 사용합니다. 다시 말해 첫번째 노드가 다음 노드를 가리키면 다음 노드는 그 다음다음 노드를 가리키는 식으로 쭉 이어지며 마지막 노드 까지 이어지는데 마지막 노드는 아무것도 가리키지 않습니다. 또한 각각의 노드는 데이터를 하나씩 가지고 있지요. 다시 말해 나중에 데이터를 한 개 더 추가하려고 하면 마지막 노드에 새 노드를 만들어서 이어주기만 하면 됩니다.</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
뿐만 아닙니다. 기존의 배열에서는 거의 불가능 하였던 작업인 '배열 중간에 새 원소 집어넣기' 가 가능해집니다. 다시 말해 노드 사이에 새로운 노드를 끼워 넣을 수 있게 된다는 것이지요. </span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/166252054C8DF0D2A5?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F166252054C8DF0D2A57736 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F166252054C8DF0D2A57736 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F166252054C8DF0D2A57736 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F166252054C8DF0D2A57736 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F166252054C8DF0D2A57736 480w" src="https://t1.daumcdn.net/cfile/tistory/166252054C8DF0D2A5" style="cursor: pointer;max-width:100%;height:auto" width="561" height="475" alt="" filename="20.2.4.png" filemime="image/png"></span></div></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt;">위 그림 처럼 기존에 있었던 연결을 없애버리고 그 사이에 새롭게 연결해주기만 하면 됩니다. 이러한 사실을 바탕으로 노드를 만들어봅시다. 가장 먼저 새로운 노드를 생성하는 CreateNode 함수 부터 만들어봅시다. 이 함수는 노드를 생성하기만 합니다. 노드를 생성하기 위해서는 데이터와 이 노드가 가리키는 다음 노드가 필요한데 이 함수는 단순히 첫번째 노드를 만드는 역할을 한다고 하고 nextNode 를 NULL 로 줍시다. </span></span><br>
<br>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">/* 새 노드를 만드는 함수 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
struct Node* CreateNode(int data)</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; struct Node* newNode = (struct Node *)malloc(sizeof(struct Node));</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; newNode-&gt;data = data;</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; newNode-&gt;nextNode = NULL;</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; return newNode;</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
}</span></span></div>
<span style="font-size: 12pt;"></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
따라서 CreateNode 함수는 위와 같이 만들 수 있습니다. 일단 malloc 을 통해 노드를 메모리에 할당하였고 이 할당된 노드는 newNode 가 가리키게 됩니다. 이제, newNode-&gt;data 에 data 를 집어넣고 이 노드가 가리키는 다음 노드를 NULL 로 주면 됩니다. </span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
사실 이 함수는 노드를 생성하기만 할 뿐 노드를 어떻게 관계짓지는 못합니다. 따라서 어떠한 노드 뒤에 새로운 노드를 생성하는 함수를 만들어야 할 것입니다. 이 함수는 InsertNode 함수라고 합시다. 따라서 어떠한 노드뒤에 올지 '앞에 있는 노드' 에 관한 정보와 '새로운 노드를 위한 데이터' 가 필요하므로 struct Node *current, int data 를 인자로 가져야 합니다. </span></span><br>
<br>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">/* current 라는 노드 뒤에 노드를 새로 만들어 넣는 함수 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
struct Node* InsertNode(struct Node *current, int data)</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; /* current 노드가 가리키고 있던 다음 노드가 after 이다 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; struct Node* after = current-&gt;nextNode; </span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; </span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; /* 새로운 노드를 생성한다 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; struct Node* newNode = (struct Node *)malloc(sizeof(struct Node));</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; /* 새 노드에 값을 넣어준다. */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; newNode-&gt;data = data; </span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; newNode-&gt;nextNode = after; </span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; /* current 는 이제 newNode 를 가리키게 된다 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; current-&gt;nextNode = newNode;</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; return newNode;</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
}</span></span></div>
<span style="font-size: 12pt;"></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/154468154C8DF2543E?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F154468154C8DF2543ECA4E 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F154468154C8DF2543ECA4E 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F154468154C8DF2543ECA4E 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F154468154C8DF2543ECA4E 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F154468154C8DF2543ECA4E 480w" src="https://t1.daumcdn.net/cfile/tistory/154468154C8DF2543E" style="cursor: pointer;max-width:100%;height:auto" width="561" height="475" alt="" filename="20.2.5.png" filemime="image/png"></span></div></span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
위 함수에 대한 설명을 위 그림을 보면서 해봅시다. </span></span><br>
<br>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; /* 새로운 노드를 생성한다 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; struct Node* newNode = (struct Node *)malloc(sizeof(struct Node));</span></span></div>
<span style="font-size: 12pt;"></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
일단 위 문장을 통해 새로운 노드 newNode 를 생성하였습니다. </span></span><br>
<br>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; /* 새 노드에 값을 넣어준다. */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; newNode-&gt;data = data; </span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; newNode-&gt;nextNode = after; </span></span></div>
<span style="font-size: 12pt;"></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
이제 위 과정을 통해 newNode 에 nextNode 를 넣어주는 과정인데요, 이는 위 그림에서 3 번에 해당하는 과정입니다. </span></span><br>
<br>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; /* current 는 이제 newNode 를 가리키게 된다 */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; current-&gt;nextNode = newNode;</span></span></div>
<span style="font-size: 12pt;"></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
또한 newNode 앞에 있던 노드의 nextNode 가 바뀌었으므로 새롭게 수정하는 과정이 위 코드인데 이는 위 그림에서 1,2 번에 해당하는 과정입니다. 이렇듯, 그림에 있던 과정들이 함수에 잘 구현이 되어 있음을 알 수 있습니다.</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
이렇게 노드를 잘 만들어주었다면 노드를 파괴하는 역할을 가지는 함수 역시 만들어야 합니다. 이를 위해서는 이 노드를 가리키고 있던 이전 노드가 필요하게 됩니다. 그런데 이 노드를 가리키고 있던 노드를 찾기 위해서는 맨 처음 부터 뒤져나가야 하는데, 맨 처음 노트를 헤드 라고 하며 우리의 DestoryNode 함수는 헤드를 인자로 받아야 합니다. 물론 파괴하고자 하는 노드도 인자로 받아야 하지요</span></span><br>
<br>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">/* 선택된 노드를 파괴하는 함수 */<br>
void DestroyNode(struct Node *destroy, struct Node* head)<br>
{<br>
&nbsp;&nbsp; &nbsp;/* 다음 노드를 가리킬 포인터*/<br>
&nbsp;&nbsp; &nbsp;struct Node *next = head;<br>
<br>
&nbsp;&nbsp; &nbsp;/* head 를 파괴하려 한다면 */<br>
&nbsp;&nbsp; &nbsp;if(destroy == head)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; free(destroy);<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return;<br>
&nbsp;&nbsp; &nbsp;}<br>
<br>
&nbsp;&nbsp; &nbsp;/* 만일 next 가 NULL 이면 종료 */<br>
&nbsp;&nbsp; &nbsp;while(next)<br>
&nbsp;&nbsp; &nbsp;{<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* 만일 next 다음 노드가 destroy 라면 next 가 destory 앞 노드*/<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if(next-&gt;nextNode == destroy)<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* 따라서 next 의 다음 노드는 destory 가 아니라 destroy 의 다음 노드가 된다. */<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; next-&gt;nextNode = destroy-&gt;nextNode;<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* next 는 다음 노드를 가리킨다. */<br>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; next = next-&gt;nextNode;<br>
<br>
&nbsp;&nbsp; &nbsp;}<br>
&nbsp;&nbsp; &nbsp;free(destroy);<br>
}</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt;"></span></span></div>
<span style="font-size: 12pt;"></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
위와 같이 만들면 됩니다. head 노드로 부터 차례 차례 하나 씩 다음 노드와 비교해가면서 찾아나가는 모습입니다. 이 과정은&nbsp;</span></span><div>
<br>
</div>
<div>
<span style="font-size: 12pt;">
</span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;while(next)</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; {</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* 만일 next 다음 노드가 destroy 라면 next 가 destory 앞 노드*/</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if(next-&gt;nextNode == destroy)</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* 따라서 next 의 다음 노드는 destory 가 아니라 destroy 의 다음 노드가 된다. */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; next-&gt;nextNode = destroy-&gt;nextNode;</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* next 는 다음 노드를 가리킨다. */</span></span><br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; next = next-&gt;nextNode;</span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; }</span></span></div>
<span style="font-size: 12pt;"></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
에 잘 나타나 있습니다. 만일&nbsp;next-&gt;nextNode == destroy 라면 next 의 다음 노드가 바로 destroy 가 되는 것이므로 거꾸로 생각해보면 destroy 를 가리키고 있었던 이전 노드는 next 가 됩니다. 이 때 destroy 는 메모리에서 파괴되어 사라지기 때문에 next 의 nextNode 가 destroy 가 되면 안되고 그 다음 다음 노드, 즉 destory 의 nextNode 가 되어야 한다는 것입니다. 따라서 위와 같은 과정을 수행하고침내 마지막에 free 를 해주면 됩니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
이 과정을 한 소스에 정리하면</span></span></div>
<div>
<br>
</div>
<div>
<div>
<span style="font-size: 12pt;">
</span></div>
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">#include &lt;stdio.h&gt;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
#include &lt;stdlib.h&gt;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
struct Node* InsertNode(struct Node *current, int data);</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
void DestroyNode(struct Node *destroy);</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
struct Node* CreateNode(int data);</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
void PrintNodeFrom(struct Node *from);</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
struct Node</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">int data; /* 데이터 */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* nextNode; /* 다음 노드를 가리키는 부분 */</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
};</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
int main()</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* Node1 = CreateNode(100);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* Node2 = InsertNode(Node1, 200);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* Node3 = InsertNode(Node2, 300);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">/* Node 2 뒤에 Node4 넣기 */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* Node4 = InsertNode(Node2, 400);&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">PrintNodeFrom(Node1);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">return 0;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
}&nbsp;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
void PrintNodeFrom(struct Node *from)</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">/* from 이 NULL 일 때 까지,</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;"> &nbsp; 즉 끝 부분에 도달할 때 까지 출력 */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">while(from)</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">		</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("노드의 데이터 : %d \n", from-&gt;data);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">		</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">from = from-&gt;nextNode;</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">}</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
}</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
/* current 라는 노드 뒤에 노드를 새로 만들어 넣는 함수 */</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
struct Node* InsertNode(struct Node *current, int data)</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">/* current 노드가 가리키고 있던 다음 노드가 after 이다 */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* after = current-&gt;nextNode;</span></span><span class="Apple-tab-span" style="white-space: pre;">		</span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">/* 새로운 노드를 생성한다 */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* newNode = (struct Node *)malloc(sizeof(struct Node));</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">/* 새 노드에 값을 넣어준다. */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">newNode-&gt;data = data;&nbsp;</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">newNode-&gt;nextNode = after;&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">/* current 는 이제 newNode 를 가리키게 된다 */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">current-&gt;nextNode = newNode;</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">return newNode;</span></span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">
}</span></span></span></div>
<span style="font-size: 12pt;">/* 선택된 노드를 파괴하는 함수 */</span><br>
<span style="font-size: 12pt;">void DestroyNode(struct Node *destroy, struct Node* head)</span><br>
<span style="font-size: 12pt;">{</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;/* 다음 노드를 가리킬 포인터*/</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;struct Node *next = head;</span><br>
<br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;/* head 를 파괴하려 한다면 */</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;if(destroy == head)</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;{</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; free(destroy);</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; return;</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;}</span><br>
<br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;/* 만일 next 가 NULL 이면 종료 */</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;while(next)</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;{</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* 만일 next 다음 노드가 destroy 라면 next 가 destory 앞 노드*/</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; if(next-&gt;nextNode == destroy)</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; {</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /* 따라서 next 의 다음 노드는 destory 가 아니라 destroy 의 다음 노드가 된다. */</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; next-&gt;nextNode = destroy-&gt;nextNode;</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; }</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* next 는 다음 노드를 가리킨다. */</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; next = next-&gt;nextNode;</span><br>
<br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;}</span><br>
<span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;free(destroy);</span><br>
<span style="font-size: 12pt;">}</span>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">
/* 새 노드를 만드는</span> 함수 */</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
struct Node* CreateNode(int data)</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* newNode = (struct Node *)malloc(sizeof(struct Node));</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">newNode-&gt;data = data;</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">newNode-&gt;nextNode = NULL;</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">return newNode;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
}</span></span></div>
</div>
<div>
<span style="font-size: 12pt;"></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
성공적으로 컴파일 하였다면</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/11474E154C8DFAC13A?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F11474E154C8DFAC13AA03C 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F11474E154C8DFAC13AA03C 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F11474E154C8DFAC13AA03C 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F11474E154C8DFAC13AA03C 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F11474E154C8DFAC13AA03C 480w" src="https://t1.daumcdn.net/cfile/tistory/11474E154C8DFAC13A" style="cursor: pointer;max-width:100%;height:auto" width="677" height="442" alt="" filename="20.2.6.png" filemime="image/png"></span></div></span></span><br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
와 같이 잘 나옵니다.</span></span></div>
<div>
<br>
</div>
<div>
<div>
<span style="font-size: 12pt;">
</span></div>
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">void PrintNodeFrom(struct Node *from)</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">/* from 이 NULL 일 때 까지,</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp; 즉 끝 부분에 도달할 때 까지 출력 */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">while(from)</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">		</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("노드의 데이터 : %d \n", from-&gt;data);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">		</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">from = from-&gt;nextNode;</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">}</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
}</span></span></div>
</div>
<div>
<span style="font-size: 12pt;"></span></div>
</div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
일단 추가적으로 위와 같이 from 이후의 모든 노드의 값을 출력하는 함수인 PrintNodeFrom 이라는 함수를 정의하였습니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<div>
<span class="Apple-tab-span" style="white-space: pre;"></span></div>
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* Node1 = CreateNode(100);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* Node2 = InsertNode(Node1, 200);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* Node3 = InsertNode(Node2, 300);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">/* Node 2 뒤에 Node4 넣기 */</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node* Node4 = InsertNode(Node2, 400);&nbsp;</span></span></div>
</div>
<div>
<span style="font-size: 12pt;"></span></div>
</div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
메인 함수에서 위와 같이 Node 들을 정의하였습니다. 먼저 헤드 노드인 Node1 을 CreateNode 함수를 통해 정의하였고, Node1 뒤에 Node2 , Node2 뒤에 Node3, 그리고 Node2 뒤에 Node4 를 끼워넣었습니다. 그리고 실행한 결과 100, 200, 400, 300 순으로 제대로 나온 것을 볼 수 있습니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
이렇게 노드는 배열과는 달리 추가/삭제/삽입이 월등히 편리합니다. 그렇다고 해서 노드가 배열 보다 월등한 것일까요? 꼭 그렇다고는 말할 수 없습니다. 왜냐하면 배열의 경우 3 번째 원소에 접근하기 위해서는 단순히 arr[3] 으로 하면 되지만 노드의 경우 헤드로 부터 3 번째 까지 일일히 찾아가야만 하기 때문이죠. 따라서 N 개의 노드가 있다면 최악의 경우 N 번동안 계속 찾아야 하지만 배열의 경우 특정한 상수 시간 내에 찾아갈 수 있기 때문에 이부분에서는 배열이 월등히 좋다고 할 수 있습니다. 또한 노드의 경우 데이터를 위한 공간 말고도 다음 노드를 가리키기 위한 4 바이트가 더 필요하기 때문에 공간적으로도 약간 손해를 본다고 생각할 수 있습니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
따라서 결론적으로 이야기 하자면 추가/삭제/삽입이 자주 일어나는 경우 노드를 사용하고 특정한 번째에 찾아가야 하는 일이 잦은 일은 배열을 사용하는 것이 이롭다는 것을 알 수 있습니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
사실 노드 말고도 여러가지 형태의 자료 구조들이 있는데 예를 들면 스택, 큐, 트리 등이 있다고 볼 수 있습니다. 이들에 관한 자세한 내용은 여러분 스스로 찾아 보시기 바랍니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;">
<div>
<table style="width: 634px; border-collapse: collapse; height: 31px;" bgcolor="#ffffff" cellpadding="1" cellspacing="1">
<tbody>
<tr>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210);" bgcolor="#3058d2" width="1%"><span style="font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-weight: bold;" class="Apple-style-span"><span style="font-size: 12pt;">&nbsp;</span></span></span></span></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210);" width="99%"><span style="color: rgb(48, 88, 210); font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-weight: bold;" class="Apple-style-span"><span style="font-size: 12pt;">&nbsp;메모리 관련 함수</span></span></span></span><font color="#c8056a"><strong><span style="font-size: 10pt;"><span style="font-family: Gulim;"><br>
</span></span></strong></font></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210) rgb(48, 88, 210) rgb(255, 70, 197);" width="100%"><span style="font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-size: 12pt;">&nbsp;</span></span></span></td>
</tr>
</tbody></table>
</div>
</span><font class="Apple-style-span" size="4"><span class="Apple-style-span" style="font-size: 16px; line-height: 24px;"><br>
</span></font>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
이번 단원이 메모리에 관한 것인 만큼 메모리에 관해서는 빠삭하게 알아가도록 합시다. 이를 위해 메모리에 관련된 C 표준 라이브러리에서 기본으로 지원되는 것들에 대해 알아보도록 합시다. 일단 메모리를 직접적으로 가지고 논다고 말할 수 있는 함수들은 memmove, memcpy, memcmp, memset 등이 있는데 우리는 여기서 대표적인 3 개의 함수인&nbsp;memmove, memcpy, memcmp 만 알아보도록 합시다. 이 함수들 모두 string.h 에 정의되어 있습니다.</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">먼저 memcpy 함수 부터 봅시다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"></span></div>
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">/* memcpy 함수 */</span></span></div>
<div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">#include &lt;stdio.h&gt;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">#include &lt;string.h&gt;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
int main()</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">char str[50]="I love Chewing C hahaha";</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">char str2[50];</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">char str3[50];</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">memcpy(str2, str, strlen(str)+1);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">memcpy(str3, "hello", 6);</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("%s \n", str);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("%s \n", str2);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("%s \n", str3);</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">return 0;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">}&nbsp;</span></span></div>
</div>
</div>
<div>
<div>
<span style="font-size: 12pt;"></span></div>
</div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/1477090B4C8E0E432F?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1477090B4C8E0E432F5108 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1477090B4C8E0E432F5108 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1477090B4C8E0E432F5108 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1477090B4C8E0E432F5108 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1477090B4C8E0E432F5108 480w" src="https://t1.daumcdn.net/cfile/tistory/1477090B4C8E0E432F" style="cursor: pointer;max-width:100%;height:auto" width="677" height="442" alt="" filename="20.2.7.png" filemime="image/png"></span></div></span></span><br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
와 같이 나옵니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
memcpy 함수는 메모리의 특정한 부분으로 부터 얼마 까지의 부분을 다른 메모리 영역으로 복사해주는 함수 입니다. 위와 같이 문자열을 복사하는데 사용될 수 있죠. 물론 문자열 복사를 전문적으로 하는 함수는 strcpy 이지만 위와 같이 memcpy 함수를 사용하는 것도 나쁘지 않습니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;"></span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">memcpy(str2, str, strlen(str)+1);</span></span></div>
<span style="font-size: 12pt;"></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
일단 위 문장은 'str 로 부터 strlen(str) + 1 만큼의 문자를 str2 로 복사해라' 라는 의미 입니다. 이 때, strlen 함수는 문자열의 길이를 리턴해주는 함수로 예를 들어 strlen("abc"); 를 하면 3 이 리턴됩니다. 이 때 마지막의 NULL 문자는 세지 않으므로 str2 에 memcpy 로 복사할 때 에는 1 을 더한만큼을 더 복사해주어야 합니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;"></span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">memcpy(str3, "hello", 6)</span></span></div>
<span style="font-size: 12pt;"></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
마찬가지로 str3 의 경우도 hello 의 5 문자와 끝에 NULL 을 위해 총 6 문자를 hello 의 시작 주소로 부터 복사를 하게 됩니다. memcpy 에 관한 자세한 내용은&nbsp;http://itguru.tistory.com/77 을 참조하시기 바랍니다.</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
다음으로 memmove 함수에 대해 살펴봅시다. 이 함수는 메모리의 특정한 부분의 내용을 다른 부분으로 옮겨주는 역할을 합니다. 이 때 '옮긴다' 고 해서 이전 공간에 있던 데이터가 사라지지는 않습니다.</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"></span></div>
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">/* memmove 함수 */</span></span></div>
<div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">#include &lt;stdio.h&gt;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">#include &lt;string.h&gt;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
int main()</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">char str[50]="I love Chewing C hahaha";</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("%s \n", str);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("memmove 이후 \n");</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">memmove(str+23, str+17, 6);</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("%s", str);</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">return 0;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">}&nbsp;</span></span></div>
</div>
</div>
<div>
<div>
<span style="font-size: 12pt;"></span></div>
</div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/14653A2F4C8E10BF61?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F14653A2F4C8E10BF619E3B 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F14653A2F4C8E10BF619E3B 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F14653A2F4C8E10BF619E3B 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F14653A2F4C8E10BF619E3B 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F14653A2F4C8E10BF619E3B 480w" src="https://t1.daumcdn.net/cfile/tistory/14653A2F4C8E10BF61" style="cursor: pointer;max-width:100%;height:auto" width="677" height="442" alt="" filename="20.2.8.png" filemime="image/png"></span></div></span></span><br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
와 같이 나옵니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;"></span></div>
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">char str[50]="I love Chewing C hahaha";</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">memmove(str+23, str+17, 6);</span></span></div>
</div>
<div>
<span style="font-size: 12pt;"></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
memmove 함수는 위 경우 str+17 에서 6 개의 문자를 str+23 에 옮겼습니다. 다시 말해 hahaha 의 시작 부분에서 6 개의 문자인 "hahaha" 를 str 의 맨 마지막 부분으로 복사해 넣었다는 뜻입니다. 다시 말해 str 뒤에 "hahaha" 를 추가하게 된 셈이지요. 이를 통해 문자열을&nbsp;I love Chewing C&nbsp;hahahahahaha 로 만들 수 있게 되었습니다. memmove 함수의 장점은 memcpy 와 하는 일이 많이 비슷해보이지만 사실 memcpy 와는 달리 메모리 공간이 겹쳐도 됩니다. 위 경우도 str 과 복사하는 부분이 겹쳤지만 성공적으로 복사가 수행되었습니다. 덕분에 나중에는 memmove 함수를 아주 많이 사용하게 될 것입니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
마지막으로 memcmp 함수를 살펴보도록 합시다. 이는 이름에서도 충분히 짐작이 되듯이 두 개의 메모리 공간을 서로 비교하는 함수 입니다.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"></span></div>
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">/* memcmp 함수 */</span></span></div>
<div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">#include &lt;stdio.h&gt;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">#include &lt;string.h&gt;</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">int main()</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">{</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">int arr[10]= {1,2,3,4,5};</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">int arr2[10] = {1,2,3,4,5};</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">if(memcmp(arr, arr2, 5)==0)</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">		</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("arr 과 arr2 는 일치! \n");</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">else</span></span></div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">		</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">printf("arr 과 arr2 는 일치 안함 \n");</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">return 0;</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">}&nbsp;</span></span></div>
</div>
</div>
<div>
<div>
<span style="font-size: 12pt;"></span></div>
</div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/164D9B1F4C8E1ED414?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F164D9B1F4C8E1ED414C774 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F164D9B1F4C8E1ED414C774 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F164D9B1F4C8E1ED414C774 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F164D9B1F4C8E1ED414C774 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F164D9B1F4C8E1ED414C774 480w" src="https://t1.daumcdn.net/cfile/tistory/164D9B1F4C8E1ED414" style="cursor: pointer;max-width:100%;height:auto" width="677" height="442" alt="" filename="20.2.9.png" filemime="image/png"></span></div></span></span><br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">와 같이 나옵니다.</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">memcmp 함수는 꽤 유용하게 사용될 수 있습니다. 이 함수는 메모리의 두 부분을 원하는 만큼 비교를 합니다. 이 때 같다면 0, 다르다면 결과에 따라 0 이 아닌 값을 리턴하게 되지요.&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<span class="Apple-tab-span" style="white-space: pre;"></span><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<span class="Apple-tab-span" style="white-space: pre;">	</span><span style="font-size: 12pt;"><span style="font-size: 12pt;">if(memcmp(arr, arr2, 5)==0)</span></span></div>
<span style="font-size: 12pt;"></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">위 문장의 경우 arr 과 arr2 를 비교해서 처음 5 개의 바이트가 같다면 0 을 리턴하게 됩니다. 주의해야 할 점은 '5 개의 원소' 가 아니라 5 바이트 라는 점 이지요. 만일 arr1 과 arr2 전체를 비교하고 싶다면 3 번째 인자로 sizeof(int) * 5 를 넣어 주어야 했었을 것입니다.</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">이렇게 메모리를 가지고 노는 3 개의 함수들을 모두 살펴보았습니다. 저는 이 함수를 사용하는 아주 기본적인 방법만을 가르쳐 주었을 뿐 이 함수들을 어떻게 응용시켜서 적용시키냐는 여러분들의 몫입니다. 이제, 메모리를 아주 빠삭하게 다룰 수 있기 되었으니 (동적 메모리 할당도 할 줄 알고, memmove 와 같은 놀라운 메모리 관련 함수들도 사용할 줄 아니..) 이번 강좌는 여기서 끝마치도록 하겠습니다.</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><b><span style="font-size: 12pt;">생각해보기</span></b></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">앞서 배운 노드는 여러모로 생각해볼 점이 많다. 다음의 과제들을 차례대로 해결해보기 바랍니다.</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">1) head 가 주어질 때 전체 노드의 개수를 세는 int CountNode(Node* head) 함수를 작성하시오 (난이도 : 下)</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">2) head 와 원하는 노드가 주어질 때 원하는 노드의 데이터 값을 출력하는 int SearchNode(Node* head, Node *search) 함수를 작성하시오 (난이도 : 下)</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">3) 앞서 구현하였던 Node 의 단점으로 '이 노드를 가리키는 노드' 를 쉽게 알 수 없다는 점이다. 이를 보완하기 위해&nbsp;</span></span></div>
<div>
<br>
</div>
<div>
<div>
<span style="font-size: 12pt;"></span></div>
<div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;">
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">struct Node</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">{</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;int data; /* 데이터 */</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;struct Node* nextNode;/* 다음 노드를 가리키는 부분 */</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">&nbsp;&nbsp; &nbsp;struct Node* prevNode; /* 이전 노드를 가리키는 부분 */</span></span></div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">};</span></span></div>
</div>
<div>
<span style="font-size: 12pt;"></span></div>
</div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">형식으로 노드를 만들어보고 앞서 작성했던 모든 함수들을 다시 작성해보시오 (난이도 : 中)</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">4) 위와 같은 형식의 노드를 개량하여 head 가 맨 마지막 노드인 tail 을 prevNode 로 가리키는 원형의 노드를 만들어보시오. 다시 말해 노드의 처음과 끝이 없다고 볼 수 있다. 이러한 형태의 노드를 이용하여 앞서 구현하였던 모든 함수를 구현해보시오 (난이도 : 中上)</span></span></div>
<div>
<br>
</div>
<div>
<span style="font-size: 12pt;"><span style="font-size: 12pt;">5) 이전 강좌에서 만들었던 도서 관리 프로그램을 동적 할당과 구조체를 이용하여 만들어보세요 (난이도 : 中)</span></span></div>
<div>
<br>
</div>
<div>
<div>
<div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox">
<span style="font-size: 11pt;"><span style="font-size: 12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 <span style="font-weight: bold;">꼭 댓글을 남겨주시기 바랍니다</span>. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span></span><span style="font-size: 11pt;"><span style="font-size: 12pt;"></span></span><br>
<br>
<span style="font-size: 11pt;"><span style="font-size: 12pt;">현재 여러분이 보신 강좌는<span style="font-style: italic;">&lt;&lt;씹어먹는 C 언어 - &lt;20 - 2. 메모리 동적할당 + 메모리 갖고 놀기&gt;&gt;&gt;</span> 입니다. 이번 강좌의 <span style="font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span>까지 다음 강좌로 넘어가지 말아주세요 </span></span><br>
<br>
<div style="text-align: right;">
<span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/notice/15">다음 강좌 보러가기</a><br>
</span>
</div>
</div>
</div>
<br>
</div>
<div>
<br>
</div>
<div style="background-color: rgb(255, 255, 191); border-width: 0px; color: rgb(0, 0, 0); margin: 0px; padding: 0px; font-family: arial,sans-serif; font-size: 13px; font-style: normal; font-variant: normal; font-weight: normal; height: auto; line-height: normal; text-align: left; width: auto; direction: ltr; z-index: 99995;">
</div><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_100" data-uoc-sc="" data-uoc-pcurl="http://itguru.tistory.com/100" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_100"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text">공감</span><span class="txt_like uoc-count" style="display: none;"></span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile22.uf.tistory.com/image/173659214C8DEDB426E889" data-title="씹어먹는 C 언어 - <20 - 2. 메모리 동적할당 + 메모리 갖고 놀기>" data-description="이번 강좌에서는 구조체의 동적 할당 노드의 이용 메모리 관리 함수(memmove, memcpy, memcmp) 함수의 사용  안녕하세요 여러분. 메모리에 관해서 두 번째 이야기를 풀어 나가려고 합니다. 원래 메모리 동적 할당.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/100" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="100"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/100&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C">C</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/103?category=194983">씹어먹는 C 언어 - &lt;22. C 언어의 잡다한 키워드들 (typedef, volatile, #pragma)&gt;</a>&nbsp;&nbsp;<span>(23)</span>
</th>
<td>
2010.12.25</td>
</tr>
<tr>
<th>
<a href="/99?category=194983">씹어먹는 C 언어 - &lt;21. 매크로 함수, 인라인 함수&gt;</a>&nbsp;&nbsp;<span>(42)</span>
</th>
<td>
2010.11.21</td>
</tr>
<tr>
<th>
<a href="/100?category=194983" class="current">씹어먹는 C 언어 - &lt;20 - 2. 메모리 동적할당 + 메모리 갖고 놀기&gt;</a>&nbsp;&nbsp;<span>(38)</span>
</th>
<td>
2010.09.13</td>
</tr>
<tr>
<th>
<a href="/98?category=194983">씹어먹는 C 언어 - &lt;20 - 1. 동동동 메모리 동적할당(Dynamic Memory Allocation)&gt;</a>&nbsp;&nbsp;<span>(35)</span>
</th>
<td>
2010.08.03</td>
</tr>
<tr>
<th>
<a href="/89?category=194983">씹어먹는 C 언어 - &lt;19. main 함수의 인자, 텅 빈 void 형&gt;</a>&nbsp;&nbsp;<span>(32)</span>
</th>
<td>
2010.08.02</td>
</tr>
<tr>
<th>
<a href="/88?category=194983">씹어먹는 C 언어 - &lt;18 - 2. 파일 뽀개기 (# 친구들, 라이브러리)&gt;</a>&nbsp;&nbsp;<span>(13)</span>
</th>
<td>
2010.07.20</td>
</tr>
</tbody></table></div>
<br> <br>


					