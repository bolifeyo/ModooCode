
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<div class="tt_article_useless_p_margin"><p><span style="font-size: 8pt;">이번 강좌에서는</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 8pt;">virtual 소멸자 (가상 소멸자)&nbsp;</span></li><li><span style="font-size: 8pt;">가상 함수 테이블 (virtual function table)</span></li><li><span style="font-size: 8pt;">다중 상속</span></li><li><span style="font-size: 8pt;">가상 상속</span></li></ul><div><font size="3"><span style="line-height: 24px; font-size: 8pt;">에 대해서 배웁니다.</span></font></div><div><font size="3"><span style="line-height: 24px;"><div><hr style="display:block; border: black 0 none; border-top: black 1px solid; height: 1px"></div><p><span class="imageblock" style="display:inline-block;width:730px;text-align: center; background-color: transparent;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/262D2C3953DD4BCE03?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F262D2C3953DD4BCE03E427 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F262D2C3953DD4BCE03E427 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F262D2C3953DD4BCE03E427 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F262D2C3953DD4BCE03E427 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F262D2C3953DD4BCE03E427 480w" src="https://t1.daumcdn.net/cfile/tistory/262D2C3953DD4BCE03" style="cursor: pointer;max-width:100%;height:auto" width="730" height="158" filename="__CODE____C___by_webblaster48.jpg" filemime="image/jpeg"></span></span></p><p><br></p></span></font></div><p><span style="font-size: 12pt;">안녕하세요 여러분. 지난 강좌에서는 놀라움의 연속이었던 virtual 키워드의 기능에 대해서 설명하였습니다. virtual 키워드를 통해서 동적 바인딩이라는 것을 이루어 낼 수 있었지요.&nbsp;이번 강좌에서는 가상 함수와 상속에 관련하여 잡다한 내용들을 모두 짚고 넘어가도록 하겠습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">지난 시간에 배웠던 것을 간단히 정리해보자면 다음과 같습니다. Parent 클래스와 Child 클래스에 모두 &nbsp;f 라는 가상함수가 정의되어 있고, Child 클래스가 Parent 를 상속 받는다고 해봅시다. 그런 다음에 동일한 Parent* 타입의 포인터들도 각각 Parent 객체와 Child 객체를 가리킨다고 해봅시다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">Parent* p = new Parent();</span></p><p><span style="font-size: 12pt;">Parent* c = new Child();</span></p></div><p><br></p><p><span style="font-size: 12pt;">컴퓨터 입장에서 p 와 c 모두 Parent 를 가리키는 포인터들이므로, 당연히&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">p-&gt;f();</span></p><p><span style="font-size: 12pt;">c-&gt;f();</span></p></div><p><br></p><p><span style="font-size: 12pt;">를 했을 때 모두 Parent 의 f() 가 호출되어야 하겠지만, 실제로는 f 가 가상함수므로, '실제로 p 와 c 가 가리키는 객체의' f, 즉 p-&gt;f() 는 Parent 의 f 를, c-&gt;f() 는 Child 의 f 가 호출됩니다. 이와 같은 일이 가능한 이유는 f 를 가상함수로 만들었기 때문입니다.&nbsp;</span></p><p><br></p><p></p><div><span style="font-size: 12pt;">
</span><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;virtual 소멸자</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">사실 클래스의 상속을 사용함으로써 중요하게 처리해야 되는 부분이 있습니다. 바로, 소멸자를 가상함수로 만들어야 된다는 점입니다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class Parent</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public :</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Parent()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Parent 생성자 호출" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~Parent()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Parent 소멸자 호출" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class Child : public Parent</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Child() : Parent()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Child 생성자 호출" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~Child()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Child 소멸자 호출" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "--- 평범한 Child 만들었을 때 ---" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">Child c;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "--- Parent 포인터로 Child 가리켰을 때 ---" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">Parent *p = new Child();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete p;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p></div></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:356px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2372D04753D905142692F7 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2372D04753D905142692F7 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2372D04753D905142692F7 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2372D04753D905142692F7 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2372D04753D905142692F7 480w" src="https://t1.daumcdn.net/cfile/tistory/2372D04753D9051426" style="max-width:100%;height:auto" width="356" height="198" filename="6.3.1.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">일단 평범하게 Child 객체를 만든 부분을 살펴봅시다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "--- 평범한 Child 만들었을 때 ---" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">Child c;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">생성자와 소멸자의 호출 순서를 살펴보자면, Parent 생성자 → Child 생성자&nbsp;</span><span style="font-size: 12pt; line-height: 1.5; background-color: transparent;">→ Child 소멸자&nbsp;</span><span style="font-size: 12pt; line-height: 1.5; background-color: transparent;">→ Parent 소멸자 순으로 호출됨을 알 수 있습니다. 이와 같은 과정이 당연한 이유는 객체를 만들고 소멸시키는 일을 집을 짓고 철거하는 일로 비유할 수 있습니다. 집을 지을 때에는 큰 틀, 즉 기초공사를 하고 건물을 세운 다음에 (Parent 생성자 호출), 집 내부 공사 - 인테리어, 가구 배치 등을&nbsp;하게 됩니다 (Child 생성자 호출). 그리고 역으로 집을 철거할 때에는 안에 있는 내용물들을 모두 제거한 뒤에 (Child 소멸자 호출), 집 구조물을 철거하겠지요 (Parent 소멸자 호출).&nbsp;</span></p><p><span style="font-size: 9pt; line-height: 1.5; background-color: transparent;"><br></span></p><p><span style="font-size: 12pt; line-height: 1.5; background-color: transparent;">그런데 문제는 그 아래 Parent 포인터가 Child 객체를 가리킬 때 입니다.&nbsp;</span></p><p><span style="font-size: 9pt; line-height: 1.5; background-color: transparent;"><br></span></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "--- Parent 포인터로 Child 가리켰을 때 ---" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">Parent *p = new Child();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete p;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">delete p 를 하더라도, p 가 가리키는 것은 Parent 객체가 아닌 Child 객체 이기 때문에, 위에서 보통의 Child 객체가 소멸되는 것과 같은 순서로 생성자와 소멸자들이 호출되어야만 합니다. 그런데 실제로는, Child 소멸자가 호출되지 않습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">소멸자가 호출되지 않는다면 여러가지 문제가 생길 수 있습니다. 예를 들어서, Child 객체에서 메모리를 동적으로 할당하고 소멸자에서 해제하는데, 소멸자가 호출 안됬다면 메모리 누수(memory leak)가 생기겠지요. 하지만 virtual 키워드를 배운 이상 여러분은 무엇을 해야 하는지 알고 계실 것입니다. 단순히 Parent 의 소멸자를 virtual 로 만들어버리면 됩니다. Parent 의 소멸자를 virtual 로 만들면, p 가 소멸자를 호출할 때, Child 의 소멸자를 성공적으로 호출할 수 있게 됩니다.&nbsp;&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class Parent</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public :</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Parent()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Parent 생성자 호출" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual ~Parent()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Parent 소멸자 호출" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class Child : public Parent</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Child() : Parent()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Child 생성자 호출" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~Child()</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Child 소멸자 호출" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "--- 평범한 Child 만들었을 때 ---" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">Child c;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "--- Parent 포인터로 Child 가리켰을 때 ---" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">Parent *p = new Child();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete p;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:341px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2267FE4553D916BC0B6C3C 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2267FE4553D916BC0B6C3C 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2267FE4553D916BC0B6C3C 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2267FE4553D916BC0B6C3C 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2267FE4553D916BC0B6C3C 480w" src="https://t1.daumcdn.net/cfile/tistory/2267FE4553D916BC0B" style="max-width:100%;height:auto" width="341" height="231" filename="6.3.2.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 제대로 Child 소멸자가 호출됨을 알 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">여기서 한 가지 질문을 하자면, 그렇다면 왜 Parent 소멸자는 호출이 되었는가 인데, 이는 Child 소멸자를 호출하면서, Child 소멸자가 '알아서' Parent 의 소멸자도 호출해주기 때문입니다 (Child 는 자신이 Parent 를 상속받는다는 것을 알고 있습니다). 반면에 Parent 소멸자를 먼저 호출하게 되면, Parent 는 Child 가 있는지 없는지 모르므로, Child 소멸자를 호출해줄 수 없습니다 (Parent 는 자신이 누구에서 상속해주는지 알 수 없지요).&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이와 같은 연유로, </span><b><span style="font-size: 12pt;">상속될 여지가 있는 Base 클래스들은 (위 경우 Parent), 반드시 소멸자를 virtual 로 만들어주어야 나중에 문제가 발생할 여지가 없게 됩니다.&nbsp;</span></b></p><p><b><span style="font-size: 12pt;"><br></span></b></p><p><b><span style="font-size: 12pt;"></span></b></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;레퍼런스도 된다</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><b><br><span style="font-size: 12pt;">
</span><font face="굴림"></font><span style="font-size: 12pt;">
</span><div></div><span style="font-size: 12pt;">
</span><div></div></b><p></p><p><span style="font-size: 12pt;">여태 까지 부모 클래스에서 자식 클래스의 함수에 접근할 때 항상 부모 클래스의 포인터를 통해서 접근하였습니다. 하지만, 사실 부모 클래스의 레퍼런스여도 문제 없이 작동합니다. 아래 간단한 예제를 통해 살펴보겠습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class A {</span></p><p><span style="font-size: 12pt;">public :</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual void show() {</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Parent !" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class B : public A {</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void show() {</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "Child!" &lt;&lt; endl;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">void test(A&amp; a) {</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">a.show();</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A a;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">B b;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">test(a);</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">test(b);</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return 0;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:356px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F25547A42578C8E63118312 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F25547A42578C8E63118312 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F25547A42578C8E63118312 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F25547A42578C8E63118312 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F25547A42578C8E63118312 480w" src="https://t1.daumcdn.net/cfile/tistory/25547A42578C8E6311" style="max-width:100%;height:auto" width="356" height="129" filename="6.3.9.png" filemime="image/png" ""=""></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span><br><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">void test(A&amp; a) {</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">a.show();</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">test 함수를 살펴보면 A 클래스의 레퍼런스를 받게 되어 있지만,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">test(b);</span></p></div><p><br></p><p><span style="font-size: 12pt;">를 통해서 B 클래스의 객체를 전달하였는데도 잘 작동하였습니다. 이는, B 클래스가 A 클래스를 상속 받고 있기 때문입니다. 즉, 함수에 타입이 <b>부모 클래스여도 그 자식 클래스는 타입 변환되어 전달 할 수 있습니다.</b>&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 test 함수에서 show() 를 호출하였을 때 인자로 b 를 전달하였다면, 비록 전달된 인자가&nbsp;</span><span style="font-size: 12pt;">A의 객체</span><span style="font-size: 12pt;">라고 표현되어 있지만&nbsp;show 함수가 virtual 으로 정의되어 있기 때문에 알아서&nbsp;B 의 show 함수를 찾아내서 호출하게 됩니다. 물론 test 에 a 를 전달하였을 때에는 A 의 show 함수가 호출되겠지요.</span></p><p><br></p></div><p><br></p><p><span style="font-size: 12pt;">
</span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;가상 함수의 구현 원리</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">여태 까지 virtual 키워드의 능력을 본 바로는 이러한 의문이 들 수 도 있을 것입니다.</span></p><p><br></p><blockquote class="tx-quote-tistory"><p><span style="font-size: 12pt;">그냥 그럼 모든 함수들을 virtual 로 만들어버리면 안되나?</span></p></blockquote><p><br></p><p><span style="font-size: 12pt;">사실 이는 매우 좋은&nbsp;질문입니다. 왜냐하면 모든 함수들을 virtual 로 만들어버린다고 해서 문제될 것이 전혀 없기 때문입니다. 간혹 '가상' 이라는 이름 때문에 혼동하시는 분이 계시는데, virtual 키워드를 붙여서 가상 함수로 만들었다&nbsp;해도 실제로 존재하는 함수이고&nbsp;정상적으로 호출도 할 수 있습니다.&nbsp;또한 모든 함수들을 디폴트로 가상 함수로 만듬으로써, 언제나 동적 바인딩이 제대로 동작하게 만들 수 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">실제로 자바의 경우 모든 함수들이 디폴트로 virtual 함수로 선언됩니다.&nbsp;</span></p><p></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 왜 C++ 에서는 virtual 키워드를 이용해 사용자가 직접 virtual 로 선언하도록 하였을까요? 그 이유는 가상 함수를 사용하게 되면 약간의 오버헤드 (overhead) 가 존재하기 때문입니다. 즉, 보통의 함수를 호출하는 것 보다 가상 함수를 호출하는 데 걸리는 시간이 (아주아주 조금) 더 오래 걸립니다. 이를 이해하기 위해 가상 함수라는 것이 어떻게 구현되는지, 다시 말해 마술과 같은 동적 바인딩이 어떻게 구현되는지 살펴보도록 합시다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">예를 들어서 다음과 같은 간단한 두 개의 클래스를 생각해봅시다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">class Parent</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual void func1();</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual&nbsp;void func2();</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class Child : public Parent</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual void func1();</span></p><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp; void func3();</span></p><p><span style="font-size: 12pt;">};</span></p></div><div><br></div><div><span style="font-size: 12pt;">C++ 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해서, 가상 함수 테이블(virtual function table; vtable)을 만들게 됩니다. 가상 함수 테이블은 전화 번호부라고 생각하시면 됩니다. 함수의 이름(전화번호부의 가게명)&nbsp;과 실제로 어떤 함수 (그 가게의 전화번호)&nbsp;가 대응되는지 테이블로 저장하고 있는 것입니다.&nbsp;</span></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">위 경우 Parent 와 Child 모두 가상 함수를 포함하고 있기 때문에 두 개 다 가상 함수 테이블을 생성하게 되지요. 그 결과;</span></div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:680px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2113164253DB01CF09ACCF 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2113164253DB01CF09ACCF 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2113164253DB01CF09ACCF 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2113164253DB01CF09ACCF 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2113164253DB01CF09ACCF 480w" src="https://t1.daumcdn.net/cfile/tistory/2113164253DB01CF09" style="max-width:100%;height:auto" width="680" height="453" filename="6.3.3.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">위와 같이 구성됩니다. 가상 함수와 가상 함수가 아닌 함수와의 차이점을 살펴보자면 Child 의 func3() 같이 비 가상함수들은 그냥 단순히 특별한 단계를 걸치지 않고, func3() 을 호출하면 직접 실행됩니다. 하지만, 가상 함수를 호출하였을 때는 그 실행 과정이 다릅니다. 위에서도 보이다 싶이, 가상 함수 테이블을 한 단계 더 걸쳐서, 실제로 '어떤 함수를 고를지' 결정하게 됩니다. 예를 들어서;</span><br></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">Parent* p = Parent();</span></p><p><span style="font-size: 12pt;">p-&gt;func1();</span></p></div><p><br></p><p><span style="font-size: 12pt;">을 해봅시다. 그러면, 컴파일러는&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">1. p 가 Parent 를 가리키는 포인터 이니까, func1() 의 정의를 Parent 클래스에서 찾아봐야겠다.</span></p><p><span style="font-size: 12pt;">2. func1() 이 가상함수네? &nbsp;그렇다면 func1() 을 직접 실행하는게 아니라, 가상 함수 테이블에서 func1() 에 해당하는 함수를 실행해야겠다.</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_5_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">그리고 실제로 프로그램 실행시에,&nbsp;가상 함수 테이블에서 func1() 에 해당하는 함수(Parent::func1()) 을 호출하게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">에 해당하는 코드를 작성하게 됩니다. 그렇다면, 다음의 경우는 어떨까요?&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">Parent* c&nbsp;= Child();</span></p><p><span style="font-size: 12pt;">c-&gt;func1();</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 처럼 똑같이 프로그램 실행시에 가상 함수 테이블에서 func1() 에 해당하는 함수를 호출하게 되는데, 이번에는 p 가 실제로는 Child 객체를 가리키고 있으므로, Child 객체의 가상 함수 테이블을 참조하여,&nbsp;</span><span style="font-size: 12pt; line-height: 1.5; background-color: transparent;">Child::func1() 을 호출하게 됩니다. 이는&nbsp;성공적으로 Parent::func1() 을 오버라이드 하지요.</span></p><p><span style="font-size: 9pt; line-height: 1.5; background-color: transparent;"><br></span></p><p><span style="font-size: 12pt; line-height: 1.5; background-color: transparent;">&nbsp;이와 같이 두 단계에 걸쳐서 함수를 호출함을 통해&nbsp;소프트웨어적으로 동적 바인딩을 구현할 수 있게 됩니다. 이러한 이유로 가상 함수를 호출하는 경우, 일반적인 함수 보다 약간 더 시간이 오래 걸리게 됩니다. 물론 눈부시게 CPU 의 속도가 빨라짐에 따라서 이러한 차이는 극히 미미해졌으나, 최적화가 매우 중요한 분야에서는 이를 감안할 필요가 있습니다. 아무튼 이러한 연유로 인해, 다른 언어들과는 다르게,&nbsp;C++ 에서는 멤버 함수가 디폴트로 가상함수가 되도록 설정하지는 않습니다.&nbsp;</span></p><p><span style="font-size: 9pt; line-height: 1.5; background-color: transparent;"><br></span></p><p><br></p><p></p><div><span style="font-size: 12pt;">
</span><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;순수 가상 함수(pure virtual function)와 추상 클래스(abstract class)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><div></div><span style="font-size: 12pt;">
</span><div></div></div><p></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><div><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></div><div><span style="font-size: 12pt;">using namespace std;</span></div><div><br></div><div><span style="font-size: 12pt;">class Animal</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">public:</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Animal() {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual ~Animal() {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual void speak() = 0;</span></div><div><span style="font-size: 12pt;">};</span></div><div><br></div><div><span style="font-size: 12pt;">class Dog : public Animal</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">public:</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Dog() : Animal() {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void speak() {</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "왈왈" &lt;&lt; endl;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">};</span></div><div><br></div><div><span style="font-size: 12pt;">class Cat : public Animal</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">public:</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Cat() : Animal() {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void speak() {</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "야옹야옹" &lt;&lt; endl;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">};</span></div><div><br></div><div><span style="font-size: 12pt;">int main()</span></div><div><span style="font-size: 12pt;">{</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Animal* dog = new Dog();</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Animal* cat = new Cat();</span></div><div><br></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dog-&gt;speak();</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cat-&gt;speak();</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:320px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F226A0B4253DB346C046970 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F226A0B4253DB346C046970 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F226A0B4253DB346C046970 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F226A0B4253DB346C046970 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F226A0B4253DB346C046970 480w" src="https://t1.daumcdn.net/cfile/tistory/226A0B4253DB346C04" style="max-width:100%;height:auto" width="320" height="109" filename="6.3.4.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">위 코드를 보면서 한 가지 특이한 점을 눈치 채셨을 것입니다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><div><span style="font-size: 12pt;">class Animal</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">public:</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Animal() {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual ~Animal() {}</span></div><div><b><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual void speak() = 0;</span></b></div><div><span style="font-size: 12pt;">};</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">Animal 클래스의 speak 함수를 살펴봅시다. 다른 함수들과는 달리, 함수의 몸통이 정의되어 있지 않고 단순히 = 0; 으로 처리되어 있는 가상 함수 입니다. 그렇다면 이 함수는 무엇을 하는 함수 일까요? 그 답은, "무엇을 하는지 정의되어 있지 않는 함수" 입니다. 다시 말해 이 함수는 "</span><b><span style="font-size: 12pt;">반드시 오버라이딩 되어야만 하는 함수</span></b><span style="font-size: 12pt;">" 이지요. 이렇게, 가상 함수에 = 0; 을 붙여서, 반드시 오버라이딩 되도록 만든 함수를 완전한 가상 함수라 해서, </span><b><span style="font-size: 12pt;">순수 가상 함수</span></b><span style="font-size: 12pt;">(pure virtual function)라고 부릅니다.&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">당연하게도, 순수 가상 함수는 본체가 없기 때문에, 이 함수를&nbsp;호출하는 것은 불가능합니다. 그렇기 때문에, Animal 객체를 생성하는것 또한 불가능입니다. 왜냐하면,&nbsp;</span></div><div><br></div><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><div><span style="font-size: 12pt;">Animal a;</span></div><div><span style="font-size: 12pt;">a.speak();</span></div></div><div><br></div><div><span style="font-size: 12pt;">하면 안되기 때문이지요. 물론, speak() 함수를 호출하는 것을 컴파일러 상에서 금지하면 되지 않냐고 물을 수 있는데, C++ 개발자들은 이러한 방법 대신에 아예 Animal 의 객체 생성을 금지시키는 것으로 택하였습니다. (쉽게 말해 Animal 의 인스턴스를 생성할 수 없지요)&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">만일 Animal 의 객체를 생성하려고 한다면 다음과 같은 컴파일 오류를 만날 수 있습니다.</span></div><div><br></div><div><div class="txc-textbox" style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);"><div><span style="font-size: 12pt;">error C2259: 'Animal' : cannot instantiate abstract class</span></div><div><span style="font-size: 12pt;">1&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;due to following members:</span></div><div><span style="font-size: 12pt;">1&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'void Animal::speak(void)' : is abstract</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">따라서 Animal 처럼, </span><b><span style="font-size: 12pt;">순수 가상 함수를 최소 한 개 이상 포함하고 있는 클래스는 객체를 생성할 수 없으며</span></b><span style="font-size: 12pt;">, 인스턴스화 시키기&nbsp;위해서는 이 클래스를 상속 받는 클래스를 만들어서 모든 순수 가상 함수를 오버라이딩 해주어야만 합니다. 이렇게 </span><b><span style="font-size: 12pt;">순수 가상 함수를 최소 한개 포함하고 있는</span></b><span style="font-size: 12pt;"> -&nbsp;반드시 상속 되어야 하는 클래스를 가리켜 </span><b><span style="font-size: 12pt;">추상 클래스 (abstract class)</span></b><span style="font-size: 12pt;"> 라고 부릅니다. (참고로, 이러한 이유 때문에 순수 가상 함수는 반드시 public 이나 protected 가 되어야 합니다. private 으로 정의될 경우 오버라이드 될 수 가 없기 때문이지요. )</span></div><div><br></div><div><span style="font-size: 12pt;">따라서;</span></div><div><br></div><div><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><div><span style="font-size: 12pt;">class Dog : public Animal</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">public:</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Dog() : Animal() {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void speak() {</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "왈왈" &lt;&lt; endl;</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">};</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">위 처럼 speak () 를 오버라이딩 함으로써 (- 정확히 말하면 Animal 의 모든 순수 가상 함수를 오버라이딩 함으로써)&nbsp;Dog 클래스의 객체를 생성할 수 있게 됩니다. Cat 클래스도 마찬가지 이지요. </span></div><div><br></div><div><span style="font-size: 12pt;">그렇다면 추상 클래스를 도대체 왜 사용하는 것일까요? 추상 클래스 자체로는 인스턴스화 시킬 수 도 없고 (추상 클래스의 객체를 만들 수 없다) 사용하기 위해서는 반드시 다른 누구가 상속 해줘야만 하기 때문이지요. 하지만,</span><b><span style="font-size: 12pt;"> 추상 클래스를&nbsp;'설계도' 라고 생각</span></b><span style="font-size: 12pt;">하면 좋습니다. 즉, 이 클래스를 상속받아서 사용하는 사람에게 "이 기능은 일반적인 상황에서 만들기 힘드니 너가 직접&nbsp;특수화 되는 클래스에 맞추어서 만들어서 써라." 라고 말해주는 것이지요.&nbsp;</span></div><p><br></p><p><span style="font-size: 12pt;">예를 들어서 위에서 예를 든 Animal 클래스의 경우</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><div><span style="font-size: 12pt;">class Animal</span></div><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">public:</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Animal() {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual ~Animal() {}</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">virtual void speak() = 0;</span></div><div><span style="font-size: 12pt;">};</span></div></div><div><br></div><div><span style="font-size: 12pt;">동물들이 소리를 내는 것은 맞으므로 Animal 클래스에 speak 함수가 필요합니다. 하지만&nbsp;</span><span style="font-size: 12pt; line-height: 1.5; background-color: transparent;">어떤 소리를 내는지는 동물 마다 다르기 때문에 s</span><span style="font-size: 12pt; line-height: 1.5; background-color: transparent;">peak 함수를 가상 함수로 만들기는 불가능 합니다. 따라서 speak 함수를&nbsp;순수 가상 함수로 만들게 되면 모든 Animal 들은 speak() 한다라는 의미 전달과 함께,&nbsp;사용자가</span><span style="font-size: 12pt; line-height: 1.5; background-color: transparent;">&nbsp;Animal 클래스를 상속 받아서&nbsp;&nbsp;(위 경우 Dog 와 Cat) speak() 를 상황에 맞게 구현하면 됩니다.&nbsp;</span></div><div><br></div><p><span style="font-size: 12pt;">추상 클래스의 또 한가지 특징은 비록 객체는 생성할 수 없지만, 추상 클래스를 가리키는 포인터는 문제 없이 만들 수 있다는 점입니다. 위 예에서도 살펴보았듯이, 아무런 문제 없이 Animal* 의 변수를 생성하였습니다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Animal* dog = new Dog();</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">Animal* cat = new Cat();</span></div><div><br></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">dog-&gt;speak();</span></div><div><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cat-&gt;speak();</span></div></div><div><br></div><div><span style="font-size: 12pt;">그리고 dog 와 cat 의 speak 함수를 호출하였는데, 앞에서도 배웠듯이, 비록 dog 와 cat 이 Animal* 타입 이지만, Animal 의 speak 함수가 오버라이드 되어서, Dog 와 Cat 클래스의 speak 함수로 대체되서 실행이 됩니다.&nbsp;</span></div><p><br></p><p><br></p><p><span style="font-size: 12pt;">
</span></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;다중 상속(multiple inheritance)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><span style="font-size: 12pt;">
</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">마지막으로 C++ 에서의 상속의 또 다른 특징인 다중 상속에 대해 알아보도록 합시다. C++ 에서는 한 클래스가 다른 여러 개의 클래스들을 상속 받는 것을 허용합니다. 이를 가리켜서 다중 상속 (multiple inheritance) 라고 부릅니다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">class A</span></p><p></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int a;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">class B</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int b;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">class C : public A, public B</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int c;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 경우, 클래스 C 가 A 와 B 로 부터 동시에 같이 상속 받고 있습니다.&nbsp;</span></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:456px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F274F493853DD288E298103 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F274F493853DD288E298103 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F274F493853DD288E298103 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F274F493853DD288E298103 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F274F493853DD288E298103 480w" src="https://t1.daumcdn.net/cfile/tistory/274F493853DD288E29" style="max-width:100%;height:auto" width="456" height="349" filename="6.3.5.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">이를 그림으로 표현하자면 위 같은 모양이 되겠지요. 사실 다중 상속은 보통의 상속 하고 똑같이 생각하시면 됩니다. 단순히 그냥 A 와 B 의 내용이 모두 C 에 들어간다고 생각하시면 됩니다. 따라서;</span><br></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">C c;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">c.a = 3;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">c.b = 2;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">c.c = 4;</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같은 것이 가능하게 되는 것이지요. 다중 상속에서 한 가지 재미있는 점은 생성자들의 호출 순서 입니다. 여러분은 과연 위 예에서 A 의 생성자가 먼저 호출될지, B 의 생성자가 먼저 호출될 지 궁금할 것입니다. 한 번 확인을 해보도록 하겠습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class A</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int a;</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A() { cout &lt;&lt; "A 생성자 호출" &lt;&lt; endl;}</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">class B</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int b;</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">B() { cout &lt;&lt; "B 생성자 호출" &lt;&lt; endl; }</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">class C : public A, public B</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int c;</span></p><p><br></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">C() : A(), B() { cout &lt;&lt; "C 생성자 호출" &lt;&lt; endl;}</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">C c;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:333px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2622683553DD2ED529CDF2 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2622683553DD2ED529CDF2 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2622683553DD2ED529CDF2 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2622683553DD2ED529CDF2 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2622683553DD2ED529CDF2 480w" src="https://t1.daumcdn.net/cfile/tistory/2622683553DD2ED529" style="max-width:100%;height:auto" width="333" height="109" filename="6.3.6.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">위 처럼 A -&gt; B -&gt; C 순으로 호출됨을 알 수 있습니다. 그렇다면 이번에는,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">class C : public A, public B</span></p></div><p><br></p><p><span style="font-size: 12pt;">에서</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">class C : public B, public A</span></p></div><p><br></p><p><span style="font-size: 12pt;">로 바꾸고 컴파일을 해보세요. 재미있게도;</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:314px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2176983F53DD2FCC2A52E0 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2176983F53DD2FCC2A52E0 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2176983F53DD2FCC2A52E0 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2176983F53DD2FCC2A52E0 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2176983F53DD2FCC2A52E0 480w" src="https://t1.daumcdn.net/cfile/tistory/2176983F53DD2FCC2A" style="max-width:100%;height:auto" width="314" height="116" filename="6.3.7.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">로 이번에는 B 의 생성자가 A 보다 먼저 호출됨을 알 수 있습니다. 몇 번 더 실험을 해보면 이 순서는 다른 것들에 의해 좌우되지 않고 오직 상속하는 순서에만 좌우 됨을 알 수 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">사실 다중 상속은 실제 프로그래밍에서 많이 쓰이지는 않습니다. 왜냐하면 다음과 같은 위험이 언제나 도사리고 있기 때문이지요.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">class A</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int a;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">class B</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int a;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">class C : public B, public A</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int c;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">위처럼 만일 두 개의 클래스에서 이름이 같은 멤버 변수나 함수가 있다고 해봅시다. 예를 들어 위 예에서는 클래스 A 와 B 에 모두 a 라는 이름의 멤버 변수가 들어가 있습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">C c;</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">c.a = 3;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">그렇다면 만일 클래스 C 의 객체를 생성해서, 위 처럼 중복되는 멤버 변수에 접근한다면;</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);"><p><span style="font-size: 12pt;">error C2385: ambiguous access of 'a'</span></p><p><span style="font-size: 12pt;">1&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;could be the 'a' in base 'B'</span></p><p><span style="font-size: 12pt;">1&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or could be the 'a' in base 'A'</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 처럼 B 의 'a' 인지, A 의 'a' 인지 구분할 수 없다는 오류를 발생하게 됩니다. 마찬가지로, 클래스 A 와 B 에 같은 이름의 함수가 있다면 똑같이 어떤 함수를 호출해야 될 지 구분할 수 없겠지요. 그 외에도 다중 상속은 코드 구조를 매우 복잡하게 만드는 경향이 있기 때문에 C++ 이외에 많은 언어들 (자바, C# 등) 에서는 다중 상속 기능을 지원하고 있지 않습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">다중 상속의 또 다른 문제는 일명 '다이아몬드 상속(diamond inheritance)</span><span style="font-size: 12pt;">' 혹은 '공포의 다이아몬드 상속(dreadful diamond of derivation)'&nbsp;</span><span style="font-size: 12pt;">이라고 부르는 형태의 다중 상속에 있습니다. 예를 들어 다음과 같은 형태의 상속 관계를</span><span style="font-size: 12pt;">&nbsp;생각해봅시다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">class Human</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class HandsomeHuman : public Human</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class SmartHuman : public Human</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class Me : public HandsomeHuman, public SmartHuman</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">일단 베이스 클래스로 Human 이라는 클래스가 있고, HandsomeHuman 과 SmartHuman 클래스는 Human 클래스를 모두 상속 받습니다. 그리고 두 가지 특성을 모두 보유한 나(Me) 라는 클래스는, HandsomeHuman 과 SmartHuman 클래스를 둘 다 상속 받습니다. 이를 그림으로 표현하자면 아래와 같은 다이아몬드 모양이 나오게 됩니다.&nbsp;</span></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:456px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F27033F4653DD3A87338E99 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F27033F4653DD3A87338E99 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F27033F4653DD3A87338E99 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F27033F4653DD3A87338E99 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F27033F4653DD3A87338E99 480w" src="https://t1.daumcdn.net/cfile/tistory/27033F4653DD3A8733" style="max-width:100%;height:auto" width="456" height="349" filename="6.3.8.png" filemime="image/png"></span></p><p><span style="font-size: 12pt;">상속이 되는 두 개의 클래스가 공통의 베이스 클래스를 포함하고 있는 형태를 가리켜서 다이아몬드 상속이라고 부릅니다. 이러한 형태의 상속에 문제점은 보기에도 명백합니다. 만일 Human 에 name 이라는 멤버 변수가 있다고 해봅시다. 그러면 HandsomeHuman 과 SmartHuman 은 모두 Human 을 상속 받고 있으므로, 여기에도 name 이라는 변수가 들어가게 됩니다. 그런데 Me 가 이 두 개의 클래스를 상속 받으니 Me 에서는 name 이라는 변수가 겹치게 되는 것이지요.</span><span style="font-size: 12pt;">&nbsp;결과적으로 볼 때 Handsome 과 SmartHuman 을 아무리 안겹치게 만든다고 해도, Human 의 모든 내용이 중복되는 문제가 발생하게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">다행이도 이를 해결할 수 있는 방법이 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);"><p><span style="font-size: 12pt;">class Human</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">public:</span><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class HandsomeHuman : public virtual Human</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class SmartHuman : public virtual Human</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 12pt;">class Me : public HandsomeHuman, public SmartHuman</span></p><p><span style="font-size: 12pt;">{</span></p><p><span class="Apple-tab-span" style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// ...</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">이러한 형태로 Human 을 virtual 로 상속 받는다면, Me 에서 다중 상속 시에도, 컴파일러가 언제나 Human 을 한 번만 포함하도록 지정할 수 있게 됩니다. 참고로, 가상 상속 시에, Me 의 생성자에서 HandsomeHuman 과 SmartHuman 의 생성자를 호출함은 당연하고, Human 의 생성자 또한 호출해주어야만 합니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">앞에서도 이야기 하였지만 반드시 필요한 경우가 아니라면 다중 상속을 피하는 것이 좋습니다. 왜냐하면 다중 상속을 사용하게 되면 프로그램의 구조가 매우 복잡해질 뿐더러 예상치 못한 오류를 발생할 가능성이 매우 높기 때문이지요. 실제로 다중 상속을 이용해서 해결해야 될 것 같은 문제도 알고보면 단일 상속을 통해 해결할 수 있는 경우가 매우 많습니다 (어떤 사람들은 100% 라고 주장하기도 하지요) 다중 상속에 좀 더 자세히 알고 싶은 분들은 이 글을 읽는 것이 많은 도움이 될 것입니다.&nbsp;</span><a href="http://www.drdobbs.com/cpp/multiple-inheritance-considered-useful/184402074" target="_blank" class="tx-link"><span style="font-size: 12pt;">http://www.drdobbs.com/cpp/multiple-inheritance-considered-useful/184402074</span></a></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_6_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_6_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_6" name="aswift_6" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">아무래도 이번 강좌는 상속에 대한 중요한 요소들을 간단 하게 짚고 넘어가는 것이라 실질적인 프로그램은 만들지 않았습니다. 하지만, 가상 함수와 상속이 어떻게 돌아가는지 완벽히 이해하는 것이 좋습니다. 저의 경우, C++ 처음 배울 때, 이 부분에서 많이 헷갈려서 고생을 한 기억이 있습니다. 여러분들도 가상 함수를 포함하는 간단한 프로그램을 작성해서 어떻게 함수들이 호출되는지 살펴보시기 바랍니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><p><br></p><p></p><div><div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox">
<span style="font-size:12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 <span style="font-weight: bold;">꼭 댓글을 남겨주시기 바랍니다</span>. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span><br>
<br>
<font size="3">현재 여러분이 보신 강좌는<i>&lt;&lt;</i><span style="line-height: 24px;"><i>씹어먹는 C++ - &lt;6 - 3. 가상함수와 상속에 관련한 잡다한 내용들&gt;</i></span><i>&gt;&gt;</i> 입니다. 이번 강좌의 </font><span style="font-size: 12pt; font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span><font size="3">까지 다음 강좌로 넘어가지 말아주세요 </font><br>
<br>
<div style="text-align: right;">
<span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135">다음 강좌 보러가기</a><br>
</span>
</div>
</div>
</div><p></p><p><span style="font-size: 12pt;"><br></span></p><p><br></p><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_211" data-uoc-sc="" data-uoc-pcurl="http://itguru.tistory.com/211" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_211"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text">공감</span><span class="txt_like uoc-count" style="display: none;"></span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile9.uf.tistory.com/image/2372D04753D905142692F7" data-title="씹어먹는 C++ - <6 - 3. 가상함수와 상속에 관련한 잡다한 내용들>" data-description="이번 강좌에서는 virtual 소멸자 (가상 소멸자) 가상 함수 테이블 (virtual function table) 다중 상속 가상 상속 에 대해서 배웁니다.  안녕하세요 여러분. 지난 강좌에서는 놀라움의 연속이었던 virtual 키워드.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/211" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="211"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/211&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++">C++</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/215?category=361027">씹어먹는 C++ - &lt;7 - 2. C++ 에서 파일 입출력 - ifstream. ofstream, stringstream&gt;</a>&nbsp;&nbsp;<span>(13)</span>
</th>
<td>
2016.07.14</td>
</tr>
<tr>
<th>
<a href="/213?category=361027">씹어먹는 C++ - &lt;7 - 1. C++ 에서의 입출력 (istream, ostream)&gt;</a>&nbsp;&nbsp;<span>(35)</span>
</th>
<td>
2015.05.04</td>
</tr>
<tr>
<th>
<a href="/211?category=361027" class="current">씹어먹는 C++ - &lt;6 - 3. 가상함수와 상속에 관련한 잡다한 내용들&gt;</a>&nbsp;&nbsp;<span>(14)</span>
</th>
<td>
2014.04.13</td>
</tr>
<tr>
<th>
<a href="/210?category=361027">씹어먹는 C++ - &lt;6 - 2.  가상(virtual) 함수와 다형성&gt;</a>&nbsp;&nbsp;<span>(35)</span>
</th>
<td>
2014.03.31</td>
</tr>
<tr>
<th>
<a href="/209?category=361027">씹어먹는 C++ - &lt;6 - 1. C++ 표준 문자열 &amp; 부모의 것을 물려쓰자 - 상속&gt;</a>&nbsp;&nbsp;<span>(10)</span>
</th>
<td>
2014.03.30</td>
</tr>
<tr>
<th>
<a href="/204?category=361027">씹어먹는 C++ - &lt;5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열&gt;</a>&nbsp;&nbsp;<span>(24)</span>
</th>
<td>
2013.09.04</td>
</tr>
</tbody></table></div></div>
<br> <br>


					