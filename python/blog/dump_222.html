
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<div class="tt_article_useless_p_margin"><p><span style="font-size: 8pt;">.이번 강좌에서는</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 8pt;">의존 타입 (dependent type)</span></li><li><span style="font-size: 8pt;">Unit 라이브러리 만들기</span></li><li><span style="font-size: 8pt;">auto 키워드</span></li></ul><div><span style="font-size: 8pt;">에 대해서 배웁니다.</span></div><div><span style="font-size: 16px;"><hr><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/2634C0465958BE1736?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2634C0465958BE17369176 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2634C0465958BE17369176 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2634C0465958BE17369176 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2634C0465958BE17369176 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2634C0465958BE17369176 480w" src="https://t1.daumcdn.net/cfile/tistory/2634C0465958BE1736" style="cursor: pointer;max-width:100%;height:auto" width="730" height="158" filename="__CODE____C___by_webblaster48.jpg" filemime="image/jpeg"></span></span></p><p><br></p></span></div><p><span style="font-size: 12pt;">안녕하세요 여러분! 지난 강좌에서 왜 TMP 를 활용하여 힘들게 힘들게 Ratio 클래스를 만들었는데,&nbsp;아직 아마 이걸 왜 굳이 TMP 로 만들었는지는 설명하지 않았었습니다.</span></p><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">그에 앞서, 이번 강좌에서 왜 Ratio 클래스를 만들었는지 설명하기 전에 지난 강좌의 생각 해보기에 대해서 짚고 넘어가보자 합니다.&nbsp;</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;지난 강의 생각해보기 문제</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">지난번 생각해보기 문제는 아래와 같습니다.</span></p><p></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">1. TMP 를 사용해서 어떤 수가 소수인지 아닌지를 판별하는 프로그램을 만들어보세요. (난이도 : 상)</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; boolalpha;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is prime ? :: " &lt;&lt; is_prime&lt;2&gt;::result &lt;&lt; endl; // true</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is prime ? :: " &lt;&lt; is_prime&lt;10&gt;::result &lt;&lt; endl; // false</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is prime ? :: " &lt;&lt; is_prime&lt;11&gt;::result &lt;&lt; endl; // true</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is prime ? :: " &lt;&lt; is_prime&lt;61&gt;::result &lt;&lt; endl; // true</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">사실 처음에 딱 보았을 때 도대체 어떻게 TMP 로 구현할 것인지 감이 안잡혔을 것입니다. 하지만 만약에 소수 인지 아닌지 판별하라는 '함수' 를 작성하게 하였다면 잘 작성하였겠지요. 아마 여러분은 아래와 같은 코드를 쓰셨을 것입니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">bool is_prime(int N)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (N == 2) return true;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (N == 3) return true;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 2; i &lt;= N / 2; i++) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (N % i == 0) return false;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return true;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">왜 2 와 3 일 때 따로 처리하냐면 N / 2 까지 나누는 걸로 비교할 때 2, 3 일 경우 제대로 처리가 안되기 때문입니다. 이제 여러분이 해야할 일은 간단히 저 코드를 TMP 형식으로 옮기는 것입니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template &lt;&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">struct is_prime&lt;2&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">static const bool result = true;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template &lt;&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">struct is_prime&lt;3&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">static const bool result = true;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template&lt;int N&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">struct is_prime {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">static const bool result = !check_div&lt;N, 2&gt;::result;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template&lt;int N, int d&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">struct check_div {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">static const bool result = (N % d == 0) || check_div&lt;N, d + 1&gt;::result;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template&lt;int N&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">struct check_div&lt;N, N / 2&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">static const bool result = (N % (N / 2) == 0);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">무언가 잘 짜여진 코드 같습니다. 하지만 실제로 컴파일 해보면 다음과 같은 오류가 발생합니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="font-size: 12pt;">check_div&lt;N,N/&gt;: non-type parameter of a partial specialization must be a simple identifier</span><span style="white-space: pre; font-size: 12pt;">	</span></p></div><p><br></p><p><span style="font-size: 12pt;">바로&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp; template&lt;int N&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">struct check_div&lt;N, N / 2&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">static const bool result = (N % (N / 2) == 0);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 부분에서 발생하는 문제 이지요. 위 오류가 발생한 문제는 템플릿 부분 특수화 시에 반드시 다른 연산자가 붙지 않고 단순한&nbsp;식별자만 입력해주어야만 합니다. 따라서 C++ 컴파일러에 한계 상</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="font-size: 12pt;">struct check_div&lt;N, N / 2&gt;</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같은 문법은 불가능 합니다. 그렇다면 이를 어떻게 해결할 수 있을까요? 생각을 잘 해보면, N 을 int 인자로 나타내는 대신에, 아예 N 을 나타내는 '타입' 으로 구현하면 어떨까요? 그렇다면 N / 2 역시, 직접 계산하는것이 아니라 N / 2 를 나타내는 타입으로 대체할 수 있고 따라서 템플릿 부분 특수화 문제를 해결할 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 아래와 같이 int 값을 표현하는 타입을 만들 수 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;int N&gt;</span></p><p><span style="font-size: 12pt;">struct INT {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int num = N;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename a, typename b&gt;</span></p><p><span style="font-size: 12pt;">struct add {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef INT&lt;a::num + b::num&gt; result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename a, typename b&gt;</span></p><p><span style="font-size: 12pt;">struct divide {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef INT&lt;a::num / b::num&gt; result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">using one = INT&lt;1&gt;;</span></p><p><span style="font-size: 12pt;">using two = INT&lt;2&gt;;</span></p><p><span style="font-size: 12pt;">using three = INT&lt;3&gt;;</span></p><p><br></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">예를 들어 one 타입은 1을, two 타입은 2 를 나타내게 됩니다. 그렇다면 이를 바탕으로 TMP 코드를 수정해보도록 하겠습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">using one = INT&lt;1&gt;;</span></p><p><span style="font-size: 12pt;">using two = INT&lt;2&gt;;</span></p><p><span style="font-size: 12pt;">using three = INT&lt;3&gt;;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename N, typename d&gt;</span></p><p><span style="font-size: 12pt;">struct check_div {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// result 중에서 한 개라도 true 면 전체가 true</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">= (N::num % d::num == 0) || check_div&lt;N, add&lt;d, one&gt;::result&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename N&gt;</span></p><p><span style="font-size: 12pt;">struct is_prime {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = !check_div&lt;N, two&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;&gt;</span></p><p><span style="font-size: 12pt;">struct is_prime&lt;two&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = true;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;&gt;</span></p><p><span style="font-size: 12pt;">struct is_prime&lt;three&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = true;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename N&gt;</span></p><p><span style="font-size: 12pt;">struct check_div &lt;N, divide&lt;N, two&gt;::result&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = (N::num % (N::num / 2) == 0);</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">그런데 컴파일 한다면 다음과 같은 오류를 보게 됩니다.&nbsp;</span><br><br></p><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><div><span style="font-size: 12pt;">'check_div': 'divide&lt;N,two&gt;::result' is not a valid template type argument for parameter 'd'</span><span style="white-space: pre; font-size: 12pt;">	</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">왜 저런 오류가 발생하였을까요? 일단 오류가 발생하는&nbsp;다음 두 부분의 코드를 살펴보겠습니다.</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">(N::num % d::num == 0) || check_div&lt;N, add&lt;d, one&gt;::result&gt;::result;&nbsp;</span></div></div><div><br></div><div><span style="font-size: 12pt;">와</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">struct check_div &lt;N, divide&lt;N, two&gt;::result&gt; {</span></div></div><div><br></div><div><span style="font-size: 12pt;">입니다. 먼저 컴파일러 입장에서 저 ::result 를 어떻게 해석할지에 대해 생각해봅시다. 물론 우리는 add&lt;d, one&gt;::result 가 언제나 INT&lt;&gt; 타입 이라는 사실을 알고 있습니다. 왜냐하면 typename 인자로 들어오는 N 과 d 가 항상 INT 타입이기 때문에&nbsp;저 result 를 항상 '타입'이네 라고 생각할 것입니다.&nbsp;</span></div><div><br></div><div><b><span style="font-size: 12pt;">그런데, 컴파일러에 구조상 어떠한 식별자(변수 이름이든 함수 이름이든 코드 상의 이름들 - 위 코드의 경우 add, check_div,, result, one 등등 ... ) 를 보았을 때 이 식별자가 '값' 인지 '타입' 인지 결정을 해야 합니다.</span></b><span style="font-size: 12pt;">&nbsp;왜냐하면 예를들어서&nbsp;</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><div><span style="font-size: 12pt;">template &lt;typename T&gt;</span></div><div><span style="font-size: 12pt;">int func() {</span></div><div style="margin-left: 2em;"><span style="font-size: 12pt;">T::t* p;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 16px;">class A {</span></div><div style="margin-left: 2em;"><span style="font-size: 16px;">const static int t;</span></div><div><span style="font-size: 16px;">};</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">class B {</span></div><div style="margin-left: 2em;"><span style="font-size: 16px;">using t = int;&nbsp;</span></div><div><span style="font-size: 16px;">};</span></div></div><div><br></div><div><span style="font-size: 12pt;">위와 같은 템플릿 함수에서 저 문장을 해석할 때 만약에 클래스 A 에 대해서, func 함수를 특수화 한다면, t 가 어떠한 int 값이 되어서&nbsp;</span></div><div><span style="font-size: 12pt;"><br></span></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><div><span style="font-size: 16px;">T::t * p;</span></div></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">위 문장은 단순히 클래스 A 의 t 와 p 를 곱하는 식으로 해석이 됩니다.</span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">반면에 func 함수가 클래스 B 에 대해서 특수화 된다면,&nbsp;</span></div><div><span style="font-size: 16px;"><br></span></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><div><span style="font-size: 16px;">T::t* p;</span></div></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;">이 문장은 int 형 포인터 p 를 선언하는 꼴이 되겠지요. 따라서 컴파일러가 이 두 상황을 명확히 구분하기 위해 저 T::t 가 타입인지 아니면 값인지 명확하게 알려줘야만 합니다.&nbsp;</span></div><div><br></div><div><span style="font-size: 12pt;">우리가 쓴 코드도 마찬가지로&nbsp;컴파일러가</span><b><span style="font-size: 12pt;">&nbsp;'result' 가 항상 '타입' 인지 아니면 '값' 인지 알 수 없습니다</span></b><span style="font-size: 12pt;">. 예컨대 만약에&nbsp;</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;&gt;</span></p><p><span style="font-size: 12pt;">struct divide &lt;int a, int b&gt;&nbsp;{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">const static int result = a + b;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">이런 템플릿이 정의가 되어있다면, 만약에 N 과 two 가 그냥 int 값이였다면&nbsp;저 result 는 static const int 타입의 '값' 이 됩니다. </span><b><span style="font-size: 12pt;">이렇게 템플릿 인자에 따라서 어떠한 타입이 달라질 수 있는 것을 '의존 타입(dependent type)' 이라고 부릅니다.</span></b><span style="font-size: 12pt;"> 위 경우 저 result 는 N 에 의존하기 때문에 의존 타입이 되겠지요.</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 컴파일러가 저 문장을 성공적으로 해석하기 위해서는 우리가 반드시 "야 저 result 는 무조건 타입이야" 라고 알려주어야만 합니다. 이를 위해서는 간단히 아래 코드 처럼</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">struct check_div &lt;N, typename divide&lt;N, two&gt;::result&gt; {</span></div></div><div><b><br></b></div><p><b><span style="font-size: 12pt;">'typename' 키워드를 붙여주면 됩니다.</span></b><span style="font-size: 12pt;"> 마찬가지로&nbsp;</span></p><p><br></p></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">(N::num % d::num == 0) || check_div&lt;N, add&lt;d, one&gt;::result&gt;::result;&nbsp;</span></div></div><div><br></div><div><span style="font-size: 12pt;">에서 typename 키워드를 붙인다면&nbsp;</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">(N::num % d::num == 0) || check_div&lt;N, typename add&lt;d, one&gt;::result&gt;::result;&nbsp;</span></div></div><div><br></div><div><span style="font-size: 12pt;">이 되겠지요. 참고로 의존 '값' 의 경우 typename 을 안 붙여줘도 됩니다. 컴파일러는 어떤 식별자를 보았을 때 기본으로 '값' 이라고 생각합니다. 따라서 check_div 앞에 아무것도 안올 수 있는 것입니다 (check_div 의 result 는 static const bool 이기 때문에!)&nbsp;</span></div><p><br></p><p><span style="font-size: 12pt;">따라서 이를 고치면 다음과 같습니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename N, typename d&gt;</span></p><p><span style="font-size: 12pt;">struct check_div {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// result 중에서 한 개라도 true 면 전체가 true</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">= (N::num % d::num == 0) || check_div&lt;N, typename add&lt;d, one&gt;::result&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">// 생략</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename N&gt;</span></p><p><span style="font-size: 12pt;">struct check_div &lt;N, typename divide&lt;N, two&gt;::result&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = (N::num % (N::num / 2) == 0);</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">마지막으로, 위 is_prime 을 사용하기 위해서는&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">is_prime&lt;INT&lt;11&gt;&gt;::result</span></p></div><p><br></p><p><span style="font-size: 12pt;">이런 식으로 사용해야 합니다. 하지만 생각해보기에서 요구한 것은 is_prime&lt;11&gt;::result 로 사용하는 것이기 때문에 이를 위해서 is_prime 을 다음과 같이 정의하고, 기존의 is_prime 을 _is_prime 으로 바꾸도록 하겠습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;int N&gt;</span></p><p><span style="font-size: 12pt;">struct is_prime {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = _is_prime&lt;INT&lt;N&gt;&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">그렇다면 전체 코드를 살펴보겠습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;typeinfo&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int N&gt;</span></p><p><span style="font-size: 12pt;">struct INT {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int num = N;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename a, typename b&gt;</span></p><p><span style="font-size: 12pt;">struct add {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef INT&lt;a::num + b::num&gt; result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename a, typename b&gt;</span></p><p><span style="font-size: 12pt;">struct divide {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef INT&lt;a::num / b::num&gt; result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">using one = INT&lt;1&gt;;</span></p><p><span style="font-size: 12pt;">using two = INT&lt;2&gt;;</span></p><p><span style="font-size: 12pt;">using three = INT&lt;3&gt;;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename N, typename d&gt;</span></p><p><span style="font-size: 12pt;">struct check_div {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// result 중에서 한 개라도 true 면 전체가 true</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">= (N::num % d::num == 0) || check_div&lt;N, typename add&lt;d, one&gt;::result&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename N&gt;</span></p><p><span style="font-size: 12pt;">struct _is_prime {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = !check_div&lt;N, two&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;&gt;</span></p><p><span style="font-size: 12pt;">struct _is_prime&lt;two&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = true;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;&gt;</span></p><p><span style="font-size: 12pt;">struct _is_prime&lt;three&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = true;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename N&gt;</span></p><p><span style="font-size: 12pt;">struct check_div &lt;N, typename divide&lt;N, two&gt;::result&gt; {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = (N::num % (N::num / 2) == 0);</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int N&gt;</span></p><p><span style="font-size: 12pt;">struct is_prime {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const bool result = _is_prime&lt;INT&lt;N&gt;&gt;::result;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; boolalpha;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is 2 prime ? :: " &lt;&lt; is_prime&lt;2&gt;::result &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is 10 prime ? :: " &lt;&lt; is_prime&lt;10&gt;::result &lt;&lt; endl;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 708px; background-color: transparent;"><ins id="aswift_5_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 708px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="708" height="177" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;width:708px;height:177px;"></iframe></ins></ins></ins></div><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is 11 prime ? :: " &lt;&lt; is_prime&lt;11&gt;::result &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "Is 61 prime ? :: " &lt;&lt; is_prime&lt;61&gt;::result &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:281px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F246E4050595360293409F3 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F246E4050595360293409F3 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F246E4050595360293409F3 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F246E4050595360293409F3 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F246E4050595360293409F3 480w" src="https://t1.daumcdn.net/cfile/tistory/246E40505953602934" style="max-width:100%;height:auto" width="281" height="133" filename="9.3.1.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 제대로 판별함을 알 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">참고로 컴파일러에 따라서 재귀적으로 몇 번까지 사용 가능한지 깊이가 정해져있기 때문에, 꽤 큰 수를 넣는다면 컴파일 오류가 발생할 수 도 있습니다. </span><br></p><p><br></p><p><span style="font-size: 12pt;">자, 그렇다면 본격적으로 이번 강의를 시작해보도록 하겠습니다. 지난 강좌에서 Ratio 클래스를 만들면서 왜 굳이 이것을 TMP 로 만들었을까, 그냥 일반적인 클래스로 만들었다면 훨씬 직관적이고 편하지 않나라고 많이 생각하셨을 것입니다. 바로 지금부터 TMP 의 진짜 파워에 대해서 알아보도록 하겠습니다.</span></p><p><br></p><p><br></p><table cellspacing="1" cellpadding="1" bgcolor="#ffffff" style="width: 634px; border-collapse: collapse; height: 31px;"><tbody><tr><td bgcolor="#3058d2" width="1%" style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210);"><span style="font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td><td width="99%" style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210);"><span style="color: rgb(48, 88, 210); font-size: 10pt;"><span style="font-family: Gulim;"><span style="font-weight: bold; font-size: 12pt;">&nbsp;단위(Unit) 라이브러리</span></span></span><font color="#c8056a"><strong><span style="font-size: 10pt;"><span style="font-family: Gulim;"><br></span></span></strong></font></td><td width="100%" style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210) rgb(48, 88, 210) rgb(255, 70, 197);"><span style="font-size: 10pt;"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><p><br></p><div></div><div></div><p><span style="font-size: 12pt;">C++ 코드를 작성하는 이유는 여러가지가 있겠지만, 그 중 하나로 바로 여러 수치 계산을 사용하는데에도 많이 사용합니다. 예를 들어서 인공위성의 궤도를 계산한다던지, 입자의 운동을 계산한다던지 말이지요. 이러한 물리적 수치 계산 시에 꼭 필요한 것이 바로 '단위' 입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">단위라 하면 쉽게 말해 킬로그램 (kg), 미터 (m), 초 (s) 등을 생각하시면 됩니다. 이러한 것들을 계산하는 프로그램들의 경우, double 이나 float 변수에 들어가는 값에는 '단위' 가 붙어서 들어가겠지요.&nbsp;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_6_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_6_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_6" name="aswift_6" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">예를 들어서 핸드폰의 가속도 센서에서 부터 데이터를 받는 프로그램은 아마도 m/s^2 단위로 데이터를 받겠지요. 혹은 시계로 부터 데이터를 받는 프로그램은 s 단위로 데이터를 받을 것 입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">아무튼 이렇게 단위가 붙은 데이터를 처리할 때 중요한 점은 바로 데이터를 연산할 때 항상 단위를 확인해야 된다는 점입니다. 예를 들어서, 다음과 같은 코드가 있다고 생각해봅시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp; float v1, v2; // v1, v2 는 속도&nbsp;</span></p><p></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; v1 + v2;&nbsp;</span></p></div><p></p><p><br></p><p><span style="font-size: 12pt;">당연히 v1 과 v2 는 속도 값을 나타내므로 같은 단위이기 때문에 더할 수 있습니다. (여기서 더할 수 있다는 말은 물리적으로 더한 값이 말이 된다는 의미 입니다). 반면에;</span></p><p><br></p><p></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">float&nbsp;v; // 속도; m/s</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">float&nbsp;a; // 가속도; m/s^2</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; v + a; // ???</span></p></div><p><br></p><p><span style="font-size: 12pt;">만약에 v 가 속도를 나타내는 값이고, a 가 가속도를 나타내는 값이라면, v + a 는 불가능한 연산입니다. 만약에 프로그래머가 저러한 코드를 썻다면 분명히 실수일 것입니다. 물론 C++ 컴파일러 입장에서는 그냥 두 개의 float 변수를 더한 것이기 때문에 문제 없이 컴파일 됩니다. 하지만 프로그램을 돌리게 된다면 골치아픈 문제가 발생하겠지요.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">실제로, NASA 의 경우 단위를 잘못 처리해서 1조원 짜리 화성 탐사선을 날려먹은 경우가 있습니다. 이 경우 1조원 자리 버그 이겠네요.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">여러분이라면 이러한 실수를 어떻게 막을 것인가요? </span><b><span style="font-size: 12pt;">일단 가장 먼저 드는 생각으로 단위 데이터를 일반적인 변수에 보관하지 말고 클래스를 만들어서 클래스 객체에서 보관</span></b><span style="font-size: 12pt;">하는 것입니다. 그리고 operator+ 등으로 연산자들을 오버로딩 한 뒤에, 연산 시에 객체 끼리 단위를 체크해서 단위가 맞지 않으면 적절히 처리하면 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">물론 이 방법은 꽤나 괜찮아 보이지만 한 가지 문제가 있습니다. 만일 틀린 단위를 연산하는 코드가 '매우 드물게' 일어난다면 어떨까요? 즉 런타임에서 그 문제를 발견하지 못한 채 넘어갈 수 있다는 점입니다.</span></p><p><br></p><p><span style="font-size: 12pt;">가장 이상적인 상황은 단위가 맞지 않는 연산을 수행하는 코드가 있다면&nbsp;</span><b><span style="font-size: 12pt;">아예 컴파일 시에 오류를 발생</span></b><span style="font-size: 12pt;">시켜버리는 것입니다. 그렇다면 적어도 틀린 단위를 연산하는 일은 막을 수 있게 되고, 프로그램을 실행 시키면서 기다리는 수고를 줄일 수 있게 되지요.&nbsp;</span></p><p><br><span style="font-size: 12pt;">이를 위해서 다음과 같은 클래스를 생각해봅시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template&lt;typename U, typename V, typename W&gt;</span></p><p><span style="font-size: 12pt;">struct Dim {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using M = U; // kg</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using L = V; // m&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using T = W; // s</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using type = Dim &lt;M, L, T&gt;;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br><span style="font-size: 12pt;">이 Dim 이라는 클래스는 어떠한 데이터의 단위를 나타내기 위해서 사용됩니다. 어떠한 물리량의 단위를 나타내기 위해서는 무게(kg), 길이(m), 시간(s) 이 3 개로 나타낼 수 있습니다.&nbsp;(실제로는 8개가 필요하지만 단순화를 위해 3개만 사용하도록 하겠습니다).</span></p><p><br></p><p><span style="font-size: 12pt;">예를 들어서 속도의 경우 m/s 이므로, 저 Dim 클래스로 표현하자면 Dim&lt;0, 1, -1&gt; 로 나타낼 수 있습니다. 왜냐하면 m/s = kg^0 m^1 s^-1 이기 때문이지요.</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_7_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_7_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_7" name="aswift_7" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">마찬가지로 힘의 경우 단위가 kg m /s^2 이므로 Dim 클래스로 표현하자면 Dim&lt;1, 1, -2&gt; 가 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">물론 저 Dim 의 경우 템플릿 인자로 타입을 받기 때문에 단순히 Dim&lt;0, 1, -1&gt; 이렇게 사용할 수 있는 것이 아닙니다. 대신에 앞서 만들었던 </span><b><span style="font-size: 12pt;">Ratio 클래스를 이용해서 저 숫자들을 '타입' 으로 표현</span></b><span style="font-size: 12pt;">해주어야 합니다. 따라서, 실제로는&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">Dim&lt;1, 1, -2&gt;</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">가 아니라</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">Dim&lt;Ratio&lt;1, 1&gt;, Ratio&lt;1, 1&gt;, Ratio&lt;-2, 1&gt;&gt;</span></p></div><p><br></p><p><span style="font-size: 12pt;">이런 식으로 정의를 해야겠지요. 그렇다면 Dim 끼리 더하고 빼는 템플릿 클래스도 아래와 같이 만들 수 있게 됩니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template&lt;typename U, typename V&gt;</span></p><p><span style="font-size: 12pt;">struct add_dim_ {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Dim &lt;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::M, typename V::M&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::L, typename V::L&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::T, typename V::T&gt;::type&gt; type;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename U, typename V&gt;</span></p><p><span style="font-size: 12pt;">struct subtract_dim_ {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Dim &lt;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::M, typename V::M&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::L, typename V::L&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::T, typename V::T&gt;::type&gt; type;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">왜 typename 이 저렇게도 많이 붙어있는지는 아마 잘 이해하실 거라 생각합니다. 왜냐하면 예를 들어 M 의 경우 U 에 의존한 타입이고, type 의 경우도 마찬가지로 U 와 V 에 의존하는 타입이기 때문이지요.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">자 이제, 실제 데이터를 담는 클래스를 만들어보도록 하겠습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T, typename D&gt;</span></p><p><span style="font-size: 12pt;">struct quantity {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T q;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using dim_type = D;</span></p><p><span style="font-size: 12pt;">};</span></p></div><p><br></p><p><span style="font-size: 12pt;">일단 위 처럼 q 라는 멤버 변수에 데이터를 담고, (데이터의 타입은 T 가 되겠지요), dim_type 에 차원 정보를 담게 됩니다. 차원 정보는 데이터와는 다르게 'Dim&nbsp;타입' 그 자체로 표현됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">자 이제, 실제로 quantity 객체를 가지고 연산을 수행하기 위해서는 우리가 연산자들을 오버로드 해줘야만 합니다. 일단 간단히 + 와 - 연산자를 어떻게 오버로드 할 지 생각해봅시다. 앞서 말했듯이, 두 개의 데이터를 더하거나 빼기 위해서는 반드시 단위가 일치해야 합니다. 이 말은, dim_type 이 같은 타입이어야만 하다는 것이지요.&nbsp;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_8_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_8_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_8" name="aswift_8" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">따라서 operator+ 와 operator- 는 다음과 같이 간단히 정의할 수 있습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity operator+(quantity&lt;T, D&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q + quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity operator-(quantity&lt;T, D&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q - quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">위 operator+ 는 인자로 받는 quantity 의 데이터 타입과 Dim 타입이 일치해야지만 인스턴스화 됩니다. 만약에, 데이터 타입이나 Dim 타입이 일치하지 않았더라면 저 operator+ 는 인스턴스화 될 수 없고 따라서 컴파일러는 저 operator+ 를 찾을 수 없다는 오류를 발생시키게 됩니다!</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 실제로 테스트를 해볼까요.</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int X, int Y&gt;</span></p><p><span style="font-size: 12pt;">struct GCD</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int value = GCD&lt;Y, X%Y&gt;::value;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int X&gt;</span></p><p><span style="font-size: 12pt;">struct GCD&lt;X, 0&gt;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int value = X;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int N, int D = 1&gt;</span></p><p><span style="font-size: 12pt;">struct Ratio</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">private:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">const static int _gcd = GCD&lt;N, D&gt;::value;</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Ratio&lt;N / _gcd, D / _gcd&gt; type;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int num = N / _gcd;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int den = D / _gcd;</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_add</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;;</span></p><p><span style="font-size: 16px;">};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct Ratio_add : _Ratio_add&lt;R1, R2&gt;::type {};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_subtract</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;;</span></p><p><span style="font-size: 16px;">};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct Ratio_subtract : _Ratio_subtract&lt;R1, R2&gt;::type {};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_multiply</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::num , R1::den * R2::den&gt;;</span></p><p><span style="font-size: 16px;">};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct Ratio_multiply : _Ratio_multiply&lt;R1, R2&gt;::type {};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_divide</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt; R1::num * R2::den, R1::den * R2::num&gt;;</span></p><p><span style="font-size: 16px;">};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct Ratio_divide : _Ratio_divide&lt;R1, R2&gt;::type {};</span></p><div><br></div><p><span style="font-size: 12pt;">template&lt;typename U, typename V, typename W&gt;</span></p><p><span style="font-size: 12pt;">struct Dim {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using M = U;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using L = V;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using T = W;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using type = Dim &lt;M, L, T&gt;;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename U, typename V&gt;</span></p><p><span style="font-size: 12pt;">struct add_dim_ {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Dim &lt;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::M, typename V::M&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::L, typename V::L&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::T, typename V::T&gt;::type&gt; type;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename U, typename V&gt;</span></p><p><span style="font-size: 12pt;">struct subtract_dim_ {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Dim &lt;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::M, typename V::M&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::L, typename V::L&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::T, typename V::T&gt;::type&gt; type;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T, typename D&gt;</span></p><p><span style="font-size: 12pt;">struct quantity {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T q;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using dim_type = D;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity operator+(quantity&lt;T, D&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q + quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity operator-(quantity&lt;T, D&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q - quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using one = Ratio&lt;1, 1&gt;;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using zero = &nbsp;Ratio&lt;0, 1&gt;;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;double, Dim&lt;one, zero, zero&gt;&gt; kg(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;double, Dim&lt;zero, one, zero&gt;&gt; meter(1);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;double, Dim&lt;zero, zero, one&gt;&gt; second(1);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// Good</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">kg + kg;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// Bad</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">kg + meter;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">컴파일 하였다면 다음과 같은 오류가 납니다.</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><ul style="list-style-type: square;"><li><span style="font-size: 12pt;">no operator "+" matches these operands</span><br><br></li><li><span style="font-size: 12pt;">binary '+': no operator found which takes a right-hand operand of type 'quantity&lt;double,Dim&lt;zero,one,zero&gt;&gt;' (or there is no acceptable conversion)</span></li></ul></div><p><br></p><p><span style="font-size: 12pt;">즉 위 + 에 해당하는 연산자 함수를 찾을 수 없다는 것이지요. 예상했던 대로,&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// Bad</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">kg + meter;</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 부분에서 오류가 발생하는데, kg 와 meter 의 단위가 다르기 때문에 발생하게 됩니다. 반면에</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(159, 211, 49); background-color: rgb(231, 253, 181); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// Good</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">kg + kg;</span></p></div><p><br></p><p><span style="font-size: 12pt;">는 잘 컴파일되지요.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 이제 * 와 / 연산자만 만들어주면 되겠습니다. 하지만 * 와 / 의 경우 + 와 - 보다 좀 더 까다롭습니다. 왜냐하면 * 와 / 의 경우 굳이 Dim 이 일치하지 않아도 되거든요! 다만 이 연산을 수행하였을 때 새로운 차원의 데이터가 나올 뿐입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">예를 들어서 가속도를 나타내기 위해서는</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">meter / (second * second)</span></p></div><p><br></p><p><span style="font-size: 12pt;">이렇게 해주면 됩니다. 다만 새로운 차원의 데이터 (Dim&lt;zero, one, minus_two&gt;) 가 탄생할 뿐이지요. 따라서, operator* 와 operator/ 의 경우 두 개의 다른 차원의 값을 받아도 처리할 수 있어야 합니다. 따라서 opreator* 와 / 를 정의해보자면 아래와 같습니다.</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template &lt;typename D2&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;T, typename add_dim_&lt;D, D2&gt;::type&gt; operator*(quantity&lt;T, D2&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, typename&nbsp;add_dim_&lt;D, D2&gt;::type&gt;(q * quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template &lt;typename D2&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;T, typename subtract_dim_&lt;D, D2&gt;::type&gt; operator/(quantity&lt;T, D2&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, typename subtract_dim_&lt;D, D2&gt;::type&gt;(q / quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><div><br></div></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">새로 만들어지는 타입의 차원은 당연히도 add_dim_&lt;D, D2&gt;::type 이 되겠고 (opreator* 의 경우), 그 값은 그냥 실제 값을 곱해주면 됩니다. 이와 더불어서</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div style="margin-left: 2em;"><span style="font-size: 12pt;">3 * kg</span></div></div><div style="margin-left: 2em;"><br></div><div><span style="font-size: 12pt;">과 같은 곱도 처리해야 하기 때문에, 아래와 같은 함수들도 정의해줘야 합니다.</span></div><div><span style="font-size: 12pt;"><br></span></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;T, D&gt; operator*(T scalar) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q * scalar);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div><div><br></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;T, D&gt; operator/(T scalar) {</span></div><div><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q / scalar);</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">이는 위 처럼 일반적인 차원이 없는 값 과의 곱도 지원해줍니다. 그렇다면 예를 들어서 아래와 같이 정의된 F 의 타입은 어떻게 될까요?</span></div><div><br></div><div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// F 의 타입은?</span></div><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">F = kg * meter / (second * second);</span></div></div></div><div><br></div><div><span style="font-size: 12pt;">일단 F 의 차원은 계산해보면 (1, 1, -2) 이렇게 나올 것 입니다. 따라서, F 의 dim 타입은 &lt;Ratio&lt;1, 1&gt;, Ratio&lt;1, 1&gt;, Ratio&lt;-2, 1&gt;&gt; 가 되겠지요. 다시 말해, F 를 다음과 같이 나타낼 수 있습니다.&nbsp;</span></div><div><span style="font-size: 12pt;"><br></span></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">quantity&lt;double, Dim&lt;one, one, Ratio&lt;-2, 1&gt;&gt;&gt; F = kg * meter / (second * second);</span></div></div><div><br></div><div><span style="font-size: 12pt;">그런데, 매번 변수를 정의할 때 마다 저렇게 길고 긴 타입을 써주는 것은 매우 귀찮은 일입니다. 저 kg * meter / (second * second) 를 계산해서 나오는 객체의 타입이 저렇게 된다는 사실은 저도 알고 컴파일러도 알고 있습니다. 컴파일러가 쉽게 알아낼 수 있는 타입을 굳이 우리가 써주어야 할까요? 똑똑한 컴파일러가 타입을 알아서 생각하도록 하면 안될까요?</span></div><div><br></div><div><span style="font-size: 12pt;">물론 가능합니다.&nbsp;</span></div><div><br></div><div><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;타입을 알아서 추측해라! - auto 키워드</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">C++ 코드를 많이 짜면서 느꼈겠지만, 객체를 생성할 때, 많은 경우 굳이 타입을 쓰지 않아도 알아서 추측할 수 있는 경우들이 많이 있습니다. 예를 들어서,</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">(??) a = 3;</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같이 썼다면 저 (??)&nbsp;는 아마 int 를 의도한 것이겠지요. 아니면&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">some_class a;</span></p><p><span style="font-size: 12pt;">(??) b = a;</span><br></p></div><p><span style="font-size: 12pt;"><br></span></p><p><span style="font-size: 12pt;">의 경우 저 (??) 에는 아마 some_class 가 들어가겠지요/&nbsp;즉 객체가 복사 생성 될 때, 그 복사 생성하는 대상의 타입을 확실히 알 수 있다면 굳이 그 객체의 타입을 명시하지 않아도 컴파일러가 알아낼 수 있습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">물론 때때로 컴파일러가 타입을 제대로 유추할 수 없는 경우도 있습니다. 예를 들어서, 우리의 위 예제 코드에서</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;double, Dim&lt;one, zero, zero&gt;&gt; kg(1);</span></p></div><p><br></p><p><span style="font-size: 12pt;">의 경우 만약에 저 타입 부분을 가리고</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">(??)&nbsp;kg(1);</span></p></div><p><br></p><p><span style="font-size: 12pt;">와 같이 살펴본다면 어떨까요? 컴파일러에 입장에서는 단순히 생각해봤을 때 그냥 1 로 초기화 하는 변수 이므로 (??) 에는 int 가 들어가겠지요. 따라서 이 경우에는 우리가 원하는 타입으로 생성할 수 없습니다. 반면에,</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">(??) F = kg * meter / (second * second);</span></p></div><p><br></p><p><span style="font-size: 12pt;">F 의 경우 우리가 굳이 타입을 적지 않아도 컴파일러가 오른쪽의 연산을 통해서 F 의 타입을 정확하게 알아낼 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이와 같이 컴파일러가 타입을 정확히 알아낼 수 있는 경우 굳이 그 길고 긴 타입을 적지 않고 간단히 'auto' 로 표현할 수 있습니다. 그리고 그 auto 에 해당하는 타입은 컴파일 시에 컴파일러에 의해 추론됩니다. 아래 간단한 예제를 살펴볼까요.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;typeinfo&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><div><br></div><p><span style="font-size: 12pt;">int sum(int a, int b)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return a + b;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">class SomeClass</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int data;</span></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">SomeClass(int d) : data(d) {}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">SomeClass(const SomeClass&amp; s) : data(s.data) {}</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto c = sum(1, 2); // 함수 리턴 타입으로 부터 int 라고 추측 가능</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto num = 1.0 + 2.0; // double 로 추측 가능!</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">SomeClass some(10);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto some2 = some;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto some3(10); // SomeClass 객체를 만들까요?</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "c 의 타입은? :: " &lt;&lt; typeid(c).name() &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "num 의 타입은? :: " &lt;&lt; typeid(num).name() &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "some2 의 타입은? :: " &lt;&lt; typeid(some2).name() &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "some3 의 타입은? :: " &lt;&lt; typeid(some3).name() &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:304px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F212DD2445958AD6337F074 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F212DD2445958AD6337F074 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F212DD2445958AD6337F074 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F212DD2445958AD6337F074 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F212DD2445958AD6337F074 480w" src="https://t1.daumcdn.net/cfile/tistory/212DD2445958AD6337" style="max-width:100%;height:auto" width="304" height="128" filename="9.3.3.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "c 의 타입은? :: " &lt;&lt; typeid(c).name() &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "num 의 타입은? :: " &lt;&lt; typeid(num).name() &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "some2 의 타입은? :: " &lt;&lt; typeid(some2).name() &lt;&lt; endl;</span></p></div><p><br></p><p><span style="font-size: 12pt;">일단 위 3줄은 우리의 예상대로 auto 키워드가 잘 타입을 추론해줍니다. c 의 경우 함수의 리턴 타입으로 부터 int 타입이라는 것을 알 수 있고, num 의 경우 1.0 + 2.0 의 결과가 double 이므로 num 역시 double 타입 변수로 초기화 됩니다. 마지막으로 some2 의 경우 SomeClass 타입인 some 으로 부터 복사 생성 되므로 SomeClass 타입이 되지요.</span></p><p><br></p><p><span style="font-size: 12pt;">마지막으로 some3 를 살펴봅시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto some3(10); // SomeClass 객체를 만들까요?</span></p></div><p><br></p><p><span style="font-size: 12pt;">이전에 some 을 만들 때 SomeClass some(10) 으로 만들었기 때문에 저 some3 도 혹시 SomeClass 타입으로 추론하지 않을까 생각할 수 있습니다. 하지만 컴파일러는 최대한 단순하게 가능한 방법으로 추론하기 때문에 (실제로 auto 타입을 추론하는 방법은 템플릿에 들어갈 타입을 추론하는 것과 동일합니다), 그냥 int 변수로 만들어 버립니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 아래의 F 의 경우 정확히 타입을 추론할 수 있기 때문에 그냥&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// F 의 타입은 굳이 알필요 없다!</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto F = kg * meter / (second * second);</span></p></div><p><br></p><p><span style="font-size: 12pt;">위와 같이 auto 키워드를 이용하면 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">참고로 편의를 위해 quantity 를 ostream 으로 출력해주는 함수인</span></p><p><span style="font-size: 12pt;">&nbsp;</span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">template &lt;typename T, typename D&gt;</span></p><p><span style="font-size: 12pt;">ostream&amp; operator&lt;&lt; (ostream&amp; out, const quantity&lt;T, D&gt;&amp; q)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">out &lt;&lt; q.q &lt;&lt; "kg^" &lt;&lt; D::M::num / D::M::den&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">&lt;&lt; "m^" &lt;&lt; D::L::num / D::L::den</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">&lt;&lt; "s^" &lt;&lt; D::T::num / D::T::den;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return out;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">를 제작하였습니다. 따라서 전체 코드를 살펴보면 다음과 같습니다.&nbsp;</span></p><p><span style="font-size: 12pt;"><br></span></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">#include &lt;typeinfo&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int X, int Y&gt;</span></p><p><span style="font-size: 12pt;">struct GCD</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int value = GCD&lt;Y, X%Y&gt;::value;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int X&gt;</span></p><p><span style="font-size: 12pt;">struct GCD&lt;X, 0&gt;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int value = X;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;int N, int D = 1&gt;</span></p><p><span style="font-size: 12pt;">struct Ratio</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="font-size: 12pt;">private:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">const static int _gcd = GCD&lt;N, D&gt;::value;</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Ratio&lt;N / _gcd, D / _gcd&gt; type;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int num = N / _gcd;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">static const int den = D / _gcd;</span></p><p><span style="font-size: 12pt;">};</span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_add</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::den + R2::num * R1::den, R1::den * R2::den&gt;;</span></p><p><span style="font-size: 16px;">};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct Ratio_add : _Ratio_add&lt;R1, R2&gt;::type {};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_subtract</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::den - R2::num * R1::den, R1::den * R2::den&gt;;</span></p><p><span style="font-size: 16px;">};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct Ratio_subtract : _Ratio_subtract&lt;R1, R2&gt;::type {};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_multiply</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt;R1::num * R2::num , R1::den * R2::den&gt;;</span></p><p><span style="font-size: 16px;">};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct Ratio_multiply : _Ratio_multiply&lt;R1, R2&gt;::type {};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct _Ratio_divide</span></p><p><span style="font-size: 16px;">{</span></p><p><span style="font-size: 16px;"><span style="white-space:pre">	</span>using type = Ratio &lt; R1::num * R2::den, R1::den * R2::num&gt;;</span></p><p><span style="font-size: 16px;">};</span></p><p><span style="font-size: 16px;"><br></span></p><p><span style="font-size: 16px;">template &lt;class R1, class R2&gt;</span></p><p><span style="font-size: 16px;">struct Ratio_divide : _Ratio_divide&lt;R1, R2&gt;::type {};</span></p><div><br></div><p><span style="font-size: 12pt;">template&lt;typename U, typename V, typename W&gt;</span></p><p><span style="font-size: 12pt;">struct Dim {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using M = U;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using L = V;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using T = W;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using type = Dim &lt;M, L, T&gt;;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename U, typename V&gt;</span></p><p><span style="font-size: 12pt;">struct add_dim_ {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Dim &lt;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::M, typename V::M&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::L, typename V::L&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_add&lt;typename U::T, typename V::T&gt;::type&gt; type;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template&lt;typename U, typename V&gt;</span></p><p><span style="font-size: 12pt;">struct subtract_dim_ {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">typedef Dim &lt;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::M, typename V::M&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::L, typename V::L&gt;::type,</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">typename Ratio_subtract&lt;typename U::T, typename V::T&gt;::type&gt; type;</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T, typename D&gt;</span></p><p><span style="font-size: 12pt;">struct quantity {</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">T q;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using dim_type = D;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity operator+(quantity&lt;T, D&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q + quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity operator-(quantity&lt;T, D&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q - quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template &lt;typename D2&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;T, typename add_dim_&lt;D, D2&gt;::type&gt; operator*(quantity&lt;T, D2&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, typename add_dim_&lt;D, D2&gt;::type&gt;(q * quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">template &lt;typename D2&gt;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;T, typename subtract_dim_&lt;D, D2&gt;::type&gt; operator/(quantity&lt;T, D2&gt; quant) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, typename subtract_dim_&lt;D, D2&gt;::type&gt;(q / quant.q);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// Scalar multiplication and division</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;T, D&gt; operator*(T scalar) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q * scalar);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;T, D&gt; operator/(T scalar) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">return quantity&lt;T, D&gt;(q / scalar);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity(T q) : q(q) {}</span></p><p><br></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">template &lt;typename T, typename D&gt;</span></p><p><span style="font-size: 12pt;">ostream&amp; operator&lt;&lt; (ostream&amp; out, const quantity&lt;T, D&gt;&amp; q)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">out &lt;&lt; q.q &lt;&lt; "kg^" &lt;&lt; D::M::num / D::M::den&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">&lt;&lt; "m^" &lt;&lt; D::L::num / D::L::den</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">&lt;&lt; "s^" &lt;&lt; D::T::num / D::T::den;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return out;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using one = Ratio&lt;1, 1&gt;;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">using zero = &nbsp;Ratio&lt;0, 1&gt;;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;double, Dim&lt;one, zero, zero&gt;&gt; kg(2);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;double, Dim&lt;zero, one, zero&gt;&gt; meter(3);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">quantity&lt;double, Dim&lt;zero, zero, one&gt;&gt; second(1);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// F 의 타입은 굳이 알필요 없다!</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">auto F = kg * meter / (second * second);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "2 kg 물체를 3m/s^2 의 가속도로 밀기 위한 힘의 크기는? " &lt;&lt; F &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:526px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2104A74C5958A785159302 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2104A74C5958A785159302 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2104A74C5958A785159302 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2104A74C5958A785159302 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2104A74C5958A785159302 480w" src="https://t1.daumcdn.net/cfile/tistory/2104A74C5958A78515" style="max-width:100%;height:auto" width="526" height="108" filename="9.3.2.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 잘 나옵니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">auto 키워드는 템플릿의 사용으로&nbsp;복잡해진 타입 이름들을 간단하게 나타낼 수 있는 획기적인 방법입니다. 물론 짧은 이름의 타입일 경우 그냥 써주는 것이 좋지만 (왜냐면 그 코드를 읽는 사람에 입장에서 한눈에 타입을 알 수 있으면 좋기 때문에), 위 경우 처럼 복잡한 타입 이름의 경우, 그 타입을 쉽게 추측할 수 있다면 auto 키워드를 활용하는 것도 좋습니다.&nbsp;</span><br></p><p><br></p><p><span style="font-size: 12pt;">이것으로 템플릿 메타프로그래밍에 대한 강좌를 마치도록 하겠습니다. 사실 실제 현업에서 템플릿 메타 프로그래밍을 활용하는 경우는 그다지 많지 않습니다. 왜냐하면 일단 TMP 의 특성상 </span><b><span style="font-size: 12pt;">복잡하고, 머리를 매우 많이 써야되고, 무엇보다도 버그가 발생하였을 때 찾는 것이 매우 힘듧니다</span></b><span style="font-size: 12pt;">.</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 우리의 Unit 클래스 처럼 TMP 를 적절하게 활용하면 런타임에서 찾아야 하는 오류를 컴파일 타임에서 미리 다 잡아낼 수 도 있고, 런타임 시에 수행해야 하는 연산들도 일부 컴파일 타임으로 옮길 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">만약에 TMP 를 직접 작성할 일이 있다면 이미 TMP 를 그나마 편하게 수행하기 위해 만들어진 boost::MPL 라이브러리가 있습니다. 이 라이브러리를 활용하신다면 비교적 쉽게 TMP 코드를 짤 수 있<span style="font-size: 12pt;">을 것입니다!</span></span></p><p><br></p></div><p><span style="font-size: 12pt;">다음 강좌에서는 C++ 의 또다른 막강한 무기인 표준 라이브러리 (STL) 에 대해 알아보도록 하겠습니다!</span></p><p><span style="font-size: 12pt;"><br></span></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210); height: 30px;" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210); height: 30px;" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;생각 해보기</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="border-width: 0px 0px 1px; border-style: solid; border-color: rgb(48, 88, 210) rgb(48, 88, 210) rgb(255, 70, 197); height: 30px;" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><span style="font-size: 12pt;">
</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><br><span style="font-size: 12pt;">1. 컴파일러가 auto 키워드에 들어갈 타입을 추측하는 방법은 템플릿에서 들어갈 타입을 추측하는 방법과 같습니다. <a href="http://en.cppreference.com/w/cpp/language/template_argument_deduction" target="_blank" class="tx-link">여기를 클릭해서 읽어보세요!</a></span></p><p><br></p><p></p><p><span style="font-size: 12pt;"><br></span></p><p></p><div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox">
<span style="font-size:12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 <span style="font-weight: bold;">꼭 댓글을 남겨주시기 바랍니다</span>. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span><br>
<br>
<span style="font-size: 12pt;">현재 여러분이 보신 강좌는<i>&lt;&lt;</i></span><span style="font-size: 16px;"><i>씹어먹는 C++ - &lt;9 - 3. 템플릿 메타 프로그래밍 2&gt;</i></span><span style="font-size: 12pt;"><i>&gt;&gt;</i> 입니다. 이번 강좌의 </span><span style="font-size: 12pt; font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span><span style="font-size: 12pt;">까지 다음 강좌로 넘어가지 말아주세요 </span><br>
<br>
<div style="font-size: 12pt; text-align: right;">
<span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135">다음 강좌 보러가기</a><br>
</span>
</div>
</div>
<br><p></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br><br></p><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_222" data-uoc-sc="401" data-uoc-pcurl="http://itguru.tistory.com/222" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_222"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text screen_out">공감</span><span class="txt_like uoc-count">1</span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile30.uf.tistory.com/image/246E4050595360293409F3" data-title="씹어먹는 C++ - <9 - 3. 템플릿 메타 프로그래밍 2>" data-description=".이번 강좌에서는 의존 타입 (dependent type) Unit 라이브러리 만들기 auto 키워드 에 대해서 배웁니다.  안녕하세요 여러분! 지난 강좌에서 왜 TMP 를 활용하여 힘들게 힘들게 Ratio 클래스를 만들었는데, 아직.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/222" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="222"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/222&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++">C++</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/224?category=361027">씹어먹는 C++ - &lt;10 - 2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map&gt;</a>&nbsp;&nbsp;<span>(5)</span>
</th>
<td>
2017.07.08</td>
</tr>
<tr>
<th>
<a href="/223?category=361027">씹어먹는 C++ - &lt;10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.07.04</td>
</tr>
<tr>
<th>
<a href="/222?category=361027" class="current">씹어먹는 C++ - &lt;9 - 3. 템플릿 메타 프로그래밍 2&gt;</a>&nbsp;&nbsp;<span>(8)</span>
</th>
<td>
2017.07.02</td>
</tr>
<tr>
<th>
<a href="/221?category=361027">씹어먹는 C++ - &lt;9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.06.26</td>
</tr>
<tr>
<th>
<a href="/219?category=361027">씹어먹는 C++ - &lt;9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)&gt;</a>&nbsp;&nbsp;<span>(10)</span>
</th>
<td>
2017.04.07</td>
</tr>
<tr>
<th>
<a href="/218?category=361027">씹어먹는 C++ - &lt;8 - 2. Excel 만들기 프로젝트 2부&gt;</a>&nbsp;&nbsp;<span>(6)</span>
</th>
<td>
2016.07.19</td>
</tr>
</tbody></table></div></div>
<br> <br>


					