
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_0_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<div class="tt_article_useless_p_margin"><p><span style="font-size: 8pt;">이번 강좌에서는</span></p><ul style="list-style-type: disc;"><li><span style="font-size: 8pt;">복사 생략 (Copy elision)</span></li><li><span style="font-size: 8pt;">우측값 레퍼런스 (rvalue reference)</span></li><li><span style="font-size: 8pt;">이동 생성자 (move constructor)</span></li></ul><div><span style="font-size: 16px;"><hr><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/9917313B5AB64C5521?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9917313B5AB64C5521E17D 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9917313B5AB64C5521E17D 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9917313B5AB64C5521E17D 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9917313B5AB64C5521E17D 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F9917313B5AB64C5521E17D 480w" src="https://t1.daumcdn.net/cfile/tistory/9917313B5AB64C5521" style="cursor: pointer;max-width:100%;height:auto" width="730" height="158" filename="__CODE____C___by_webblaster48.jpg" filemime="image/jpeg"></span></span></p><p><br></p></span></div><p><span style="font-size: 12pt;">안녕하세요 여러분! 지난번 STL 강좌는 어떠셨나요? 이번 강좌에서는 C++ 11 에서 추가된 우측값 레퍼런스에 대해서 다루어보도록 하겠습니다. 처음에 보면 약간 생소할 수 있는데 천천히 읽어보시기 바랍니다.</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;복사 생략(Copy Elision)</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">아래 코드를 실행해보면 결과가 어떻게 나올까요?</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class A</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int data_;</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A(int data) : data_(data) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "일반 생성자 호출!" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A(const A&amp; a) : data_(a.data_) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">data_ = a.data_;</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; "복사 생성자 호출!" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A a(1); // 일반 생성자 호출</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A b(a); // 복사 생성자 호출</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 그렇다면 이것은?</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A c(A(2));</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:254px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9936A83359A3A1A72E5EDB 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9936A83359A3A1A72E5EDB 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9936A83359A3A1A72E5EDB 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9936A83359A3A1A72E5EDB 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9936A83359A3A1A72E5EDB 480w" src="https://t1.daumcdn.net/cfile/tistory/9936A83359A3A1A72E" style="max-width:100%;height:auto" width="254" height="109" filename="11.1.1.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">뭔가 예상했던 것과 조금 다르지요?</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 그렇다면 이것은?</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">A c(A(2));</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 부분에서 "일반 생성자 호출!" 한번 만 출력되었습니다. 아마 정석대로 였다면,</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p style="margin-left: 2em;"><span style="font-size: 12pt;">A(2)</span></p></div><p><br></p><p><span style="font-size: 12pt;">를 만들면서 "일반 생성자 호출!" 이 한 번 출력되어야 되고, 생성된 임시 객체로 c 가 복사 생성되면서 "복사 생성자 호출!" 이 될 것이기 때문이지요. 그런데 왜 "일반 생성자 호출!" 한 번 밖에 출력되지 않았을 까요? 복사 생성자가 왜 불리지 않았을까요?</span></p><p><br></p><p><span style="font-size: 12pt;">사실 생각해보면 굳이 임시 객체를 한 번 만들고, 이를 복사 생성할 필요가 없습니다. 어차피 A(2) 로 똑같이 c 를 만들거면, 차라리 c 자체를 A(2) 로 만들어진 객체로 해버리는 것이랑 똑같기 때문이지요.</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_5_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_5_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_5" name="aswift_5" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">따라서 똑똑한 컴파일러는 복사 생성을 굳이 수행하지 않고, 만들어진 임시로 만들어진 A(2) 자체를 c 로 만들어버립니다. 이렇게, 컴파일러 자체에서 복사를 생략해 버리는 작업을 복사 생략(copy elision) 이라고 합니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">컴파일러가 복사 생략을 하는 경우는 (함수의 인자가 아닌) 함수 내부에서 생성된 객체를 그래도 리턴할 때, 수행할 수 있습니다. 물론 C++ 표준을 읽어보면 반드시 복사 생략을 해라 라는 식이 아니라, '복사 생략을 할 수 도 있다' 라는 뜻으로 써 있습니다. 즉, 경우에 따라서는 복사 생략을 해도 되는 경우에, 복사 생략을 하지 않을 수도 있다는 뜻이지요.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이전에 만들어 놓았던 MyString 클래스를 다시 살펴보도록 해봅시다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class MyString</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">char *string_content; // 문자열 데이터를 가리키는 포인터</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int string_length; // 문자열 길이</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int memory_capacity; // 현재 할당된 용량</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 문자열로 부터 생성</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const char* str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 복사 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const MyString &amp;str);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void reserve(int size);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString operator+ (const MyString &amp;s);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int length() const;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void print();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void println();</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString()&nbsp;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = NULL;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString(const char* str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = strlen(str);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(const MyString &amp;str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "복사 생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str.string_content[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::~MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">delete[] string_content;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::reserve(int size)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (size &gt; memory_capacity) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">char *prev_string_content = string_content;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content = new char[size];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">memory_capacity = size;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">string_content[i] = prev_string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (prev_string_content != NULL)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">delete[] prev_string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString MyString::operator+ (const MyString &amp;s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.reserve(string_length + s.string_length);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[i] = string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; s.string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[string_length + i] = s.string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_length = string_length + s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return str;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int MyString::length() const</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return string_length;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::print()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; string_content[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::println()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str1("abc");</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str2("def");</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "-------------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str3 = str1 + str2;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str3.println();</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><br></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:328px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99E2F6505AB50C7A30ED98 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99E2F6505AB50C7A30ED98 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99E2F6505AB50C7A30ED98 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99E2F6505AB50C7A30ED98 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99E2F6505AB50C7A30ED98 480w" src="https://t1.daumcdn.net/cfile/tistory/99E2F6505AB50C7A30" style="max-width:100%;height:auto" width="328" height="172" filename="11.1.2.png" filemime="image/png"></span></p><p><br></p><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str3 = str1 + str2;</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 부분에서 두 개의 문자열을 더한 새로운 문자열로 str3 를 생성하고 있습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">MyString MyString::operator+ (const MyString &amp;s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.reserve(string_length + s.string_length);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[i] = string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; s.string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[string_length + i] = s.string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_length = string_length + s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return str;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 함수가 str1 + str2 를 실행 시에 호출되는데,&nbsp;먼저 빈 MyString 객체인 str 을 생성합니다. (생성자 호출 ! 출력됨) 그 후에, reserve 함수를 이용해서 공간을 할당하고, str1 과 str2 를 더한 문자열을 복사하게 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">이렇게 리턴된 str 은 str3 을 생성하는데 전달되어서, str3 의 복사 생성자가 호출 됩니다.&nbsp;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_6_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_6_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_6" name="aswift_6" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">하지만, 이미 예상했겠지만, 굳이 str3 의 복사 생성자를 또 호출할 필요가 없습니다. 왜냐하면, 어차피 똑같이 복사해서 생성할 것이면, 이미 생성된 (str1 + str2) 가 리턴한 객체를 str3 셈 치고 사용하면 되기 때문이지요. 이전의 예제에서는 컴파일러가 불필요한 복사 생성자 호출을 복사 생략을 통해 수행하지 않았지만, 이 예제의 경우, 컴파일러가 복사 생략 최적화를 수행하지 않았습니다.</span></p><p><br></p><p><span style="font-size: 12pt;">위 과정을 그림으로 간단히 살펴보면 아래와 같습니다.</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/996BBA465AB638B019?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F996BBA465AB638B019DAE7 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F996BBA465AB638B019DAE7 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F996BBA465AB638B019DAE7 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F996BBA465AB638B019DAE7 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F996BBA465AB638B019DAE7 480w" src="https://t1.daumcdn.net/cfile/tistory/996BBA465AB638B019" style="cursor: pointer;max-width:100%;height:auto" width="730" height="320" filename="11.1.3.png" filemime="image/png"></span></span></p><p><br></p><p><span style="font-size: 12pt;">만약에 str1 과 str2 의 크기가 엄청 컸다면 어떨까요? 쓸데 없는 복사를 두 번 하는데 상당한 자원이 소모될 것입니다.</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 이러한 문제를 C++ 에서는 어떠한 방식으로 해결하고 있을까요?</span></p><p><br></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><font color="#3058d2" face="Gulim"><span style="font-size: 13.3333px;"><b><span style="font-size: 12pt;">&nbsp;좌측값 (lvalue) 와&nbsp;우측값 (rvalue)</span></b></span></font></p></td><td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><p></p><p><br></p><p><span style="font-size: 12pt;">모든 C++ 표현식 (expression) 의 경우 두 가지 카테고리로 구분할 수 있습니다. 하나는 이 구문이 어떤 타입을 가지냐 이고, 다른 하나는 어떠한 종류의 '값' 을 가지냐 입니다. 값에 종류가 있어? 라고 생각 하실 수 있는데, 아래 예시를 살펴보도록 합시다.</span><br></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int a = 3;</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 표현식에서 먼저 'a' 를 살펴보도록 합시다. 우리는 a 가 메모리 상에서 존재하는 변수 임을 알고 있습니다. 즉 'a' 의 주소값을 &amp; 연산자를 통해 알아 낼 수 있다는 것입니다. 우리는 보통 이렇게 주소값을 취할 수 있는 값을 '좌측값 (lvalue)' 라고 부릅니다. 그리고 좌측값은&nbsp;어떠한 표현식의 왼쪽 오른쪽 모두에 올 수 있습니다 (왼쪽에만 와야 하는게 아닙니다).</span></p><p><br></p><p><span style="font-size: 12pt;">반면에 오른쪽에 있는 '3' 을 살펴보도록 합시다. 우리가 '3' 의 주소값을 취할 수 있나요? 아닙니다. '3' 은 왼쪽의 'a' 와는 다르게, 위 표현식을 연산할 때만 잠깐 존재할 뿐 위 식이 연산되고 나면 사라지는 값입니다. 즉, '3' 은 실체가 없는 값입니다. 이렇게, 주소값을 취할 수 없는 값을 '우측값 (rvalue)' 라고 부릅니다. 이름에도 알 수 있듯이, 우측값은 식의 오른쪽에만 항상 와야 합니다. 좌측값이 식의 왼쪽 오른쪽 모두 올 수 있는 </span><b><span style="font-size: 12pt;">반면, 우측값은 식의 오른쪽에만 존재해야 합니다</span></b><span style="font-size: 12pt;">.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int a; // a 는 좌측값</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int&amp; l_a = a; // l_a 는 좌측값 레퍼런스</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int&amp; r_b = 3; // 3 은 우측값. 따라서 오류</span></p></div><p><br></p><p><span style="font-size: 12pt;">여태까지 우리가 다루어왔던 레퍼런스는 '좌측값' 에만 레퍼런스를 가질 수 있습니다. 예를 들어서, a 의 경우 좌측값 이기 때문에, a 의 좌측값 레퍼런스인 l_a 를 만들 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">반면에 3 의 경우 우측값이기 때문에, 우측값의 레퍼런스인 r_b 를 만들 수 없습니다. 따라서 이 문장은 오류가 발생하게 됩니다.&nbsp;</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_7_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_7_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_7" name="aswift_7" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">이와 같이 &amp; 하나를 이용해서 정의하는&nbsp;레퍼런스를 '좌측값 레퍼런스&nbsp;(lvalue reference)'&nbsp;라고 부르고, 좌측값 레퍼런스 자체도 좌측값이 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그럼 다른 예제를 살펴보도록 합시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">int&amp; func1(int&amp; a)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return a;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int func2(int b)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return b;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int a = 3;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">func1(a) = 4;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; &amp;func1(a) &lt;&lt; endl;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int b = 2;</span></p><p><span style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; a = func2(b); // 가능</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">func2(b) = 5; // 오류 1</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; &amp;func2(b) &lt;&lt; endl; // 오류 2</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">컴파일 하였다면 위 오류 1, 2, 줄에서 각각 다음과 같은 오류를 볼 수 있습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(254, 137, 67); background-color: rgb(254, 222, 199); padding: 10px;"><p><span style="font-size: 12pt;">Error</span><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">C2106</span><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">'=': left operand must be l-value</span></p><p><span style="font-size: 12pt;">Error</span><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">C2102</span><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">'&amp;' requires l-value</span></p></div><p><br></p><p><span style="font-size: 12pt;">일단 func1 의 경우 좌측값 레퍼런스를 리턴합니다. 앞서, 좌측값 레퍼런스의 경우 좌측값에 해당하기 때문에,</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">func1(a) = 4;</span></p></div><p><br></p><p><span style="font-size: 12pt;">의 경우 'func(a) 가 리턴하는 레퍼런스의 값을 4' 로 해라 라는 의미로, 실제로 변수 a 의 값이 바뀌게 됩니다. 또한, func1(a) 가 좌측값 레퍼런스를 리턴하므로, 그 리턴값의 주소값 역시 취할 수 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">하지만 func2 를 살펴볼까요? func2 의 경우, 레퍼런스가 아닌, 일반적인 int 값을 리턴하고 있습니다. 이 때 리턴되는 값은&nbsp;</span></p><p><br></p><p></p></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">&nbsp; &nbsp; &nbsp; &nbsp; a = func2(b);</span></p></div><p><br></p><p><span style="font-size: 12pt;">이 문장이 실행 될 때 잠깐 존재할 뿐 그 문장 실행이 끝나면 사라지게 됩니다. 즉, 실체가 없는 값이라는 뜻이지요. 따라서 func2(b) 는 우측값이 됩니다. 따라서 위와 같이 우측값이 실제 표현식의 오른쪽에 오는 경우는 가능하지만,</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">func2(b) = 5;&nbsp;</span></p></div><p><br></p><p><span style="font-size: 12pt;">위 문장 처럼 우측값이 왼쪽의 오는 경우는 가능하지 않습니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; &amp;func2(b) &lt;&lt; endl; // 오류 2</span></p></div><div><br></div><div><span style="font-size: 12pt;">마찬가지로 우측값의 주소값을 취할 수 없기 때문에 위 문장은 허용되지 않습니다.&nbsp;</span><br><br></div><div><span style="font-size: 12pt;">그렇다면 앞선 예제에서</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str3 = str1 + str2;</span></div></div><div><br></div><div><span style="font-size: 12pt;">를 다시 살펴보도록 합시다. 위 문장은&nbsp;</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str3 (str1.operator+(str2));</span></div></div><div><br></div><div><span style="font-size: 12pt;">와 동일합니다. 그런데, operator+ 의 정의를 살펴보면,</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">MyString MyString::operator+ (const MyString &amp;s)</span><br></div></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">로 우측값을 리턴하고 있는데, 이 우측값이 어떻게 좌측값 레퍼런스를 인자로 받는,</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const MyString &amp;str);</span></div></div><div><br></div><div><span style="font-size: 12pt;">를 호출 시킬 수 있었을까요? 이는 &amp; 가 좌측값 레퍼런스를 의미하지만, 예외적으로</span></div><div><br></div><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><div><span style="font-size: 12pt;">const T &amp;</span></div></div><div><br></div><div><span style="font-size: 12pt;">의 타입의 한해서만, 우측값도 레퍼런스로 받을 수 있습니다. 그 이유는 const 레퍼런스 이기 때문에 임시로 존재하는 객체의 값을 참조만 할 뿐 이를 변경할 수 없기 때문입니다.&nbsp;</span></div><div><br></div><div><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;그렇다면 이동은 어떻게?</span><span style="font-size: 12pt;">&nbsp;</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="color: rgb(48, 88, 210); font-size: 12pt;">&nbsp;</span><br><span style="font-size: 12pt;">
</span></span></span></strong></font></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">그렇다면 앞서 MyString 에서 지적한 문제를 해결할 생성자의 경우 어떠한 방식으로 작동해야 할까요?</span></p><p><br></p><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:730px;;height:auto;max-width:100%"><span data-url="https://t1.daumcdn.net/cfile/tistory/99DC5E435AB639BF0D?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99DC5E435AB639BF0D7DD5 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99DC5E435AB639BF0D7DD5 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99DC5E435AB639BF0D7DD5 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99DC5E435AB639BF0D7DD5 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99DC5E435AB639BF0D7DD5 480w" src="https://t1.daumcdn.net/cfile/tistory/99DC5E435AB639BF0D" style="cursor: pointer;max-width:100%;height:auto" width="730" height="422" filename="11.1.4.png" filemime="image/png"></span></span></p><p><span style="font-size: 12pt;">위와 같이 간단합니다. str3 생성 시에 임시로 생성된 객체의 string_content 가리키는 문자열의 주소값을 str3 의 string_content 로 해주면 됩니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">문제는 이렇게 하게 되면, 임시 객체가 소멸 시에 string_content 를 메모리에서 해제하게 되는데, 그렇게 되면 str3 가 가리키고 있던 문자열이 메모리에서 소멸되게 됩니다. 따라서 이를 방지 하기 위해서는, 임시 생성된 객체의 string_content 를 NULL 로 바꿔주고, 소멸자에서 string_content 가 NULL 이면 소멸하지 않도록 해주면 됩니다. 매우 간단하지요?</span></p><div class="google-auto-placed ap_container" style="text-align: center; width: 100%; height: auto; clear: none;"><ins data-ad-format="auto" class="adsbygoogle adsbygoogle-noablate" data-ad-client="ca-pub-6608926154840997" data-adsbygoogle-status="done" style="display: block; margin: auto; background-color: transparent;"><ins id="aswift_8_expand" style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent;"><ins id="aswift_8_anchor" style="display: block; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 730px; background-color: transparent; overflow: hidden; opacity: 0;"><iframe width="730" height="183" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_8" name="aswift_8" style="left:0;position:absolute;top:0;width:730px;height:183px;"></iframe></ins></ins></ins></div><p><br></p><p><span style="font-size: 12pt;">하지만, 이 방법은 기존의 복사 생성자에서 사용할 수 없습니다. 왜냐하면 우리는 인자를&nbsp;const MyString&amp; 으로 받았기 때문에, 인자의 값을 변경할 수 없게 되지요. 즉 임시 객체의 string_content 값을 수정할 수 없기에 문제가 됩니다.</span></p><p><br></p><p><span style="font-size: 12pt;">이와 같은 문제가 발생한 이유는 const MyString&amp; 이 좌측값과 우측값 모두 받을 수 있다는 점에서 비롯되었습니다. 그렇다면, 좌측값 말고 우측값만 특이적으로 받을 수 있는 방법은 없을까요? 바로 C++ 11 부터 제공하는 우측값 레퍼런스를 이용하면 됩니다. (참고로 C++ 11 가 기본으로 설정되어 있지 않는 컴파일러는 사용 불가능 합니다. 비주얼 스튜디오 2017 버전의 경우 자동으로 on 되어 있으니 걱정하실 필요 없습니다. )</span><br></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><p><span style="COLOR: rgb(48,88,210); FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;우측값 레퍼런스</span></span></span><font color="#c8056a"><strong><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><br><span style="font-size: 12pt;">
</span></span></span></strong></font></p></td>
<td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">

</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">#include &lt;iostream&gt;</span></p><p><span style="font-size: 12pt;">using namespace std;</span></p><p><br></p><p><span style="font-size: 12pt;">class MyString</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">char *string_content; // 문자열 데이터를 가리키는 포인터</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int string_length; // 문자열 길이</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int memory_capacity; // 현재 할당된 용량</span></p><p><br></p><p><span style="font-size: 12pt;">public:</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 문자열로 부터 생성</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const char* str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 복사 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(const MyString &amp;str);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 이동 생성자</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString(MyString&amp;&amp; str);</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void reserve(int size);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString operator+ (const MyString &amp;s);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">~MyString();</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int length() const;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void print();</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">void println();</span></p><p><span style="font-size: 12pt;">};</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString()&nbsp;</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = 0;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = NULL;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">MyString::MyString(const char* str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = strlen(str);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(const MyString &amp;str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "복사 생성자 호출 ! " &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = new char[string_length];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content[i] = str.string_content[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::MyString(MyString&amp;&amp; str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동 생성자 호출 !" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = str.string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = str.memory_capacity;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 임시 객체 소멸 시에 메모리를 해제하지</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 못하게 한다.&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_content = nullptr;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString::~MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (string_content)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete[] string_content;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::reserve(int size)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (size &gt; memory_capacity) {</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">char *prev_string_content = string_content;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">string_content = new char[size];</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">memory_capacity = size;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">string_content[i] = prev_string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">if (prev_string_content != NULL)</span></p><p><span style="white-space: pre; font-size: 12pt;">			</span><span style="font-size: 12pt;">delete[] prev_string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">MyString MyString::operator+ (const MyString &amp;s)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.reserve(string_length + s.string_length);</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[i] = string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i &lt; s.string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">str.string_content[string_length + i] = s.string_content[i];</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_length = string_length + s.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return str;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">int MyString::length() const</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">return string_length;</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::print()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; string_content[i];</span></p><p><span style="font-size: 12pt;">}</span></p><p><span style="font-size: 12pt;">void MyString::println()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">for (int i = 0; i != string_length; i++)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">cout &lt;&lt; string_content[i];</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; endl;</span></p><p><span style="font-size: 12pt;">}</span></p><p><br></p><p><span style="font-size: 12pt;">int main()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str1("abc");</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str2("def");</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "-------------" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString str3 = str1 + str2;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str3.println();</span></p><p><span style="font-size: 12pt;">}</span></p></div><div><span style="font-size: 12pt;"><br></span></div><div><span style="font-size: 12pt;">성공적으로 컴파일 하였다면</span></div><div><br></div><div><p style="text-align: center; clear: none; float: none;"><span class="imageblock" style="display:inline-block;width:294px;;height:auto;max-width:100%"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F995166505AB63D112FF31F 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F995166505AB63D112FF31F 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F995166505AB63D112FF31F 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F995166505AB63D112FF31F 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F995166505AB63D112FF31F 480w" src="https://t1.daumcdn.net/cfile/tistory/995166505AB63D112F" style="max-width:100%;height:auto" width="294" height="162" filename="11.1.5.png" filemime="image/png"></span></p><p><br></p></div><p><span style="font-size: 12pt;">와 같이 나옵니다.</span></p><p><br></p><p><span style="font-size: 12pt;">먼저 우측값 레퍼런스를 사용한 이동 생성자의 정의 부분 부터 살펴봅시다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">MyString::MyString(MyString&amp;&amp; str)</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">cout &lt;&lt; "이동 생성자 호출 !" &lt;&lt; endl;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_length = str.string_length;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = str.string_content;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">memory_capacity = str.memory_capacity;</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 임시 객체 소멸 시에 메모리를 해제하지</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 못하게 한다.&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_content = nullptr;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">우측값의 레퍼런스를 정의하기 위해서는 좌측값과는 달리 &amp; 를 두 개 사용해서 정의해야 합니다. 즉, 위 생성자의 경우 MyString 타입의 우측값을 인자로 받고 있습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">그렇다면 한 가지 퀴즈! 과연 str 자체는&nbsp;우측값 일까요 좌측값 일까요? 당연히도 좌측값 입니다. 실체가 있기 때문이지요 (str 이라는 이름이 있잖아요). 다시 말해 str 은&nbsp;타입이 'MyString 의 우측값&nbsp;레퍼런스' 인 좌측값 이라 보면 됩니다. 따라서 표현식의 좌측에 올 수도 있습니다. (마지막 줄 처럼)</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">string_content = str.string_content;</span></p></div><div><br></div><p><span style="font-size: 12pt;">이제 위와 같이 우리가 바라던 대로 임시 객체의 string_content 가 가리키는 메모리를 새로 생성되는 객체의 메모리로 옮겨주기만 하면 됩니다. 기존의 복사 생성자의 경우 문자열 전체를 새로 복사해야 했지만, 이동 생성자의 경우 단순히 주소값 하나만 달랑 복사해주면 끝이기 때문에 매우 간단합니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 임시 객체 소멸 시에 메모리를 해제하지</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">// 못하게 한다.&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str.string_content = nullptr;</span></p></div><p><br></p><p><span style="font-size: 12pt;">한 가지 중요한 부분은 인자로 받은 임시 객체가 소멸되면서 자신이 가리키고 있던 문자열을 delete 하지 못하게 해야 합니다. 만약에 그 문자열을 지우게 된다면, 새롭게 생성된 문자열 str3 도 같은 메모리를 가리키고 있기 때문에 str3 의 문자열도 같이 사라지는 셈이 되기 때문입니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">따라서 str 의 string_content 를 nullptr 로 바꿔줍니다. 참고로 nullptr 역시 C++ 11 에 새로 추가된 키워드로, 기존의 NULL 대체합니다. C 언어에서의 NULL 은 단순히 #define 으로 정의되어 있는 상수값 0 인데, 이 때문에 이 NULL 이 값 0 을 의미하는 것인지, 아니면 포인터 주소값 0 을 의미하는 것인지 구분할 수 가 없었습니다. 하지만 nullptr 로 '포인터 주소값 0' 을 정확히 명시해 준다면 미연에 발생할 실수를 줄여 줄 수 있게 됩니다.&nbsp;</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="font-size: 12pt;">MyString::~MyString()</span></p><p><span style="font-size: 12pt;">{</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">if (string_content)</span></p><p><span style="white-space: pre; font-size: 12pt;">		</span><span style="font-size: 12pt;">delete[] string_content;</span></p><p><span style="font-size: 12pt;">}</span></p></div><p><br></p><p><span style="font-size: 12pt;">그리고 물론 소멸자 역시 바꿔줘야만 합니다. string_content 가 nullptr 가 아닐 때 에만 delete 를 하도록 말이죠.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">일반적으로 우측값 레퍼런스는 아래와 같은 방식으로 사용할 수 있습니다.</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int a;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int&amp; l_a = a;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int&amp; ll_a = 3; // 불가능</span></p><p><br></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int&amp;&amp; r_b = 3;&nbsp;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">int&amp;&amp; rr_b = a; // 불가능</span></p></div><p><br></p><p><span style="font-size: 12pt;">일단 우측값 레퍼런스의 경우 반드시 우측값의 레퍼런스만 가능합니다. 따라서, r_b 의 경우 우측값 '3' 의 레퍼런스가 될 수 있겠지만, rr_b 의 경우 a 가 좌측값이기 때문에 컴파일 되지 않습니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">우측값 레퍼런스의 재미있는 특징으로 레퍼런스 하는 임시 객체가 소멸되지 않도록 붙들고 있는다는 점입니다. 예를 들어서,</span></p><p><br></p><div class="txc-textbox" style="border-style: solid; border-width: 1px; border-color: rgb(121, 165, 228); background-color: rgb(219, 232, 251); padding: 10px;"><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">MyString&amp;&amp; str3 = str1 + str2;</span></p><p><span style="white-space: pre; font-size: 12pt;">	</span><span style="font-size: 12pt;">str3.println();</span></p></div><p><br></p><p><span style="font-size: 12pt;">의 경우 str3 이 str1 + str2 에서 리턴되는 임시 객체의 레퍼런스가 되면서 그 임시 객체가 소멸되지 않도록 합니다. 실제로, 아래 println 함수에서 더해진 문자열이 잘 보여집니다.&nbsp;</span></p><p><br></p><p><span style="font-size: 12pt;">자 이것으로 이번 강좌는 여기서 마치도록 하겠습니다. 다음 강좌에서는 C++ 11 에 우측값 레퍼런스와 함께 새로 추가된 move 에 대해 살펴보도록 하겠습니다.&nbsp;</span></p><p><br></p><p></p><table style="WIDTH: 634px; BORDER-COLLAPSE: collapse; HEIGHT: 31px" cellspacing="1" cellpadding="1" bgcolor="#ffffff">
<tbody>
<tr>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" bgcolor="#3058d2" width="1%"><span style="FONT-SIZE: 10pt"><span style="FONT-FAMILY: Gulim"><span style="font-weight: bold; font-size: 12pt;">&nbsp;</span></span></span></td>
<td style="BORDER-BOTTOM: rgb(48,88,210) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="99%"><font color="#3058d2" face="Gulim"><span style="font-size: 13.3333px;"><b><span style="font-size: 12pt;">&nbsp;생각 해보기</span></b></span></font></td><td style="BORDER-BOTTOM: rgb(255,70,197) 1px solid; BORDER-LEFT: rgb(48,88,210) 0px solid; BORDER-TOP: rgb(48,88,210) 0px solid; BORDER-RIGHT: rgb(48,88,210) 0px solid" width="100%"><span style="FONT-SIZE: 10pt"><span style="font-family: Gulim; font-size: 12pt;">&nbsp;</span></span></td></tr></tbody></table><br><span style="font-size: 12pt;">
</span><span style="font-size: 12pt;">
</span><p></p><div></div><span style="font-size: 12pt;">
</span><div></div><p><span style="font-size: 12pt;">1. 사실 C++ 에서 값의 종류로 좌측값 우측값 만이 있는게 아니라 조금 더 세부적으로 나눠어집니다. 이에 대해 자세히 알아보고 싶으신 분들은 </span><a href="https://medium.com/@barryrevzin/value-categories-in-c-17-f56ae54bccbe" target="_blank" class="tx-link"><span style="font-size: 12pt;">여기를 참조해주세요</span></a><span style="font-size: 12pt;"> (난이도 : 상)</span><br><br></p><p></p><div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox">
<span style="font-size:12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 <span style="font-weight: bold;">꼭 댓글을 남겨주시기 바랍니다</span>. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span><span style="font-size: 11pt;"></span><br>
<br>
<span style="font-size: 12pt;">현재 여러분이 보신 강좌는<i>&lt;&lt;</i></span><span style="font-size: 16px;"><i>씹어먹는 C++ - &lt;11 - 1. 우측값 레퍼런스와 이동 생성자&gt;</i></span><span style="font-size: 12pt;"><i>&gt;&gt;</i> 입니다. 이번 강좌의 </span><span style="font-size: 12pt; font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span><span style="font-size: 12pt;">까지 다음 강좌로 넘어가지 말아주세요 </span><br>
<br>
<div style="text-align: right;">
<span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/135">다음 강좌 보러가기</a><br>
</span>
</div>
</div>
<br><p></p><p></p><p><br></p></div><p><br></p><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_227" data-uoc-sc="" data-uoc-pcurl="http://itguru.tistory.com/227" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_227"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text">공감</span><span class="txt_like uoc-count" style="display: none;"></span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile23.uf.tistory.com/image/9936A83359A3A1A72E5EDB" data-title="씹어먹는 C++ - <11 - 1. 우측값 레퍼런스와 이동 생성자>" data-description="이번 강좌에서는 복사 생략 (Copy elision) 우측값 레퍼런스 (rvalue reference) 이동 생성자 (move constructor)  안녕하세요 여러분! 지난번 STL 강좌는 어떠셨나요? 이번 강좌에서는 C++ 11 에서 추가된 우측값.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/227" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="227"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/227&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C++">C++</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/228?category=361027">씹어먹는 C++ - &lt;11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)&gt;</a>&nbsp;&nbsp;<span>(7)</span>
</th>
<td>
2018.03.27</td>
</tr>
<tr>
<th>
<a href="/227?category=361027" class="current">씹어먹는 C++ - &lt;11 - 1. 우측값 레퍼런스와 이동 생성자&gt;</a>&nbsp;&nbsp;<span>(0)</span>
</th>
<td>
2018.03.24</td>
</tr>
<tr>
<th>
<a href="/225?category=361027">씹어먹는 C++ - &lt;10 - 3. C++ STL - 알고리즘(algorithm)&gt;</a>&nbsp;&nbsp;<span>(16)</span>
</th>
<td>
2017.07.09</td>
</tr>
<tr>
<th>
<a href="/224?category=361027">씹어먹는 C++ - &lt;10 - 2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map&gt;</a>&nbsp;&nbsp;<span>(5)</span>
</th>
<td>
2017.07.08</td>
</tr>
<tr>
<th>
<a href="/223?category=361027">씹어먹는 C++ - &lt;10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)&gt;</a>&nbsp;&nbsp;<span>(2)</span>
</th>
<td>
2017.07.04</td>
</tr>
<tr>
<th>
<a href="/222?category=361027">씹어먹는 C++ - &lt;9 - 3. 템플릿 메타 프로그래밍 2&gt;</a>&nbsp;&nbsp;<span>(8)</span>
</th>
<td>
2017.07.02</td>
</tr>
</tbody></table></div></div>
<br> <br>


					