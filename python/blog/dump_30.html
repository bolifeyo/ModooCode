
<center>								
<table border="0">
<tbody><tr>
<td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_1_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_1_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
	
</td><td width="336" height="280" align="center">

<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- itguru Top -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6608926154840997" data-ad-slot="9540252860" data-adsbygoogle-status="done"><ins id="aswift_2_expand" style="display:inline-table;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><ins id="aswift_2_anchor" style="display:block;border:none;height:280px;margin:0;padding:0;position:relative;visibility:visible;width:336px;background-color:transparent;"><iframe width="336" height="280" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_2" name="aswift_2" style="left:0;position:absolute;top:0;width:336px;height:280px;"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</td>
</tr>
</tbody></table>
</center>
<br><br>
<span style="font-size: 8pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;"><span style="font-size: 9pt;">이번 강좌에서는</span><br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 9pt;">재귀 함수에 대한 이해</span></li>
<li><span style="font-size: 9pt;">여러가지 주요 알고리즘. (버블 정렬, 유클리드 호제법, 에라토스테네스의 체) </span><br>
</li>
</ul>
<div>
<hr style="border-color: black; border-width: 1px 0px 0px; height: 1px; display: block;"></div>
<div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/150EAA134B362F6B44?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F150EAA134B362F6B447187 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F150EAA134B362F6B447187 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F150EAA134B362F6B447187 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F150EAA134B362F6B447187 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F150EAA134B362F6B447187 480w" src="https://t1.daumcdn.net/cfile/tistory/150EAA134B362F6B44" style="cursor: pointer;max-width:100%;height:auto" width="700" height="525" alt="" filename="C-gods-programming-language.jpg" filemime="image/jpeg"></span></div><br>
&nbsp; 안녕하세요 여러분. <a title="[http://itguru.tistory.com/28]로 이동합니다." target="_blank" href="http://itguru.tistory.com/28">이전 강좌의 예제</a>가 중요한 만큼, 예제에 좀더 쉽게 접근할 수 있는 아이디어에 관해서 짧은 힌트 형식으로 강좌를 작성하도록 하겠습니다. 물론, 언제까지나 힌트일 뿐 완전한 코드는 여러분이 완성시켜야 합니다.</span></span><br>
<br>
<span style="font-size: 9pt;"><span style="font-size: 8pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;"><div style="border: 1px solid rgb(159, 211, 49); padding: 10px; background-color: rgb(231, 253, 181);" class="txc-textbox">
<span style="font-weight: bold;">생각해볼 문제 1)</span> 사용자로 부터 5 명의 학생의 수학, 국어, 영어 점수를 입력 받아서
평균이 가장 높은 사람 부터 평균이 가장 낮은 사람까지 정렬되어 출력하도록 하세요. 특히, 평균을 기준으로 평균 이상인 사람
옆에는 '합격', 아닌 사람은 '불합격' 을 출력하게 해보세요. </div>
</span><br>
&nbsp;&nbsp;
<span style="font-size: 12pt;">일단, 여러분이 직면했을 가장 큰 문제는 '어떻게 정렬하는 프로그램' 을 만드느냐 이였겠습니다. 정렬을 하는 방법 (보통 알고리즘 이라 표현합니다) 에는 여러가지가 있습니다. 가장 직관적으로 이해하기 쉬운 것은 <span style="font-weight: bold;">버블 정렬</span>(Bubble sorting) 이라 불리는 것인데 컴퓨터가 다음과 같은 규칙을 통해 작업을 합니다. </span><br>
<br>
<span style="font-size: 12pt;">
예를 들어 5, 1, 4, 2, 8 을 정렬한다고 합시다</span><span style="font-size: 12pt;"><img class="txc-footnote" border="0" src="http://cfs.tistory.com/static/admin/editor/footnotes.gif" ld="아래 내용은 타이핑 하기 귀찮았던 관계로 Wikipedia 의 내용을 따왔습니다. "></span><span style="font-size: 12pt;">. (작은 순으로) </span><br>
<br>
</span></span></span></span><span style="font-size: 12pt;">( </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">1</span></b><span style="font-size: 12pt;"> 4 2 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( </span><b><span style="font-size: 12pt;">1</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> 4 2 8 )<br>
&nbsp;버블 정렬 알고리즘은 처음 두 개의 원소를 비교해 왼쪽이 크면 자리를 바꿉니다. 이 경우, 5 가 1 보다 더 크기 때문에 1 과 5 의 자리를 바꾸었습니다. </span><br>
<span style="font-size: 12pt;">
( 1 </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> 2 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> 2 8 )<br>
&nbsp;그 다음 두 원소를 비교합니다. 이번에도 5 가 더 크므로 4 와 자리를 바꿉니다. </span><br>
<span style="font-size: 12pt;">
( 1 4 </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">2</span></b><span style="font-size: 12pt;"> 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 4 </span><b><span style="font-size: 12pt;">2</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> 8 )<br>
&nbsp;그 다음 두 원소 5,2 를 비교합니다. 이번에도 5 가 더 크므로 자리를 바꿉니다. </span><br>
<span style="font-size: 12pt;">
( 1 4 2 </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">8</span></b><span style="font-size: 12pt;"> ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 4 2 </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">8</span></b><span style="font-size: 12pt;"> )<br>
&nbsp;그 다음 두 원소 5,8 를 비교합니다. 이번에는 오른쪽이 더 크므로 자리를 안바꿔도 됩니다. 끝 원소 까지 비교하였다면, 가장 큰 원소가 가장 오른쪽에 위치하게 됩니다. (왜 그런지는 잘 알겠지요?) </span><br>
<b><br>
</b><span style="font-size: 12pt;">
( </span><b><span style="font-size: 12pt;">1</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> 2 5 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( </span><b><span style="font-size: 12pt;">1</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> 2 5 8 ), 이제 다시 처음부터 두 원소를 골라 비교합니다. </span><br>
<span style="font-size: 12pt;">
( 1 </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">2</span></b><span style="font-size: 12pt;"> 5 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 </span><b><span style="font-size: 12pt;">2</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> 5 8 ), 위와 같은 작업들을 쭉 시행합니다. </span><br>
<span style="font-size: 12pt;">
( 1 2 </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 2 </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> 8 )</span><br>
<span style="font-size: 12pt;">
( 1 2 4 </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">8</span></b><span style="font-size: 12pt;"> ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 2 4 </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">8</span></b><span style="font-size: 12pt;"> ), 마지막까지 비교하였다면 다시 처음으로 갑니다. </span><br>
<br>
<span style="font-size: 12pt;">
그렇다면 이를 언제까지 반복해야 할까요? 더이상 자리가 바뀌는 원소들이 없을 때 까지 해야 하겠죠? </span><br>
<br>
<span style="font-size: 12pt;">
( </span><b><span style="font-size: 12pt;">1</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">2</span></b><span style="font-size: 12pt;"> 4 5 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( </span><b><span style="font-size: 12pt;">1</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">2</span></b><span style="font-size: 12pt;"> 4 5 8 )</span><br>
<span style="font-size: 12pt;">
( 1 </span><b><span style="font-size: 12pt;">2</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> 5 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 </span><b><span style="font-size: 12pt;">2</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> 5 8 )</span><br>
<span style="font-size: 12pt;">
( 1 2 </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> 8 ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 2 </span><b><span style="font-size: 12pt;">4</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> 8 )</span><br>
<span style="font-size: 12pt;">
( 1 2 4 </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">8</span></b><span style="font-size: 12pt;"> ) </span><span style="font-size: 12pt;"><img class="tex" alt="\to" src="http://upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png"></span><span style="font-size: 12pt;"> ( 1 2 4 </span><b><span style="font-size: 12pt;">5</span></b><span style="font-size: 12pt;"> </span><b><span style="font-size: 12pt;">8</span></b><span style="font-size: 12pt;"> )</span><br>
<br>
<span style="font-size: 12pt;">
위 작업을 완료하였다면, 컴퓨터는 더이상 자리가 바뀌는 원소들이 없다는 것을 알아채고 정렬을 그만하게 됩니다. 음, 역시 정확하게 1,2,4,5,8 로 정렬이 되었군요. </span><br>
<br>
<span style="font-size: 12pt;">
일단, 위 버블 정렬 알고리즘을 C 언어에서 구현하기 위해서 저는 여러분들이 다음과 같은 함수를 만들어주기를 원합니다. </span><br>
<br>
<span style="font-size: 12pt;">
</span><div style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);" class="txc-textbox">
<span style="font-size: 12pt;">Bubble_sort(int* arr, int num_elements), swap(int *pele)</span></div>
<br>
<span style="font-size: 12pt;">
Bubble_sort 함수는 말그대로 정렬을 하는 함수 입니다. 이 때, num_elements 로 arr 이 가리키는 배열의 원소 개수를 알아야 하겠죠? 그리고 swap 함수는 pele 가 가리키는 원소와 그 다음 원소를 서로 뒤바꿔주는 함수 입니다. 따라서 Bubble_sort 함수가 pele 함수를 호출해야 되겠죠? </span><br>
<br>
<span style="font-size: 12pt;">
사실 버블 정렬은 매우 비효율적인 정렬 알고리즘 입니다. 하지만 구현하가 매우 단순하여 정렬해야 될 것이 작은 경우에는 이를 자주 이용하게 되지요. 정렬 알고리즘에 대해 궁금하신 분들은 </span><a title="[http://en.wikipedia.org/wiki/Sorting_algorithm]로 이동합니다." target="_blank" href="http://en.wikipedia.org/wiki/Sorting_algorithm"><span style="font-size: 12pt;">여기를 클릭</span></a><span style="font-size: 12pt;">해서 정렬 알고리즘의 세상에 빠져보세요. </span><br>
<br>
<div style="border: 1px solid rgb(159, 211, 49); padding: 10px; background-color: rgb(231, 253, 181);" class="txc-textbox">
<span style="font-size: 8pt;"><span style="font-size: 9pt;"><span style="font-size: 8pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;"><span style="font-weight: bold;">생각해볼 문제 2)</span> </span></span></span></span></span><span style="font-size: 12pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;">유클리도 호제법</span></span><span style="font-size: 9pt;"><span style="font-size: 12pt;">을 이용해서</span></span></span><span style="font-size: 12pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;"> N 개의 수들의 최대공약수를 구하는 함수를 만들어보세요.</span></span></span><span style="font-size: 12pt;"><span style="font-size: 9pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;"> 유클리드 호제법이 무엇인지 모르신다면, 인터넷 검색을 활용하는 </span></span><span style="font-size: 12pt;">것을 추천합니다. (댓글을 달아도 돼요)</span></span></span></div>
<br>
<span style="font-size: 12pt;">
유클리드 호제법은 어떠한 두 수의 최대공약수를 계산하는데 쓰이는 방법입니다. 방법 자체는 간단합니다. </span><br>
<br>
<ol style="list-style-type: decimal;">
<li><span style="font-size: 12pt;">두 수를 m 과 n 이라 하자. (m &gt; n) </span><br>
</li>
<li><span style="font-size: 12pt;">m 을 n 으로 나눈 나머지를 계산한다. (m%n)</span><br>
</li>
<li><span style="font-size: 12pt;">m%n 이 0 이라면 n 값이 맨 처음 두 수의 최대공약수이다. (종료)</span></li>
<li><span style="font-size: 12pt;">m%n 이 0 이 아니였다면, m%n 과 n 중 큰 것을 m, 작은 것을 n 이라 한 후 ① 로 돌아간다. </span><br>
</li>
</ol>
<br>
<br>
<span style="font-size: 12pt;">
&nbsp;예를 들어서 63 와 35 의 최대공약수를 구한다고 합시다. 그렇다면 유클리드 호제법을 이용하면 아래와 같은 과정을 거칩니다.</span><br>
<br>
<ol style="list-style-type: decimal;">
<li><span style="font-size: 12pt;">m = 63, n = 35</span></li>
<li><span style="font-size: 12pt;">63%35 = 28</span></li>
<li><span style="font-size: 12pt;">28 이 0 이 아니므로, 28 과 35 를 비교한느데 35 가 크므로 m = 35, n = 28</span></li>
<li><span style="font-size: 12pt;">m = 35, n = 28</span></li>
<li><span style="font-size: 12pt;">35%28 = 7</span></li>
<li><span style="font-size: 12pt;">7 이 0 이 아니므로, 7 과 28 을 비교, 28 이 크므로 m = 28, n = 7</span></li>
<li><span style="font-size: 12pt;">m = 28, n = 7</span></li>
<li><span style="font-size: 12pt;">28%7 = 0</span></li>
<li><span style="font-size: 12pt;">0 이므로, n 값 ( 7 ) 이 맨 처음 두 수의 최대공약수. 즉, 63 과 35 의 최대공약수는 7 이다. <br>
</span></li>
</ol>
<span style="font-size: 12pt;">
<br>
&nbsp; 사실, 왜 위 과정을 거치면 두 수의 최대공약수가 나오는지에 대한 증명은 간단합니다. 수학적 지식이 없다면 이해가 안갈 수 도 있지만, </span><br>
<br>
<div style="text-align: center;">
<span style="font-size: 12pt;"><img style="clear: none; float: none;" id="equationview" name="equationview" onload="processEquationChange()" title="This is the rendered form of the equation. You can not edit this directly. Right click will give you the option to save the image, and in most browsers you can drag the image onto your desktop or another program." src="http://latex.codecogs.com/gif.latex?m%20=%20qn%20+%20r,%20%280%20%5Cleq%20r%20%3C%20q%29%20%7E%7Egcd%28m,n%29%20=%20gcd%28qn%20+%20r,%20n%29%20=%20gcd%28r,n%29"></span><br>
</div>
<br>
<span style="font-size: 12pt;">
&nbsp; 때문에 그렇습니다. 유클리드 호제법은 두 개의 수의 최대공약수를 찾는데에만 사용하였지만 이를 어떻게 N 개의 수의 공통된 최대공약수를 찾는데 응용할 수 있을까요? 답은 간단합니다. 처음 두 수의 최대 공약수를 구합시다. 그리고, 그 다음수와 구한 최대공약수의 최대 공약수를 계산합니다. 그리고 이를 쭈우욱 반복합니다. </span><br>
<br>
<span style="font-size: 12pt;">
&nbsp; 예를 들어서 18, 24, 40, 60 의 최대공약수를 구한다고 해봅시다. 18 과 24 의 최대공약수는 6 입니다. 그러면 이제 6 과 40 의 최대공약수를 계산합니다. 이는 2 입니다. 그러면 이제 2 와 60 의 최대공약수를 계산합니다. 이는 2 입니다. 따라서, 이 4 개의 수의 공통된 최대공약수는 2 가 됩니다. </span><br>
<br>
<span style="font-size: 12pt;">
&nbsp; 여기에도 수학적 원리가 있지만 간단하기 때문에 넘어가도록 하겠습니다. 여러분이 생각해보세요~</span><br>
<br>
<span style="font-size: 8pt;"><span style="font-size: 9pt;"><span style="font-size: 8pt;"><span style="font-size: 9pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;"></span></span></span></span></span></span><div style="border: 1px solid rgb(159, 211, 49); padding: 10px; background-color: rgb(231, 253, 181);" class="txc-textbox">
<span style="font-size: 8pt;"><span style="font-size: 9pt;"><span style="font-size: 8pt;"><span style="font-size: 9pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;"><span style="font-weight: bold;">생각해볼 문제 3)</span> </span></span></span></span></span></span><span style="font-size: 12pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;">자기 자신을 호출하는 함수를 이용해서 1 부터 특정한 수까지의 곱을 구하는 프로그램을 만들어보세요.</span></span></span></div>
<br>
<span style="font-size: 12pt;">
&nbsp; 여러분은 '자기 자신을 호출한다' 에 대해서 많은 고민을 많이 하셨을 것입니다. 일단, 아래의 코드를 직접 컴파일 후 실행해보세요</span><br>
<br>
<span style="font-size: 12pt;"></span><div style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);" class="txc-textbox">
<span style="font-size: 12pt;">#include &lt;stdio.h&gt;</span><br>
<span style="font-size: 12pt;">
int recursive (int n)</span><br>
<span style="font-size: 12pt;">
{</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; printf("난 인자가 %d 에요! \n");</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; if (n &lt;= 0)</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return 0;</span><br>
<br>
<span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; recursive(0);</span><br>
<span style="font-size: 12pt;">
}</span><br>
<span style="font-size: 12pt;">
int main()</span><br>
<span style="font-size: 12pt;">
{</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; recursive(3);</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; return 0;</span><br>
<span style="font-size: 12pt;">
}</span></div>
<br>
<span style="font-size: 12pt;">&nbsp; 성공적으로 컴파일 했다면</span><br>
<br>
<span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/1903D2284B36263D76?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1903D2284B36263D76E85B 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1903D2284B36263D76E85B 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1903D2284B36263D76E85B 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1903D2284B36263D76E85B 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1903D2284B36263D76E85B 480w" src="https://t1.daumcdn.net/cfile/tistory/1903D2284B36263D76" style="cursor: pointer;max-width:100%;height:auto" width="678" height="442" alt="" filename="13.4.1.png" filemime="image/png"></span></div></span><br>
<span style="font-size: 12pt;">
&nbsp; 흠. 어느 정도 예측 가능했던 결과입니다. 그렇다면, 아래의 코드는 어떨까요?</span><br>
<br>
<span style="font-size: 12pt;"></span><div style="border: 1px solid rgb(121, 165, 228); padding: 10px; background-color: rgb(219, 232, 251);" class="txc-textbox">
<span style="font-size: 12pt;">#include &lt;stdio.h&gt;</span><br>
<span style="font-size: 12pt;">
int recursive (int n)</span><br>
<span style="font-size: 12pt;">
{</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; printf("난 인자가 %d 에요! \n", n);</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; if (n &lt;= 0)</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return 0;</span><br>
<br>
<span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; recursive(n - 1);</span><br>
<br>
<span style="font-size: 12pt;">&nbsp;&nbsp;&nbsp; return 0;</span><br>
<span style="font-size: 12pt;">
}</span><br>
<span style="font-size: 12pt;">
int main()</span><br>
<span style="font-size: 12pt;">
{</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; recursive(3);</span><br>
<span style="font-size: 12pt;">
&nbsp;&nbsp;&nbsp; return 0;</span><br>
<span style="font-size: 12pt;">
}</span><br>
</div>
<br>
<span style="font-size: 12pt;">&nbsp; 성공적으로 컴파일 했다면</span><br>
<br>
<span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/176283254B362678AE?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F176283254B362678AE89BF 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F176283254B362678AE89BF 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F176283254B362678AE89BF 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F176283254B362678AE89BF 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F176283254B362678AE89BF 480w" src="https://t1.daumcdn.net/cfile/tistory/176283254B362678AE" style="cursor: pointer;max-width:100%;height:auto" width="678" height="442" alt="" filename="13.4.2.png" filemime="image/png"></span></div></span><br>
<span style="font-size: 12pt;">
일단, 컴퓨터 상에서 위 코드는 아래의 순서로 실행됩니다.</span><br>
<br>
<ol style="list-style-type: decimal;">
<li><span style="font-size: 12pt;">main 함수에서 recursive(3) 을 호출함</span></li>
<li><span style="font-size: 12pt;">recursive 에서 n = 3, '난 인자가 3 이에요' 를 출력</span></li>
<li><span style="font-size: 12pt;">n 이 0 이하가 아니므로 넘어감</span></li>
<li><span style="font-size: 12pt;">recursive(n-1), 즉 recursive(2) 를 호출</span></li>
<li><span style="font-size: 12pt;">recursive 에서 n = 2, '난 ~ 2 ~ ' 를 출력 (~ 는 생략)</span></li>
<li><span style="font-size: 12pt;">n 이 0 이하가 아니므로 넘어감</span></li>
<li><span style="font-size: 12pt;">recursive(n-1), 즉 recursive(1) 을 호출</span></li>
<li><span style="font-size: 12pt;">recursive 에서 n = 1, '~ 1 ~ ' 를 출력</span></li>
<li><span style="font-size: 12pt;">n 이 0 이하가 아니므로 넘어감</span></li>
<li><span style="font-size: 12pt;">recursive(n-1), 즉 recursive(0) 을 호출</span></li>
<li><span style="font-size: 12pt;">recursisve 에서 n = 0, '~0~' 을 출력</span></li>
<li><span style="font-size: 12pt;">n 이 0 이하이므로 return 0;</span></li>
<li><span style="font-size: 12pt;">n = 1 이였던 recursive 에서 return 0;</span></li>
<li><span style="font-size: 12pt;">n = 2 이였던 recursive 에서 return 0;</span></li>
<li><span style="font-size: 12pt;">n </span><span style="font-size: 9pt;"><span style="font-size: 12pt;">= 3 이였던 recursive 에서 return 0; </span></span><br>
</li>
<li><span style="font-size: 9pt;"><span style="font-size: 12pt;">main 함수로 돌아감. </span></span><br>
</li>
</ol>
<span style="font-size: 9pt;"><span style="font-size: 12pt;"><br>
&nbsp; 사실, 위 작업이 이해가 잘 안되는 수도 있습니다만.. 나중에 변수의 정의 범위에 대해 배우게 된다면 좀더 쉽게 이해할 수 있으실 것입니다. 아무튼 위 사실을 활용해서 1 부터 n 까지 곱하는 재귀 함수를 만들어보세요 (위와 같이 자기 자신을 호출하는 함수를 재귀함수, 즉 recursive function 이라 합니다.) </span></span><br>
<br>
<span style="font-size: 12pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;">생각해볼 문제4) 계산기를 만들어보세요. 사용자가 1 을 누르면 +, 2 를 누르면
- 와 같은 방식으로 해서 만들면 됩니다. 물론 이전의 계산 결과는 계속 누적되어야 하고, 지우기 기능도 있어야 합니다. (물론
하나의 함수에 구현하는 것이 아니라 여러개의 함수로 분할해서 만들어야겠죠?)</span></span></span><br>
<br>
<span style="font-size: 12pt;">이 문제는 그다지 어려운 아이디어 같은 것이 필요한 것이 아니므로 생략하도록 하겠습니다. 사실, 난이도는 중하 정도 됩니다. </span><br>
<span style="font-size: 12pt;"></span><br>
<div style="border: 1px solid rgb(159, 211, 49); padding: 10px; background-color: rgb(231, 253, 181);" class="txc-textbox">
<span style="font-size: 12pt;"><span style="font-size: 12pt;">
<span style="font-weight: bold;">생각해볼 문제 5) </span>N 진법에서 M 진법으로 변환하는 프로그램을 만들어보세요. (난이도 : 中)</span></span></div>
<br>
<span style="font-size: 12pt;">&nbsp; 사실 이 문제는 잘못낸 문제입니다. 물론 아이디어는 충분히 구현할 수 있지만 여러분은 아직 '문자열'에 대한 개념이 없기 때문에 정확하게 구현할 수 는 없지만 생각 정도는 할 수 있습니다. 일단 위 프로그램을 어떻게 만들 것인지에 대해 생각해 놓은 것을 보세요. 나중에 필요한 개념을 다 배우고 나면 하실 수 있을 것입니다. (참고적으로 문제에 조건 하나가 빠졌는데 N,M 은 모두 36 이하 입니다. 왜냐하면 숫자를 이용시 0,1,...,9,A,B,.. 로 사용하는데 알파벳이 26 개이므로 총 36 진수 까지 나타낼 수 있거든요) </span><br>
<br>
<ul style="list-style-type: square;">
<li><span style="font-size: 12pt;">사용자로 부터 무슨 진법에서 무슨 진법으로 변환할 지 입력받습니다. (N,M 입력)</span></li>
<li><span style="font-size: 12pt;">N 진법의 수를 입력받습니다.</span></li>
<li><span style="font-size: 12pt;">그 수를 각 자리로 분해해 int 배열에 값을 넣습니다. 이 때, 값은 십진수로 넣습니다. 예를 들어서 16 진법으로 7AE 를 입력받았다면 digit[0] = 14, digit[1] = 10, digit[2] = 7 로 넣으면 됩니다. 참고로, 올바르지 않은 숫자가 사용되면 종료합니다. (예를 들어서 2 진법인데 3 이란 숫자를 사용함) </span><br>
</li>
<li><span style="font-size: 9pt;"><span style="font-size: 12pt;">이 수를 십진수로 변환합니다. (NtoDec 함수 제작 요망)</span></span><br>
</li>
<li><span style="font-size: 9pt;"><span style="font-size: 12pt;">이 십진수를 다시 M 진법의 수로 변환합니다. (DectoM 함수 제작 요망) </span></span><br>
</li>
</ul>
<span style="font-size: 9pt;"><span style="font-size: 12pt;"><br>
물론, 이 문제는 꼭 안푸셔도 됩니다. 나중에 개념을 좀더 배우다 보면 풀 수 있는 스킬들을 습득하실 것입니다. </span></span><br>
<span style="font-size: 12pt;"><br>
<span style="font-size: 9pt;"><span style="font-size: 12pt;">
</span></span></span><div style="border: 1px solid rgb(159, 211, 49); padding: 10px; background-color: rgb(231, 253, 181);" class="txc-textbox">
<span style="font-size: 12pt;"><span style="font-size: 9pt;"><span style="font-size: 12pt;"><span style="font-weight: bold;">생각해볼 문제 6) </span>에라토스테네스의 체를 이용해서 1 부터 N 까지의 소수를 구하는 프로그램을 만들어보세요. (난이도 : 中)</span></span></span><br>
</div>
<br>
<span style="font-size: 12pt;">&nbsp; 에라토스테네스의 체.. 이름이 참 어렵군요. 사실 이는 간단합니다. 말그대로 숫자들만 걸러내는 '체(sieve)' 인데, 아래와 같은 방식으로 숫자를 걸러내어 소수들을 찾습니다. </span><br>
<br>
<ul style="list-style-type: disc;">
<li><span style="font-size: 12pt;">수들을 쭉 쓴다.</span></li>
<li><span style="font-size: 12pt;">2 의 배수들을 다 지운다.</span></li>
<li><span style="font-size: 12pt;">2 에서 가장 가까운 안지워진 수를 찾는다. 아마도 3 일 것이다. (소수 찾았다!)</span></li>
<li><span style="font-size: 12pt;">3 의 배수들을 다 지운다.</span></li>
<li><span style="font-size: 12pt;">3 에서 가장 가까운 안지워진 수를 찾는다. 아마도 5 일 것이다. (소수 찾았다!)</span></li>
<li><span style="font-size: 12pt;">5 의 배수들을 다 지운다.</span></li>
<li><span style="font-size: 12pt;">5 에서 가장 가까운 안지워진 수를 찾는다. 아마도 7 일 것이다. (소수 찾았다!)</span></li>
<li><span style="font-size: 12pt;">7 의 배수들을 다 지운다.</span></li>
<li><span style="font-size: 12pt;">그 뒤로 쭈우욱 같은 작업을 실시</span></li>
</ul>
<span style="font-size: 12pt;">&nbsp; <br>
위키피디아에서 이 과정을 알기 싶게 애니메이션으로 나타낸 자료가 있으니 보시기 바랍니다.</span><br>
<br>
<br>
<span style="font-size: 12pt;"><div class="imageblock center" style="text-align: center; clear: both;"><span data-url="https://t1.daumcdn.net/cfile/tistory/2037AA0E4B362D7CB9?original" data-lightbox="lightbox"><img srcset="//img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2037AA0E4B362D7CB91FA1 1920w, //img1.daumcdn.net/thumb/R960x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2037AA0E4B362D7CB91FA1 960w, //img1.daumcdn.net/thumb/R720x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2037AA0E4B362D7CB91FA1 720w, //img1.daumcdn.net/thumb/R640x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2037AA0E4B362D7CB91FA1 640w, //img1.daumcdn.net/thumb/R480x0.q70/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2037AA0E4B362D7CB91FA1 480w" src="https://t1.daumcdn.net/cfile/tistory/2037AA0E4B362D7CB9" style="cursor: pointer;max-width:100%;height:auto" width="554" height="445" alt="" filename="New_Animation_Sieve_of_Eratosthenes.gif" filemime="image/gif"></span></div></span><span style="font-size: 12pt;"><br>
<span style="font-size: 12pt;">
</span></span><div style="border: 1px solid rgb(159, 211, 49); padding: 10px; background-color: rgb(231, 253, 181);" class="txc-textbox">
<span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 14pt;"><span style="font-size: 12pt;"><span style="font-weight: bold;">생각해볼 문제 7) </span>1000 자리의 수들의 덧셈, 뺄셈, 곱셈, 나눗셈을 수행하는 프로그램을 만들어보세요. 나눗셈의 경우 소수 부분을
잘라버리세요. 물론, 소수 부도 1000 자리로 구현해도 됩니다. 1000 자리 수들의 연산 수행 시간은 1 초 미만이여야
합니다. (난이도 : 上)&nbsp; </span></span></span></span><span style="font-size: 12pt;"></span><span style="font-size: 12pt;"> </span></div>
<br>
<span style="font-size: 12pt;">int 자료형은 대략 42 억, 그러니까 10 자리 정도의 수 밖에 사용할 수 없었습니다. 그런데 문제에서 요구하는 것은 무려 1000 자리나! 이걸 도대체 어떻게 하라는 말일까요. 사실, 간단합니다. 크기가 1000 인 char 배열을 만들어서 배열의 한 원소를 수의 한 자리라고 생각하면 되죠. 이게 도대체 무슨 말이냐고요? </span><br>
<br>
<span style="font-size: 12pt;">예를 들어서 char BigNum[1000]; 을 정의하였다고 할 때, 사용자가 만일 123456 을 입력하였다면 BigNum[999] = 6, BigNum[998] = 5, ... BigNum[994] = 1 로 하면 되죠. 이러한 형식의 두 수를 더하는 연산을 하기 위해서는 각 원소를 더한 뒤, 받아올림이 있으면 그 다음 원소에 더해주고 하는 방식으로 쭉 나가면 됩니다. 어때요? 간단하죠.</span><br>
<br>
<span style="font-size: 12pt;">곱셈은 쉽게 하면 덧셈을 여러번 반복해서 호출하는 것으로 해결될 수 있지만 연산 속도가 느리므로 인간이 곱셈하는 방식으로 하는 것을 권합니다. 그렇다면 문제는 나눗셈인데 나눗셈 역시 뺄셈을 반복하는 것으로 해결 될 수 있지만 역시 느리므로, 인간이 나눗셈 하는 방식으로 계산하는 함수를 만들어보세요. 그럼. 행운을 빕니다. </span><br><br>
<div style="border: 1px solid rgb(254, 137, 67); padding: 10px; background-color: rgb(254, 222, 199);" class="txc-textbox">
<span style="font-size: 11pt;"><span style="font-size: 12pt;">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 <span style="font-weight: bold;">꼭 댓글을 남겨주시기 바랍니다</span>. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요. </span></span><span style="font-size: 11pt;"><span style="font-size: 12pt;"></span></span><br>
<br>
<span style="font-size: 11pt;"><span style="font-size: 12pt;">현재 여러분이 보신 강좌는<span style="font-style: italic;"> &lt;&lt;씹어먹는 C 언어 - &lt;13 - 4. 마술 상자 함수 (생각해볼 문제에 대한 아이디어)&gt;&gt;&gt;</span> 입니다. 이번 강좌의 <span style="font-weight: bold;">모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전</span>까지 다음 강좌로 넘어가지 말아주세요 </span></span><br>
<br>
<div style="text-align: right;">
<span style="font-size: 12pt;"><a style="font-weight: bold;" title="[http://itguru.tistory.com/notice/15]로 이동합니다." target="_blank" href="http://itguru.tistory.com/notice/15">다음 강좌 보러가기</a><br>
</span>
</div>
</div><div class="container_postbtn"><div class="postbtn_like"><div class="like_btn" data-uoc-svc="tistory" data-uoc-uid="329162_30" data-uoc-sc="" data-uoc-pcurl="http://itguru.tistory.com/30" data-uoc-fetchurl="http://api.kakao.tistory.com/like/fetch?uid=329162_30"><label class="uoc-icon"><span class="ico_postbtn ico_like"></span> <span class="txt_like uoc-text screen_out">공감</span><span class="txt_like uoc-count">1</span><input type="button" class="inp_btn uoc-button"></label></div><span class="ico_bar"></span><label data-thumbnail-url="http://cfile2.uf.tistory.com/image/1903D2284B36263D76E85B" data-title="씹어먹는 C 언어 - <13 - 4. 마술 상자 함수 (생각해볼 문제에 대한 아이디어)>" data-description="이번 강좌에서는 재귀 함수에 대한 이해 여러가지 주요 알고리즘. (버블 정렬, 유클리드 호제법, 에라토스테네스의 체)  안녕하세요 여러분. 이전 강좌의 예제가 중요한 만큼, 예제에 좀더 쉽게 접근할 수 있는 아.." data-profile-image="http://cfile30.uf.tistory.com/image/24672D3F58DB509F14CA8E" data-profile-name="Psi" data-pc-url="http://itguru.tistory.com/30" data-blog-title="Programming IT"><span class="ico_postbtn ico_sns">sns</span><input type="button" class="inp_btn"></label><span class="ico_bar"></span><label data-entry-id="30"><span class="ico_postbtn ico_report">신고</span><input type="button" class="inp_btn"></label></div><div class="postbtn_ccl" data-ccl-type="3"><a href="http://creativecommons.org/licenses/by/4.0/deed.ko" target="_blank" class="link_ccl"><span class="bundle_ccl"><span class="ico_postbtn ico_ccl1">저작자표시</span></span></a></div></div>    <!--
	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-fr/">
			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>
			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>
			<requires rdf:resource="http://web.resource.org/cc/Notice"/>
			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>
			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>
		</License>
	</rdf:RDF>
	--><div style="text-align:center; padding-top:10px;clear:both">
<iframe src="//www.facebook.com/plugins/like.php?href=http://itguru.tistory.com/30&amp;layout=standard&amp;show_faces=true&amp;width=310&amp;action=like&amp;font=tahoma&amp;colorscheme=light&amp;height=65" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:310px; height:65px;" allowtransparency="true"></iframe>
</div>
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/C">C</a>' 카테고리의 다른 글</h4>
<table>
<tbody><tr>
<th>
<a href="/29?category=194983">씹어먹는 C 언어 - &lt;15 - 1. 일로와봐, 문자열(string)&gt;</a>&nbsp;&nbsp;<span>(42)</span>
</th>
<td>
2009.12.29</td>
</tr>
<tr>
<th>
<a href="/31?category=194983">씹어먹는 C 언어 - &lt;14. 컴퓨터의 머리로 따라가보자 - 디버깅(debugging)&gt;</a>&nbsp;&nbsp;<span>(32)</span>
</th>
<td>
2009.12.29</td>
</tr>
<tr>
<th>
<a href="/30?category=194983" class="current">씹어먹는 C 언어 - &lt;13 - 4. 마술 상자 함수 (생각해볼 문제에 대한 아이디어)&gt;</a>&nbsp;&nbsp;<span>(33)</span>
</th>
<td>
2009.12.27</td>
</tr>
<tr>
<th>
<a href="/28?category=194983">씹어먹는 C 언어 - &lt;13 - 3. 마술 상자 함수 3 (function)&gt;</a>&nbsp;&nbsp;<span>(114)</span>
</th>
<td>
2009.12.22</td>
</tr>
<tr>
<th>
<a href="/27?category=194983">씹어먹는 C 언어 - &lt;13 - 2. 마술 상자 함수 2 (function)&gt;</a>&nbsp;&nbsp;<span>(79)</span>
</th>
<td>
2009.12.19</td>
</tr>
<tr>
<th>
<a href="/26?category=194983">씹어먹는 C 언어 - &lt;13 - 1. 마술 상자 함수(function)&gt;</a>&nbsp;&nbsp;<span>(122)</span>
</th>
<td>
2009.12.14</td>
</tr>
</tbody></table></div>
<br> <br>


					