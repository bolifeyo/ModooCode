Link :  133
2011-02-05 16:56
----------------
title : 티스토리용 통계 프로그램 (댓글, 포스트, 방문자 등등) - tistory_stat (v.0.1)
publish_date : 2011-02-05 16:56
--------------



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F205D883D4D4D02442A6149)

  안녕하세요. 원래 제가 기억하기로 `tistat` 이라는 프로그램이 있었는데, 이 좋은 프로그램을 만드신 분의 사이트가 사라지는 바람에 결국 제가 직접 만들어야 했습니다 ㅎㅎ. C++ 연습도 해볼 겸 프로그램을 재미 삼아 만들어보았는데요, 이게 생각보다 복잡하여서 여러가지 걸림돌이 많더라고요. 일단 `XML` 파일을 읽어들여야 하기 때문에 좋은 `XML parser` 인 `tinyxml` 을 이용하였고, 또다른 문제로 이 파일이 `UTF-8` 형식으로 되어 있어서 이를 제대로 인코딩하는데에도 많은 애를 먹었습니다. 그래고 일단 만들어 놓으니 뿌듯하네요.

 기존의 `tistat` 에서 지원하는 기능들의 거의 대부분의 기능은 구현하였습니다. 필요 없는 것들은 몇 개 뺐는데 (예를 들어 제가 거의 관심을 안가지는 트랙백 ㅋ), 지원하는 기능은

월별 글 수
시간대별 글 수
전체 댓글 수
월별 댓글 수
시간별 댓글 수
댓글 많이 달린 글 100개
댓글 단 사람 (이름으로 추정) 전체 목록
댓글 단 사람 (이름 및 `ip` 를 고려해서 추정) 전체 목록
월별 방문객 수
가장 많이 방문한 날

 들을 지원합니다. 그런데 무엇보다도 제가 가장 잘 만들었다고(?) 생각하는 기능은 댓글 단 사람의 이름과 `ip` 를 고려해서 추정하는 것인데, 동일한 사람이라도 여러가지 사용자 명으로 댓글을 남기는 사람들이 있고 또 동일한 사용자 명이라도 다른 `ip` 지역대에서 접속하는 사람들이 있는데 이것을 모두 고려하여서 '동일한 인물인지 정확하게 구분하여' 댓글 단 개수를 추정하는 것을 넣었습니다.

  이는 특히 제 블로그에 많은 도움이 되는데, 제 블로그의 형식상 `tistory` 보다는 외부 검색엔진에서 유입되는 사람들이 훨씬 많기 때문에 `ID` 를 기입하지 않고 댓글을 다는 사람이 무척이나 많습니다. 또한 매번 댓글을 달 때 마다 사용자 명을 바꾸는 사람들도 태반이지요. 따라서 어느 사람이 누구누구 인지 구분하기 위해 위와 같은 루틴을 넣었습니다.

  또한 부가적으로

전체 댓글 수
전체 포스트 수
댓글 수가 1 개 이상인 포스트 수
포스트 당 댓글 수
댓글 수가 0 인 포스트를 제외한 포스트 당 댓글 수
댓글 작성자 평균 댓글 작성 수
방문자 당 댓글 수 비율

  를 모두 알 수 있도록 추가하였습니다. 그리고 확실히 C++ 이 다른 인터프리팅 언어 보다는 훨씬 가볍고 빠르네요. 크기도 `200kb` 정도 밖에 안되고, `xml` 파일 분석도 금방 금방 합니다.

  아래는 그 파일 입니다. `tistory_statistics.exe` 를 누르시면 다운 받으실 수 있습니다.


 [ tistory_stastics.exe](http://itguru.tistory.com/attachment/cfile29.uf@153EAB414D4D00671D82F7.exe)
  사용하는 방법은, 프로그림이 위치한 곳에 분석을 원하는 파일을 놔둔 후, 프로그램을 실행 시킨 뒤 파일 이름을 쓰고 데이터를 가져오기 원하는 시간 범위를 써주시면 됩니다. 아래 그림을 보시면 이해가 쉽습니다


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F135CCC434D4D01220FC847)

위 그림처럼 같은 위치에 원하는 `xml` 파일을 둔 뒤,


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F15420A434D4D012230D529)

위와 같이 파일 이름을 입력하고, 원하는 데이터 범위 `yyyymmdd` 형식으로 넣으시면 됩니다. 예를 들어서 2009 년 1 월 1 일 부터 2011 년 2 월 5 일 까지의 데이터 범위를 얻고 싶다면 20090101 을 쓰고 엔터를 누른 뒤 20110205 를 쓰고 다시 한 번 엔터를 누르면 됩니다. 그렇다면 아래 그림 처럼 `out.txt` 와 `csv_out.csv` 파일이 만들어져 있을 것입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1357713E4D4D019D113A85)

`csv_out.csv` 는 `csv` 형식 파일로 엑셀에서 바로 열어보실 수 있고, `out.txt` 는 텍스트 파일로 `csv_out.csv` 와 내용은 동일합니다.

그럼 모두 잘 쓰세요~~ 버그 같은거나 추가하기 원하는 기능은 댓글로 달아주세요.
Link :  132
2011-01-27 11:24
----------------
title : C 언어 레퍼런스 - atol 함수
path : /C Reference/stdlib.h
cat_title :  atol
publish_date : 2011-01-27 11:24
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ atol

```info
#include <stdlib.h> // C++ 에서는 <cstdlib>

long int atol ( const char * str ); // long atol (const char *str) 인 경우도 있음
```


문자열을 `long` 형 정수로 변환한다.
C 형식 문자열을 `long` 형 정수로 변환하여 변환된 값을 리턴한다 C 형식 문자열을 `long` 형 정수로 변환하여 변환된 값을 리턴한다.

이 함수는 C 형식 문자열에서 비-공백 문자가 나오기 전 까지 최대한 많은 공백 문자(' ', '\t', \n') 들을 무시한다. 그 다음에 첫 번째 비-공백 문자부터 최대한 많은 숫자들을 수로 변환한다. 이 때, 숫자의 맨 앞부분에는 `+` 나 `-` 가 올 수 도 있다. 숫자들 다음에 나타나는 문자들은 모두 무시된다. 예를 들면

\n\n-123aaa

이라는 문자열이 있다면 -123 으로 변환된다.
만일 문자열에서 첫 번째로 나타나는 비-공백 문자가 숫자 혹은 `+` 나 `-` 가 아니라면 어떠한 변환도 이루어 지지 않는다. 또한 문자열이 공백 문자로만 이루어져 있어도 변환이 이루어 지지 않는다. 예로

`a123`

의 경우 123 이 있지만 첫번째 비-공백 문자가 `a` 이기 때문에 변환이 이루어지지 않는다. 변환이 이루어 지지 않는 경우 0 이 리턴된다.



###  인자


`str`

정수를 포함하고 있는 C 형식 문자열



###  리턴값




성공적으로 변환하였다면 변환된 `long` 형 정수를 리턴한다.
만일 변환이 실패하였다면 0 이 리턴된다.
변환된 수가 `long` 형으로 표현 가능한 범위를 넘어갔다면 `LONG_MAX` 혹은 `LONG_MIN` 이 리턴된다.



###  실행 예제


```cpp-formatted
/*

문자열로 데이터를 입력 받아서 long int 형으로 변환한다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstdlib/atol/
에서 가져왔습니다.


*/
#include <stdio.h>
#include <stdlib.h>

int main() {
  long int li;
  char szInput[256];
  printf("Enter a long number: ");
  gets(szInput);
  li = atol(szInput);
  printf("The value entered is %d. The double is %d.\n", li, li * 2);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1130654A4D414D3E29BE90)





###  연관된 함수

*  [atoi](http://itguru.tistory.com/131)  :  문자열을 정수로 변환한다.
*  [atof](http://itguru.tistory.com/124)  :  문자열을 `double` 형으로 변환한다.
* strtol  :  문자열을 `long` 형으로 변환한다.
Link :  131
2011-01-27 10:47
----------------
title : C 언어 레퍼런스 - atoi 함수
path : /C Reference/stdlib.h
cat_title :  atoi
publish_date : 2011-01-27 10:47
--------------


#@ atoi

```info
#include <stdlib.h> // C++ 에서는 <cstdlib>

int atoi ( const char * str );
```


문자열을 정수로 변환한다.

C 형식 문자열을 정수로 변환하여 변환된 값을 리턴한다 C 형식 문자열을 정수로 변환하여 변환된 값을 리턴한다.

이 함수는 C 형식 문자열에서 비-공백 문자가 나오기 전 까지 최대한 많은 공백 문자(' ', '\t', \n') 들을 무시한다. 그 다음에 첫 번째 비-공백 문자부터 최대한 많은 숫자들을 수로 변환한다. 이 때, 숫자의 맨 앞부분에는 `+` 나 `-` 가 올 수 도 있다. 숫자들 다음에 나타나는 문자들은 모두 무시된다. 예를 들면

```cpp-formatted
"\n\n-123aaa"
```

이라는 문자열이 있다면 -123 으로 변환된다.
만일 문자열에서 첫 번째로 나타나는 비-공백 문자가 숫자 혹은 `+` 나 `-` 가 아니라면 어떠한 변환도 이루어 지지 않는다. 또한 문자열이 공백 문자로만 이루어져 있어도 변환이 이루어 지지 않는다. 예로

```cpp-formatted
"a123"
```

의 경우 123 이 있지만 첫번째 비-공백 문자가 `a` 이기 때문에 변환이 이루어지지 않는다. 변환이 이루어 지지 않는 경우 0 이 리턴된다. 참고로 `atoi` 함수를 잘 이용하면 `scanf` 로 정수를 입력받을 때 문자를 입력하면 오류가 발생하는 문제를 피할 수 있다. 예를 들면

```cpp-formatted
int i;
char input[10];

scanf("%s", input);
i = atoi(input);
```


와 같은 형태로 입력을 받으면 설사 문자를 입력 했다고 해도 오류가 나지 않고 정수를 입력하면 `atoi` 로 잘 변환된다.



###  인자




`str`

정수를 포함하고 있는 C 형식 문자열




###  리턴값




성공적으로 변환을 하였다면 `int` 값을 리턴한다.
만일 변환을 실패하였다면 0 이 리턴된다.

만일 변환을 하였지만 그 값이 표현 가능한 범위를 벗어난다면 `INT_MAX` 혹은 `INT_MIN` 이 리턴된다.



###  구현 예


```cpp-formatted
/*

아래 예제는
http://cboard.cprogramming.com/linux-programming/125356-complete-function-definition-i-e-atoi.html
에서 가져왔습니다.

*/
#include <ctype.h>  // C++ 에서는 <cctype>

int atoi(char s[]) {
  int i, n, sign;
  for (i = 0; isspace(s[i]); i++)
    ; /* skip white space */
  sign = (s[i] == '-') ? -1 : 1;
  if (s[i] == '+' || s[i] == '-') /* skip sign */
    i++;
  for (n = 0; isdigit(s[i]); i++) n = 10 * n + (s[i] - '0');
  return sign * n;
}
```





###  실행 예제




```cpp-formatted
/*

수를 문자열로 입력받은 뒤 atoi 함수로 이를 정수로 변환한다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <stdlib.h>

int main() {
  int i;
  char szInput[256];
  printf("Enter a number: ");
  fgets(szInput, 256, stdin);
  i = atoi(szInput);
  printf("The value entered is %d. The double is %d.\n", i, i * 2);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F196A4A444D40CB2D281113)





###  연관된 함수


* atol  :  문자열을 `long` 형 정수로 변환한다.
*  [atof](http://itguru.tistory.com/124)  :  문자열을 `double` 형으로 변환한다.
* strtol  :  문자열을 `long` 형 정수로 변환한다.
Link :  130
2011-01-20 00:33
----------------
title : 초보자를 위한 C 언어 강좌 - 씹어먹는 C 언어 (완결)
publish_date : 2011-01-20 00:33
--------------

![씹어먹는 C 언어](/img/ChewingClogo.png)


마침내 끝났습니다.

마침내 길고 길었던 항해가 끝났습니다. 아마도 이 글을 읽는 분들 중 저의 첫번째 강의부터 열심이 보셨던 분들이 여럿 계셨으면 하는 바램이 간절합니다^^ 제가 첫번째 강좌를 야심차게 시작했을 때가 2009 년 4월 16일 입니다.(사실 1 월 경에 시범적으로 C 언어 강좌 두 편을 올린 적이 있었는데 너무 어렵게 쓰는 바람에 반응이 없어서 다시 쓴 것입니다 ㅎ)

그리고 제가 마지막 강좌를 업로드 한 날짜가 2011 년 1 월 18일 이지요. 무려 2 년 간의 엄청난 격차가 있습니다. 평균적으로 따지면 1 달에 강좌 한 편도 올린 것이 아닌 셈인데, 제 블로그를 꾸준히 방문해 주신 여러분 덕분에 이렇게 강좌가 완성될 수 있었습니다.


감사의 말

아래 분들은 제 블로그에 (특히 더 많이) 기여를 해주신 분들입니다. 아래 여러분들께 저의 특별한 감사의 말을 전하고 싶습니다.

* [코이치](http://koichis.tistory.com/)` (39)`
* 곰돌 (22)
* song (14)
* 감사합니다 (14)
* 희망 (11)
* 스프 (10)
* 프로그래머가 되고싶은 1인. (8)
* 괴도 (7)
* ore (7)
* 두루뭉술 (7)
* 질무이있으요. (6)
* 모르겠어요 (6)
* 배움의장터 (6)
* [winape](http://winape.tistory.com/) (6)
* 질문 (6)
* eager (5)
* 행인 (5)
* 궁금 (5)
* sweetick (5)
* Stephanos (5)
* 울림 (5)
* 공부중 (5)

그 외에 제 블로그를 방문해 주신 여러분!

감사합니다:)


### 씹어먹는 C 언어 칭찬

  인터넷을 보다보면 수 많은 C 언어 강좌들이 있습니다. 하지만 안타까운 사실은 제가 본 대다수의 C 언어 강좌들은 대개 중간에 끝나는 경우가 엄청 많았습니다. 그 분들의 문제가 과연 무엇이였을까요? 개인적으로 생각했을 때 두 가지 문제가 있었다고 생각합니다. 먼저 강좌를 쓰는 일은 엄청난 끈기가 필요한 작업 입니다. 왜냐하면 자신이 완벽히 알고 있지 않는 한 남한테 가르쳐 주는 일은 매우 어려운 일이기 때문이지요. 예를 들면 포인터 하나를 가르치려고 해도, '포인터가 왜 필요한지' 부터 시작해서 '포인터의 타입은 왜 있는 것인지', 등등 모든 내용을 꿰뚤고 있어야 합니다. 그 만큼 가르치는 것은 엄청난 일이지요. 더군다나 얼굴 보고 맞대고 설명 하는 것도 힘든데 인터넷 상에서 글 만드로 이야기 할려니 얼마나 힘들겠습니까.

  이를 이겨내더라도 문제가 한 가지 더 있습니다. 바로 읽는이와의 '소통' 이 불가능 하다라는 점 입니다. 아무리 가르쳐 주는 사람이 훌륭하다고 해도 읽는 사람의 모든 부분을 이해시켜 줄 수 없는 것이 아닙니다. 한 마디로 한개의 강좌로 독자의 가려운 곳을 정확하게 긁어줄 수 없는 셈이지요. 이를 위해서는 확실한 '애프터 서비스' 가 필요한데 이것이 바로 독자와 '댓글' 을 통해 소통하는 것이였습니다. 제 강좌에서 가장 강조 했던 부분이 바로 이 부분이였습니다. 강좌에서 궁금한 점이나 이해가 안가는 점이 있다면 무조건 '댓글을 남겨라' 이지요. 이렇게 댓글을 남겨서 이를 해결해 주는 방법을 통해서 저는 제 글을 읽는 여러분 모두와 확실하게 소통을 할 수 있었다고 생각합니다. 바로 이 것이 1 달에 강좌를 평균적으로 1 편 씩만을 써도 끝까지 완결할 수 있는 방법이지요 :)

   아무튼 이제 여러분은 'C 언어' 라는 하나의 산을 정ㅋ벅ㅋ 하셨습니다.

그럼 여러분은 이제 무얼 해야 될까요?

  일단 여러가지를 하실 수 있습니다. 만일 C 언어를 다른 곳에서 이미 배우시고 제 강좌를 '복습' 차원에서 읽으신 분들이라면 제 강좌를 다시 볼 필요가 없겠지요. 하지만 C 언어를 제 강좌를 통해 처음 접했던 분들이라면 복습이 최고라고 말씀드리고 싶습니다. 물론 여기서 복습이란 말은 다시 꼼꼼히 정독 하라는 것이 아니라 대충 필요한 강좌만 다시 보는게 좋을 것이라는 거지요.

  아래는 저의 전체 강좌 리스트 입니다.


1. `2009/04/16` [씹어먹는 C 언어 - <1. C 언어가 뭐야?>](http://itguru.tistory.com/5)
2. `2009/04/17` [씹어먹는 C 언어 - <2 - 1. C 언어 본격 맛보기>](http://itguru.tistory.com/6)
3. `2009/09/24` [씹어먹는 C 언어 - <2 - 2. 주석(Comment)에 대한 이해>](http://itguru.tistory.com/19)
4. `2009/10/12` [씹어먹는 C 언어 - <2 - 3. 수를 표현하는 방법(기수법)>](http://itguru.tistory.com/21)
5. `2009/04/22` [씹어먹는 C 언어 - <3. 변수가 뭐지? >](http://itguru.tistory.com/7)
6. `2009/04/24` [씹어먹는 C 언어 - <4. 계산하리 >](http://itguru.tistory.com/8)
7. `2009/04/27` [씹어먹는 C 언어 - <5. 문자 입력 받기>](http://itguru.tistory.com/9)
8. `2009/04/28` [씹어먹는 C 언어 - <6. 만약에...(if 문)>](http://itguru.tistory.com/10)
9. `2009/08/06` [씹어먹는 C 언어 - <7. 뱅글 뱅글 (for, while) >](http://itguru.tistory.com/12)
10. `2009/08/06` [씹어먹는 C 언어 - <8. 우분투 리눅스에서 C 프로그래밍 하기>](http://itguru.tistory.com/14)
11. `2009/08/15` [씹어먹는 C 언어 - <9. 만약에... 2탄 (switch 문)>](http://itguru.tistory.com/16)
12. `2009/08/15` [씹어먹는 C 언어 - <10. 연예인 캐스팅(?) (C 언어에서의 형 변환)>](http://itguru.tistory.com/17)
13. `2009/11/14` [씹어먹는 C 언어 - <11 - 1. C 언어의 아파트 (배열), 상수>](http://itguru.tistory.com/18)
14. `2009/10/29` [씹어먹는 C 언어 - <11 - 2. C 언어의 아파트2 (고차원의 배열)>](http://itguru.tistory.com/20)
15. `2009/11/09` [씹어먹는 C 언어 - <12 - 1. 포인터는 영희이다! (포인터)>](http://itguru.tistory.com/23)
16. `2009/11/14` [씹어먹는 C 언어 - <12 - 2. 포인터는 영희이다! (포인터)>](http://itguru.tistory.com/24)
17. `2009/11/26` [씹어먹는 C 언어 - <12 - 3. 포인터는 영희이다! (포인터)>](http://itguru.tistory.com/25)
18. `2009/12/14` [씹어먹는 C 언어 - <13 - 1. 마술 상자 함수(function)>](http://itguru.tistory.com/26)
19. `2009/12/19` [씹어먹는 C 언어 - <13 - 2. 마술 상자 함수 2 (function)>](http://itguru.tistory.com/27)
20. `2009/12/22` [씹어먹는 C 언어 - <13 - 3. 마술 상자 함수 3 (function)>](http://itguru.tistory.com/28)
21. `2009/12/27` [씹어먹는 C 언어 - <13 - 4. 마술 상자 함수 (생각해볼 문제에 대한 아이디어)>](http://itguru.tistory.com/30)
22. `2009/12/29` [씹어먹는 C 언어 - <14. 컴퓨터의 머리로 따라가보자 - 디버깅(debugging)>](http://itguru.tistory.com/31)
23. `2009/12/29` [씹어먹는 C 언어 - <15 - 1. 일로와봐, 문자열(string)>](http://itguru.tistory.com/29)
24. `2010/01/25` [씹어먹는 C 언어 - <15 - 2. 일로와봐, 문자열(string) - 버퍼에 관한 이해>](http://itguru.tistory.com/32)
25. `2010/02/01` [씹어먹는 C 언어 - <15 - 3. 일로와봐, 문자열(string) - 문자열 지지고 볶기/리터럴>](http://itguru.tistory.com/33)
26. `2010/02/08` [씹어먹는 C 언어 - <15 - 4. 일로와봐, 문자열(string) - 도서 관리 프로젝트>](http://itguru.tistory.com/43)
27. `2010/02/14` [씹어먹는 C 언어 - <16 - 1. 모아 모아 구조체(struct)>](http://itguru.tistory.com/55)
28. `2010/04/11` [씹어먹는 C 언어 - <16 - 2. 모아 모아 구조체(struct) - 구조체 인자로 가진 함수>](http://itguru.tistory.com/60)
29. `2010/06/13` [씹어먹는 C 언어 - <16 - 3. 구조체와 친구들(공용체(union), 열거형(enum))>](http://itguru.tistory.com/71)
1. `2010/06/19` [씹어먹는 C 언어 - <17. 변수의 생존 조건 및 데이터 세그먼트의 구조>](http://itguru.tistory.com/83)
1. `2010/07/16` [씹어먹는 C 언어 - <18 - 1. 파일 뽀개기 (헤더파일과 #include) >](http://itguru.tistory.com/87)
1. `2010/07/20` [씹어먹는 C 언어 - <18 - 2. 파일 뽀개기 (# 친구들, 라이브러리)>](http://itguru.tistory.com/88)
1. `2010/08/02` [씹어먹는 C 언어 - <19. main 함수의 인자, 텅 빈 void 형>](http://itguru.tistory.com/89)
1. `2010/08/03` [씹어먹는 C 언어 - <20 - 1. 동동동 메모리 동적할당(Dynamic Memory Allocation)>](http://itguru.tistory.com/98)
1. `2010/09/13` [씹어먹는 C 언어 - <20 - 2. 메모리 동적할당 + 메모리 갖고 놀기>](http://itguru.tistory.com/100)
1. `2010/11/21` [씹어먹는 C 언어 - <21. 매크로 함수, 인라인 함수>](http://itguru.tistory.com/99)
1. `2010/12/25` [씹어먹는 C 언어 - <22. C 언어의 잡다한 키워드들 (typedef, volatile, #pragma)>](http://itguru.tistory.com/103)
1. `2010/12/28` [씹어먹는 C 언어 - <23 - 1. 파일 하고 이야기 하기 (파일 입출력의 기본적 이해)>](http://itguru.tistory.com/117)
1. `2011/01/10` [씹어먹는 C 언어 - <23 - 2. 파일 하고 이야기 하기 (파일 입출력)>](http://itguru.tistory.com/123)
1. `2011/01/17` [씹어먹는 C 언어 - <23 - 3. 파일 하고 이야기 하기 (파일 입출력 - 마무리)>](http://itguru.tistory.com/125)
1. `2011/01/18` [씹어먹는 C 언어 - <24. 더 빠르게 실행되는 코드를 위하여 (C 코드 최적화)>](http://itguru.tistory.com/129)

 위 많은 강좌들 중에서 여러분들이 한 번 더 보면 좋을 것이라 생각되는 강좌들은


* `2009/08/15` [씹어먹는 C 언어 - <10. 연예인 캐스팅(?) (C 언어에서의 형 변환)>](http://itguru.tistory.com/17)
* `2009/12/29` [씹어먹는 C 언어 - <14. 컴퓨터의 머리로 따라가보자 - 디버깅(debugging)>](http://itguru.tistory.com/31)
* `2010/01/25` [씹어먹는 C 언어 - <15 - 2. 일로와봐, 문자열(string) - 버퍼에 관한 이해>](http://itguru.tistory.com/32)
* `2010/02/01` [씹어먹는 C 언어 - <15 - 3. 일로와봐, 문자열(string) - 문자열 지지고 볶기/리터럴>](http://itguru.tistory.com/33)
* `2010/06/19` [씹어먹는 C 언어 - <17. 변수의 생존 조건 및 데이터 세그먼트의 구조>](http://itguru.tistory.com/83)
* `2010/08/03` [씹어먹는 C 언어 - <20 - 1. 동동동 메모리 동적할당(Dynamic Memory Allocation)>](http://itguru.tistory.com/98)
* `2010/12/25` [씹어먹는 C 언어 - <22. C 언어의 잡다한 키워드들 (typedef, volatile, #pragma)>](http://itguru.tistory.com/103)
* `2011/01/10` [씹어먹는 C 언어 - <23 - 2. 파일 하고 이야기 하기 (파일 입출력)>](http://itguru.tistory.com/123)
* `2011/01/18` [씹어먹는 C 언어 - <24. 더 빠르게 실행되는 코드를 위하여 (C 코드 최적화)>](http://itguru.tistory.com/129)

  이 9 개의 강좌들 입니다. 왜냐하면 위 9 개의 강좌들에서는 여러분이 다른 곳에서 접하기 쉽지 않은 내용들이 많이 들어가 있기 때문에 제 강좌를 졸업 하기 전에 다시 한 번 읽어 두는 것이 많이 도움이 될 듯 합니다. 또한 C 언어를 보다 잘하기 위해서는 여러가지 표준 라이브러리 함수들과 친해지는 것이 중요한데, 제 블로그의 오른쪽 카테고리에 보면 C 언어 레퍼런스 라는 부분이 있습니다. 각 카테고리에 들어가셔서 나오는 여러가지 함수들과 친숙해 지는 것도 좋을 법 합니다.

자 그럼 위 강좌들도 다 읽고 C 언어로 왠만한 프로그램은 다 만들 수 있게 되었다면 어떻게 할까요. 그럼 이제 여러분들에게는 엄청나게 많은 선택권이 주어집니다. 일단 많은 사람들의 경우 다른 언어를 한 가지씩 더 배우게 됩니다. 대부분 C++ 아니면 Java 와 같은 객체 지향 언어(Object Oriented Programming Language) 를 배우거나 파이썬(Python) 과 같은 인터프리팅 형식의 언어들을 배울 수 도 있습니다.

저는 개인적으로 C++ 을 먼저 배우기를 추천합니다 :)

최근 들어서 아이폰 개발이나 안드로이드 개발에 붐이 일면서 Objective-C (아이폰), Java(안드로이드) 언어들을 배우는 사람들도 늘고 있습니다. 물론 이들을 배우는 것도 좋지만 개인적으로 생각해 볼 때 아무래도 C 를 배웠다면 'C 의 거의 대부분의 문법 요소들을 받아들인' C++ 을 배우는 것이 더 좋을 것 같네요.

그래서 저는 씹어먹는 C 언어를 끝내고 '씹어먹는 C++' 을 연재할 생각입니다. 더 다른 강좌 이름이 생각나신다면 댓글로 달아주시고요 ㅎㅎ 여러분들도 C 언어를 다 배웠다고 제 사이트를 잊지 말고 저의 두 번째 작품인 씹어먹는 C++ 에 관심을 가져 주시기 바랍니다.


```warning
저의 씹어먹는 C 언어 강좌를 TEX 형식 파일로 만들어주실 분 안계시나요 ??
```


```warning
씹어먹는 C 언어의 PDF 버전이 드디어 나왔습니다.
이제 모바일에서도 편하게 보실 수 있습니다.
 [여기를 클릭해서 확인하세요!](http://itguru.tistory.com/187)
```
Link :  129
2011-01-18 20:11
----------------
title : 씹어먹는 C 언어 - <24. 더 빠르게 실행되는 코드를 위하여 (C 코드 최적화)>
cat_title : 24. 더 빠르게 실행되는 코드를 위하여 (C 코드 최적화)
next_page : 130
publish_date : 2011-01-18 20:11
--------------



이번 강좌에서는

* C 언어 코드의 최적화 기법에 대해 살펴본다 C 언어 코드의 최적화 기법에 대해 살펴본다.


![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분~ 이제 저의 마지막 강의(총 41 강)가 되겠네요. 그럼, 오늘도 강의를 시작해 볼까요?


우리의 컴퓨터는 무한정 빠르지 않습니다. 따라서 동일한 작업을 시키더라도 어떠한 방식으로 시키냐에 따라서 그 속도가 엄청나게 차이가 나게 됩니다. 우리는 언제나 코드를 만들 때 '과연 어떻게 해야지 이 작업을 가장 빠르게 할 수 있도록 코드를 만들 수 있을까?' 를 고민 해야 합니다. 이렇게 똑같은 일이라도 더 빠르게 수행할 수 있도록 코드를 짜는 행위를 '코드 최적화' 라고 부릅니다.

  참고적으로 아래의 내용은 대부분 [http://www.codeproject.com/KB/cpp/C___Code_Optimization.aspx](http://www.codeproject.com/KB/cpp/C___Code_Optimization.aspx)에서 가져왔으며, 특히 한국어로 번역된 자료는 [http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/C/Documents/COptimization](http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/C/Documents/COptimization)에서 보실 수 있습니다. 저는 여러분들께 여기에서 가장 중요하다고 생각되는 몇 가지 부분만을 쉽게 이야기 하고자 합니다.

### 산술 연산 관련

#### 부동 소수점 (float, double) 은 되도록 사용하지 말자

  예전에 [10 강에서 부동 소수점 수의 구조](http://itguru.tistory.com/17)에 대해 이야기 한 적이 있습니다. 그 때 강좌를 잘 보셨던 분은 알겠지만 부동 소수점 수는 그 구조가 매우매우 복잡합니다. 정수 자료형(int, `short, ... )` 의 경우 단순히 2 진수를 나타낸 것에 불과하지만 부동 소수점은 그 수의 특정한 규격이 정해진 것이기 때문에 상당히 복잡하지요.

  따라서 부동 소수점 수를 가지고 하는 연산 자체도 매우 느릴 수 밖에 없습니다. 여러분들은 꼭부동 소수점 연산은 오직 '반드시 필요할 때 에만' 사용하시기 바랍니다. 여기서 반드시 필요할 때 라면 소수점 몇 째 자리 까지 정밀도를 요구할 때에나 매우 큰 수를 다룰 때 입니다. 만일 소수점 둘째 자리나 첫째 자리 정도의 정밀도를 요구한다면 단순히 그 수에 `x 10, x 100` 을 하셔서 정수 자료형으로 다루는 것이 오히려 좋습니다.

#### 나눗셈을 피해라 (1)

아래는 초 를 증가시켜주는 함수 입니다.

```cpp-formatted
int inc_second(int second) { return (++second) % 60; }
```

  초의 범위는 0 부터 59 이므로 1 증가시킨 뒤에 만일 60 을 넘었을 때를 대비하여 위와 같이 60 으로 나눈 나머지를 구해야 되겠지요. 그런데 여기서 문제는 나눗셈은 매우매우 느린 연산이라는 것입니다. 다른 덧셈 뺄셈에 비해 몇 배 가까이 느리기 때문에 엄청난 시간 손해가 있겠지요. 우리가 만약 `second` 가 60 보다 커질 일이 없다는 것을 알고 있다면 굳이 60 으로 나눌 필요 없이 `if` 문으로 60 일 때만 0 을 리턴해주면 되는 것입니다. 왜냐하면 `if` 문은 나눗셈 보다는 훨씬 빠르게 처리가 되기 때문이지요.

```cpp-formatted
int inc_second(int second) {
  ++second;
  if (second >= 60) return 0;
  return second;
}
```


따라서 위와 같이 하면 훨씬 시간을 아낄 수 있습니다.

#### 나눗셈을 피해라 (2)

  앞에서도 말했듯이 나눗셈은 시간이 매우매우 오래 걸리는 작업이라고 했습니다. 그런데 놀랍게도 2 의 멱수들 (2,4,8,16,32 ...)  로 나눌 때에는 굳이 나눗셈을 사용하지 않고도 매우 간단하게 처리할 수 있는 방법이 있습니다. 바로 '쉬프트' 연산을 사용하는 것입니다. 쉬프트는 컴퓨터 연산 중에서도 가장 빠른 연산이므로 이를 잘만 활용한다면 시간을 엄청나게 절약할 수 있습니다.

2 의 멱수들을 이진수로 표현해 보면 1, 10, 100, 1000 등이 될 것입니다. 그럼 감이 오시나요? 우리가 만일 10 진수로 생각할 때 7865 를 100 으로 나누면 몫이 얼마가 될까요? 우리는 별로 고민하지 않고도 78 이라고 말할 수 있을 것입니다. 왜냐하면 단순히 끝의 두 자리를 버려버리면 되기 때문이지요. 이진수도 마찬가지 입니다. 11101010 을 1000 으로 나눈 몫은 얼마일까요? 이는 단순히 마지막 세자리를 버리면 되므로 11101 이 되겠지요.

  이 아이디어를 이용하면 1000 (이진수) 으로 나눌 때 에는 수를 오른쪽으로 3 칸 쉬프트 해버리면 됩니다. 즉, 오른쪽으로 3 칸 밀어버리는 것이지요 (쉬프트가 기억이 나지 않으면 [4 강 계산하리](http://itguru.tistory.com/8)를 보시기 바랍니다) 아래 예제는 32 로 나누는 것입니다. 32 는 2 의 5 승이므로 오른쪽으로 5 칸 쉬프트 해버리면 됩니다.

```cpp-formatted
#include <stdio.h>
int main() {
  int i;
  printf("정수를 입력하세요 : ");
  scanf("%d", &i);

  printf("%d 를 32 로 나누면 : %d \n", i, i / 32);
  printf("%d 를 5 칸 쉬프트 하면 : %d \n", i, i >> 5);

  return 0;
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F123D4E494D3405F70A846B)


두 결과가 일치함을 보실 수 있습니다.

#### 비트 연산 활용하기 (1)

  비트 연산(OR, `AND, XOR` 등등) 은 컴퓨터에서 가장 빠르게 실행되는 연산들 입니다. 이러한 연산들을 잘 활용하면 좋겠지요. 일단 비트연산은 다음과 같이 여러가지 정보를 하나의 변수에 포함하는데 자주 사용됩니다. 예를 들어서 우리가 하나의 사람에 대한 여러가지 상태에 관한 정보를 나타내는 변수를 만든다고 합시다. 구조체를 배운 여러분으로써는 아래와 같이 만들 것입니다.

```cpp-formatted
struct HUMAN {
  int is_Alive;
  int is_Walking;
  int is_Running;
  int is_Jumping;
  int is_Sleeping;
  int is_Eating;
};
```

이는 상당한 메모리 낭비가 되겠지요. 6 가지 정보를 나타내는데 192 개의 비트나 소모하였기 때문이지요. 물론 이를 `char` 로 바꾸면 되지 않나 라고 물어볼 수 있지만 결국은 같은 얘기 입니다. 굳이 하나의 정보를 한 개의 비트에 대응시켜서 사용할 수 도 있는데 이를 각각의 변수에 모두 대응 시켜서 사용한 것이 문제이지요. 하지만 비트 연산을 잘 이용하면 이를 해결할 수 있습니다. 아래의 예제를 보세요

```cpp-formatted
#include <stdio.h>
#define ALIVE 0x1      // 2 진수로 1
#define WALKING 0x2    // 2 진수로 10
#define RUNNING 0x4    // 2 진수로 100
#define JUMPING 0x8    // 2 진수로 1000
#define SLEEPING 0x10  // 2 진수로 10000
#define EATING 0x20    // 2 진수로 100000
int main() {
  int my_status = ALIVE | WALKING | EATING;

  if (my_status & ALIVE) {
    printf("I am ALIVE!! \n");
  }
  if (my_status & WALKING) {
    printf("I am WALKING!! \n");
  }
  if (my_status & RUNNING) {
    printf("I am RUNNING!! \n");
  }
  if (my_status & JUMPING) {
    printf("I am JUMPING!! \n");
  }
  if (my_status & SLEEPING) {
    printf("I am SLEEPING!! \n");
  }
  if (my_status & EATING) {
    printf("I am EATING!! \n");
  }
  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F203281334D3409E03A15C4)


와 같이 단순히 하나의 `int` 변수에 위 모든 데이터를 나타낼 수 있었습니다. 그 이유는 아래와 같이

```cpp-formatted
#define ALIVE 0x1     // 2 진수로 1
#define WALKING 0x2   // 2 진수로 10
#define RUNNING 0x4   // 2 진수로 100
#define JUMPING 0x8   // 2 진수로 1000
#define SLEEPING 0xC  // 2 진수로 10000
#define EATING 0x10   // 2 진수로 100000
```

`define` 을 이용해 여러개의 변수에 값을 대응시켰는데 한가지 특징은 각 데이터에는 오직 한 개의 비트만 1 이고 나머지는 모두 0 인 것입니다. 예를 들면 `JUMPING` 을 보면 16 진수 8 을 대응시켰는데, 이를 2 진수로 보면 끝에서 4 번째 자리만 1 이고 나머지 모든 자리는 0 인 수가 됩니다. 따라서 이와 같은 방식으로 수를 대응시키고

```cpp-formatted
int my_status = ALIVE | WALKING | EATING;
```

와 같이 `my_status` 에 `OR` 연산을 시켜주게 되면 각 데이터들이 나타내는 자리만 1 이 되고 나머지 모든 자리는 0 이 됩니다. 따라서 `my_status` 에는 `0...0100011` 이 되겠지요. 이제 이를 이용하여 `if` 문에서도 쉽게 사용할 수 있는데 단순히 유무를 파악하고자 하는 데이터와 `AND` 연산을 시키면 됩니다.

```cpp-formatted
if (my_status & WALKING) {
  printf("I am WALKING!! \n");
}
```


  예를 들면 위와 같이 내가 현재 `WALKING` 중인지 아닌지 파악하기 위해 `WALKING` 과 `AND` 연산을 시켜보면 만일 내가 `WALKING` 중이였다면 `AND` 연산시 '나머지 부분은 모두 0 이고, `WALKING` 에 해당하는 자리수만  1 이 될 것' 이여서 `if` 문에서 참으로 판단되고 (if 문은 0 이 아닌 모든 값을 참으로 생각한다) , 내가 `WALKING` 중이 아니였다면 '나머지 부분은 모두 0 이고 `WALKING` 에 해당하는 자리수 조차 0 이 될 것' 이므로 0 이 되어서 `if` 문에서 거짓으로 판단됩니다. 참으로 재밌는 일이지요. 참고로 비트 연산에 관련하여 아래의 내용을 기억하시면 편합니다.

1. 어떠한 정수의 특정 자리를 1 로 만들고 싶다면 그 자리만 1 이고 나머지는 0 인수와 `OR` 하면 됩니다.

1. 어떠한 정수의 특정 자리가 1 인지 검사하고 싶다면 그 자리만 1 이고 나머지는 0 인 수와 `AND` 하면 됩니다.

#### 비트 연산 활용하기 (2)

비트 연산을 가장 많이 활용하는 예로 또한 홀수/짝수 판별이 있습니다. 여태까지 여러분들은 아마 홀수 짝수 판별을

```cpp-formatted
if (i % 2 == 1)  // 이 수가 홀수인가
{
  printf("%d 는 홀수 입니다 \n", i);
} else {
  printf("%d 는 짝수 입니다 \n", i);
}
```

와 같이 만드셨을 것입니다. 그런데 제가 앞에서 계속 강조해 왔던 것이지만, 나눗셈 연산은 매우 느립니다! 하지만 놀랍게도 단순한 `AND` 연산 한번으로 이를 해결할 수 있습니다.

```cpp-formatted
if (i & 1)  // 이 수가 홀수인가
{
  printf("%d 는 홀수 입니다 \n", i);
} else {
  printf("%d 는 짝수 입니다 \n", i);
}
```

  만일 어떤 정수가 홀수라면, 2 진수로 나타냈을 때 맨 마지막 자리가 1 이여야 합니다 (당연하지요?) 이를 이용해서 단순히 어떤 정수의 맨 마지막 비트가 1 인지만 확인하면 되지요? 근데 위에서 강조했듯 것을 보면 맨 마지막 비트가 1 인지 확인하려면 맨 마지막 비트만 1 인 수(즉 `1)` 과 `AND` 하면 됩니다. 아래 소스로 컴파일해서 실행해보면 잘 됨을 알 수 있습니다.

```cpp-formatted
#include <stdio.h>
int main() {
  int i;
  scanf("%d", &i);

  if (i & 1)  // 이 수가 홀수인가
  {
    printf("%d 는 홀수 입니다 \n", i);
  } else {
    printf("%d 는 짝수 입니다 \n", i);
  }
  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1938A6594D34119938AE3D)


### 루프(loop) 관련

#### 알고 있는 일반적인 계산 결과를 이용하라

대표적으로 이야기 하자면 1 부터 `n` 까지 더하는 함수를 만들 때 입니다. 일반적으로 이러한 작업을 하는 코드를 짤 때에는

```cpp-formatted
for (i = 1; i <= n; i++) {
  sum += i;
}
```

위와 같이 `for` 문으로 구현하는 경우가 대부분 입니다. 하지만 여러분이 초등학생 가우스 정도의 머리를 가졌더라면 위와 같이 일일히 더하는 것 말고도

```cpp-formatted
sum = (n + 1) * n / 2;
```


로 간단히 나타낼 수 있겠지요. 이렇게 하게 될 경우 많은 계산 시간을 절약하게 됩니다.

#### 끝낼 수 있을 때 끝내라

아래 코드는 특정한 문자열에 'a' 라는 문자가 포함되어 있는지 검사하는 코드 입니다.

```cpp-formatted
while (*pstr) {
  if (*pstr != 'a') {
    does_string_has_a = 1;
  }

  pstr++;
}
```

위 코드에서 `does_string_has_a` 가 한 번 1 이 되었다면 뒤에서 바뀔 일이 없으므로 굳이 루프를 끝까지 실행하는 것은 무의미한 짓입니다. 이 때 이런 곳에 `break` 문을 넣어서 빠져 나갈 수 있게 한다면 불필요한 실행을 줄일 수 있습니다.

```cpp-formatted
while (*pstr) {
  if (*pstr != 'a') {
    does_string_has_a = 1;
    break;
  }

  pstr++;
}
```

위 코드 처럼 말이지요.

#### 한 번 돌 때 많이 해라.

  하나의 루프에서 동일한 일을 2 번 하는 것과, 하나의 루프에서 동일한 일을 한 번 하고 루프를 두번 돈다면 전자의 경우가 훨씬 효율적이라 말할 수 있습니다. 왜냐하면 루프를 한 번 돌 때 여러가지 조건들이 맞는지 비교하는 부분에서 시간이 약간 소모되기 때문이지요. 따라서 되도록이면 루프 한 번에 안에서 많은 일을 해버리는 것이 중요합니다.

  아래 코드는 정수 `n` 에서 값이 1 인 비트가 몇 개나 존재하는지 세는 프로그램 입니다.

```cpp-formatted
while (n != 0) {
  if (n & 1) {
    one_bit++;
  }
  n >>= 1;
}
```

   위 코드에서는 맨 끝 한개의 비트를 검사하고 오른쪽으로 쉬프트 해서 또 다시 맨 끝 비트를 검사하는 식으로 해서 결과적으로 모든 비트를 검사하여 값이 1 인 것의 개수를 셉니다. 하지만 우리는 C 언어에서 모든 정수 자료형의 크기가 8 비트의 배수 임을 알고 있습니다. 예를 들면 `char` 은 1 바이트로 8 비트, `int` 는 4 바이트로 32 비트 이지요. 따라서 굳이 1 개 비트씩 검사할 필요 없이 8 비트를 한꺼번에 묶어서 검사해도 상관이 없다는 말입니다. 이 때 8 비트를 한꺼번에 비교하면 너무 난잡하므로 4 비트씩 비교하는 것으로 하지요.

```cpp-formatted
while (n != 0) {
  if (n & 1) {
    one_bit++;
  }
  if (n & 2) {
    one_bit++;
  }
  if (n & 4) {
    one_bit++;
  }
  if (n & 8) {
    one_bit++;
  }
  n >>= 4;
}
```

와 같이 하면 됩니다. 사실 C 언어에서 `if` 문이나 `for` 문 다음에 한 줄만이 올 경우 중괄호를 생략해도 되는데,

```cpp-formatted
while (n != 0) {
  if (n & 1) one_bit++;
  if (n & 2) one_bit++;
  if (n & 4) one_bit++;
  if (n & 8) one_bit++;
  n >>= 4;
}
```

로 쓰셔도 됩니다. 아무튼 위와 같이 할 경우 루프 도는 회수를 줄일 수 있게 되므로 어느 정도의 시간 절약 효과를 보게 됩니다.

`4.` 루프에서는 되도록 0 과 비교하여라

```cpp-formatted
for (i = 0; i < 10; i++) {
  printf("a");
}

for (i = 9; i != 0; i--) {
  printf("a");
}
```

위 두 개의 `for` 문 중에서 무엇이 더 빠르게 실행될까? 실제로는 그리 큰 차이는 없을 테지만 엄밀히 따지고 보면 아래의 루프가 더 빠르게 돌아갑니다. 왜냐하면 위 루프의 경우 `i` 가 10 보다 작은지 비교하고 있고, 아래 루프에서는  `i` 가 0 과 다른지 비교하고 있는데 일반적으로 0 과 비교하는 명령어는 `CPU` 에서 따로 만들어져 있기 때문에 더 빠르게 작동될 수 있습니다.

#### 되도록 루프를 적게 써라

루프문을 굳이 쓰지 않고 쓸 수 있는 문장들은 되도록 직접 쓰는 것이 좋습니다. 예를 들어

```cpp-formatted
int i;
for (i = 1; i <= 3; i++) {
  func(i);
}
```


보다는

```cpp-formatted
func(1);
func(2);
func(3);
```

와 같이 루프를 풀어버리는 것이 더 좋을 때가 있습니다. 물론 루프를 쓰면 무엇을 하는지 한눈에 알 수 있지만 `for` 문 자체에서 여러가지 비교를 수행하는데 시간이 들기 때문에 위와 같이 간단히 루프를 쓰지 않고도 나타낼수 있다면 그 방법을 선택하시기 바랍니다.

### `if` 및 `switch` 문 관련

#### if 문을 2 의 배수로 쪼개기

예를 들면 아래와 같은 비교 명령들이 있다고 합시다.

```cpp-formatted
if (i == 1) {
} else if (i == 2) {
} else if (i == 3) {
} else if (i == 4) {
} else if (i == 5) {
} else if (i == 6) {
} else if (i == 7) {
} else if (i == 8) {
}
```

(물론 위와 같은 명령들은 `switch` 문을 이용하는 것이 훨씬 바람직합니다)
위 경우 `if` 문에서는 최악의 경우 최대 8 번의 비교작업을 해야 하는 상황이 발생합니다. 이는 엄청난 낭비가 아닐 수 없죠.

```cpp-formatted
if (i <= 4) {
  if (i <= 2) {
    if (i == 1) {
      /* i is 1 */
    } else {
      /* i must be 2 */
    }
  } else {
    if (i == 3) {
      /* i is 3 */
    } else {
      /* i must be 4 */
    }
  }
} else {
  if (i <= 6) {
    if (i == 5) {
      /* i is 5 */
    } else {
      /* i must be 6 */
    }
  } else {
    if (i == 7) {
      /* i is 7 */
    } else {
      /* i must be 8 */
    }
  }
}
```

하지만 `if` 문을 위와 같이 구성하게 된다면 어떨까요? 이와 같이 `if` 문을 쪼개는 것을 `Binary Breakdown` 이라고 하는데 이진의 형태로 쪼갠 것이지요. 이럴 경우 `i` 가 1 에서 8 까지 어떠한 값을 가지더라도 3 번만의 비교로 값을 알아낼 수 있습니다. 참고로 이전의 `if` 문의 형태로는 평균적으로 4 번의 비교가 필요했지요.

#### 순차적 비교에서는 `switch` 문을 사용해라

  사실 위의 `if` 문 예제에서는, 즉 위와 같이 순차적인 정수 값을 비교하는 경우에는 `switch` 문을 사용하는 것이 매우 요긴합니다. 왜냐하면 `switch` 문에서는 단 한번의 비교만으로 우리가 실행될 코드가 있는 곳으로 ‘점프’ 하기 때문이지요. `switch` 문의 원리는 9강 – 만약에.. 2 탄 [http://itguru.tistory.com/16](http://itguru.tistory.com/16)에서 보시기 바랍니다.

  즉 아래와 같은 코드가 훨씬 더 효율적입니다.

```cpp-formatted
switch (i) {
  case 1:
    break;
  case 2:
    break;
  case 3:
    break;
  case 4:
    break;
  case 5:
    break;
  case 6:
    break;
  case 7:
    break;
  case 8:
    break;
}
```



#### 룩업 테이블(look `up table,` LUT)을 사용할 수 있으면 사용해라

  룩업 테이블이란, 원론적으로 설명하면 특정 데이터에서 다른 데이터로 변환할 때 사용되는 테이블이라 할 수 있습니다. 말만 들으면 조금 어려운데요, 사실 컴퓨터에서 매우 자주 사용되고 있습니다. 예를 들어 컴퓨터에서 `3D` 처리를 할 때 많은 수의 `sine` 이나 `cosine` 연산들이 들어가게 됩니다. 이 때 `sin` 값 계산은 꽤 오랜 시간 걸리는 계산인데 `sin 1` 값이 필요할 때 마다 계산을 하게 된다면 아주 시간 낭비가 심하겠지요. 이를 막기 위해 프로그램 실행 초기에 `sin 1` 부터 `sin 90` 까지 미리 다 계산해 둔 뒤 표로 만들어 버리면 나중에 `sin 1` 값이 필요하면 단순히 표에서 1 번째 값을 찾으면 되니까 아주 편하겠지요.

  이렇게 만들어 놓은 테이블을 룩업 테이블이라고 부릅니다. 즉, 필요한 데이터를 쉽게 ‘찾을 수 있도록’ 만들어 놓은 표라고 보시면 됩니다. 예를 들면 아래와 같은 경우 사용할 수 있습니다.

```cpp-formatted
char* Condition_String1(int condition) {
  switch (condition) {
    case 0:
      return "EQ";
    case 1:
      return "NE";
    case 2:
      return "CS";
    case 3:
      return "CC";
    case 4:
      return "MI";
    case 5:
      return "PL";
    case 6:
      return "VS";
    case 7:
      return "VC";
    case 8:
      return "HI";
    case 9:
      return "LS";
    case 10:
      return "GE";
    case 11:
      return "LT";
    case 12:
      return "GT";
    case 13:
      return "LE";
    case 14:
      return "";
    default:
      return 0;
  }
}
```


위 코드의 경우 꽤 괜찮지만 아래 처럼 훨씬 간단하게 만들 수 있습니다.

```cpp-formatted
char* Condition_String2(int condition) {
  if ((unsigned)condition >= 15) {
    return 0;
  }
  return "EQ\0NE\0CS\0CC\0MI\0PL\0VS\0VC\0HI\0LS\0GE\0LT\0GT\0LE\0\0" +
         3 * condition;
}
```



위에서 주목할 부분은 룩업 테이블을 이용한 것인데, 위 코드에서 룩업 테이블은

```cpp-formatted
"EQ\0NE\0CS\0CC\0MI\0PL\0VS\0VC\0HI\0LS\0GE\0LT\0GT\0LE\0\0"
```



을 가리킵니다. 이 것이 룩업 테이블인 이유는 `condition` 값을 알면 바로 위 테이블에서 문자열을 찾아낼 수 있기 때문이지요. 위 `switch` 문을 룩업 테이블로 만들어 버릴 수 있었던 이유가 바로 리턴되는 문자열의 크기가 모두 동일해서 인데 이를 통해 위 룩업 테이블의 시작 주소값에서 `3 * condition` 을 더하면 우리가 원하는 문자열의 시작 주소값이 나오게 됩니다.

이 때 위와 같이 룩업 테이블을 이용하면 좋은 점이 코드의 길이가 훨씬 짧아진다는 점이고 실제 프로그램의 크기도 줄어든다는 점에 있습니다.

### 함수 관련

#### 함수를 호출할 때에는 시간이 걸린다.

```cpp-formatted
#include <stdio.h> void print_a();

int main() {
  int i;
  for (i = 0; i < 10; i++) {
    print_a();
  }
  return 0;
}
void print_a() { printf("a"); }
```



위 코드와 아래 코드를 보면 무엇이 더 빠르게 작동할까요?

```cpp-formatted
#include <stdio.h>
void print_a();
int main() {
  print_a();
  return 0;
}
void print_a() {
  int i;
  for (i = 0; i < 10; i++) {
    printf("a");
  }
}
```



그 답은 바로 아래 코드 입니다. 왜냐하면 함수를 호출하는 데에도 꽤 많은 시간이 걸리기 때문이지요. 함수를 호출하기 위해서는 여러가지 작업이 필요한데 이 부분에 대한 설명은 생략하고 아무튼 위와 같이 동일한 작업을 위해 함수를 반복적으로 호출하기 보단 차라리 그 함수 내에서 반복적인 작업을 처리하는 것이 훨씬 더 효율적입니다.

#### 인라인(inline) 함수를 활용하자

```cpp-formatted
#include <stdio.h>
int max(int a, int b) {
  if (a > b) return a;
  return b;
}
__inline int imax(int a, int b) {
  if (a > b) return a;

  return b;
}
int main() {
  printf("4 와 5 중 큰 것은?", max(4, 5));
  printf("4 와 5 중 큰 것은?", imax(4, 5));
  return 0;
}
```



  위 두 개의 `printf` 문 중에서 더 빠르게 실행되는 문장은 어떤 것일까요? 바로 아래의 `inline` 함수를 이용한 것입니다. 위와 같이 `max` 와 같은 단순한 작업을 함수로 만들 때 에는 인라인 함수를 사용하는 것이 훨씬 더 효율적입니다. 이미 잘 알고 계시겠지만 인라인 함수는 함수가 아니지요 (자세한 설명은 [21 강 – 매크로 함수, 인라인 함수](http://itguru.tistory.com/99)참조). 반면에 `max` 함수는 실제로 함수의 호출 과정 부터 해서 여러가지 작업이 필요한데, 정작 내부에서 수행하는 작업은 매우 단순하여 오히려 함수 내부에서 하는 작업 시간 보다 호출하는데 걸리는 시간이 더 큰 배보다 배꼽이 더 큰 격이 됩니다. 따라서 위와 같이 단순한 작업을 함수로 만들 경우 인라인 함수를 이용하는 것이 더 좋습니다.

#### 인자를 전달할 때에는 포인터를 이용해라

```cpp-formatted
struct big {
  int arr[1000];
  char str[1000];
};
```



위와 같은 매우 거대한 구조체가 있다고 합시다. 만일 이 구조체 변수의 `arr[3]` 값을 얻어 오는 함수를 만들고 싶다면 어떻게 해야 할까요? 물론 아래와 같이 프로그램을 짜는 사람도 있을 것입니다.

```cpp-formatted
void modify(struct big arg) { /* 무언가를 한다 */ }
```


하지만 이 함수를 호출하게 될 경우 `modify` 함수의 `arg` 인자로 구조체 변수의 모든 데이터가 복사가 되야 하는데 이는 엄청난 시간이 걸리게 됩니다. 말그대로 5000 바이트나 되는 데이터의 복사를 수행해야 할 뿐더러 `modify` 변수의 메모리 공간을 위한 할당도 따로 필요하기 때문이지요. 그렇다면 아래의 코드는 어떨까요?

```cpp-formatted
void modify(struct big *arg) { /* 무언가를 한다 */ }
```


위 함수는 구조체 변수의 주소값을 얻어옵니다. 이는 단순히 4 바이트의 주소값 복사만이 일어날 뿐 이전의 예와 같은 무지막지한 복사는 일어나지 않습니다. 뿐만 아니라 동일하게 인자로 전달된 구조체 변수의 데이터들도 손쉽게 읽어들일 수 있게 됩니다. 단순히 `arg->arr[3]` 과 같은 방식으로 말이지요. 여러분들은 언제나 이 점을 명심하시고 되도록 인자를 전달할 때에는 포인터를 자주 활용하시기 바랍니다.

그럼 이것으로 마지막 강좌를 끝내도록 하겠습니다~ 혹시 1 강 부터 시작해서 여기까지 도달하신 분이라면 [http://itguru.tistory.com/notice/126#/](http://itguru.tistory.com/notice/126#/)에 가셔서 자유 게시판에 꼭 글을 남겨주시기 바랍니다~


### 생각해보기

#### 문제 1

 다음의 글들을 읽어보세요
 [http://decoder.tistory.com/529](http://decoder.tistory.com/529)
 [http://www.azillionmonkeys.com/qed/optimize.html](http://www.azillionmonkeys.com/qed/optimize.html)


##@ chewing-c-end
Link :  128
2011-01-17 01:46
Link :  125
2011-01-17 01:30
----------------
title : 씹어먹는 C 언어 - <23 - 3. 파일 하고 이야기 하기 (파일 입출력 - 마무리)>
cat_title : 23 - 3. 파일 하고 이야기 하기 (파일 입출력 - 마무리)
next_page : 129
publish_date : 2011-01-17 01:30
--------------


이번 강좌에서는

* 지난 도서 관리 프로그램의 완성



![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분! 이제 슬슬 파일 입출력도 마무리를 해가며 저의 C 언어 강좌도 끝을 향해 달려갑니다. 이번 강좌에서는 파일 입출력을 이용한 여러 가지 프로그램을 만들어보면서 파일 입출력에 대해 조금 더 친해지도록 하지요 :)

지난 강좌에서 여러분들과 함께 도서 관리 프로그램을 열심히 만들었었습니다. 그리고 제가 여러분들께 '생각해보기' 로 입력을 받는 형태로 바꿔보자고 이야기 했었죠. 여러분들은 모두 해보셨나요? 아직 오랜 시간 고민을 하지 안 하신 분들은 살포시 뒤로가기를 눌러주시기 바랍니다.

```cpp-formatted
/* 도서 관리 프로그램의 전체 소스 코드*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct BOOK {
  char book_name[30];
  char auth_name[30];
  char publ_name[30];
  int borrowed;
};

typedef struct BOOK BOOK;
int register_book(BOOK *book_list, int *nth);
int search_book(BOOK *book_list, int total_num_book);
int borrow_book(BOOK *book_list);
int return_book(BOOK *book_list);
int print_book_list(BOOK *book_list, int total_num_book);
int retrieve_book_info(BOOK **book_list, int *total_num_book);
char compare(char *str1, char *str2);

int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */

  BOOK *book_list;
  int i;

  printf("도서관의 최대 보관 장서 수를 설정해주세요 : ");
  scanf("%d", &user_choice);

  book_list = (BOOK *)malloc(sizeof(BOOK) * user_choice);

  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");
    printf("6. 책들의 내용을 book_list.txt 에 출력 \n");
    printf("7. 책들의 내용을 book_list.txt 에서 불러옴 \n");
    printf("8. 책들의 목록을 출력 \n");

    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);

    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
      register_book(book_list, &num_total_book);
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
      search_book(book_list, num_total_book);
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
      borrow_book(book_list);
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
      return_book(book_list);
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    } else if (user_choice == 6) {
      /* book_list.txt 에 책들의 목록을 출력한다*/
      print_book_list(book_list, num_total_book);
    } else if (user_choice == 7) {
      /* book_list.txt 에서 책들의 목록을 가져온다*/
      retrieve_book_info(&book_list, &num_total_book);
    } else if (user_choice == 8) {
      /* 책들의 목록을 화면에 출력한다. */
      for (i = 0; i < num_total_book; i++) {
        printf("%s // %s // %s // ", book_list[i].book_name,
               book_list[i].auth_name, book_list[i].publ_name);
        if (book_list[i].borrowed == 0)
          printf("NO\n");
        else
          printf("YES\n");
      }
    }
  }

  free(book_list);
  return 0;
}
int print_book_list(BOOK *book_list, int total_num_book) {
  FILE *fp = fopen("book_list.txt", "w");
  int i;

  if (fp == NULL) {
    printf("출력 오류 ! \n");
    return -1;
  }

  fprintf(fp, "%d\n", total_num_book);

  for (i = 0; i < total_num_book; i++) {
    fprintf(fp, "%s\n%s\n%s\n", book_list[i].book_name, book_list[i].auth_name,
            book_list[i].publ_name);
    if (book_list[i].borrowed == 0)
      fprintf(fp, "NO\n");
    else
      fprintf(fp, "YES\n");
  }

  printf("출력 완료! \n");
  fclose(fp);

  return 0;
}
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}

/* 포인터인 book_list 의 값을 바꿔야 하므로 더블 포인터 형태 */
int retrieve_book_info(BOOK **book_list, int *total_num_book) {
  FILE *fp = fopen("book_list.txt", "r");
  int total_book;
  int i;
  char str[10];

  if (fp == NULL) {
    printf("지정한 파일을 찾을 수 없습니다! \n");
    return -1;
  }

  /* 찾았다면 전체 책의 개수를 읽어온다. */
  fscanf(fp, "%d", &total_book);
  (*total_num_book) = total_book;

  /* 기존의 book_list 데이터를 삭제 */
  free(*book_list);
  /* 그리고 다시 malloc 으로 재할당 한다. */
  (*book_list) = (BOOK *)malloc(sizeof(BOOK) * total_book);

  if (*book_list == NULL) {
    printf("\n ERROR \n");
    return -1;
  }
  for (i = 0; i < total_book; i++) {
    /* book_list[i]->book_name 이 아님에 유의!! */
    fscanf(fp, "%s", (*book_list)[i].book_name);
    fscanf(fp, "%s", (*book_list)[i].auth_name);
    fscanf(fp, "%s", (*book_list)[i].publ_name);
    fscanf(fp, "%s", str);

    if (compare(str, "YES")) {
      (*book_list)[i].borrowed = 1;
    } else if (compare(str, "NO")) {
      (*book_list)[i].borrowed = 0;
    }
  }

  fclose(fp);
  return 0;
}
/* 책을 추가하는 함수*/
int register_book(BOOK *book_list, int *nth) {
  printf("책의 이름 : ");
  scanf("%s", book_list[*nth].book_name);

  printf("책의 저자 : ");
  scanf("%s", book_list[*nth].auth_name);

  printf("책의 출판사 : ");
  scanf("%s", book_list[*nth].publ_name);

  book_list[*nth].borrowed = 0;
  (*nth)++;

  return 0;
}
/* 책을 검색하는 함수 */
int search_book(BOOK *book_list, int total_num_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];

  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);

  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);

  printf("검색 결과 \n");

  if (user_input == 1) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < total_num_book; i++) {
      if (compare(book_list[i].book_name, user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_list[i].book_name, book_list[i].auth_name,
               book_list[i].publ_name);
      }
    }

  } else if (user_input == 2) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < total_num_book; i++) {
      if (compare(book_list[i].auth_name, user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_list[i].book_name, book_list[i].auth_name,
               book_list[i].publ_name);
      }
    }

  } else if (user_input == 3) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < total_num_book; i++) {
      if (compare(book_list[i].publ_name, user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_list[i].book_name, book_list[i].auth_name,
               book_list[i].publ_name);
      }
    }
  }

  return 0;
}
int borrow_book(BOOK *book_list) {
  /* 사용자로 부터 책번호를 받을 변수*/
  int book_num;

  printf("빌릴 책의 번호를 말해주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &book_num);

  if (book_list[book_num].borrowed == 1) {
    printf("이미 대출된 책입니다! \n");
  } else {
    printf("책이 성공적으로 대출되었습니다. \n");
    book_list[book_num].borrowed = 1;
  }

  return 0;
}
int return_book(BOOK *book_list) {
  /* 반납할 책의 번호 */
  int num_book;

  printf("반납할 책의 번호를 써주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &num_book);

  if (book_list[num_book].borrowed == 0) {
    printf("이미 반납되어 있는 상태입니다\n");
  } else {
    book_list[num_book].borrowed = 0;
    printf("성공적으로 반납되었습니다\n");
  }

  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F126815394D2F31B9209A2B)

와 같이 여러가지 기능들이 잘 작동함을 알 수 있습니다.

일단, 저는 지난번 강좌의 '생각해보기' 에서 일컫은대로 `print_book_list` 함수의 파일 출력 형태를 수정하였습니다.

```cpp-formatted
int print_book_list(BOOK *book_list, int total_num_book) {
  FILE *fp = fopen("book_list.txt", "w");
  int i;

  if (fp == NULL) {
    printf("출력 오류 ! \n");
    return -1;
  }

  fprintf(fp, "%d\n", total_num_book);

  for (i = 0; i < total_num_book; i++) {
    fprintf(fp, "%s\n%s\n%s\n", book_list[i].book_name, book_list[i].auth_name,
            book_list[i].publ_name);
    if (book_list[i].borrowed == 0)
      fprintf(fp, "NO\n");
    else
      fprintf(fp, "YES\n");
  }

  printf("출력 완료! \n");
  fclose(fp);

  return 0;
}
```

일단 출력을 위해 `fprintf` 함수를 사용하고 있는데 문자열을 하나 출력할 때 마다 `\n` 을 넣어서 나중에 파일에서 입력받을 때 구분을 용이하게 하였습니다. `print_book_list` 함수는 상당히 간단하므로 설명은 이 정도에서 마치도록 하겠고요, 이제 가장 중요한 부분인 `retrieve_book_list` 함수에 대해 살펴봅시다.

```cpp-formatted
/* 포인터인 book_list 의 값을 바꿔야 하므로 더블 포인터 형태 */
int retrieve_book_info(BOOK **book_list, int *total_num_book) {
  FILE *fp = fopen("book_list.txt", "r");
  int total_book;
  int i;
  char str[10];

  if (fp == NULL) {
    printf("지정한 파일을 찾을 수 없습니다! \n");
    return -1;
  }

  /* 찾았다면 전체 책의 개수를 읽어온다. */
  fscanf(fp, "%d", &total_book);
  (*total_num_book) = total_book;

  /* 기존의 book_list 데이터를 삭제 */
  free(*book_list);
  /* 그리고 다시 malloc 으로 재할당 한다. */
  (*book_list) = (BOOK *)malloc(sizeof(BOOK) * total_book);

  if (*book_list == NULL) {
    printf("\n ERROR \n");
    return -1;
  }
  for (i = 0; i < total_book; i++) {
    /* book_list[i]->book_name 이 아님에 유의!! */
    fscanf(fp, "%s", (*book_list)[i].book_name);
    fscanf(fp, "%s", (*book_list)[i].auth_name);
    fscanf(fp, "%s", (*book_list)[i].publ_name);
    fscanf(fp, "%s", str);

    if (compare(str, "YES")) {
      (*book_list)[i].borrowed = 1;
    } else if (compare(str, "NO")) {
      (*book_list)[i].borrowed = 0;
    }
  }

  fclose(fp);
  return 0;
}
```


이 함수를 처음에 만들때 저는 살짝 실수를 했었는데요, 그것은 바로 인자의 형태를 잘못 생각하였기 때문입니다. 일단 이 함수에서 하는 일들을 살펴보자면



1. 기존의 프로그램상에 저장되어 있던 `book_list` 정보를 없앤다. (간단히 메모리를 `free` 한다고 생각하시면 됩니다)


1. 파일에서 입력받은 책의 수 많큼 `malloc` 으로 `book_list` 에 할당한다.


1. 파일에 책들에 관한 데이터들을 입력받는다.


으로 보실 수 있습니다. 먼저 1 번 작업을 하는 부분을 살펴봅시다.

```cpp-formatted
int retrieve_book_info(BOOK **book_list, int *total_num_book) {
  /*  ...(생략) ...*/

  /* 찾았다면 전체 책의 개수를 읽어온다. */
  fscanf(fp, "%d", &total_book);
  (*total_num_book) = total_book;

  /* 기존의 book_list 데이터를 삭제 */
  free(*book_list);
```


함수의 인자 부분이 굵은 글씨체로 되어 있는데 아마도 여러분들 중 많은 분들이 간과했을 부분 입니다. 우리는 이 함수에서 `malloc` 을 통해 `book_list` 를 다시 할당 하면서 `book_list` 의 값을 바꿔야 하는데요,이전의 저의 함수 강좌를 잘 보신 분들은 알겠지만 다른 함수에서 또다른 함수 내부에서 정의된 변수의 값을 바꾸기 위해서는 그 변수의 포인터를 인자로 전달해야 한다고 했습니다. 즉, `book_list` 를 가리키는 포인터, 이 때 `book_list` 가 `BOOK*` 형이므로 우리는 인자를 `BOOK**` 형으로 잡아야 한다는 것을 알 수 있지요.

이제 인자로 `book_list` 를 받았다면 위와 같이 `free` 를 통해 메모리 공간을 반환 함으로써 이전에 저장되어 있는 책 목록 데이터를 없앨 수 있습니다.

```cpp-formatted
/* 그리고 다시 malloc 으로 재할당 한다. */
(*book_list) = (BOOK *)malloc(sizeof(BOOK) * total_book);

if (*book_list == NULL) {
  printf("\n ERROR \n");
  return -1;
}
```


이제 두 번째 단계를 살펴보도록 합시다. 아까 위에서 `free` 함수를 통해 우리가 동적으로 할당하였던 `Heap` 공간에 있었던 데이터들은 날라가버렸습니다. 이제 다시 `malloc` 을 통해 책 목록에서 입력받는 `total_book` 의 크기 만큼 다시 할당 해야 겠지요? 따라서 위와 같이 `malloc` 함수를 통해 할당할 수 있게 됩니다.

여기서 중요한 부분은 위와 같이 `*book_list == NULL` 을 통해 `malloc` 으로 메모리 할당이 제대로 이루어졌는지 확인할 수 있습니다. 이는 마치 파일 입출력에서 `fp == NULL` 로 검사하는 것과 비슷한 이치 입니다.
```cpp-formatted
for (i = 0; i < total_book; i++) {
  /* book_list[i]->book_name 이 아님에 유의!! */
  fscanf(fp, "%s", (*book_list)[i].book_name);
  fscanf(fp, "%s", (*book_list)[i].auth_name);
  fscanf(fp, "%s", (*book_list)[i].publ_name);
  fscanf(fp, "%s", str);

  if (compare(str, "YES")) {
    (*book_list)[i].borrowed = 1;
  } else if (compare(str, "NO")) {
    (*book_list)[i].borrowed = 0;
  }
}
```

마지막으로 `for` 문을 통해서 파일로 부터 입력 받는 부분을 살펴봅시다. 여기서 `fscanf` 를 통해 문자열을 파일로 부터 입력을 받고 있는데 재미있는 부분은 `book_list` 의 구조체 변수들을 참조하는 과정 입니다. 왜 저렇게 어렵게 표현을 했을까요?

일단 `*book_list` 를 통해서 원래 `main` 함수의 `book_list` 배열을 가리킬 수 있습니다. 그리고 `(*book_list)[i]` 를 통해 그 배열의 `i` 번째 원소를 가리킬 수 있지요. 이 때 그 원소는 구조체 변수 입니다. 따라서 우리는 `(*book_list)[i].book_name` 을 통해 `main` 함수의 특정 책의 책 이름에 대한 정보를 지칭할 수 있게 되지요. 이를 전개해서 표현 시켜 보면

```cpp-formatted
(*(*book_list) + i)).book_name
```



이라 쓴 것과 동일한 표현이 됩니다. 그런데 문제는 이와 같이 포인터를 이용할 때 간혹 다음과 같이 쓰는 사람들이 있기 마련이죠.

```cpp-formatted
book_list[i]->book_name
```

사실 저도 처음에 이렇게 썼다가 봉변을 맞았었는데 이렇게 사용하면 컴파일 시에 오류가 나지도 않고 디버깅 해도 도대체 뭐가 문제인지 알기 어렵습니다. 원래는 `(*book_list)[i].book_name` 이라고 머리 속에 생각은 하고 위와 같은 코드가 튀어 나왔지요. 그런데 이 둘은 완전히 다른 문장 입니다. 무엇이 다른지는 말그대로 전개를 시켜보면 알 수 있습니다.

```cpp-formatted
(*book_list)[i].book_name == (*(*book_list + i)).book_name;
book_list[i]->book_name == (*(*(book_list + i))).book_name;
```



무엇이 다른지 확 눈에 보이시나요? 위의 식에서는 `book_list` 에 먼저 `*` 이 붙었고 아래 식에서는 `book_list + i` 에 먼저 `*` 이 붙었습니다. 우리가 원하던 내용은 `book_list` 에 `*` 이 붙어서 `main` 함수의 실제 `book_list` 를 의미한 뒤 `+ i` 를 해서 원소를 참조하는 것이지 후자 처럼 존재하지도 않는 `book_list` 의 `i` 번째 원소를 참조하여 말도 안되는 식을 의도하는 것은 아닙니다.

아무튼 이렇게 해서 성공적으로 도서 관리 프로그램에 대한 파일 입출력을 수행 할 수 있게 됩니다.


이것으로 해서 파일 입출력에 관한 강좌는 끝내도록 하겠습니다. 기타 파일 입출력에 관한 함수들에 대해 설명하는 것은 무의미한 행동이므로 파일 입출력에 관련한 함수들을 더욱 알고 싶다면 [C 언어 레퍼런스를 참조](http://itguru.tistory.com/34)하시기 바랍니다 (특히 보셔야 할 부분은 `stdio.h` 부분이지요).


이제 여기 까지 도달하셨다면 여러분은 C 언어에 대한 기초적인 모든 부분을 학습하셨다고 해도 과언이 아닙니다. 여러분의 손에는 이제 훌륭한 조각칼이 들려있는 셈입니다. 이 조각칼로 여러분의 능력에 따라 멋진 조각품을 만들어 낼 수 있듯이 C 언어라는 훌륭한 도구를 통해서 최고의 프로그램을 만들 수 있게 될 것입니다.

저의 C 언어 강좌는 이제 마지막 강좌를 남겨두고 있습니다. 사실 여기서 강좌를 끝내도 무방하고, 여러분들은 여기까지 강좌를 읽으셨다면 축하 파티를 하셔도 됩니다! 마지막 강좌는여러분들이 실제로 프로그래밍을 하면서 여러가지 실수들을 하실 텐데 이를 대비하기 위한 오류 해결책들에 대해 이야기 해보려고 합니다. 여러 골치 아픈 오류들을 만났을 때 꽤 도움이 많이 될 듯 합니다.  여러분들이 실제로 프로그래밍을 하면서 피가 되고 살이 될 '코드 최적화' 에 대해서 이야기 하고자 합니다. 우리가 흔히 느끼기에 똑같은 한국말을 해도 어떤 사람은 말을 참 잘하지만 어떠한 사람은 말을 참 못한다고 생각 하는 경우가 있습니다. C 언어도 마찬가지 입니다. 저의 C 언어 강좌는 여기서 끝났지만 C 언어 자체를 안다고 해도 모두다 훌륭한 코드를 쓸 수 있는 것은 아닙니다. 따라서 다음 강좌에서는 여러분이 훌륭한 코드에 조금이니마 근접한 코드를 쓸 수 있도록 도와 줄 코드 최적화에 대해서 이야기 할 것입니다.

### 생각해보기

#### 문제 1

책들의 목록을 `html` 형식에 맞게 출력하여 표로 깔끔하게 보여질 수 있게 해보세요. `html` 문법은 [http://www.w3schools.com/html/default.asp](http://www.w3schools.com/html/default.asp)에서 배우실 수 있습니다. (난이도 : 上)

##@ chewing-c-end
Link :  123
2011-01-10 22:57
----------------
title : 씹어먹는 C 언어 - <23 - 2. 파일 하고 이야기 하기 (파일 입출력)>
cat_title : 23 - 2. 파일 하고 이야기 하기 (파일 입출력)
next_page : 125
publish_date : 2011-01-10 22:57
--------------

이번 강좌에서는


* 파일 위치 지시자(File `Position Indicator)` 에 대한 이해

* `fseek` 함수 다루기

* `fopen` 에서 `"r+", "w+", "a", "a+"` 형태에 대해 배우고, 쓰기/읽기 전환 시 문제점에 대해 알기

* `fprintf` 함수와 `fscanf` 함수를 사용하기

* 도서 관리 프로그램에 입출력 처리 적용하기

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요~ 여러분. 파일 입출력의 관한 두 번째 강좌 입니다! 사실 지난번에는 뭔가 아쉬움이 남게 끝냈었습니다. 파일 입출력으로 무언가 제대로된 프로그램도 만들어 보지 않고 단순히 어떻게 사용하는지에 대해서만 간단히 다루어 보았었는데 이번에는 본격적으로 파일 입출력을 이용해서 무언가를 해보도록 하겠습니다.


### 파일 위치 지시자(File Position Indicator)

지난번에 파일 위치 지시자에 관해서 대충 설명하고 나갔는데요, 지난번의 설명이 무언가 부족하다는 느낌이 강하게 들어서 여기서 다시 한번 짚고 넘어가도록 하겠습니다.  스트림의 기본 모토는 바로 ‘순차적으로 입력을 받는다’ 입니다.

즉 스트림에서 데이터를 입력 받을 때 에는 질서 정연하게 앞에 있는 데이터 먼저 순서대로 읽어들이게 되죠. 뒤에서 부터 거꾸로 읽는다나 데이터들을 뛰어 넘으며 읽어 들인다는 듯한 비정상적인 짓들을 하지 않습니다. 이렇게 순차적으로 읽어들이는 것을 가능하게 해주는 것이 바로 ‘파일 위치 지시자’ 때문입니다.

```cpp-formatted
/* 파일에서 문자를 하나씩 입력 받는다 */
#include <stdio.h>

int main() {
  FILE *fp = fopen("some_data.txt", "r");
  char c;

  if (fp == NULL) {
    printf("file open error ! \n");
    return 0;
  }

  while ((c = fgetc(fp)) != EOF) {
    printf("%c", c);
  }
}
```




성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F206F774A4D29DC64132DAF)



참고로 아래는 `some_data.txt` 에 들어 있엇던 내용입니다. 당연하게도 화면에 출력된 내용과 정확히 일치합니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1666014A4D29DC642A3D72)




  위 소스 코드에서 흥미로왔던 점은 없나요? 사실 이전 강좌에서도 다루었던 예제이지만 무언가 궁금한 점이 있을 것입니다. 바로 `fgetc(fp)` 를 실행할 때 마다 파일에 그 다음 문자를 입력 받는 다는 점이지요. 컴퓨터는 어떻게 어디까지 읽어들었는지를 알고 이전에 입력 받았던 문자 바로 다음 문자를 입력 받는 것일까요? 그 이유는 간단합니다. 다음에 입력 받을 위치를 미리 표시해 놓으면 되지요. 이렇게 '다음에 입력 받아야 할 위치' 를 기억해 놓은 것을 '파일 위치 지시자' 가 하는 일입니다. 파일 위치 지시자는 파일에서 다음에 입력 받을 부분의 위치를 가리키고 있습니다.
  예를 들어 위 예제에서 `fgetc` 를 세 번 호출했다고 해봅시다. 그렇다면 파일 위치 지시자는 아래 그림과 같은 위치를 가리키고 있게 됩니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F196F7D564D29DE910B763E)


  어때요? 간단하지요. `fgetc` 를 호출하기 전에는 `T` 를 가리켰다가 한 번 호출하면 `H,` 두 번 호출하면 `E,` 세번 호출하면 `R` 을 가리키게 되지요. 따라서 다음번 `fgetc` 호출에서는 `R` 을 읽어들이고 파일 위치 지시자를 한 칸 옆으로 이동시킵니다.
  이렇게 파일 위치 지시자가 다음으로 한 칸 씩 움직이는 바람에 데이터를 순차적으로 읽어들일 수 있게 되는 것이지요. 하지만 놀랍게도 C 언어에서는 파일 위치 지시자의 위치를 사용자 마음대로 바꿀 수 있게 해주는 여러가지 함수들을 지원해주고 있습니다. 그 중 대표적으로 가장 많이 사용하는 `fseek` 함수가 있지요. `fseek` 함수는 다음과 같이 생겼습니다. (자세한 설명은 [ C 언어 함수 레퍼런스 - fseek 함수](http://itguru.tistory.com/72)를 참조하세요)

```info
int fseek ( FILE * stream, long int offset, int origin );
```



  여기서 `stream` 에는 우리가 파일 위치 지시자를 옮기고 싶은 스트림의 포인터를, `origin` 에는 어디서 부터 옮길지, 그리고 `offset` 에는 얼마만큼 옮길지에 대한 정보가 들어가게 됩니다. 참고로 `origin` 에는 `SEEK_SET, SEEK_CUR, SEEK_END` 들이 있는데 각각 파일의 시작, 현재 파일 위치 지정자의 위치, 파일의 끝을 의미합니다. 그리고 `offset` 에는 `origin` 으로 부터 얼마나 옮길 것인지 숫자를 써주면 됩니다. 재미있는 점은 `+` 값을 쓰면 오른쪽으로 (위의 사진을 기준으로), - 값을 쓰면 왼쪽으로 파일 위치 지정자가 움직입니다.

```cpp-formatted
/* fseek 함수 예제 */
#include <stdio.h>
int main() {
  FILE *fp = fopen("some_data.txt", "r");
  char data[10];
  char c;

  if (fp == NULL) {
    printf("file open error ! \n");
    return 0;
  }

  fgets(data, 5, fp);
  printf("입력 받은 데이터 : %s \n", data);

  c = fgetc(fp);
  printf("그 다음에 입력 받은 문자 : %c \n", c);

  fseek(fp, -1, SEEK_CUR);

  c = fgetc(fp);
  printf("그렇다면 무슨 문자가? : %c \n", c);

  fclose(fp);
}
```


성공적으로 컴파일 하였다면



![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1203C2554D2A94FE0D0274)



와 같이 나오는 것을 볼 수 있습니다. 참고로, `some_data.txt` 에 있었던 내용은 이전 내용과 동일하게 `There is some data in this FILE!!!!` 입니다. 소스를 살펴보자면,



```cpp-formatted
fgets(data, 5, fp);
```



  위와 같이 `fgets` 함수를 통해서 `fp` 로 부터 입력을 받습니다. 이 때, 문자열 형태로 입력을 받는데 입력을 받을 때 \n 이 나올 때 까지 입력을 받거나 (두번째 인자의 크기 `- 1)` 만큼 입력을 받을 때 까지 입력을 받게 됩니다. 위 경우 \n 이 나오기 전에 4 바이트 만큼 입력을 받으므로 `data` 에는 "Ther" 이란 내용의 문자열이 들어갑니다. 참고적으로 왜 1 만큼 뺀 크기로 입력을 받냐면, `data` 에 문자열을 구성하기 위해 맨 뒤에는 언제나 `NULL` 문자를 위한 자리를 만들어주어야 하기 때문이죠.
  이렇게 입력을 받게 된다면 이제 파일 위치 지정자는 `e` 를 가리키게 됩니다.





```cpp-formatted
c = fgetc(fp);
printf("그 다음에 입력 받은 문자 : %c \n", c);
```



  그 다음에 `fgetc` 로 `fp` 에서 문자를 받아 오면 역시 생각했던 대로 `e` 가 출력이 되겠지요. 그리고 파일 위치 지정자는 다시 한 칸 옆으로 옮겨가서 ' ' 을 가리키게 됩니다. 띄어쓰기도 엄연한 문자이지요. (즉, 띄어쓰기에도 `ASCII` 값이 당연히 대응되어 있습니다)


```cpp-formatted
fseek(fp, -1, SEEK_CUR);
```



  드디어 `fseek` 함수를 사용했습니다. 앞에서 말했듯이 `SEEK_CUR` 은 현재 파일 위치 지정자의 위치를 나타내고, 두번째 인자로 -1 을 전달했으므로 왼쪽으로 1 만큼 옮기라는 것이지요. 즉, 현재 파일 위치 지정자의 위치에서 왼쪽으로 1 만큼 다시 옮겼으니 ' ' 을 가리키고 있던 파일 위치 지정자가 이전의 'e' 를 가리키게 됩니다. 따라서 다시
```cpp-formatted
c = fgetc(fp);
printf("그렇다면 무슨 문자가? : %c \n", c);
```


을 호출하여 문자를 입력 받으면 다시 `e` 가 나오게 되는 것이지요. 어때요. 간단하지요?

```cpp-formatted
/* 파일의 마지막 문자를 보기*/
#include <stdio.h>

int main() {
  FILE *fp = fopen("some_data.txt", "r");
  char data[10];
  char c;

  if (fp == NULL) {
    printf("file open error ! \n");
    return 0;
  }

  fseek(fp, -1, SEEK_END);
  c = fgetc(fp);
  printf("파일 마지막 문자 : %c \n", c);

  fclose(fp);
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F15610F344D2AA01C1C69E1)

와 같이 잘 나옵니다. 참고로 `some_data.txt` 에는 여태까지 위에서 써왔던 데이터인 `There is some data in this FILE!!!!` 가 들어있습니다. 이 때 이 파일의 마지막 문자는 `!` 가 되겠지요.

```cpp-formatted
fseek(fp, -1, SEEK_END);
```


   위 소스에서 가장 중요한 부분은 딱 위 하나 입니다. 파일 위치 지정자를 파일의 맨 끝에서 한 칸 왼쪽으로 간 부분으로 옮깁니다. 왜 한 칸 왼쪽으로 옮기냐면, 맨 끝으로 옮기게 되면 그 부분에는 `EOF` (파일의 끝) 을 나타내는 것이 들어 있기 때문에 우리가 원하는 결과가 아니게 되지요. 우리가 파일에 입력한 맨 마지막 문자는 `EOF` 바로 왼쪽에 위치한 `!` 가 됩니다.




### 파일에 쓰기, 읽기 같이 하기


  여태까지 여러분은 하나의 파일에 읽기 또는 쓰기 작업을 한 번에 하나씩 밖에 할 수 없었습니다. 그런데 다행스럽게도 `fopen` 에는 하나의 파일에 대해 읽기/쓰기를 모두 할 수 있는 방법을 지원해줍니다.

```cpp-formatted
/* fopen 의 "r+" 인자 이용해보기 */
#include <stdio.h>
int main() {
  FILE *fp = fopen("some_data.txt", "r+");
  char data[100];

  fgets(data, 100, fp);
  printf("현재 파일에 있는 내용 : %s \n", data);

  fseek(fp, 5, SEEK_SET);

  fputs("is nothing on this file", fp);

  fclose(fp);
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F202B06554D2AAC4813A052)

와 같이 잘 나옵니다. 그리고 수정된 `some_data.txt` 의 모습은 아래와 같습니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1827FB554D2AAC491AC05D)

아주 잘 되는군요. 일단 맨 처음에

```cpp-formatted
FILE *fp = fopen("some_data.txt", "r+");
```


같이 하였습니다. 이는 `some_data.txt` 를 "읽기 및 쓰기형식으로 열겠다" 라는 뜻인데, 파일이 존재하지 않는다면 열지를 않겠다는 의미 입니다. 만일 파일이 존재한다면 파일의 내용을 지우지 않지요. 반면에 뒤에서 배울 "w+" 도 "읽기 및 쓰기 형식으로 열겠다" 이지만, 이 경우 파일이 존재하지 않는다면 파일을 새로 만들고 파일이 존재한다면 파일의 내용을 싹 지워버리게 됩니다.

```cpp-formatted
fgets(data, 100, fp);
printf("현재 파일에 있는 내용 : %s \n", data);
```


를 통해 파일의 있는 내용들을 모두 읽어들였습니다 (정확히 말하면 최대 100 바이트 까지 읽지만 우리의 파일의 내용은 100 바이트 보다 작으므로 모두 읽어들여다고 보면 됩니다). 그리고 이와 함께 파일 위치 지정자도 파일 맨 끝을 가리키고 있겠지요.

```cpp-formatted
fseek(fp, 5, SEEK_SET);
```


이에 위와 같이 `fseek` 함수를 이용하여 파일의 맨 앞에서 5 칸 떨어진 곳으로 이동해봅시다. 0 칸 떨어졌을 때는 `T, 1` 칸은 `h, ...` 와 같은 방식으로 세보면 5 칸 떨어진 곳은 ' ' 임을 알 수 있습니다. (공백 문자가 위치한 곳) 그리고 이제 여기에

```cpp-formatted
fputs("is nothing on this file", fp);
```


를 하게 되면 이전에 있던 내용은 무시하고 `is nohting on this file` 이 차지하는 만큼 덮어 씌우기가 됩니다. 따라서 위의 사진에서도 나타나듯이 파일에 위와 같이 나타나게 되지요.

```cpp-formatted
/* 특정한 파일을 입력 받아서 소문자를 대문자로, 대문자를 소문자로 바꾸는
 * 프로그램*/
#include <stdio.h>
int main() {
  FILE *fp = fopen("some_data.txt", "r+");
  char c;

  if (fp == NULL) {
    printf("파일 열기를 실패하였습니다! \n");
    return 0;
  }

  while ((c = fgetc(fp)) != EOF) {
    /* c 가 대문자일 경우 */
    if (65 <= c && c <= 90) {
      /* 한 칸 뒤로 가서*/
      fseek(fp, -1, SEEK_CUR);
      /* 소문자로 바뀐 c 를 출력한다*/
      fputc(c + 32, fp);

    }
    /* c 가 소문자일 경우*/
    else if (97 <= c && c <= 122) {
      fseek(fp, -1, SEEK_CUR);
      fputc(c - 32, fp);
    }
  }

  fclose(fp);
}
```

성공적으로 컴파일 하였다면 원래는 아래와 같은 파일이


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1404963D4D2AB75D190A83)

와 같이 괴상하게 변해버렸습니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F187FE03D4D2AB75D1FD0D9)

사실 프로그램이 종료 되지도 않아서 강제로 종료해야만 했었습니다.

도대체 왜 이런 일이 발생한 것일까요?

```cpp-formatted
while ((c = fgetc(fp)) != EOF) {
  /* c 가 대문자일 경우 */
  if (65 <= c && c <= 90) {
    /* 한 칸 뒤로 가서*/
    fseek(fp, -1, SEEK_CUR);
    /* 소문자로 바뀐 c 를 출력한다*/
    fputc(c + 32, fp);

  }
  /* c 가 소문자일 경우*/
  else if (97 <= c && c <= 122) {
    fseek(fp, -1, SEEK_CUR);
    fputc(c - 32, fp);
  }
```


위 소스를 보면 큰 문제는 없어 보입니다. 일단 대문자일 경우만 살펴보면 `ASCII` 표를 보면 영어 대문자의 경우 값이 `65 ~ 90` 에 있으므로 위와 같이 `if` 문을 설정하면 대문자들을 처리할 수 있습니다.

```cpp-formatted
/* 한 칸 뒤로 가서*/
fseek(fp, -1, SEEK_CUR);
/* 소문자로 바뀐 c 를 출력한다*/
fputc(c + 32, fp);
```


  사실 위 과정에서는 문제가 없습니다.
  예를 들어서 `What?` 이란 문자열이 있을 때 `c` 에 `W` 가 들어있다면 현재 파일 위치 지시자는 그 다음인 `h` 를 가리키고 있을 것입니다. 따라서 `w` 부분에 `W` 를 쓰기 위해 파일 위치 지시자를 한 칸 뒤로 옮겨서 `w` 를 가리키게 하고, `fputc` 를 통해 (c 에 32 를 더한 값, 아스키 코드표를 보면 그 대문자에 해당하는 소문자값 임을 알 수 있다) 을 써서 결과적으로 `what?` 가 됩니다.

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F170CE3404D2ABADE2D991F)

그런데 도대체 무엇이 문제일까요? 사실 그 이유는 간단합니다.

스트림 작업에서 읽기/쓰기 를 변환할 때 에는 반드시 `fflush` 함수를 호출하거나 `fseek` 이나 `rewind` 와 같은 함수를 호출하여 파일 위치 지정자를 다시 설정해주어야 하기 때문(자세한 내용은 [fopen 함수 레퍼런스](http://itguru.tistory.com/58)를 참조)입니다. 따라서 반드시 위와 같이 쓰기 작업 후 다시 읽기 작업 (while 문에서 fputc 를 통해 읽기 작업이 수행된다) 을 할 때 에는 `fflush` 나 `fseek` 함수를 호출해 주시기 바랍니다.

이를 토대로 코드를 수정해보았습니다.

```cpp-formatted
#include <stdio.h>

int main() {
  FILE *fp = fopen("some_data.txt", "r+");
  char c;

  if (fp == NULL) {
    printf("파일 열기를 실패하였습니다! \n");
    return 0;
  }

  while ((c = fgetc(fp)) != EOF) {
    /* c 가 대문자일 경우 */
    if (65 <= c && c <= 90) {
      /* 한 칸 뒤로 가서*/
      fseek(fp, -1, SEEK_CUR);
      /* 소문자로 바뀐 c 를 출력한다*/
      fputc(c + 32, fp);
      /*

      쓰기 - 읽기 모드 전환을 위해서는 무조건
      fseek 함수와 같은 파일 위치 지정자 설정 함수들을
      호출해야 한다.

      */
      fseek(fp, 0, SEEK_CUR);
    }
    /* c 가 소문자일 경우*/
    else if (97 <= c && c <= 122) {
      fseek(fp, -1, SEEK_CUR);
      fputc(c - 32, fp);
      fseek(fp, 0, SEEK_CUR);
    }
  }

  fclose(fp);
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1404963D4D2AB75D190A83)

위와 같았던 파일 내용이


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F15787D3D4D2AB75D3556F0)

아래와 같이 예쁘게 바뀝니다.
```cpp-formatted
/*

쓰기 - 읽기 모드 전환을 위해서는 무조건
fseek 함수와 같은 파일 위치 지정자 설정 함수들을
호출해야 한다.

*/
fseek(fp, 0, SEEK_CUR);
```


위 소스에서 굳이 파일 위치 지정자 의 위치를 옮길 필요가 없음에도 불구하고 `fseek` 함수를 통해 파일 위치 지정자를 설정하였습니다. 사실 위와 같이 `fseek` 함수를 호출하면 파일 위치 지정자는 하나도 옮겨지지 않습니다. 단순히 쓰기작업에서 읽기 작업으로 바꾸기 위해 `fseek` 함수를 호출한 것 뿐이지요.

만일 위의 `fseek` 이 마음에 들지 않는다면

```cpp-formatted
/* 한 칸 뒤로 가서*/
fseek(fp, -1, SEEK_CUR);
/* 소문자로 바뀐 c 를 출력한다*/
fputc(c + 32, fp);

fflush(fp);
```


로 하셔도 됩니다. 아무튼 `fseek` 이든 `fflush` 함수든 호출해 주어야만 합니다.



### `fopen` 함수의 기타 인자 사용


```cpp-formatted
/* fopen 의 'append' 기능 사용*/
#include <stdio.h>
int main() {
  FILE *fp = fopen("some_data.txt", "a");
  char c;
  if (fp == NULL) {
    printf("파일 열기를 실패하였습니다! \n");
    return 0;
  }
  /* 아래 내용이 파일 뒤에 덧붙여진다.*/
  fputs("IS ADDED HAHAHAHA", fp);
  fclose(fp);
}
```

성공적으로 컴파일 하였다면아래와 같았던 파일 내용이


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F153F80554D2ABDF3340478)

아래 처럼 바뀝니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F113F13554D2ABDF4337D6B)

  `fopen` 부분을 살펴보면

```cpp-formatted
FILE *fp = fopen("some_data.txt", "a");
```


  로 파일을 "a" 형식을 열었습니다. 이 뜻은 파일을 '덧붙이기(append)' 형식으로 연다는 의미입니다. 기존의 "w" 로 열었을 때에는 파일의 내용이 모두 지워지는 대신에 맨 앞부터 내용이 쓰여졌는데 덧붙이기 형식에서는 파일의 맨 끝부분 부터 내용이 쓰여지고 앞 부분은 전혀 건들여지지 않습니다. 즉, 이전에 파일에 들어가 있었던 내용들은 아주 소중하게 보호가 됩니다.

"r+" 나 "w+" 와 마찬가지로 "a+" 형식도 있는데 이도 마찬가지로 읽기/덧붙이기 를 번갈아가면서 할 수 있습니다. 참고로 읽는 작업은 파일 어디에서든지 사용할 수 있지만 쓰기 작업의 경우 아무리 파일 위치 지시자를 이동 시켜 보아도 '기존파일의 끝 부분 위치' 에서 부터만 쓸 수 있습니다.



### `fscanf` 사용하기




```cpp-formatted
/* fscanf 이용하기 */
#include <stdio.h>

int main() {
  FILE *fp = fopen("some_data.txt", "r");
  char data[100];

  if (fp == NULL) {
    printf("파일 열기 오류! \n");
    return 0;
  }

  printf("---- 입력 받은 단어들 ---- \n");

  while (fscanf(fp, "%s", data) != EOF) {
    printf("%s \n", data);
  }

  fclose(fp);
}
```


  성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F115F7C394D2AA3EE029D1D)

와 같이 잘 나옵니다. `fscanf` 함수는 우리가 여태까지 사용해왔던 `scanf` 함수와 아주 아주 유사한데, 사실 `scanf` 가 `stdin` 에서만 입력을 받고 `fscanf` 는 임의의 스트림에서도 입력을 받을 수 있는 좀더 일반화 된 함수라고 보시면 됩니다.

`fscanf` 함수의 첫번째 인자로 입력을 받을 스트림을 써주게 되는데, 따라서

```cpp-formatted
fscanf(stdin, "%s", data);
scanf("%s", data);
```

는 정확히 일치하는 문장들 입니다. 아무튼 `fscanf` 는 사용자가 지정한 형식에 맞게 데이터를 읽어오게 되는데 `fgets` 와는 달리 띄어쓰기나 탭 문자들도 모두 인식하므로 위와 같이 각각의 단어들을 읽어오는데 요긴하게 사용할 수 있습니다.

```cpp-formatted
while (fscanf(fp, "%s", data) != EOF) {
  printf("%s \n", data);
}
```


  일단 위 소스에서 가장 중요한 부분을 봅시다. `fscanf` 를 통해 `fp` 에서 문자열을 읽어오고 있는데 `fgets` 는 \n 이 나올 때 까지 하나의 문자열로 보고 받아들이지만 `fscanf` 는 띄어쓰기나 탭 문자(\t), \n 들 중 어느 하나가 나올 때 까지 입력 받으므로 파일에서는 각 단어들을 하나씩 읽어들이게 됩니다. 물론 읽어 들인 만큼 파일 위치 지정자는 이동하게 되지요. 이 때 `fscanf` 가 더이상 새로운 데이터를 입력을 받을 수 없을 경우에는 `EOF` 를 리턴하게 됩니다. 즉, 파일의 끝에 도달하면 `EOF` 를 리턴하여 `while` 문을 빠져나갑니다.

```cpp-formatted
/* 파일에서 'this' 를 'that' 으로 바꾸기*/
#include <stdio.h>
#include <string.h>

int main() {
  FILE *fp = fopen("some_data.txt", "r+");
  char data[100];

  if (fp == NULL) {
    printf("파일 열기 오류! \n");
    return 0;
  }

  while (fscanf(fp, "%s", data) != EOF) {
    if (strcmp(data, "this") == 0) {
      fseek(fp, -(long)strlen("this"), SEEK_CUR);
      fputs("that", fp);

      fflush(fp);
    }
  }

  fclose(fp);
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1622D03A4D2AC95E15E280)

위와 같았던 파일이


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1128033A4D2AC9630CFAC8)

아래 처럼 `this` 들이 모두 `that` 으로 바뀐 것을 보실 수 있습니다. 사실 그 원리는 아주 간단합니다.

```cpp-formatted
while (fscanf(fp, "%s", data) != EOF) {
  if (strcmp(data, "this") == 0) ```

이전 예제에서와 같은 방식으로 `fscanf` 들을 통해 파일에서 단어들을 입력받는데, 각각의 단어들을 `strcmp` 함수를 이용하여 `this` 와 같은지 비교를 하지요. 만일 같다면 이제 `this` 를 `that` 으로 덮어 씌우기만 하면 됩니다.

```cpp-formatted
fseek(fp, -(long)strlen("this"), SEEK_CUR);
fputs("that", fp);
```

`fscanf` 에서 “this” 를 입력 받은 시점에서 파일 위치 지정자는 `this` 바로 다음 문자를 가리키고 있으므로 “this” 의 길이만큼 왼쪽으로 이동시킨다면 파일 위치 지정자는 `t` 를 가리키게 되지요. 이제 이 상태에서 `fputs` 로 “that” 을 쓴다면 “this” 가 들어가 있던 자리에 “that” 이 정확히 자리를 대체하게 됩니다. 그리고 마지막으로

```cpp-formatted
fflush(fp);
```

위 쓰기 작업이 끝나면 다시 `while` 문에서 `fscanf` 로 읽기 작업을 하게 되므로 `fflush` 를 사용해 주어야만 합니다. 물론 이전 처럼 `fseek` 를 사용하셔도 되고요

### 파일 입출력 실제로 적용해보기



이제 본격적으로 파일 입출력을 이용해서 무언가를 해보아야 겠죠?
가장 먼저 여태가지 만들어보았던 도서 관리 프로그램에 입출력 기능을 적용시켜봅시다.

일단 아래는 입출력 기능을 적용시키기 전 단계의 도서 관리 프로그램으로 여태까지 배운 새로운 기술들을 이용하여 작성하였습니다.




```cpp-formatted
/*
지난번에 만들었었던 도서 관리 프로그램으로 우리가 여태까지 배운 최신 C 언어
기술들(!!) 을 이용하여 새롭게 만들었습니다.어떻게 보면
http://itguru.tistory.com/60 의 생각해 볼 문제의 두번째 문제의 해답이 되기도
하겠군요*/
#include <stdio.h>
#include <stdlib.h>
struct BOOK {
  char book_name[30];
  char auth_name[30];
  char publ_name[30];
  int borrowed;
};
typedef struct BOOK BOOK;
char compare(char *str1, char *str2);
int register_book(BOOK *book_list, int *nth);
int search_book(BOOK *book_list, int total_num_book);
int borrow_book(BOOK *book_list);
int return_book(BOOK *book_list);
int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */
  BOOK *book_list;
  printf("도서관의 최대 보관 장서 수를 설정해주세요 : ");
  scanf("%d", &user_choice);
  book_list = (BOOK *)malloc(sizeof(BOOK) * user_choice);
  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");
    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);
    if (user_choice == 1) { /* 책을 새로 추가하는 함수 호출 */
      register_book(book_list, &num_total_book);
    } else if (user_choice == 2) { /* 책을 검색하는 함수 호출 */
      search_book(book_list, num_total_book);
    } else if (user_choice == 3) { /* 책을 빌리는 함수 호출 */
      borrow_book(book_list);
    } else if (user_choice == 4) { /* 책을 반납하는 함수 호출 */
      return_book(book_list);
    } else if (user_choice == 5) { /* 프로그램을 종료한다. */
      break;
    }
  }
  free(book_list);
  return 0;
} /* 책을 추가하는 함수*/
int register_book(BOOK *book_list, int *nth) {
  printf("책의 이름 : ");
  scanf("%s", book_list[*nth].book_name);
  printf("책의 저자 : ");
  scanf("%s", book_list[*nth].auth_name);
  printf("책의 출판사 : ");
  scanf("%s", book_list[*nth].publ_name);
  book_list[*nth].borrowed = 0;
  (*nth)++;
  return 0;
} /* 책을 검색하는 함수 */
int search_book(BOOK *book_list, int total_num_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];
  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);
  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);
  printf("검색 결과 \n");
  if (user_input ==
      1) { /*        i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을
              사용자가 입력한 검색어와 비교하고 있다.        */
    for (i = 0; i < total_num_book; i++) {
      if (compare(book_list[i].book_name, user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_list[i].book_name, book_list[i].auth_name,
               book_list[i].publ_name);
      }
    }
  } else if (user_input ==
             2) { /*        i 가 0 부터 num_total_book 까지 가면서 각각의 지은이
                     이름을        사용자가 입력한 검색어와 비교하고 있다. */
    for (i = 0; i < total_num_book; i++) {
      if (compare(book_list[i].auth_name, user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_list[i].book_name, book_list[i].auth_name,
               book_list[i].publ_name);
      }
    }
  } else if (user_input == 3) { /*        i 가 0 부터 num_total_book 까지 가면서
                                   각각의 출판사를        사용자가 입력한
                                   검색어와 비교하고 있다.        */
    for (i = 0; i < total_num_book; i++) {
      if (compare(book_list[i].publ_name, user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_list[i].book_name, book_list[i].auth_name,
               book_list[i].publ_name);
      }
    }
  }
  return 0;
}
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }
    str1++;
    str2++;
  }
  if (*str2 == '\0') return 1;
  return 0;
}
int borrow_book(BOOK *book_list) { /* 사용자로 부터 책번호를 받을 변수*/
  int book_num;
  printf("빌릴 책의 번호를 말해주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &book_num);
  if (book_list[book_num].borrowed == 1) {
    printf("이미 대출된 책입니다! \n");
  } else {
    printf("책이 성공적으로 대출되었습니다. \n");
    book_list[book_num].borrowed = 1;
  }
  return 0;
}
int return_book(BOOK *book_list) { /* 반납할 책의 번호 */
  int num_book;
  printf("반납할 책의 번호를 써주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &num_book);
  if (book_list[num_book].borrowed == 0) {
    printf("이미 반납되어 있는 상태입니다\n");
  } else {
    book_list[num_book].borrowed = 0;
    printf("성공적으로 반납되었습니다\n");
  }
  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F134BA8504D29D1221117EE)

와 같이 여러가지 재미있는 것들을 할 수 있습니다.

위 소스에서는 여태까지 배운 것들을 대부분 사용하였는데요, 예를 들면

```cpp-formatted
struct BOOK {
  char book_name[30];
  char auth_name[30];
  char publ_name[30];
  int borrowed;
};

typedef struct BOOK BOOK;
```

을 통해서 귀찮게 'struct BOOK' 이라고 매번 써야 하는 대신에 'BOOK' 이라고 해도 'struct BOOK' 의 의미를 지니게 하였습니다. 참고적으로 위 문장들은

```cpp-formatted
typedef struct BOOK {
  char book_name[30];
  char auth_name[30];
  char publ_name[30];
  int borrowed;
} BOOK;
```

와 같이 써도 동일한 의미를 지닙니다.

또한 재미있는 부분은로 다음과 같이 동적할당을 이용하였는데

```cpp-formatted
printf("도서관의 최대 보관 장서 수를 설정해주세요 : ");
scanf("%d", &user_choice);

book_list = (BOOK *)malloc(sizeof(BOOK) * user_choice);
```

위와 같이 하여서 `book_list` 의 책들의 최대 보관 개수를 지정하여 그 크기에 딱 맞는 배열을 생성하도록 하였습니다. 이전과 함수의 모습도 많이 달라졌는데

```cpp-formatted
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book);
int borrow_book(int *borrowed);
int return_book(int *borrowed);
```

가 기존의 구조체를 쓰지 않았을 때의 함수들의 모습이라면 아래는

```cpp-formatted
int register_book(BOOK *book_list, int *nth);
int search_book(BOOK *book_list, int total_num_book);
int borrow_book(BOOK *book_list);
int return_book(BOOK *book_list);
```

구조체를 써서 훨씬 간단해진 함수들의 모습 입니다.

  아무튼 위 소스에 대한 설명은 이정도로 마치도록 하고 (나머지 부분은 여러분이 스스로 분석/개량 해보세요!) 이제 본격적으로 파일 입출력을 도서 관리 프로그램에 적용시켜 봅시다. 먼저 우리가 하고 싶은 일은 현재 도서관에 등록된 장서들의 목록을 예쁘게 파일에 출력시키는 것입니다. 사실 이는 간단하므로 여러분들도 만들어보시기 바랍니다.

```cpp-formatted
int register_book(BOOK *book_list, int *nth);
int search_book(BOOK *book_list, int total_num_book);
int borrow_book(BOOK *book_list);
int return_book(BOOK *book_list);
int print_book_list(BOOK *book_list, int total_num_book);
int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */

  BOOK *book_list;

  printf("도서관의 최대 보관 장서 수를 설정해주세요 : ");
  scanf("%d", &user_choice);

  book_list = (BOOK *)malloc(sizeof(BOOK) * user_choice);
  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");
    printf("6. 책들의 내용을 book_list.txt 에 출력 \n");

    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);

    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
      register_book(book_list, &num_total_book);
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
      search_book(book_list, num_total_book);
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
      borrow_book(book_list);
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
      return_book(book_list);
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    } else if (user_choice == 6) {
      print_book_list(book_list, num_total_book);
    }
  }

  free(book_list);
  return 0;
}
int print_book_list(BOOK *book_list, int total_num_book) {
  FILE *fp = fopen("book_list.txt", "w");
  int i;

  if (fp == NULL) {
    printf("출력 오류 ! \n");
    return -1;
  }

  fprintf(fp, " 책 이름/저자 이름/출판사/반납 유무\n");
  for (i = 0; i < total_num_book; i++) {
    fprintf(fp, "%s / %s / %s", book_list[i].book_name, book_list[i].auth_name,
            book_list[i].publ_name);
    if (book_list[i].borrowed == 0)
      fprintf(fp, " /NO \n");
    else
      fprintf(fp, " /YES \n");
  }

  fclose(fp);
}
```


바뀐 부분만 보면 위와 같습니다.성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F167B6A4F4D29D63C3AE67C)

와 같이 나옵니다.
이제 6 번을 눌러서 출력을 해보면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F11780A4F4D29D63D64A800)

와 같이 아주 예쁘게 파일에 출력되었음을 알 수 있습니다.

위 소스 코드에서 주목해야 할 부분은 바로 파일에 내용을 출력하는 `print_book_list` 함수 입니다. `print_book_list` 에서 새로운 입출력 함수를 사용하였는데 바로 `fprintf` 함수 입니다. 이 함수는 `printf` 와 비슷하게 생겼는데 `printf` 의 경우 인자로 지정한 내용을 콘솔 화면(정확히 말하면 `stdout)` 에 출력하는 반면에 `fprintf` 함수는 지정한 스트림에 출력하게 되지요. 다시 말하면

```cpp-formatted
fprintf(stdout, "Hello, World! \n");
printf("Hello, World! \n");
```


은 정확히 동일한 작업을 하게 됩니다. 아무튼, `printf` 가 화면에 출력한다면 `fprintf` 는 스트림에 출력하신다고 생각하면 됩니다. 그렇다면

```cpp-formatted
fprintf(fp, " 책 이름/저자 이름/출판사/반납 유무\n");
for (i = 0; i < total_num_book; i++) {
  fprintf(fp, "%s / %s / %s", book_list[i].book_name, book_list[i].auth_name,
          book_list[i].publ_name);
  if (book_list[i].borrowed == 0)
    fprintf(fp, " /NO \n");
  else
    fprintf(fp, " /YES \n");
}
```


은 쉽게 이해할 수 있으리라 봅니다. 맨 첫번째 문장에서 책 이름/저자 이름/출판사/반납 유무 를 화면에 출력했다면, 아래 `for` 문에서 `book_list` 에 들어있는 책의 정보들을 모두 표시하게 되지요. 상당히 간단하지요?

  원래는 도서 관리 프로그램에서 출력한 데이터를 읽어들이는 작업도 같이 해볼려고 했는데 이 부분은 여러분들께 생각해보기로 남기겠습니다^^ 그럼 이번 강좌는 여기에서 마치도록 하겠고요, 다음 시간 까지도 파일 입출력에 대해서 좀더 이야기 보도록 하겠습니다!

### 생각해보기

#### 문제 1

위의 도서관리 프로그램에서 출력한 도서 목록을 입력 받아서 배열에 집어 넣는 작업을 만들어보세요. 참고로 도서 목록 출력 파일의 형식은 아래와 같다고 합시다.

```info
전체 책의 개수
책 이름
저자 이름
출판사 이름
대출 유무
책 이름
저자 이름
출판사 이름
대출 유무
```

예를 들면

```info
2 2
C언어
Psi Psi
itguru
offset
AAA
```

와 같은 형식 이지요. 물론 파일에 도서 목록을 출력하는 작업도 수정해야 되겠지요. (난이도 : 中)

#### 문제 2

파일에서 특정한 단어를 검색하여 몇 번째 줄에 나오는지 모두 출력하는 프로그램을 만드세요. (난이도 : 上)
(참고로 1 줄의 기준은 \n 의 유무로 합시다. 따라서 `fscanf` 를 사용하면 안되겠지요?)

#### 문제 3

파일에서 특정한 문자를 검색하여 몇 개나 나오는지 출력하는 프로그램을 만드세요. (난이도 : 下)

##@ chewing-c-end
Link :  124
2011-01-09 23:42
----------------
title : C 언어 레퍼런스 - atof 함수
path : /C Reference/stdlib.h
cat_title :  atof
publish_date : 2011-01-09 23:42
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ atof

```info
#include <stdlib.h> // C++ 에서는 <cstdlib>

double atof ( const char * str );

```

문자열을 `double` 형 값으로 바꾼다.

C 형식 문자열의 내용을 `double` 형 수로 생각하여 그 값을 `double` 로 변환한다. 즉, 문자열 "3.145" 로 입력 받은 데이터를 실제 산술 연산에 사용하기 위해서 `double` 형인 `3.145` 로 변환함을 의미한다.

이 함수는 입력 받은 문자열에서 최초로 공백 문자가 아닌 문자(non-whitespace) 까지 도달할 때 까지 그 앞의 모든 공백 문자를 지워버린다. 그리고, 최초의 비 공백문자로 부터 부동 소수점 수와 연관된 문자들(예를 들면 0 부터 9 까지 숫자들과, 소수점 (.), -, + 등등)을 최대한 많이 읽어들인 후 그 데이터를 수치로 변환하다. 문자열의 나머지 부분들은 무시되고 이 함수에 전혀 영향을 주지 않는다.

`atof` 함수가 변환할 수 있는 올바른 형태의 수는 다음과 같다.

* 숫자 앞의 `+` 또는 `-` 기호

* `0` 부터 9 까지의 숫자들, 그리고 소수 0 부터 9 까지의 숫자들, 그리고 소수점

* 지수로 부호 기호와 숫자들 뒤에 나타나야 하며 `e` 또는 `E` 가 사용될 수 있다.



만일 맨 첫번재 비 공백문자로 올바른 부동 소수점 수를 구성할 수 없거나, 문자열 자체가 비어 있다면 어떠한 작업도 진행되지 않는다.

※ 참고적으로 `double` 형 변수를 문자열 형태로 바꾸는 방법은 `sprintf` 를 참조하기를 바란다.



###  인자




`str`

C 형식 문자열로 부동 소수점 수를 문자열 형태로 포함하고 있어야 한다 C 형식 문자열로 부동 소수점 수를 문자열 형태로 포함하고 있어야 한다.



###  리턴값

성공적으로 수를 구했다면 `double` 형의 형태로 그 값이 리턴된다.

만일 올바른 값을 구할 수 없거나, 수의 값이 언더플로우(underflow - double 형 부동 소수점으로 표현할 수 있는 최소의 값보다도 값이 작은 경우) 일 경우 `0.0` 이 리턴된다.

만일 문자열의 수가 `double` 형에서 표현할 수 있는 최대의 범위 보다 클 경우 양 또는 음의 `HUGE_VAL` 이 리턴된다.



###  실행 예제




```cpp-formatted
/*

각도를 문자열로 입력 받아서 double 형 수치 값으로 변환한 뒤 이의 sine 값을
계산한다. 이 예제는 http://www.cplusplus.com/reference/clibrary/cstdlib/atof/
에서 가져왔습니다.

 */
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
  double n, m;
  double pi = 3.1415926535;
  char szInput[256];
  printf("Enter degrees: ");
  gets(szInput);
  n = atof(szInput);
  m = sin(n * pi / 180);
  printf("The sine of %f degrees is %f\n", n, m);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F113F11534D29C4192AA79E)




###  연관된 함수




* `strtod`  :  문자열을 `double` 형 값으로 바꾼다.
*  [atoi](http://itguru.tistory.com/131)  :  문자열을 `int` 형 값으로 바꾼다.
*  [atol](http://itguru.tistory.com/132)  :  문자열을 `long` 형 값으로 바꾼다.
Link :  122
2011-01-05 22:21
----------------
title : C 언어 레퍼런스 - strftime 함수
cat_title :  strftime
publish_date : 2011-01-05 22:21
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strftime

```info
#include <time.h> // C++ 에서는 <ctime>

size_t strftime ( char * ptr, size_t maxsize, const char * format, const struct tm * timeptr );
```


시간을 사용자가 원하는 형식에 맞추어 출력한다.
`format` 에 들어있는 형식에 맞추어서 `timeptr` 이 가리키는 `tm` 구조체의 값을 해석하여 현재 시간을 출력한다. 이 때, 출력되는 문자열의 최대 길이는 `maxsize` 로 한다.



###  인자




`ptr`

C 형식 문자열이 복사되는 배열을 가리키는 포인 C 형식 문자열이 복사되는 배열을 가리키는 포인터

`maxsize`

`ptr` 에 복사되는 문자열의 최대 길이

`format`

C 형식 문자열로 특정한 형식 지정자(format specifier) 들을 포함하고 있다. 이는 `printf` 에서 `%d` 나 `%c` 와 같이 사용하는 것과 유사하다. 다만 `printf` 는 인자로 지정한 변수들의 값을 출력하지만 `strftime` 함수는 인자로 지정한 `timeptr` 의 값을 해석하여 형식 지정자에 따라 문자열을 출력하게 된다. `printf` 와 같이 모든 형식 지정자의 앞에는 `%` 를 붙이면 된다.

|형식 지정자| 형식 지정자를 대체하여 들어가는 값|예시|
|---------|---------------------------|----|
|`%a`|요일 이름을 약자로 표기|`Thu`|
|`%A`|요일 이름을 완전하게 표기|`Thursday`|
|`%b`|월 이름을 약자로 표기|`Aug`|
|`%B`|월 이름을 완전하게 표기|`August`|
|`%c`|날짜와 시간 표시 형식|`Thu Aug 23 14:55:02 2001`|
|`%d`|몇 일인지 (01-31)|`23`|
|`%H`|24 시간 형식으로 시간을 표기 (00-23)|`14`|
|`%I`|12 시간 형식으로 시간을 표기 (01-12)|`02`|
|`%j`|1 년 중 몇 번째 일인지 (001-366)|`235`|
|`%m`|월을 숫자로 표시 (01-12)|`08`|
|`%M`|몇 분인지 (00-59)|`55`|
|`%p`|`AM` 또는 `PM` 을 나타낸다.|`PM`|
|`%S`|몇 초 인지(00-61)|`02`|
|`%U`|그 해의 첫번째 일요일을 첫 번째 주의 시작이라고 할 때 몇 번째 주인지 표시한다(00-53)|`33`|
|`%w`|요일을 숫자로 표시한다. (일요일은 0, 0 부터 6까지)|`4`|
|`%W`|그 해의 첫번째 월요일을 첫 번째 주의 시작이라고 할 때 몇 번째 주인지 표시한다 (00-53)|`34`|
|`%x`|날짜 표시|`08/23/01`|
|`%X`|시간 표시|`14:55:02`|
|`%y`|Y 년도를 끝 두 자리만 표시 `01`|
|`%Y`|년도 표시|`2001`|
|`%Z`|시간대(Timezone) 을 표시|`CDT`|
|`%%`|`%` 기호를 표시|`%`|

`timeptr`

`tm` 구조체를 가리키는 포인터




###  리턴값


만일 만들어지는 문자열의 길이가 종료 널 문자를 포함하여 `maxsize` 보다 작다면 `ptr` 에 복사된 문자의 수가 리턴되고 (이 때에는 종료 널 문자를 포함하지 않는다), 보다 크다면 0 이 리턴된다. 이 때 `ptr` 에 복사되는 문자열의 내용은 알 수 없다.




###  이식성


C++ 에서의 `strftime` 함수는 1990 년의 `ISO-C` 표준에서와 동일하다. C 컴파일러는 위에 나타나 있는 형식 지정자 말고도 부가적인 형식 지정자를 더 가질 수 있는데 위의 C 표준에서는 나타나 있지 않다.



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/ctime/strftime/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <time.h>

int main() {
  time_t rawtime;
  struct tm* timeinfo;
  char buffer[80];

  time(&rawtime);
  timeinfo = localtime(&rawtime);

  strftime(buffer, 80, "Now it's %I:%M%p.", timeinfo);
  puts(buffer);

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F111039584D246E6A33FF6E)

###  연관된 함수

* [asctime](http://itguru.tistory.com/116)  :  `tm` 구조체를 문자열로 변환한다.
* [ctime](http://itguru.tistory.com/118)  :  `time_t` 값을 토대로 `asctime` 함수와 동일한 작업을 한다.
Link :  121
2011-01-05 21:34
----------------
title : C 언어 레퍼런스 - stdlib.h (cstdlib)
path : /C Reference/stdlib.h
cat_title :  stdlib.h (cstdlib)
ref_title : <stdlib.h>, cstdlib
publish_date : 2011-01-05 21:34
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ stdlib.h (cstdlib)

C 표준 유틸리티 함수들을 모아놓은 헤더파일.

이 헤더파일에는 프로그래밍시에 범용적으로 사용되는 여러가지 함수들을 모아 놓고 있는데, 예를 들면 동적 할당 관련 함수, 난수 생성 함수, 정수의 연산 함수, 검색 및 정렬 함수 등 이다.




###  문자열 변환 함수


   문자열로 입력받은 데이터를 수로 변환한다. 예를 들어 문자열로 "123" 을 입력 받았다면 이를 실제 정수인 123 으로 변환하는 함수들이다.


*  [atof](http://itguru.tistory.com/124)  :  문자열을 `double` 형으로 변환한다.



*  [atoi](http://itguru.tistory.com/131)  :  문자열을 정수형으로 변환한다.



*  [atol](http://itguru.tistory.com/132)  :  문자열을 `long` 형 정수로 변환한다.



* `strtod`  :  문자열을 `double` 형으로 변환한다.

* `strtol`  :  문자열을 `long` 형 정수로 변환한다.



* `strtoul`  :  문자열을 `unsigned long` 형 정수로 변환하다.





###  난수 생성 함수




의사 난수 (Pseudo random) 를 생성한다. 참고로 의사 난수란, 실제 난순열이 아닌 특정한 알고리즘에 따라 난수 처럼 나타나는 수열이다.


*  [rand](http://itguru.tistory.com/139)  :  난수를 생성한다.



*  [srand](http://itguru.tistory.com/140)  :  난수 생성을 위한 초기값을 설정한다.




###  동적 할당 관련 함수




동적 할당 관련 함수들이다. [다음 강좌](http://itguru.tistory.com/98)를 보면 동적 할당 함수를 사용하는 방법을 볼 수 있다.


* `calloc`  :  메모리에 배열을 위한 공간을 할당한다.



* `free` :  메모리에서 공간을 사용 해제한다.



* `malloc`  :  메모리에서 공간을 할당한다.



* `realloc`  :  메모리에서 공간을 재할당 한다.




###  실행 환경 관련 변수들



* `abort`  :  현재 프로세스를 종료한다.



* `atexit`  :  특정 함수를 종료시 실행되게 설정한다.

* `exit`  :  호출한 프로세스를 종료한다.



* `getenv`  :  환경 문자열을 얻는다.

* `system`  :  시스템 명령어를 수행한다.





###  검색 및 정렬 함수들





* `bsearch`  :  배열에서 이진 탐색을 수행한다.

* `qsort`  :  배열의 원소들을 정렬한다.




###  정수 관련 연산 함수들





* `abs`  :  절대값을 구한다.

* `div`  :  정수 나눗셈을 수행한다.



* `labs` :  절대값을 구한다.

* `ldiv`  :  정수 나눗셈을 수행한다.





###  다중 바이트(multibyte) 문자 관련 함수




다중 바이트 문자열이란, 한 문자의 크기가 1 바이트 이상인 문자열을 의미한다. 예를 들면 유니코드가 있는데, 유니코드의 경우 한 글자를 2 바이트로 나타낸다.


* `mblen`  :  멀티바이트 문자의 크기를 구한다.

* `mbtowc`  :  멀티바이트 문자를 `wchar_t` 형 문자로 변환한다.



* `wctomb`  :  `wchar_t` 형 문자를 멀티바이트 문자로 변환한다.






###  다중 바이트(multibyte) 문자열 관련 함수



* `mbstowcs`  :  멀티바이트 문자열을 `wchar_t` 형 문자열로 변환한다.

* `wcstombs`  :  `wchar_t` 형 문자열을 멀티바이트 문자열로 변환한다.




###  매크로





* `EXIT_FAILURE`  :  비정상 종료 코드



* `EXIT_SUCCESS`  :  정상 종료 코드



* `MB_CUR_MAX`  :  멀티바이트 문자의 최대 크기

* `NULL`  :  널 포인터

* `RAND_MAX`  :  `rand` 함수가 리턴하는 난수의 최대 크기




###  타입들





* `div_t`  :  `div` 가 리턴하는 구조체

* `ldiv_t`  :  `div` 와 `ldiv` 가 리턴하는 구조체

* `size_t`  :  부호 없는 정수 타입
Link :  67
2011-01-03 00:32
----------------
title : C 언어 레퍼런스 - sscanf 함수
cat_title :  sscanf
publish_date : 2011-01-03 00:32
--------------


#@ sscanf

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int sscanf ( const char * str, const char * format, ...);
```


문자열에서 형식화 된 데이터를 읽어온다.
`str` 에서 데이터를 형식 문자열(format)에서 지정하는 바에 따라 읽어와 그 데이터를 뒤에 부수적인 인자들이 가리키는 메모리 공간에 저장하게 된다. 이 때, 데이터가 저장되는 방식 역시 형식 문자열에 의해 결정된다.



###  인자


`str`

C 문자열로 `sscanf` 함수가 데이터를 얻어올 문자열이다 C 문자열로 `sscanf` 함수가 데이터를 얻어올 문자열이다.

`format`

C 문자열로 다음의 것들을 포함하고 있다 C 문자열로 다음의 것들을 포함하고 있다.

* 공백 문자 (Whitespace character 이라 부르며, 개행 문자(\n), 탭 문자, 띄어쓰기(' ') 를 일컫는다) : `fscanf` 함수는 비-공백 문자를 읽어들이기 전까지 읽혀지는 모든 공백 문자들을 무시한다.

* 비-공백 문자 (Non whitespcae character), 단 `%` 를 제외한다 : 공백 문자가 아니거나 형식 지정자에 포함되지 않는 것들은 함수로 하여금 다음 문자를 스트림에서 읽어 들이고 이와 이 비-공백 문자와 비교하여 같다면 버리고 다음 문자와 형식으로 진행한다. 만일 다르다면 함수가 종료되고, 스트림에서 읽혀지지 않은 다른 문자들은 모두 남아있게 된다.

* 형식 지정자 : 이는 `%` 로 지정되는 것들로 스트림에서 어떠한 형식으로 데이터를 읽어오고, 또 각각의 형식 지정자에 대응되는 인자에 어떠한 형식으로 저장할 지에 대해 결정한다. 형식 지정자는 아래와 같은 꼴로 생겼다.


```info
%[*][폭(width)][한정자(modifiers)]타입(type)
```

|종류|설명|
|----|----|
|`*`| 데이터를 `stdin` 에서 받아들이지만 무시된다. 물론, 이에 대응되는 인자에는 받아들인 데이터가 저장되지 않고 이 인자는 다음 형식 태그에 대응된다. 예를 들어 `scanf("%*d%d", i,j);` 의 경우 먼저 수를 입력하더라도 `%*d` 형식이므로 무시 된다. 그 다음 수를 입력하면 `%d` 형식 태그가 `j` 가 아닌 `i` 에 대응되어 `i` 에 그 다음 입력한 수가 들어가게 된다. 이 때 `j` 에는 아무런 값도 들어가지 않는다.|
|폭|`stdin` 에서 읽어들일 최대 문자 수를 지정한다. 예를 들어 `scanf("%10s", str);` 로 했을 경우 `stdin` 에서 최대 10 문자를 읽어와 `str` 에 저장한다. 이 때 주의할 점은 `str` 에는 `NULL` 문자가 들어갈 수 있는 충분한 공간이 남아 있어야 한다.|
|한정자|입력받는 데이터의 크기를 지정한다. `int, unsigned int, float` 형에 대해 입력받는 데이터의 크기를 설정할 수 있다. `h` 의 경우 `short int` (`d, i, n` 의 경우) 혹은 `unsigned short int` (`o, u, x` 일 경우). `l` 의 경우 `long int` (`d, i, n` 의 경우) 혹은 `unsigned long int` (`o, u, x` 일 경우), 혹은 `double` (`e, f, g` 일 경우). 마지막으로 `L` 의 경우 `long double` (`e, f, g` 일 경우) 에 사용할 수 있다.|
|타입|데이터를 어떠한 형식으로 혹은 어떠한 값만을 읽어들어야 할 지에 대해 지정해준다. 아래 표를 참고.|

#### sscanf 함수의 타입 지정자들

|타입|대응되는 입력 방식|대응되는 인자의 형태|
|`c`|단일 문자: 하나의 문자를 읽어들인다. 만일 폭에 1 이 아닌 값으로 지정되어 있다면 (기본값은 1) 함수는 폭 만큼의 문자를 읽어들인 후 이에 대응하는 인자가 가리키는 메모리 공간에 저장한다. 이 때 마지막에는 널 문자를 붙이지 않는다.|`char *`|
|`d`|십진법으로 표현된 정수: 말그대로 십진법으로 쓰인 정수로, `+` 나 `-` 기호로 시작할 수도 있다.|`int *`|
|`e, E, f, g, G`|부동 소수점: 소수점을 포함하고 있는 소수(decimal number) 로 `+` 나 `-` 기호로 시작할 수도 있으며, `e` 나 `E` 문자(10 의 지수를 나타내기 위해)를 포함할 수 도 있다. -732.103, 12e-4, +123.10 은 모두 올바른 입력이다.| `float *`|
|`o`|8진법으로 표현된 정수|`int *`|
|`s`|문자열: 공백문자를 찾을 때 까지 문자들을 읽어들인다.|`char *`|
|`u`|부호가 없는 십진법으로 표현된 정수|`unsigned int *`|
|`x, X`|16진법으로 표현된 정수|`int *`|

#### 부수적 인자

형식 문자열의 정의된 순서대로 각 형식 지정자는 이에 대응하는 인자가 가리키는 메모리 공간에 데이터를 집어넣는다. 이 때, 부수적 인자들은 모두 포인터의 형태 (주소값) 여야 한다. 예를 들어서 `i` 라는 변수에 값을 대입하려면 인자로 `&i` 를 전달해야 한다. 절대로 `i` 를 전달하면 안된다.

예를 들면 다음과 같다.

```cpp-formatted
char str[30] = "word";
char c;

sscanf(str, "%c", &c);
```




###  sscanf 함수를 이용해서 문자열을 수로 바꾸기


보통 우리는 문자열을 수로 바꿀 때 `atoi` 함수를 사용하지만, `sscanf` 함수를 통해서도 동일한 작업을 수행할 수 있습니다.

```cpp-formatted
#include <stdio.h>
int main() {
  char str[30] = "1234";
  int i;

  sscanf(str, "%d", &i);

  printf("Number from : '%s' \n", str);
  printf("number : %d \n", i);

  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F2019520D4B8290B942A3FF)

위와 같이 `str` 에서 `sscanf` 함수로 `%d` 형식, 즉 정수 형식으로 수를 읽어오면 이 값을 `i` 에 저장하게 된다.

위 함수의 장점은 `%d` 뿐만이 아니라 `%o` 나 `%f, %x` 등이 가능하기 때문에 팔진수나 부동소수점 수, 16 진수 들도 모두 동일한 방법으로 입력받을 수 있다. 반면에 `atoi` 계열 함수들은 `atoi, atof` 등 세분화 되어 있기 때문에 불편한 면이 있다.


###  리턴값


입력 성공 시에 이 함수는 읽어들인 것의 개수를 리턴한다. 물론, 0 이 리턴될 수 도 있다. (이 경우에는 `str` 에서 `format` 에서 지정한 형식과 일치하는 데이터가 없어서 아무것도 읽어들이지 않은 경우 발생한다. 아래의 `EOF` 가 리턴되는 경우와 조금 다르다)

만일 어떠한 데이터도 성공적으로 읽기 전에 입력이 실패한다면 `EOF` 가 리턴된다.



###  실행 예제



```cpp-formatted
/*sentence 로 부터 Rudolph 와 12 라는 수를 sscanf 함수를 이용해 추출한다.이
 * 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/sscanf/에서
 * 가져왔습니다. */
#include <stdio.h>
int main() {
  char sentence[] = "Rudolph is 12 years old";
  char str[20];
  int i;
  sscanf(sentence, "%s %*s %d", str, &i);
  printf("%s -> %d\n", str, i);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F166187534D209A7F15737F)




###  연관된 함수





*  [scanf](http://itguru.tistory.com/36)  :  표준입력(stdin) 으로 부터 데이터를 형식에 맞추어 읽어온다.

*  [sprintf](http://itguru.tistory.com/66)  :  문자열에 데이터를 형식에 맞추어 쓴다.
Link :  120
2010-12-30 23:51
----------------
title : C 언어 레퍼런스 - localtime 함수
cat_title :  localtime
publish_date : 2010-12-30 23:51
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ localtime

```info
#include <time.h> // C++ 에서는 <ctime>

struct tm * localtime ( const time_t * timer );
```


 [time_t](http://itguru.tistory.com/113)값을 이용하여 지역 시간을 기준으로 [ tm 구조체](http://itguru.tistory.com/109)를 초기화한다.
`timer` 가 가리키는 [time_t](http://itguru.tistory.com/113)형 변수의 값을 이용하여 [tm 구조체](http://itguru.tistory.com/109)의 멤버들을 초기화 한 뒤 이를 가리키는 포인터를 리턴한다.
참고적으로 현재 시간을 구해와야 하는 경우 십중 팔구 이 함수를 사용하게 된다.



###  현재 시각을 구해오는 가장 간단한 방법



```cpp-formatted
time_t rawtime;
struct tm* timeinfo;
time(&rawtime);
timeinfo = localtime(&rawtime);
```


를 통해 `timeinfo` 가 가리키는 구조체에 현재 시각에 관련한 정보가 포함되게 된다. 예를 들어 `timeinfo->tm_hour` 을 하면 현재 몇 시인지 알아내올 수 있다. `tm` 구조체에 관련한 설명은 [여기](http://itguru.tistory.com/109)를 참조하여라.



###  인자




`timer`

 [time_t](http://itguru.tistory.com/113)형 변수를 가리키는 포인터



###  리턴값




멤버들이 초기화된 [tm 구조체](http://itguru.tistory.com/109)를 가리키는 포인터가 리턴된다.

이 때 이 `tm` 구조체는 정적으로 할당된 메모리에 자리하고 있는데, `gmtime` 함수와 `localtime` 함수가 공유하고 있는 공간이다. 따라서 이들 함수들을 호출하게 되면 이 구조체에 쓰여져 있던 내용이 덮어 씌워지게 된다. 만일 이 함수가 리턴한 `tm` 구조체를 사용할 일이 있으면 다른 구조체에 복사해 놓는 것이 좋다.



###  실행 예제




```cpp-formatted
/*

현재 시각을 출력한다.
이 예제는
http://www.cplusplus.com/reference/clibrary/ctime/localtime/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <time.h>

int main() {
  time_t rawtime;
  struct tm* timeinfo;

  time(&rawtime);
  timeinfo = localtime(&rawtime);
  printf("Current local time and date: %s", asctime(timeinfo));

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F121528504D1C9BC50A04E3)




###  연관된 함수

* [asctime](http://itguru.tistory.com/116)  :  `tm` 구조체를 문자열로 변환한다.
* [ctime](http://itguru.tistory.com/118)  :  `time_t` 값을 토대로 `asctime` 함수와 동일한 작업을 한다.
*  [gmtime](http://itguru.tistory.com/119): `time_t` 값을 토대로 `UTC` 시간에 맞추어 `tm` 구조체를 초기화한다.
*  [mktime](http://itguru.tistory.com/112)  :  `tm` 구조체 내용을 토대로 `time_t` 형 값을 계산한다.
*  [time](http://itguru.tistory.com/114)  :  현재 시간을 구한다.
Link :  119
2010-12-29 20:07
----------------
title : C 언어 레퍼런스 - gmtime 함수
cat_title :  gmtime
publish_date : 2010-12-29 20:07
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ gmtime

```info
#include <time.h> // C++ 에서는 <ctime>

struct tm * gmtime ( const time_t * timer );
```


 [time_t](http://itguru.tistory.com/113) 형 값을 입력 받아서 `UTC` 형식 시간에 따른 `tm` 구조체를 만들어서 리턴한다.
`timer` 가 가리키는 [time_t](http://itguru.tistory.com/113) 형 변수의 값을 받아 그 값을 토대로 [tm 구조체](http://itguru.tistory.com/109)의 멤버들을 초기화 한다.



###  인자


`timer`

`time_t` 형 변수를 가리키는 포인터



###  리턴값

인자로 받은 [time_t](http://itguru.tistory.com/113) 형 변수의 값을 토대로 멤버가 초기화 된 [tm 구조체](http://itguru.tistory.com/109) 변수를 가리키는 포인터가 리턴된다.

이 때, 이 구조체 변수는 정적으로 할당된 변수로 `gmtime` 함수와 `localtime` 함수 모두 공통으로 사용한다. 따라서 이들 함수를 호출하게 되면 구조체 변수의 내용이 덮어 씌워지기 때문에 리턴된 구조체 변수를 이용하기 위해서는 동일한 `tm` 구조체 변수에 복사해 넣는 것이 중요하다.



###  실행 예제


```cpp-formatted
/*

세계 몇몇 도시의 시각을 보여준다.
이 예제는
http://www.cplusplus.com/reference/clibrary/ctime/gmtime/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <time.h>

#define MST (-7)
#define UTC (0)
#define CCT (+8)
#define GMT (+9)

int main() {
  time_t rawtime;
  struct tm* ptm;

  time(&rawtime);

  ptm = gmtime(&rawtime);

  puts("Current time around the World:");
  printf("Phoenix, AZ (U.S.) :  %2d:%02d\n", (ptm->tm_hour + MST) % 24,
         ptm->tm_min);
  printf("Reykjavik (Iceland) : %2d:%02d\n", (ptm->tm_hour + UTC) % 24,
         ptm->tm_min);
  printf("Beijing (China) :     %2d:%02d\n", (ptm->tm_hour + CCT) % 24,
         ptm->tm_min);
  printf("Seoul (Korea) :       %2d:%02d\n", (ptm->tm_hour + GMT) % 24,
         ptm->tm_min);

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F13155B484D1B14B32FA168)




###  연관된 함수


*  [asctime](http://itguru.tistory.com/116)  :  `tm` 구조체를 문자열로 변환한다.
*  [ctime](http://itguru.tistory.com/118)  :  `time_t` 값을 토대로 `asctime` 함수와 동일한 작업을 한다.
*  [localtime](http://itguru.tistory.com/120)  :  `time_t` 값을 토대로 `tm` 구조체를 지역 시간으로 설정한다.
* [mktime](http://itguru.tistory.com/112)  :  `tm` 구조체 내용을 토대로 `time_t` 형 값을 계산한다.
*  [time](http://itguru.tistory.com/114)  :  현재 시간을 구한다.
Link :  118
2010-12-29 17:54
----------------
title : C 언어 레퍼런스 - ctime 함수
cat_title :  ctime
publish_date : 2010-12-29 17:54
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ ctime

```info
#include <time.h> // C++ 에서는 <ctime>

char * ctime ( const time_t * timer );
```


`time_t` 값을 문자열로 바꾼다.
`timer` 가 가리키는 [ time_t](http://itguru.tistory.com/113)형 변수를 읽어들여서, 그 값을 해석하여 지역 시간에 맞추어 아래와 같은 형식으로 문자열로 바꾼다.

`Www Mmm dd` hh:mm:ss `yyyy`

`Www` 는 요일, `Mmm` 은 월 이름, `dd` 는 몇일인지, hh:mm:ss 는 현재 시간, `yyyy` 는 현재 년도를 말한다.이 때 문자열 끝에는 자동으로 \n 과 `NULL` 문자가 들어가게 된다.

참고로 이 함수는 `asctime(localtime(timer))` 와 동일하다.



###  인자




`timer`

`time_t` 형 변수를 가리키는 포인터



###  리턴값




 [time_t](http://itguru.tistory.com/113)값을 해석해서 만든 문자열이 리턴된다. 이 때 이 문자열은 정적으로 할당되었으며 `ctime` 함수와 `asctime` 함수가 동시에 사용한다. 따라서 이들 함수를 호출하게 되면 이 문자열에 들어가 있던 내용에 덮어 씌우게 된다. 따라서 이들 함수가 호출한 문자열 내용을 영구적으로 보관하려면 다른 메모리 공간에 보관해야 한다.



###  실행 예제


```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/ctime/ctime/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <time.h>

int main() {
  time_t rawtime;

  time(&rawtime);
  printf("The current local time is: %s", ctime(&rawtime));

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F120E3A574D1AF68D20F071)




###  연관된 함수


*  [asctime](http://itguru.tistory.com/116)  :  `tm` 구조체를 문자열로 변환한다.
*  [gmtime](http://itguru.tistory.com/119)  :  `time_t` 값을 `tm` 구조체로 변환하되, `UTC` 시간으로 한다.
*  [localtime](http://itguru.tistory.com/120)  :  `time_t` 값을 `tm` 구조체로 변환하되 지역 시간으로 한다.
*  [time](http://itguru.tistory.com/114)  :  현재 시간을 알아온다.
Link :  115
2010-12-28 02:40
----------------
title : 100 번째 글을 돌파하며
publish_date : 2010-12-28 02:40
--------------



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F16014D4D4D1612C924A4BB)

안녕하세요 여러분. [Psi](http://itguru.tistory.com/notice/107)입니다. 제가 블로그를 연지 어언 2 년이 거의 다 되었군요. 제가 이 블로그에서 첫번째 글을 쓴 것이 2009 년 1 월 9 일인데, 이제 2010 년 12 월 26 일이니, 이 블로그이 두 번째 생일도 앞으로 딱 2 주가 남았습니다. 사실 제가 티스토리에 몸을 담은 것은 이 블로그가 처음이 아닙니다. 무려 2007 년도 부터 글을 써왔었던 ' [나의 휴식터](http://kevin0960.tistory.com/)' 라는 블로그가 처음이지요. 이 블로그를 통해 '글을 쓰는 재미' 에 맛이 들린 뒤로 부터 사람들에게 무언가 정보를 주면서 기쁨을 느끼는 삶을 살아가고 싶었습니다. 이러한 제 꿈이 실현 된 것이 저의 두번째 블로그 'Programming IT' 입니다.

이렇게 한글 두글 쓰다 보니 이제 100 번째 글을 돌파하게 되었습니다. 사실 2 년 동안 글을 100 개 밖에 쓰지 않았다면 우수한 블로거라고는 할 수 없지요. 하루에 글을 한 편씩 써내는 대단한 분들이 얼마나 많은데 말이죠. 하지만 제가 쓴 100 개의 글은 다른 블로거들이 쓴 1000 개의 글들 보다도 훨씬 더 소중하고 정성이 들어갔다고 생각합니다... :) 제가 이렇게 꾸준하게 글을 쓸 수 있게 했던 원동력은 뭐니뭐니 해도 제 글에 아낌없이 댓글을 달아주는 여러분이 있어서 였습니다.

이 자리를 빌어서 제 블로그에 많은 댓글로 제게 힘이 되었던 분들에게 감사를 표하고 싶은데요, 일단 무엇 보다도 가장 감사 드리는 분은 코이치님 이고요, 그 외에도 song님, 곰돌님, 희망님, 프로그래머가 되고싶은 1인님 (꼭 프로그래머가 되시기 바랍니다), 괴도님, 두루뭉술님, winape님, 스프님, ore 님,Stephanos 님 등 입니다. 그 외에도 소중한 댓글을 남겨주신 모든 분들께 감사의 말을 전합니다.

저는 C 언어 강좌와 레퍼런스 작업을 모두 마치게 되면 그 다음 목표로 C++ 강좌를 시작해보고 싶습니다. 물론 C++ 관련 레퍼런스 작업도 마찬가지 이죠. 그 후에는 인터프리팅 언어인 파이썬이나 펄 과 같은 언어 강좌를 하고 싶고, 나중에는 `Windows API` 와 시스템 프로그래밍 등과 같이 인터넷에서 무료로 쉽게 접할 수 없는 내용들을 가르치는 컴퓨터 계의 전도사가 되는 것이 저의 목표 입니다. 당연하겠지만, 이 모든 것이 이루어지려면 여러분의 아낌없는 응원이 꼭 필요하겠지요 :)

아무튼 이 글을 보고 계시는 제 블로그의 소중한 방문자 님에게 감사의 말을 전합니다. 그리고 2011 년도 힘차게 시작하시기를 빌겠습니다!

P.S 이참에 제 [프로필 페이지](http://itguru.tistory.com/notice/107)도 들려보세요!
Link :  117
2010-12-28 02:37
----------------
title : 씹어먹는 C 언어 - <23 - 1. 파일 하고 이야기 하기 (파일 입출력에 대한 기본적 이해)>
cat_title : 23 - 1. 파일 하고 이야기 하기 (파일 입출력에 대한 기본적 이해)
next_page : 123
publish_date : 2010-12-28 02:37
--------------


이번 강좌에서는

* 파일 입출력이란 무엇인가, 스트림이란 무엇인가



* `fopen, fputs, fgets, fgetchar` 함수에 대한 이해

* 파일 위치 지정자와 `fseek` 함수에 대한 이해

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요~ 여러분 드디어 38 번째 강좌 입니다! 제 목표로는 40 번째 강좌를 끝으로 마칠 예정인데 조금 더 길어 질지도 모르겠군요 :) 여러분이 여태까지 프로그램들을 만들면서 '데이터를 어떻게 하면 프로그램이 종료되어도 보관할 수 있을까?' 라는 생각을 많이 하셨을 것입니다. 사실 그 방법은 단순합니다. 특정한 데이터가 있으면 이를 하드디스크에 기록하면 해결되는 일이지요.

여태까지 만든 모든 프로그램에서 변수는 하드디스크가 아니라 언제나 `RAM` 에 상주하는 데이터 였습니다. 즉, 프로그램이 종료되어도 그렇지만 컴퓨터가 꺼지게 되면 데이터가 날아가게 되는 **휘발성 메모리** 이지요. (여러분이 배운 내용이 이렇지 않기를 바랍니다) 하지만 여러분의 컴퓨터에 깔려있는 대부분의 프로그램이나 문서들은 껐다 켜도 사라지지 않습니다. 왜냐하면 그 내용들이 **비휘발성 저장매체** 인 하드 디스크에 저장되어 있기 때문입니다.

그렇다고 해서 하드 디스크에 아무렇게나 데이터를 보관할 수 있는 것은 아닙니다.  하드디스크에 데이터를 보관할 때 에는 **파일**의 단위로 데이터를 보관하게 됩니다. 따라서 이번 강좌에서는 어떻게 하면 파일을 만들고, 파일에 데이터를 저장하고, 파일을 읽어들일 수 있을지 알아보도록 하겠습니다.



### 파일에 출력하기


```cpp-formatted
/* a.txt 에 내용을 기록한다. */
#include <stdio.h>

int main() {
  FILE *fp;
  fp = fopen("a.txt", "w");

  if (fp == NULL) {
    printf("Write Error!!\n");
    return 0;
  }

  fputs("Hello World!!! \n", fp);

  fclose(fp);
  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F161E6D564D18890D0BB74A)

와 같이 아무것도 나오지 않습니다. 왜냐하면 화면에 출력하는 문장이 아무것도 없거든요. 대신, 소스 파일이 위치한 곳으로 들어가봅시다. 저의 경우 다음과 같은 경로에 소스파일이 위치해있습니다.

```info
C:\Users\Lee\Documents\Visual Studio 2008\Projects\teach\teach
```


찾으셨다면 아래 그림처럼 예쁘게 `a.txt` 라는 파일이 생성된 것을 볼 수 있습니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F127093554D1889A70DEA5B)


그렇다면 기대되는 마음으로 이 파일을 열어보겠습니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F183AEC3C4D1889DC08B497)

와우! 우리가 원하던 문자열 "Hello World!!!" 가 제대로 들어가 있는 것을 보실 수 있습니다. 이제, 다시 소스 코드를 살펴보도록 하죠.

```cpp-formatted
FILE *fp;
fp = fopen("a.txt", "w");
```

  사실 우리가 하드디스크에 저장되어 있는 파일들을 자유롭게 이용할 수 있다고는 하나 이를 쓰는 과정은 매우매우 복잡할 것입니다. 왜냐하면 파일을 새로 만든다고 쳐도, 하드디스크 어떤 부분에 파일을 새로 만들어야 할지, 얼마나 크게 파일을 만들 수 있는지 등의 모든 것들을 고려해야 합니다. 자그마한 파일 하나를 만드는데 이런 짓들을 하기엔 너무 지나친 일이지요. 그래서 다행스럽게도 이와 같은 복잡한 일들은 컴퓨터 운영체제에서 알아서 해줍니다.

  `fopen` 함수는 바로 위에서 말한' 운영체제가 알아서 해주는 부분' 을 처리합니다. `fopen` 함수는 우리가 지정한 파일(a.txt) 과 소통할 수 있도록 스트림을 만들어 줍니다. 어, 그렇다면 스트림이 무엇일까요?



### 스트림





![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F154733414D1894062D76CF)

우리가 `printf` 함수를 이용할 때 어떠한 작업이 컴퓨터에서 내부적으로 처리되는지 생각해봅시다. 먼저, 출력할 문자열을 구성해야 겠죠. 그리고 이를 모니터에 전달해서 출력하라는 명령을 내리게 해야 합니다. 과연 이것이 쉬운 일일까요? 모니터에 명령을 내리기 위해서는 모니터를 만든 회사마다 그 방식이 다를 것이고, 어떠한 명령을 내려햐 하는지도 다를 것입니다. 하지만 우리는 이를 `printf` 라는 함수 하나로 이 모든 것을 할 수 있었습니다.

그 이유는 바로 **스트림** 에 있습니다. 스트림은 이 두 개의 완전히 다른 장치들을 이어주는 **파이프** 라고 보시면 됩니다. 이러한 스트림은 우리가 직접 구현해야 되는 것이 아니라 운영체제가 스스로 처리해 주는 것이지요. 만일 우리가 모니터와 잇는 스트림을 이용한다면 운영체제는 모니터에 맞는 명령을 내릴 것이고, 키보드와 잇는 스트림을 이용한다면 운영체제가 키보드에 맞는 명령을 알아서 내릴 것입니다. 우리 프로그래머 입장에서는 걱정을 전혀 할 필요가 없겠지요.

\sidenote{수준 높은 분들을 위한 설명 : 스트림을 정확히 표현하면 '추상화된 장치(abstract devices)' 라고 말할 수 있습니다. 왜냐하면 여러가지 주변 장치들(모니터, 키보드, 하드 디스크) 을 추상화 시켜서 사용자가 마치 동일한 장치에 접근하는 것 처럼 사용할 수 있게 만들었기 때문이죠. 어떠한 모습으로 장치들을 추상화 시켰냐면 스트림은 마치 책장과 같이 만들었습니다. 책장에 책을 끼우거나 빼는 것 처럼 데이터를 순차적으로 쭉 나열해서 데이터의 끝 까지 차례대로 읽어들일 수 있도록 만들었습니다.}

따라서 만일 우리가 모니터에 *A* 를 출력하고 싶다면 단순히 스트림에 *A* 를 넣으면 됩니다. 왜냐하면 이렇게 스트림으로 전달된 문자 *A* 는 운영체제에 의해 알아서 모니터에 명령을 내려서 *A* 를 출력하게 되지요. 마찬가지로 키보드에서 문자를 받고 싶다면 스트림을 타고 무슨 문자가 오는지에만 관심을 가지면 됩니다. 왜냐하면 우리가 키보드에 무언가를 입력했다면 운영체제에서 알아서 잘 해석을 한 다음 우리가 이해할 수 있는 데이터로 만들어서 스트림에 전달하기 때문이죠.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1438BA514D189A2D0FA2F2)
http://en.wikipedia.org/wiki/File:Stdstreams-notitle.svg

그런데 사실 생각해보면 우리는 위에서 말한 두 예인 모니터와 키보드에 대한 스트림을 한번도 만든 적이 없습니다. 파일을 이용할 때 에는 파일에 대한 스트림을 `fopen` 으로 만든다고 했는데 말이죠. 사실 모니터와 키보드에 대한 스트림은 **표준 스트림(standard stream)** 이라 해서 프로그램이 실행될 때 자동으로 생성됩니다.

위 그림에도 달 나와있듯이 모니터에 대한 스트림은 `stdout` 이고, 키보드에 대한 스트림은 `stdin` 입니다. (그 외에 `stderr` 이라는 표준 오류 스트림이란 것이 있는데 `stdout` 하고 거의 동일하다고 보시면 됩니다. 단지, 오류 메세지를 출력하는 스트림 입니다)

이제 다시 맨 처음의 예제로 돌아가보도록 합시다.

```cpp-formatted
FILE *fp;
fp = fopen("a.txt", "w");
```

이렇게 해서 스트림을 만들었으면 `fopen` 함수는 만든 스트림을 가리키는 포인터를 리턴합니다. 스트림에 관한 정보는 `FILE` 구조체에 들어가 있습니다. (FILE 구조체에 대한 자세한 내용을 알고 싶다면 [여기](http://blog.naver.com/bsbs0126/150033511204)로) 이제, 우리는 `fp` 를 가지고 파일을 사용할 수 있게 되는 것입니다. 그런데, 우리는 `fopen` 에서 두 번째 인자로 "w" 를 전달했는데, 이 말의 의미는 파일에 오직 '쓰기' 만이 가능하게 하겠다 라는 의미 입니다. 다시 말해 스트림인데도 출력 스트림만 만들어 놓은 것이지요. (파일에 쓰는 것은 프로그램의 관점에서 보았을 때 출력이므로 출력 스트림, 파일에서 읽는 것은 프로그램의 관점에서 보았을 때 입력 받는 것이므로 입력 스트림 입니다) 쉽게 말하면 일방 통행 도로를 만들어 놓은 것과 같습니다.

이렇게 출력만 하게 했다면 당연히 파일에 **쓰기** 만 할 수 있습니다. 파일에서 데이터를 읽는 작업은 불가능 하게 됩니다. 일단 읽는 것은 나중에 생각하기로 하고 어떻게 파일에 쓰기를 하는지 알아보도록 합시다. `fopen` 에서 "w" 로 전달했을 때 특징이, 첫번째 인자로 전달된 이름의 파일이 존재하지 않는다면 아무 내용이 없는 파일을 새로 만들거나, 동일한 이름의 파일이 존재 한다면 그 내용을 다 지워버리게 됩니다. 참고로, "a.txt" 로 그냥 파일의 이름을 전달한다면 오직 '소스 파일과 동일한 경로에 들어있는 파일들' 을 찾게 됩니다. 만일 다른 폴더에 있는 `a.txt` 를 찾고 싶다면 그 경로를 넣어주면 됩니다.

예를 들어 C 드라이브의 `BBB` 라는 폴더의 `a.txt` 를 원한다면 다음과 같이 하면 됩니다.

```cpp-formatted
fp = fopen("C:\\BBB\\a.txt", "w");
```


이 때 `\\` 를 쓰는 이유는 `\` 하나만 쓰면 `escape character` 라고 해서 이상한 문자가 되므로 `\\` 를 두개 붙여 써서 `\` 로 나타내야 합니다.

아무튼, 우리의 `a.txt` 의 경우 원래 존재 하지 않았을 것이므로 `fopen` 에서 `a.txt` 를 `"w"` 로 여는 순간 새로운 파일이 만들어집니다.

```cpp-formatted
if (fp == NULL) {
  printf("Write Error!!\n");
  return 0;
}
```


이 다음은 아주 중요한 부분인데, 파일이 어떠한 이유에서라든지 열지 못한 경우 `fopen` 함수는 `NULL` 을 리턴합니다. `fopen` 이 실패하는 경우는 그리 많지 않으므로 이 부분을 생략하는 경우가 가끔 있는데, 만일 `fopen` 이 실패하게 되었을 경우 이렇게 검사하지 않는다면 소스 뒷부분에서 어떠한 문제가 발생할지 모르므로 이렇게 항상 검사하는 것이 중요합니다.

```cpp-formatted
fputs("Hello World!!! \n", fp);
```

이제 `fputs` 라는 훌륭한 함수로 파일에 기록할 수 있습니다. 첫번째 인자로 파일에 기록할 문자열을 전달하고 두번째 인자로 어떠한 스트림을 택할지 그 포인터를 써주면 됩니다. 우리는 우리가 위에서 열은 파일 스트림을 택할 것이므로 `fp` 를 써주면 됩니다. 재미있는 사실은 표준 스트림들은 이미 이름이 정해져 있는데 앞서 말했듯이 `stdout` 은 컴퓨터의 모니터에 해당하는 표준 출력 스트림이라 했습니다. 즉, 두 번째 인자로 `stdout` 을 전달하면 우리 콘솔 화면에 그 문자열이 뜨게 되겠지요.

```cpp-formatted
fputs("Hello World!!! \n", stdout);
```


  을 해보면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F203F1E334D18A92C17EEE9)

  와 같이 실제로 잘 나오는 것을 알 수 있습니다. 아무튼

```cpp-formatted
fputs("Hello World!!! \n", fp);
```


를 통해 파일에 `"Hello World!!! \n"` 을 기록하게 됩니다. 이제 마지막으로

```cpp-formatted
fclose(fp);
```

를 통해 연결되었던 스트림을 닫아 주어야만 합니다. 만일 이렇게 `fclose` 로 닫지 않는다면 스트림이 계속 살아 있게 되어서 이 파일은 계속 쓰기 상태로 남아 있게 됩니다. 이는 프로그램이 종료되기 전까지 이 상태로 계속 남아 있기 때문에, 마치 동적 메모리 할당에서 `free` 로 메모리를 반환해 주어야 하는 것처럼 스트림도 닫아 주어야 합니다.

재미있는 사실은 `fclose` 로 표준 스트림들도 닫아버릴 수 있는데 예를 들어

```cpp-formatted
/* stdout 을 닫아버린다 */
#include <stdio.h>
int main() {
  fclose(stdout);
  printf("aaa");
  return 0;
}
```


으로 표준 출력 스트림을 닫아버리면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F19389B334D18A9E6285A11)

와 같이 `printf` 를 해도 아무것도 나오지 않는 재미있는 일이 발생합니다.



### 파일에서 입력 받기


```cpp-formatted
/* fgets 로 a.txt 에서 내용을 입력 받는다. */

#include <stdio.h>
int main() {
  FILE *fp = fopen("a.txt", "r");
  char buf[20];  // 내용을 입력받을 곳
  if (fp == NULL) {
    printf("READ ERROR !! \n");
    return 0;
  }
  fgets(buf, 20, fp);
  printf("입력받는 내용 : %s \n", buf);
  fclose(fp);
  return 0;
}
```


  성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F185FFD594D18B0B00A6393)

한 번 소스코드를 살펴봅시다.

```cpp-formatted
FILE *fp = fopen("a.txt", "r");
```

이번에는 "w" 가 아니라 "r" 형으로 열었습니다. 이번에는 **읽기** 형식으로 파일을 열게됩니다.

```cpp-formatted
if (fp == NULL) {
  printf("READ ERROR !! \n");
  return 0;
}
```

이전 예제와 마찬가지로 `fp` 가 `NULL` 인지 아닌지 확인하는데, 특히 읽기 형식으로 파일을 열 때 에는 더욱 주의해야 할 부분입니다. 왜냐하면 쓰기 형식으로 파일을 열었을 때 에는 파일이 존재하지 않는다면 새로 만들었지만 읽기 형식으로 열 때 에는 읽어들일 파일이 없다면 `NULL` 을 리턴하고 스트림을 만들지 않기 때문이지요.

```cpp-formatted
fgets(buf, 20, fp);
```


이제 `fgets` 함수를 통해 파일로 부터 문자열을 입력 받습니다. 첫번째 인자로 어디에 입력받을 지, 두번째 인자로 입력받을 바이트 수, 세번째 인자로 어떤 스트림을 통해 입력받을지 명시해 주면 됩니다. 

우리의 경우 `buf` 라는 공간에 20 바이트를 입력받을 것입니다. `fgets` 의 좋은 점이 입력받는 양을 제한할 수 있다는 점인데 기존의 `scanf` 와 의 경우 문자열을 입력 받을 때 제한을 두지 않아 할당된 메모리 크기를 넘어버리는 오버플로우 (예를 들어 `char str[20];` 에 100 글자를 입력 받는다던지) 가 되는 경우가 있었지만 `fgets` 는 이를 방지할 수 있으므로 상당히 안정적이라고 볼 수 있습니다.

```cpp-formatted
printf("입력받는 내용 : %s \n", buf);
```


이렇게 입력 받은 `printf` 로 출력하면 됩니다.

```cpp-formatted
/* 한 글자씩 입력받기*/
#include <stdio.h>

int main() {
  FILE *fp = fopen("a.txt", "r");
  char c;

  while ((c = fgetc(fp)) != EOF) {
    printf("%c", c);
  }

  fclose(fp);
  return 0;
}
```

성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F127AD7414D18B6512277B4)

와 같이 나옵니다.

```cpp-formatted
while ((c = fgetc(fp)) != EOF) {
  printf("%c", c);
}
```


주목할 부분은 위 부분 입니다. `fgetc` 는 `fp` 에서 문자 하나를 얻어옵니다. 즉, 한 문자씩 읽어들이는 것이지요. 이 때 문자열 맨 마지막이 `NULL` 문자로 종료를 나타내는 것 처럼,파일의 맨 마지막에는 `EOF` 라고 `End Of File` 을 나타내는 값인 `-1` 이 들어가 있습니다. 실제로 `EOF` 의 원형을 찾아보아도

```cpp-formatted
#define EOF (-1)
```

로 `-1` 로 선언되어 있습니다. 따라서 우리는 `c` 가 `EOF` 인지 아닌지 비교함을 통해 파일의 끝까지 입력을 받았는지 안받았는지 알 수 있습니다. 이와 같은 방식을 통해 아래 예제 처럼 파일의 크기를 알아내는 프로그램도 만들 수 있습니다.

```cpp-formatted
#include <stdio.h>

int main() {
  FILE *fp = fopen("a.txt", "r");
  int size = 0;

  while (fgetc(fp) != EOF) {
    size++;
  }

  printf("이 파일의 크기는 : %d bytes \n", size);
  fclose(fp);
  return 0;
}
```


성공적으로 컴파일 했다면



![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F147962594D18BCE501D55E)

와 같이 잘 나옵니다.

원리는 이전의 예제와 동일합니다. `EOF` 가 나오기 전 까지 계속 `size` 를 증가시켜서 파일의 크기를 알아내는 것이지요.



### 파일 위치 지정자





여태까지 파일에서 입력을 받을 때 언제나 파일의 시작 부분에서 끝 부분으로 입력을 쭉 받아 나갔습니다. 즉, 이전에 입력 받았던 데이터는 다시 입력 받지 않았다는 것이지요. 이것이 가능하게 된 이유는 **파일 위치 지정자** 때문 입니다. 영어로 **Position Indicator** 라고 합니다.

만일 `a.txt` 에 `abcdefg` 가 들어있고 우리가 `fgetc` 로 입력을 받는다고 해봅시다. 파일을 맨 처음 열었을 때 에는 파일 위치 지정자는 파일의 맨 첫부분을 가리키고 있습니다. 따라서 `a` 를 가리키고 있다고 보아도 무방합니다. 이제, 우리가 `fgetc` 로 입력을 받는다면 파일 위치지정자는 한 칸 넘어가서 다음에 입력 받을 것을 가리키고 있게 되지요. 따라서 `fgetc` 를 한 번 더하면 `a` 를 다시 입력 받는 것이 아니라 그 다음인 `b` 를 입력 받게 됩니다. 그리고 또 파일 위치지정자는 또 한 칸 이동해서 그 다음인 `c` 를 가리키고 있겠지요.

그런데 만일 여러분이 `abcd` 까지 파일에서 입력 받았는데 다시 처음 부터 입력받고 싶다면 어떻게 할까요? 일단 두 가지 방법이 있는데 하나는 `fopen` 으로 파일을 다른 스트림으로 또 여는 것이고, 또다른 방법은 파일 위치지정자를 맨 앞으로 옮기면 되겠지요. 여기서는 후자를 택하도록 합시다.

```cpp-formatted
#include <stdio.h>
int main() {
  /* 현재 fp 에 abcdef 가 들어있는 상태*/
  FILE *fp = fopen("a.txt", "r");
  fgetc(fp);
  fgetc(fp);
  fgetc(fp);
  fgetc(fp);
  /* d 까지 입력받았으니 파일 위치지정자는 이제 e 를 가리키고 있다 */
  fseek(fp, 0, SEEK_SET);
  printf("다시 파일 처음에서 입력 받는다면 : %c \n", fgetc(fp));
  fclose(fp);
  return 0;
}
```



성공적으로 컴파일 하였다면



![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F155FDA344D18C94901D0C3)



와 같이 `a` 가 다시 잘 나오는 것을 보실 수 있습니다.

```cpp-formatted
fgetc(fp);
fgetc(fp);
fgetc(fp);
fgetc(fp);
```


일단 `a.txt` 에 원래 `abcdef` 가 들어있었다고 합시다. 그렇다면 위 문장을 통해 차례대로 `a,b,c,d` 를 입력받고 (물론 저장은 하지 않지만) 이제 파일 위치지정자는 `e` 를 가리키게 됩니다. 그런데,

```cpp-formatted
fseek(fp, 0, SEEK_SET);
```

를 통해 파일 위치지정자를 맨 처음으로 돌려버릴 수 있었습니다. `fseek` 함수는 `fp` 를 세번째 인자로 부터 두번째 인자 만큼 떨어진 곳으로 파일 위치지정자를 돌리는데, 위 경우 `SEEK_SET` 으로 부터 0 번째 떨어진 곳, 즉 `SEEK_SET` 으로 돌린다고 볼 수 있습니다.

이 때 `SEEK_SET` 은 파일의 맨 처음을 일컫는 매크로 상수 입니다. 따라서 위 함수를 통해 `fp` 의 파일 위치지정자를 맨 처음으로 돌려서 다시 `fgetc` 를 하였을 때 `a` 를 입력받게 됩니다. 참고로, `SEEK_SET` 외에도, 현재의 위치를 표시하는 `SEEK_CUR` 과 파일의 맨 마지막을 표시하는 `SEEK_END` 상수들이 있습니다.

```cpp-formatted
/* 출력 스트림도 마찬가지*/
#include <stdio.h>
int main() {
  FILE *fp = fopen("a.txt", "w");
  fputs("Psi is an excellent C programmer", fp);
  fseek(fp, 0, SEEK_SET);
  fputs("is Psi", fp);
  fclose(fp);
  return 0;
}
```



성공적으로 컴파일 하였을 때, `a.txt` 의 모습을 보면



![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F1664BD404D18CBC1051A2E)




로 나타납니다. 사실 이번 예제도 상당히 쉬운데, 먼저 `fputs` 로

```cpp-formatted
fputs("Psi is an excellent C programmer", fp);
```


`Psi is an excellent C programmer` 을 넣었고, 이 때 파일을 열어보았더라면 이와 같은 문장이 들어 있었을 것입니다. 그런데,

```cpp-formatted
fseek(fp, 0, SEEK_SET);
```



로 파일 위치지정자를 맨 처음으로 돌려서 다시 `fputs` 를 했을 때, 파일 앞에 내용이 끼워져 들어가는 것이 아니라 이전의 내용에 덮어쓰기 하면서 기록이 되므로 맨 처음 ‘Psi is’ 를 ‘is Psi’ 로 내용을 바꿔버립니다. 따라서 결국에는 `is Psi an excellent C programmer` 라는 문장이 파일에 남아 있게 됩니다.

이번 강좌에서는 이렇게 대략적으로 파일 입출력을 어떻게 하는 것인지, 그리고 파일 위치지정자가 무엇인지 소개했습니다. 사실 파일 입출력의 백미는 다음 강좌에서 부터 시작이라 보시면 됩니다 :)

### 생각해보기

#### 문제 1

사용자로 부터 경로를 입력 받아서 그 곳에 파일을 생성하고 `a` 를 입력해놓는 프로그램을 만들어보세요 (난이도 : 下)

#### 문제 2

`a.txt` 에 어떠한 긴 글이 들어 있는데, 이 글을 입력 받아서 특정한 문자열을 검색하는 프로그램을 만들어보세요 (난이도 : 中)

#### 문제 3

`a.txt` 에 문자열을 입력 받아서 `b.txt` 에 그 문자열을 역으로 출력하는 프로그램을 만들어보세요 (난이도 : 中下)


##@ chewing-c-end
Link :  116
2010-12-26 09:04
----------------
title : C 언어 레퍼런스 - asctime 함수
cat_title :  asctime
publish_date : 2010-12-26 09:04
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ asctime

```info
#include <time.h> // C++ 에서는 <ctime>

char * asctime ( const struct tm * timeptr );
```


`tm` 구조체를 문자열로 바꾼다.
`timeptr` 이 가리키는 `tm` 구조체를 읽어들여서 아래와 같은 형식으로 문자열을 만들어서 출력한다.

`Www Mmm dd` hh:mm:ss `yyyy`

이 때 `Www` 는 요일 이름, `Mmm` 은 월 이름, `dd` 는 몇 일인지, 그리고 hh:mm:ss 는 현재 시간, `yyyy` 는 년도를 말한다. 예를 들면

`Sun Dec 25` 09:00:12 2010

과 같은 형식의 출력이 가능하다. 이 때, 리턴되는 문자열은 자동으로 끝에 \n 과 널 종료 문자열이 포함되어 있다.



###  인자




`timeptr`

`tm` 구조체를 가리키는 포인터 이다. 이 구조체에 들어있는 값을 토대로 문자열이 생성된다.



###  리턴값




`timeptr` 을 읽어서 위에서 말한 형식으로 만은 C 형식 문자열을 리턴한다. 이 때, 이 문자열은 정적으로 할당된 메모리 공간을 차지하고 있는데 `ctime` 과 `asctime` 함수가 같이 사용하고 있다. 따라서 이들 함수를 호출할 때 마다 이 문자열에 있는 내용이 덮어쓰기 되므로, 리턴된 문자열을 보관하기 위해서는 사용자가 직접 메모리 공간을 할당하여서 그 내용을 복사해 넣어야만 한다.



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/ctime/asctime/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <time.h>

int main() {
  time_t rawtime;
  struct tm* timeinfo;

  time(&rawtime);
  timeinfo = localtime(&rawtime);
  printf("The current date/time is: %s", asctime(timeinfo));

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F131466354D168E052284C6)

###  연관된 함수


*  [ctime](http://itguru.tistory.com/118)  :  `time_t` 를 가지고 `asctime` 과 동일한 작업을 한다.
*  [gmtime](http://itguru.tistory.com/119)  :  `time_t` 변수를 `UTC` 시간의 `tm` 구조체로 바꾼다.
*  [localtime](http://itguru.tistory.com/120)  :  `time_t` 변수를 지역 시간의 `tm` 구조체로 바꾼다.
*  [time](http://itguru.tistory.com/114)  :  현재 시간을 구한다.
Link :  114
2010-12-26 00:17
----------------
title : C 언어 레퍼런스 - time 함수
cat_title :  time
publish_date : 2010-12-26 00:17
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ time

```info
#include <time.h> // C++ 에서는 <ctime>

time_t time ( time_t * timer );
```


현재 시간을 구한다.

현재 시간을 [time_t 형](http://itguru.tistory.com/113)으로 구한다. (즉, 1970년 1 월 1 일 0 시 (UTC) 부터 현재 까지 흐른 초 수를 구한다고 보면 된다)

이 때 이 함수는 구한 [time_t](http://itguru.tistory.com/113) 형 값을 리턴하기도 하고, 인자로 받은 `timer` 가 가리키는 변수를 구한 `time_t` 형 값으로 설정한다.



###  인자




`timer`

[time_t](http://itguru.tistory.com/113) 형 변수를 가리키는 포인터로, 이 곳에 구해진 `time_t` 값이 전달된다. 물론 이 함수는 동일한 값을 친절하게 리턴도 해주기 때문에 `timer` 에 `NULL` 을 전달하고 리턴값을 받아도 된다.




###  리턴값




 [time_t](http://itguru.tistory.com/113) 형으로 구한 현재 시간을 리턴한다. 만일 그 값을 알아 올 수 없을 경우 -1 을 리턴한다.



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/ctime/time/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <time.h>

int main() {
  time_t seconds;

  seconds = time(NULL);
  printf("%ld hours since January 1, 1970 \n", seconds / 3600);

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F133D89414D16827029ED76)




###  연관된 함수


* [asctime](http://itguru.tistory.com/116)  :  `tm` 구조체를 문자열로 바꾼다.
*  [gmtime](http://itguru.tistory.com/119)  :  `time_t` 를 `UTC` 시간에 따라 `tm` 구조체로 바꾼다.
*  [localtime](http://itguru.tistory.com/120)  : `time_t` 를 지역 시간에 따라 `tm` 구조체로 바꾼다.
Link :  112
2010-12-26 00:09
----------------
title : C 언어 레퍼런스 - mktime 함수
cat_title :  mktime
publish_date : 2010-12-26 00:09
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ mktime

```info
#include <time.h> // C++ 에서는 <ctime>

time_t mktime ( struct tm * timeptr );

```

`tm` 구조체를 `time_t` 형식으로 변환한다.
`timeptr` 이 가리키는 [ tm 구조체](http://itguru.tistory.com/109)를 읽어 들여서 [time_t](http://itguru.tistory.com/113)형식으로 리턴한다.

이 때, 이 함수가 `tm` 구조체에서 참조하는 값은 현재 시각과 날짜 뿐이다. 나머지 정보인 `tm_wday` 와 `tm_yday` 는 무시한다.

참고로 이 함수는 `timeptr` 이 가리키는 `tm` 구조체의 내용을 수정하는데, `tm` 구조체에 들어있는 시각과 날짜 정보를 가지고 `tm_wday` 와 `tm_yday` 를 설정한다. 따라서 이를 통해 역으로 `mktime` 함수를 호출 하여서 특정한 날짜가 무슨 요일이고, 몇 번째 날인지 추적할 수 도 있다.



###  인자


`timeptr`

 [tm 구조체](http://itguru.tistory.com/109)를 가리키는 포인터로 반드시 날짜와 시간에 관한 정보가 들어 있어야 한다.



###  리턴값





현재 `timeptr` 로 전달된 날짜와 시각에 맞추어서 이에 대한 [time_t](http://itguru.tistory.com/113)값이 리턴된다. 오류 발생시에는 -1 이 리턴된다.



###  실행 예제



```cpp-formatted
/*

특정한 날짜가 무슨 요일인지 알아온다.
이 예제는
http://www.cplusplus.com/reference/clibrary/ctime/mktime/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <time.h>

int main() {
  time_t rawtime;
  struct tm* timeinfo;
  int year, month, day;
  char* weekday[] = {"Sunday",   "Monday", "Tuesday", "Wednesday",
                     "Thursday", "Friday", "Saturday"};

  /* 사용자로 부터 날짜를 입력 받는다. */
  printf("Enter year: ");
  scanf("%d", &year);
  printf("Enter month: ");
  scanf("%d", &month);
  printf("Enter day: ");
  scanf("%d", &day);

  /* rawtime 에 time 함수로 현재 시간 정보로 세팅한 뒤,
     사용자로 부터 입력받은 데이터로 년/월/일 정보를 수정한다. */
  time(&rawtime);
  timeinfo = localtime(&rawtime);
  timeinfo->tm_year = year - 1900;
  timeinfo->tm_mon = month - 1;
  timeinfo->tm_mday = day;

  /* mktime 함수를 호출하면 년/월/일 데이터에 따라
     tm_wday 와 tm_yday 를 설정한다. 이 때 리턴되는 time_t 데이터는 사용하지
     않는다.*/
  mktime(timeinfo);

  printf("That day is a %s.\n", weekday[timeinfo->tm_wday]);

  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F2053CC544D1607BD2BED84)





###  연관된 함수


*  [asctime](http://itguru.tistory.com/116) : `tm` 구조체를 문자열로 변환한다.
*  [gmtime](http://itguru.tistory.com/119)  :  `time_t` 값을 `UTC` 시간에 따라 `tm` 구조체로 변환한다.
*  [localtime](http://itguru.tistory.com/120) : `time_t` 값을 지역 시간에 따라 `tm` 구조체로 변환한다.
*  [time](http://itguru.tistory.com/114)  :  현재 시각을 알아온다.
Link :  113
2010-12-25 23:59
----------------
title : C 언어 레퍼런스 - time_t 형
cat_title : time_t 형
ref_title : time_t
publish_date : 2010-12-25 23:59
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ time_t

`time_t` 형은 `ISO C` 라이브러리에서 정의된 데이터 타입이다. 이 타입은 `time()` 과 같은 라이브러리 함수에서 리턴되는 타입인데, `<time.h>` 헤더에서 (C++ 의 경우 `<ctime>` ) `typedef` 를 통해 정의되어 있다.

`ISO C` 에 따르면 `time_t` 는 산술 연산이 가능한 타입이지만 특정한 크기가 값의 범위 등을 명시하고 있지는 않다. 더군다나, 어떠한 산술 연산이 적용 가능해야하는지 조차 불분명 하게 정의되어 있다.

유닉스와 `POSIX` 시스템에서는 `time_t` 를 정수 (통상적으로 32 또는 64 비트 정수) 혹은 부동 소수점 형으로 정의하고 있다. 이 때, 이 값은 1970 년 1 월 1 일 자정 (UTC) 에서 부터 현재 까지 흐른 초 수를 의미한다.

윈도우즈의 경우도 마찬가지로 1970년 1 월 1일 자정 부터 현재까지 흐른 초 수를 의미하며 32 비트 혹은 64 비트 정수형을 사용한다.

현재 많은 경우 `time_t` 형을 32 비트 정수형으로 잡고 있는데 이 때문에 2038년이 되면 32 비트 형에서 오버플로우가 일어나므로 64 비트로의 전환이 시급한 문제이다. 참고로 `Visual C++ 2008` 에서 `time_t` 는 `__time64_t` 로 정의되어 있고 `__time64_t` 는 `__int64` 로 정의되어 있어서 2038 년의 오버플로우 문제는 발생하지 않는다.



### 실행 예제

```cpp-formatted
#include <stdio.h>
#include <time.h>

int main() {
  time_t seconds;

  time(&seconds);

  printf("1970년 부터 몇 초나 지났나 : %d 초 \n", seconds);

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F143FF65A4D16845F19903F)
Link :  111
2010-12-25 23:05
----------------
title : C 언어 레퍼런스 - difftime 함수
cat_title :  difftime
publish_date : 2010-12-25 23:05
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ difftime

```info
#include <time.h> // C++ 에서는 <ctime>

double difftime ( time_t time2, time_t time1 );
```


두 개 시각의 차이를 구한다.
`time1` 과 `time2` 가 몇 초 차이나는지 계산한다.



###  인자




`time2`

  `time_t` 형 변수로 나중 시각을 나타낸다.

`time1`

  `time_t` 형 변수로 이전 시각을 나타낸다.



###  리턴값




`time2` 와 `time1` 가 몇 초 차이 나는지를 `double` 형으로 리턴한다.



###  실행 예제




```cpp-formatted
/*이름을 쓰는데 얼마나 걸리는지 알아온다.이
 * 예제는http://www.cplusplus.com/reference/clibrary/ctime/difftime/에서
 * 가져왔습니다.*/
#include <stdio.h> #include <time.h> int
main() {
  time_t start, end;
  char szInput[256];
  double dif;
  time(&start);
  printf("Please, enter your name: ");
  gets(szInput);
  time(&end);
  dif = difftime(end, start);
  printf("Hi %s.\n", szInput);
  printf("It took you %.2lf seconds to type your name.\n", dif);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F177A173A4D15F9B43D6540)



###  연관된 함수


*  [asctime](http://itguru.tistory.com/116):  `tm` 구조체를 문자열로 변환한다.
*  [gmtime](http://itguru.tistory.com/119)  :  `time_t` 를 `tm` 으로 바꾸되 `UTC` 형식 시간으로 바꾼다.
*  [localtime](http://itguru.tistory.com/120)  :  `time_t` 를 `tm` 으로 바꾸되 지역 시간으로 바꾼다.
*  [time](http://itguru.tistory.com/114)  :  현재 시각을 구한다.
Link :  110
2010-12-25 12:31
----------------
title : C 언어 레퍼런스 - clock 함수
cat_title :  clock
publish_date : 2010-12-25 12:31
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ clock

```info
#include <time.h> // C++ 에서는 <ctime>

clock_t clock ( void );
```


프로그램 실행 후 몇 클록이 지나갔는지 알려준다.
우리는 `CLOCKS_PER_SEC` 매크로를 통해 1 초에 몇 클록인지 알 수 있다. 참고로 여기서의 클록은 `CPU` 의 클록 수 와는 의미가 다르다.

참고로 이 함수가 '프로그램의 시작' 으로 잡는 위치는 플랫폼 마다 다를 수 있다. 따라서 특정 프로그램의 실행 시간을 알기 위해서는 프로그램 시작시 `clock` 함수를 호출한 값과 프로그램 종료시 `clock` 함수를 한 번 더 호출하여서 그 값을 비교해야만 한다.



###  인자


없다




###  리턴값




프로그램이 시작했을 때 부터 몇 클록이 지나갔는지 그 값을 리턴한다.
만일 그 값을 읽는데 실패하였다면 -1 을 리턴한다.

참고로 `clock_t` 는 `<time.h>` (혹은 `<ctime>` ) 에 정의되어 있으며 통상적으로 `long` 형 이다.



###  실행 예제




```cpp-formatted
/*

10 초를 카운트 다운 한다.

이 예제는
http://www.cplusplus.com/reference/clibrary/ctime/clock/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <time.h>

void wait(int seconds) {
  clock_t endwait;
  endwait = clock() + seconds * CLOCKS_PER_SEC;
  while (clock() < endwait) {
  }
}

int main() {
  int n;
  printf("Starting countdown...\n");
  for (n = 10; n > 0; n--) {
    printf("%d\n", n);
    wait(1);
  }
  printf("FIRE!!!\n");
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1445DF5A4D15652D1B7F62)




###  연관된 함수

*  [time](http://itguru.tistory.com/114)  :  현재 시각을 알아온다.
*  [difftime](http://itguru.tistory.com/111)  :  두 개 시각의 차이를 구한다.
Link :  103
2010-12-25 03:02
----------------
title : 씹어먹는 C 언어 - <22. C 언어의 잡다한 키워드들 (typedef, volatile, #pragma)>
cat_title : 22. C 언어의 잡다한 키워드들 (typedef, volatile, #pragma)
next_page : 117
publish_date : 2010-12-25 03:02
--------------


이번 강좌에서는

* `typedef` 키워드에 대해 알아본다.

* `volatile` 키워드에 대해 알아본다.

* `#pragma` 에 대해 알고, 특히 `#pragma pack` 과 `#pragma once` 키워드에 대해 이해한다.

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분. 저의 C 언어 강의도 이제 막바지에 다다랐습니다. 정말로 첫번째 강의부터 여기 까지 달려오셨다면 정말 대단하다고 말씀 드리고 싶네요. 마라톤에 비유하자면, `42.195km` 에서 한 `40km` 정도 까지 열심히 뛰어 왔다고 보시면 됩니다. 그럼, 나머지 `2.195km` 도 더 뛸 의향이 있겠죠?

```cpp-formatted
/* 루저 위너 판별*/
#include <stdio.h>
int Print_Status(struct HUMAN human);
struct HUMAN {
  int age;
  int height;
  int weight;
  int gender;
};

int main() {
  struct HUMAN Adam = {31, 182, 75, 0};
  struct HUMAN Eve = {27, 166, 48, 1};

  Print_Status(Adam);
  Print_Status(Eve);
}

int Print_Status(struct HUMAN human) {
  if (human.gender == 0) {
    printf("MALE \n");
  } else {
    printf("FEMALE \n");
  }

  printf("AGE : %d / Height : %d / Weight : %d \n", human.age, human.height,
         human.weight);

  if (human.gender == 0 && human.height >= 180) {
    printf("HE IS A WINNER!! \n");
  } else if (human.gender == 0 && human.height < 180) {
    printf("HE IS A LOSER!! \n");
  }

  printf("------------------------------------------- \n");

  return 0;
}
```

위 코드는 이전에 구조체 단원에서 만들었던 루저-위너 구별 프로그램 입니다. 그런데 위 코드에서 한 가지 귀찮은 점이 있습니다. 바로, 구조체를 사용할 때 마다 앞에 `struct` 키워드를 붙여야 한다는 점입니다. 이게 상당히 짜증나는 일인데, 간혹 `struct` 키워드를 붙이지 않는 날에는

```warning
error C2146: 구문 오류 : ')'이(가) 'human' 식별자 앞에 없습니다.
error C2061: 구문 오류 : 식별자 'human'
error C2059: 구문 오류 : ';'
error C2059: 구문 오류 : ')'
error C2449: 파일 범위에 '{'가 있습니다. 함수 헤더가 없는 것 같습니다.
error C2059: 구문 오류 : '}'
```


위와 같은 오류 테러를 맞보게 됩니다. (위 오류는 `int Print_Status(struct HUMAN human)` 대신에 `int Print_Status(HUMAN human)` 이라 썼을 때 나타나는 오류들 입니다) 상당히 짜증나는 일지요. 그렇다면 귀찮게 'struct HUMAN' 이라 길게 쓰는 대신에 짧에 쓰는 방법이 없을까요?

물론 있습니다.

```cpp-formatted
/* typedef 의 이용 */
#include <stdio.h>
struct HUMAN {
  int age;
  int height;
  int weight;
  int gender;
};

typedef struct HUMAN Human;
int Print_Status(Human human);
int main() {
  Human Adam = {31, 182, 75, 0};
  Human Eve = {27, 166, 48, 1};

  Print_Status(Adam);
  Print_Status(Eve);
}

int Print_Status(Human human) {
  if (human.gender == 0) {
    printf("MALE \n");
  } else {
    printf("FEMALE \n");
  }

  printf("AGE : %d / Height : %d / Weight : %d \n", human.age, human.height,
         human.weight);

  if (human.gender == 0 && human.height >= 180) {
    printf("HE IS A WINNER!! \n");
  } else if (human.gender == 0 && human.height < 180) {
    printf("HE IS A LOSER!! \n");
  }

  printf("------------------------------------------- \n");

  return 0;
}
```

성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F157220264CF104BC288A84)

와 같이 나옵니다.

위 코드에서 가장 눈여겨 보아야 할 부분은

```cpp-formatted
typedef struct HUMAN Human;
```


입니다. 우리는 여기서 `typedef` 라는 키워드를 사용했는데 이 키워드는 다음과 같이 사용합니다

```info
typedef (이름을 새로 부여하고자 하는 타입) (새로 준 타입의 이름)
```


다시 말해 위에서 썼던 코드는 `struct HUMAN` 이라는 타입에 `Human` 이라는 다른 이름을 붙인 것이 됩니다. 즉, `struct HUMAN` 이라고 쓸 것을 `Human` 이라고 써도 된다는 것이지요. 물론 기존의 이름을 없애 버린 것이 아니기 때문에 `typedef` 를 사용한 이후에도 `struct HUMAN` 이라고 쓴 것은 유효 합니다.

즉 위와 같은 일을 하고 나면 다음과 같은 문장은 모두 동일해집니다.

```cpp-formatted
struct HUMAN a;
Human a;
```

상당히 편리해졌지요? 하지만 진정 `typedef` 를 이용하는 이유는 이렇게 형을 간단하게 쓴다는 이유 때만은 아닙니다. 아래의 예제를 보세요.

```cpp-formatted
/* 간단한 계산기 프로그램 */
#include <stdio.h>
int main() {
  int input;
  int a, b;

  while (1) {
    printf("--- 계산기 --- \n");
    printf("1. 덧셈 \n");
    printf("2. 뺄셈 \n");
    printf("3. 종료 \n");

    scanf("%d", &input);

    if (input == 1) {
      printf("두 수 : ");
      scanf("%d%d", &a, &b);
      printf("%d 와 %d 의 합 : %d \n", a, b, a + b);
    } else if (input == 2) {
      printf("두 수 : ");
      scanf("%d%d", &a, &b);
      printf("%d 와 %d 의 차 : %d \n", a, b, a - b);
    } else
      break;
  }

  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F2057E0564D0D58391AEC1F)

와 같이 계산기 프로그램이 잘 실행됩니다. 만일 이 프로그램을 실제 계산기에 사용한다고 합시다. 그런데, 우리가 이 프로그램을 사용할 계산기는 안타깝게도 `CPU` 에서 32 비트 정수의 연산을 할 수 없습니다. 오직 16 비트 이하만 연산할 수 있다고 합시다. 그렇다면 이 계산기에서 `int` 형을 사용하는 것은 불가능 하고 `short` 나 `char` 형의 변수들만 선언해야 겠죠.

그렇다면 이를 위해 소스 코드 전체의 모든 변수들을 `char` 이나 `short` 로 바꿔주어야 합니다. 그런데 만일 동일한 프로그램인데 다른 기종의 계산기 에서는 `int` 형이 사용 가능하다고 합시다. 그렇다면 이 코드를 다시 또 바꿔주어야 합니다. 아주 아주 귀찮은 일이 아닐 수 없죠. 이런 상황을 대비하여서 다음과 같이 코드를 바꿔봅시다.

```cpp-formatted
/* 향상된 소스 코드 */
#include <stdio.h>
typedef int CAL_TYPE;
int main() {
  CAL_TYPE input;
  CAL_TYPE a, b;

  while (1) {
    printf("--- 계산기 --- \n");
    printf("1. 덧셈 \n");
    printf("2. 뺄셈 \n");
    printf("3. 종료 \n");

    scanf("%d", &input);

    if (input == 1) {
      printf("두 수 : ");
      scanf("%d%d", &a, &b);
      printf("%d 와 %d 의 합 : %d \n", a, b, a + b);
    } else if (input == 2) {
      printf("두 수 : ");
      scanf("%d%d", &a, &b);
      printf("%d 와 %d 의 차 : %d \n", a, b, a - b);
    } else
      break;
  }

  return 0;
}
```


이 역시 잘 실행됩니다. 다만 바뀐 것은 변수들의 타입을 `CAL_TYPE` 라고 했던 점이지요. 그리고 위에서 `typedef` 를 통해 `CAL_TYPE` 가 `int` 형과 같다고 정의하였습니다. 만일 이 소스 코드를 `short` 나 `char` 만 되는 계산기에 적용시킬려면 어떻게 해야 할까요? 기존에는 모든 변수의 타입을 전부다 수정해야 했지만 이제는 `typedef` 에서 `CAL_TYPE` 의 형을 `short` 나 `char` 로 간단히 바꿔버리면 되는 것입니다. 정말로 일이 쉬워졌습니다.



### 여러가지 `typedef` 들


```cpp-formatted
/* 여러가지 typedef 예제들 */

#include <stdio.h>
int add(int a, int b) { return a + b; }
typedef int CAL_TYPE;
typedef int (*Padd)(int, int);
typedef int Arrays[10];
int main() {
  CAL_TYPE a = 10;
  Arrays arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};
  Padd ptr = add;
  printf("a : %d \n", a);
  printf("arr[3] : %d \n", arr[3]);
  printf("add(3, 5) : %d \n", ptr(3, 5));
  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F20513A4E4D0D5B96266941)


가장 먼저 소스 코드에서 아래 문장 부터 살펴봅시다.

```cpp-formatted
typedef int (*Padd)(int, int);
```


이전에 배웠던 함수 포인터가 잘 기억이 나시는지는 잘 모르겠지만 아무튼, 위 `typedef` 명령문은 복잡한 함수 포인터 명령을 `Padd` 라는 이름을 붙이는 것입니다. 즉, 다음 문장은 정확히 동일해집니다.

```cpp-formatted
int (*ptr)(int, int) = add;
Padd ptr = add;
```

참고로 간혹

```cpp-formatted
typedef int (*Padd)(int, int);
```

문장을 잘못 이해 하셔서, "우리가 앞에서 배운 바에 따르면 위 문장은 `int` 라는 형에 `(*Padd)(int, int)` 라는 또다른 이름을 붙이는 것이 아닌가?" 라고 물으실 수 있는데, 그건 아니고 `Padd` 라는 이름을 붙여주신다고 생각하시면 편합니다. 마찬가지로

```cpp-formatted
typedef int Arrays[10];
```


도 역시 '원소가 10 개인 `int` 형 배열을 선언해라' 문장을 `Arrays` 라고 하나의 이름으로 바꾼 것이라 보면 됩니다. 즉,

```cpp-formatted
int arr[10];
Arrays arr;
```

은 정확히 동일한 문장입니다.



### `volatile` 키워드





`volatile` 은 아주 아주 특수한 상황이 아니고서는 사용하지 않는 키워드 입니다. 사실 저도 그렇게 흔하게  사용하지 않고요. `volatile` 키워드를 사용하는 경우는 대부분 외부 하드웨어와 통신할 때 사용하게 됩니다. 이 말이 무슨 말이냐면, 아래 예제를 보시면 알게 될 것입니다.

만일 여러분이 특정한 외부 센서와 소통하는 프로그램을 만든다고 합시다. 이 센서는 RAM 의 특정 영역을 이용하는데, 만일 센서에 값이 감지되지 않으면 그 곳의 값이 0 이 되어 무언가가 감지되면 그 부분의 값을 1 로 한다고 합시다. 그렇다면 여러분은 십중팔구 아래와 같은 코드를 작성할 것입니다.

```cpp-formatted
#include <stdio.h>
typedef struct SENSOR {
  /* 감지 안되면 0, 감지되면 1 이다.*/
  int sensor_flag;
  int data;
} SENSOR;

int main() {
  SENSOR *sensor;
  /* 값이 감지되지 않는 동안 계속 무한 루프를 돈다*/
  while (!(sensor->sensor_flag)) {
  }
  printf("Data : %d \n", sensor->data);
}
```

\sidenote{참고로 typedef 를 위와 같이 써줌으로써 typedef struct SENSOR SENSOR 한 효과를 낼 수 있습니다.} 위 코드는 가상의 코드 이므로 컴파일 해보지 않겠습니다만, 일단 여러분은 위 코드에서 별 이상을 느끼지는 못할 것입니다. 하지만 똑똑한 컴파일러는 ‘너무 과하게 똑똑해서’ 우리가 사용한 `while` 문을 최적화 해버립니다. 보통의 상황에서 `sensor->sensor_flag` 의 값이 바뀌는 경우는 없기 때문에 굳이 `while` 문을 매번 돌릴 때 마다 값을 비교할 필요가 없게 되는 것이지요. 그냥 컴파일러는 값을 딱 한 번만 읽고 0 이 아니라면 그냥 가고, 0 이라면 `while` 문을 무한히 돌리는 것으로 생각해버립니다. 결과적으로 위 코드를 컴파일러는 다음과 같은 코드로 바꿔버립니다.

```cpp-formatted
#include <stdio.h>
typedef struct SENSOR {
  /* 감지 안되면 0, 감지되면 1 이다.*/
  int sensor_flag;
  int data;
} SENSOR;
int main() {
  SENSOR *sensor;
  if (!(sensor->sensor_flag)) {
    while (1) {
    }
  }
  printf("Data : %d \n", sensor->data);
}
```



이는 우리가 결코 원하던 결과가 아닙니다. 만일 센서에 값이 감지되었다고 해도 `while` 문을 절대로 탈출할 수 없게 되어 무한 루프에 빠지게 되는 것이지요. 우리는 컴파일러가 이런 최적화 작업을 수행하는 것을 원하지 않습니다. 이를 컴파일러에게 알려주기 위해서는 두 가지 방법이 있습니다.

첫번째로는 컴파일러의 최적화 옵션을 빼버리는 것입니다. `gcc` 에서는 단순히 최적화 옵션을 안주면 됩니다. `Visual Studio` 에서는 살짝 복잡한데, 프로젝트 속성의 **C/C++ –> 최적화** 에서 사용 안함을 선택하시면 됩니다. 그런데, 최적화를 하지 않기에는 너무나 그 손실이 큽니다. 최적화 옵션을 끄는 순간 다른 모든 코드들도 최적화를 하지 않겠다는 의미가 되거든요. 이를 위해 `volatile` 키워드가 생겨났습니다.

```cpp-formatted
#include <stdio.h>
typedef struct SENSOR {
  /* 감지 안되면 0, 감지되면 1 이다.*/
  int sensor_flag;
  int data;
} SENSOR;

int main() {
  volatile SENSOR *sensor;
  /* 값이 감지되지 않는 동안 계속 무한 루프를 돈다*/
  while (!(sensor->sensor_flag)) {
  }
  printf("Data : %d \n", sensor->data);
}
```



이렇게 해준 순간 컴파일러는 `sensor` 에 대해 최적화를 수행하지 않게 됩니다. `volatile` 의 의미는 ‘변덕스러운’ 이라는 의미를 가지고 있는데, `sensor` 에 `volatile` 키워드를 붙여준 순간 `sensor->sensor_flag` 의 값이 ‘변덕스럽게 변할 수 있기 때문’ 에 이에 대한 최적화 작업들을 수행하지 말라 라는 의미가 됩니다. 따라서 컴파일러는 위 소스를 의미 그대로 컴파일 하게 되어 우리가 원하던 결과를 얻을 수 있게 됩니다.

### #pragma 키워드

`#pragma` 는 **컴파일러에게 말하는 전처리기 명령** 이라고 보시면 됩니다. 즉, `#include` 나 `#define` 처럼 전처리기에 의해 컴파일 이전에 처리되지만, 그 명령은 컴파일러에게 전달되기 때문이죠. 사실 `pragma` 는 C 언어의 기본 키워드라고 하기 보다는, 컴파일러에 종속적인 키워드라고 하는 것이 맞습니다. `pragma` 를 사용하는 문법은 컴파일러 마다 다르고 딱히 통일 된 것이 없기 때문입니다. 이 강좌에서는 `pragma` 를 사용하는 몇 가지 예제들을 보고 어떤 경우에 편리하게 `pragma` 를 사용할 수 있는지 살펴봅시다.

#### `#pragma pack`

```cpp-formatted
#include <stdio.h>
struct Weird {
  char arr[2];
  int i;
};
int main() {
  struct Weird a;
  printf("size of a : %d \n", sizeof(a));
  return 0;
}
```



성공적으로 컴파일 했다면

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F160848524D1491DA137DB7)

와 같이 나옵니다.


상당히 이상하지요. 분명히 `Weird` 구조체 내의 원소들의 총 바이트 수를 계산해보면 `arr` 은 `char` 형 변수 2 개로 2 바이트 이고, `i` 는 `int` 형 변수 1 개로 4 바이트 이므로 6 이 나와야 정상이지요. 그런데 도대체 왜 컴퓨터는 이를 8 로 출력했을까요?

왜냐하면 실제로 메모리 상에서 위 구조체의 크기를 8 바이트로 **컴파일러**가 지정하였기 때문입니다. 현재 우리가 사용하는 컴퓨터에서는 언제나 4 바이트 단위로 모든 것을 처리하는 것이 빠릅니다. 따라서 언제나 컴퓨터에서 데이터를 보관할 때 에는 4의 배수로 데이터를 보관하는 것이 처리시 용이하게 됩니다. 이렇게 데이터가 4 의 배수 경계에 놓인 것을 *더블 워드 경계에 놓여 있다* 라고 합니다.

이러한 이유 때문에 위 `Weird` 구조체 역시 4 의 배수를 맞추기 위해 크기를 8 바이트로 ‘필요없는 2 바이트를 추가하면서 까지’ 맞춘 것입니다. 이 문제가 중요하게 여겨지는 부분은 역시 하드웨어 간의 통신 때문에 그렇습니다. 

예를 들어서 `SCSI` 인터페이스는 `PC` 에서 하드 디스크와 같은 주변 기기에 연결하기 위한 통신 방식으로 `SCSI` 장치들에게 읽기 명령을 내리기 위해서는 6 바이트의 명령어를 전송하면 됩니다. 이 6 바이트의 명령어의 구조는 꽤 복잡해서 흔히 구조체로 많이 이용하는데, 만일 위와 같이 그냥 사용했다가는 구조체의 크기가 8 바이트로 설정되어서 무슨 문제가 생길 지 알 수 없습니다.

이렇게 컴파일러로 하여금 구조체를 더블 워드 경계에 놓지 말라고 하고 싶을 때 `pragma` 키워드를 이용하면 됩니다.

```cpp-formatted
#include <stdio.h>
/* 전처리기 명령에는 ; 를 붙이지 않는다! */
#pragma pack(1)
struct Weird {
  char arr[2];
  int i;
};
int main() {
  struct Weird a;
  printf("size of a : %d \n", sizeof(a));
  return 0;
}
```

성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F180710424D14A4D401D28E)

와 같이 나옵니다.

이번에는 6 으로 잘 나옵니다. 위 명령은 마이크로소프트 계열의 컴파일러들에만 유효한 문장인데, 구조체를 ‘1 바이트 단위로 정렬하라는 뜻’ 입니다. 즉, 구조체의 크기가 1 의 배수가 되게 하라는 것이지요. 1 외에도 2,4,8,16 등이 올 수 있습니다. 만일 기본값, 즉 더블 워드 경계로 정렬하기 위해서는 `#pragma pack(4)` 로 하시면 됩니다.

#### `#pragma once`

아까의 `Weird` 구조체 예제에서 `Werid` 부분만 다른 헤더파일로 빼놓아 봅시다. 이 헤더파일의 이름은 `werid.h` 입니다.

```cpp-formatted
/* weird.h */
struct Weird {
  char arr[2];
  int i;
};
```

```cpp-formatted
/* test.c*/
#include <stdio.h>
#include "weird.h"
int main() {
  struct Weird a;
  a.i = 3;
  printf("Weird 구조체의 a.i : %d \n", a.i);
  return 0;
}
```



성공적으로 컴파일 했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F186C4F424D14A4D42684F7)




와 같이 나옵니다.

상당히 단순한 예제이지요. `test.c` 에서 `weird.h` 를 포함했으므로 `weird.h` 의 내용이 `test.c` 로 그대로 복사된 셈입니다. (즉, #include “weird.h” 부분이 `weird.h` 의  내용으로 바뀌었다고 보셔도 무방합니다) 따라서 `struct Weird` 를 사용할 수 있게 되므로 위와 같은 결과가 발생합니다. 그런데 만일 실수로 `weird.h` 를 두 번 포함했다고 합시다. 그렇다면 어떻게 될까요?

```cpp-formatted
#include <stdio.h>
#include "weird.h"
int main() {
  struct Weird a;
  a.i = 3;
  printf("Weird 구조체의 a.i : %d \n", a.i);
  return 0;
}
```



컴파일 하였다면

```warning
error C2011: 'Weird' : 'struct' 형식 재정의
 'Weird' 선언을 참조하십시오.
```


위와 같이 오류를 만나게 됩니다. 왜냐하면 각각 `#include "weird.h"` 부분이 `weird.h` 의 내용으로 바뀌어서 결과적으로는

```cpp-formatted
#include <stdio.h>
struct Weird {
  char arr[2];
  int i;
};
struct Weird {
  char arr[2];
  int i;
};

int main() {
  struct Weird a;
  a.i = 3;
  printf("Weird 구조체의 a.i : %d \n", a.i);
  return 0;
}
```



를 한 것과 마찬가지가 되어서 `struct Weird` 를 두 번 정의하였다고 오류가 나게 됩니다. 이를 막으려면 어떻게 해야 할까요?
일단 C 의 기본 전처리기 명령을 이용하여 하는 방법이 있습니다.

```cpp-formatted
/* 수정된 weird.h*/
#ifndef WEIRD_H
#define WEIRD_H
struct Weird {
  char arr[2];
  int i;
};
#endif
```



```cpp-formatted
/* 이상한 test.c*/
#include <stdio.h>
#include "weird.h"
int main() {
  struct Weird a;
  a.i = 3;
  printf("Weird 구조체의 a.i : %d \n", a.i);
  return 0;
}
```



성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F186C4F424D14A4D42684F7)




와 같이 잘 실행됩니다. 일단 왜 오류가 나지 않는지 살펴 봅시다. 우리가 전처리기라고 한다면 맨 처음에 첫번째 `#include "weird.h"` 를 만났을 때 `WEIRD_H` 가 정의되어 있지 않으므로 #ifndef 가 참이 되어 아래 #define `WEIRD_H` 가 수행되어 `WEIRD_H` 라는 것이 정의됩니다. (값은 모르지만 아무튼, 이러한 이름이 정의되었다고 합시다) 또한 헤더파일의 내용도 `test.c` 로 그대로 복사되죠. 그 후에 실수로 `weird.h` 를 다시 한 번 `include` 하였을 때 에는 이미 `WEIRD_H` 가 정의되어 있는 상태이므로 `#ifndef WEIRD_H` 가 거짓이 되어 #endif 로 넘어가버려 `test.c` 에 그 내용이 복사가 안됩니다.

이렇게 하면 헤더파일의 내용이 중복으로 포함되는 것을 막을 수 있습니다. (이는 이미 수많은 헤더파일에서 사용되고 있는 방법입니다) 하지만 `#pragma` 를 이용하면 훨씬 단순하게 할 수 있는데,

```cpp-formatted
/* #pragma 의 위엄 – weird.h*/
#pragma once
struct Weird {
  char arr[2];
  int i;
};
```




```cpp-formatted
/* test.c*/
#include <stdio.h>
#include "weird.h"
int main() {
  struct Weird a;
  a.i = 3;
  printf("Weird 구조체의 a.i : %d \n", a.i);
  return 0;
}
```



성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F186C4F424D14A4D42684F7)




와 같이 잘 나옵니다. 이 명령은 컴파일러로 하여금 이 파일이 오직 딱 한 번만 `include` 될 수 있다는 것을 말해주는데, 이는 위에서 #ifndef 를 이용하여 복잡하게 하였던 작업들을 단순하게 한 문장으로 끝낼 수 있게 됩니다. 또한 `#pragma once` 의 장점으로 `#ifndef` 를 이용하는 것 보다 컴파일 시간을 절약할 수 있다는 점인데, `#ifndef` 를 이용하게 되면 `include` 하였을 때 전처리기가 직접 헤더파일을 열어 보아서 과연 `WEIRD_H` 가 정의되었나 정의되지 않았나 확인해 보아야 하는데, `pragma once` 를 이용하면 한 번 `include` 되었다면 헤더파일을 다시 열어보지도 않기 때문에 컴파일 시간이 절약되는 효과가 나게 됩니다.

다만 앞에서도 말했듯이 `#pragma` 관련 키워드들이 컴파일러 종속적이여서 어떤 컴파일러에서는 `#pragma once` 가 지원이 되지 않을 수 도 있습니다. 따라서 무슨 컴파일러를 사용하는지 보고 `#pragma once` 를 지원한다면 되도록 이것을 사용하는 것이 도움이 됩니다.

실제로 아래 코드는 `stdio.h` 의 헤더파일을 열어본 것입니다.

```cpp-formatted
/***
 *stdio.h - definitions/declarations for standard I/O routines
 *
 *       Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *Purpose:
 *       This file defines the structures, values, macros, and functions
 *       used by the level 2 I/O ("standard I/O") routines.
 *       [ANSI/System V]
 *
 *       [Public]
 *
 ****/
#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STDIO
#define _INC_STDIO

/* 내용 (생략) */

#endif /* _INC_STDIO */
```



위 헤더파일에서 사용하는 컴파일러마다 어떠한 키워드를 사용할 수 있게 하였는지 알 수 있는데,
```cpp-formatted
#if _MSC_VER > 1000
#pragma once
#endif
```



를 보면 `_MSC_VER` 이 1000 보다 크면 `#pragma once` 키워드를 사용하라고 되어있습니다. `_MSC_VER` 은 마이크로소프트 사의 전처리기에 의해 기본적으로 정의되어 있는 상수로 컴파일러의 버전을 나타내는데, `Visual C++` 의 경우 `_MSC_VER` 값이 1000 부터 시작 하여 현재 2008 버전은 1500 의 값을 가지고 있습니다. 즉, 현재 버전의 컴파일러의 경우 `_MSV_VER > 1000` 이 참이 되므로 `#pragma once` 키워드를 이용하게 됩니다. 구 버전의 컴파일러는 그 아래

```cpp-formatted
#ifndef _INC_STDIO
#define _INC_STDIO

…

#endif /* _INC_STDIO */
```



과 같이 C 표준 방식의 형태를 사용하도록 되어 있는 것을 볼 수 있습니다.

자. 이제 C 언어의 가장 뒷부분인 `typedef, volatile, #pragma` 와 같은 키워들에 대해서도 모두 알아 보았습니다. 이제 더이상 강의할 내용들도 별로 없는 것 같아서 슬프네요 ㅠㅠ. 아무튼 제 강의를 읽는 모든 분들, 즐거운 성탄절을 보내시기 바랍니다 :)

### 생각해 볼 문제

#### 문제 1

MSDN 에 들어가서 `#pragma` 와 연관된 키워드들을 잘 살펴보시기 바랍니다.
 [http://msdn.microsoft.com/en-us/library/d9x1s805%28v=VS.71%29.aspx](http://msdn.microsoft.com/en-us/library/d9x1s805%28v=VS.71%29.aspx)

##@ chewing-c-end
Link :  109
2010-12-25 03:00
----------------
title : C 언어 레퍼런스 - struct tm ( tm 구조체 )
cat_title :  struct tm
ref_title : tm 구조체
publish_date : 2010-12-25 03:00
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ struct tm

```info
#include <time.h> // C++ 에서는 <ctime>
struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};
```


시간 구조체이다.

이 구조체는 현재의 날짜와, 시간에 관한 정보를 포함하고 있다. 이 구조체는 9 개의 `int` 형 멤버들로 구성되어 있는데 각각의 멤버들에 대해 설명을 하자면 아래의 표와 같다.


|멤버|의미|값의 범위|
|----|----|-----|
|`tm_sec`|현재 시각이 몇 초 인지|`0-61*`|
|`tm_min`|현재 시각이 몇 분 인지|`0-59`|
|`tm_hour`|현재 시각이 몇 시 인지|`0-23`|
|`tm_mday`|지금이 몇 일 인지|`1-31`|
|`tm_mon`|지금이 몇 월 인지|`0-11`|
|`tm_year`|지금이 몇 년 인지 (1900 이후)||
|`tm_wday`|지금이 무슨 요일 인지|`0-6`|
|`tm_yday`|1 월 1 일 부터 몇 일이 지났는지|`0-365`|
|`tm_isdst`|서머 타임제를 실시하고 있는지 아닌지||


만일 `tm_isdst` 가 0 보다 크면 서머 타임제를 실시하고 있다는 것이고, 0 이면 실시하고 있지 않다는 의미고, 0 보다 작으면 알 수 없다는 의미가 된다. 참고로 `tm_sec` 은 보통의 경우 0 부터 59 까지의 값을 가지게 되겠지만 종종 지구 자전 속도의 차이로 인해서 몇 년 마다 한 번 씩 '윤초' 를 도입하여 시간을 보정하는 경우가 있는데 이 때문에 `tm_sec` 의 값이 60 혹은 61 이 될 수 있다.

`tm_year` 의 경우 1900 년 이후의 년 수를 입력하는 것이므로 2000 년의 경우 100 이 들어가게 된다.
Link :  108
2010-12-25 02:54
----------------
title : C 언어 레퍼런스 - time.h 헤더파일
cat_title :  time.h
ref_title : <time.h>
publish_date : 2010-12-25 02:54
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ time.h (ctime)

이는 C 언어에서 시간 관련 함수를 모아놓은 라이브러리이다.


시간 관련 함수들


*  [clock](http://itguru.tistory.com/110)  :  시계 프로그램
*  [difftime](http://itguru.tistory.com/111)  :  두 개 시간의 차이를 구한다.
*  [mktime](http://itguru.tistory.com/112)  :  `tm` 구조체를 `time_t` 로 바꾼다.
*  [time](http://itguru.tistory.com/114)  :  현재 시간을 구한다.


변환 관련


*  [asctime](http://itguru.tistory.com/116)  :  `tm` 구조체를 문자열로 바꾼다.
*  [ctime](http://itguru.tistory.com/118)  :  `time_t` 값을 문자열로 바꾼다.
*  [gmtime](http://itguru.tistory.com/119)  :  `time_t` 를 `UTC` 시간으로 하여 `tm` 으로 바꾼다.
*  [localtime](http://itguru.tistory.com/120)  :  `time_t` 를 현지 시간으로 하여 `tm` 으로 바꾼다.
*  [strftime](http://itguru.tistory.com/122)  :  특정한 형식(사용자가 지정한 형식 문자열)으로 시간을 출력한다.




매크로


* `CLOCKS_PER_SEC`  :  1 초 당 클록 수
* `NULL`  :  널 포인터



타입

* `clock_t`  :  클록 타입
* `size_t`  :  부호 없는 정수형
*  [time_t](http://itguru.tistory.com/113)  :  시간 타입
*  [struct tm](http://itguru.tistory.com/109)  :  시간 구조체
Link :  106
2010-12-12 01:50
----------------
title : C 언어 레퍼런스 - strlen 함수
cat_title :  strlen
publish_date : 2010-12-12 01:50
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strlen

```info
#include <string.h> // C++ 에서는 <cstring>

size_t strlen ( const char * str );
```


문자열의 길이를 구한다.
문자열의 길이는 리턴한다. C 문자열의 길이는 마지막 널 문자에 의해 결정된다. 따라서 `strlen` 은 문자열의 시작 부터, 널 문자 직전 까지의 문자의 개수를 센다.

간혹

```cpp-formatted
char mystr[100] = "test string";
```


라 되어 있으면 `strlen` 이 100 을 리턴할 것 같지만 `mystr` 은 오직 11 개의 문자로만 선언되어 있으므로 11 이 리턴된다.



###  인자




`string`

C 형식 문자 C 형식 문자열



###  리턴값


문자열의 길이. 참고로 `size_t` 형으로 선언 되어 있는데 대부분의 `string.h` 에서는 부호 없는 정수형으로 선언되어 있다.



###  구현 예




```cpp-formatted
/*

이 예제는
http://www.jbox.dk/sanos/source/lib/string.c.html
에서 가져왔습니다.

*/
size_t strlen(const char *s) {
  const char *eos = s;
  while (*eos++)
    ;
  return (int)(eos - s - 1);
}
```




###  실행 예제




```cpp-formatted
/*

문자열을 하나 입력 받아서 그 길이를 리턴한다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strlen/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char szInput[256];
  printf("Enter a sentence: ");
  gets(szInput);
  printf("The sentence entered is %u characters long.\n", strlen(szInput));
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1772BF1F4D0420B837D97C)




###  연관된 함수


*  [strcmp](http://itguru.tistory.com/85)  :  두 개의 문자열을 비교한다.
*  [strchr](http://itguru.tistory.com/93)  :  문자열에서 특정한 문자의 첫번째로 나타나는 위치를 찾는다.
*  [strrchr](http://itguru.tistory.com/96)  :  문자열에서 특정한 문자의 마지막으로 나타나는 위치를 찾는다.
Link :  105
2010-12-12 00:46
----------------
title : C 언어 레퍼런스 - strerror 함수
cat_title :  strerror
publish_date : 2010-12-12 00:46
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strerror

```info
#include <string.h> // C++ 에서는 <cstring>

char * strerror ( int errnum );
```

오류 메세지 문자열을 가리키는 포인터를 얻어온다.
`errnum` 의 값을 통해 발생하였던 오류에 알맞은 오류 메세지를 가리키는 포인터를 리턴한다. 이 때 리턴되는 포인터는 [문자열 리터럴](http://itguru.tistory.com/33)을 가리키고 있기 때문에 그 내용이 바뀔 수 없다. 참고로 `strerror` 에 의해 출력되는 오류 메세지는 현재 사용중인 컴파일러나 플랫폼에 따라 다를 수 있다.



###  인자




`errnum`

오류 번호



###  리턴값




오류 번호에 해당하는 오류 문자열을 가리키는 포인터



###  놀라운 사실




이 함수는 C 표준 함수 중에서이름에 `r` 이 가장 많이 포함되어 있는 함수이다. 무려 `r` 이 4 개나 있다.




###  실행 예제


```cpp-formatted
/*

존재하지 않는 파일 unexist.ent 를 열라고 해 오류가 발생한다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strerror/
에서 가져왔습니다.

 */
#include <errno.h>
#include <stdio.h>
#include <string.h>

int main() {
  FILE* pFile;
  pFile = fopen("unexist.ent", "r");
  if (pFile == NULL)
    printf("Error opening file unexist.ent: %s\n", strerror(errno));
  return 0;
}
```

실행 결과




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F146390194D039BFE0DBDB8)



###  연관된 함수

*  [perror](http://itguru.tistory.com/53):  오류 메세지를 출력한다.
Link :  104
2010-11-28 09:26
----------------
title : C 언어 레퍼런스 - memset 함수
cat_title :  memset
publish_date : 2010-11-28 09:26
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ memset

```info
#include <string.h> // C++ 에서는 <cstring>

void * memset ( void * ptr, int value, size_t num );
```


메모리 블록을 채운다.
`ptr` 로 시작하는 메모리 주소 부터 `num` 개의 바이트를 `value` 값으로 채운다. 이 때, `value` 는 `unsigned char` 로 형변환 된다.



###  인자


`ptr`

값을 채울 메모리의 시작 주소

`value`

채울 값. 인자로는 `int` 로 전달되지만 함수 내부적으로는 `unsigned char` 로 형변환 되어서 사용된다.

`num`

`value` 로 채울 바이트 수



###  리턴값




`ptr` 이 리턴된다.



###  실행 예제


```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/memset/
에서 가져왔습니다.

*/
#include <stdio.h>
#include <string.h>

int main() {
  char str[] = "almost every programmer should know memset!";
  memset(str, '-', 6);
  puts(str);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F19727B194CF1A1D02D9726)




###  연관된 함수





*  [memcpy](http://itguru.tistory.com/77)  :   메모리 블록을 복사한다.
*  [strncpy](http://itguru.tistory.com/80)  :  문자열의 일부분을 복사한다.
*  [memcmp](http://itguru.tistory.com/84):  두 개의 메모리 블록을 비교한다.
Link :  35
2010-11-27 21:36
----------------
title : C 언어 레퍼런스 - printf 함수
cat_title :  printf
publish_date : 2010-11-27 21:36
--------------

```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?
* 참고적으로 이 레퍼런스는 printf 함수에 대한 기초적인 이해가 있는 사람들을 위한 것이므로 printf 함수를 처음 보는 사람은 [http://itguru.tistory.com/7](http://itguru.tistory.com/7)를 보시는 것을 추천합니다.

```

#@ printf

```info
<stdio.h> // C++ 의 경우 <cstdio>
int printf ( const char * format, ... );
```

일련의 데이터를 특정한 형식에 맞추어 `stdout` 에 출력한다.


표준 출력(stdout) 에 일련의 데이터들을 형식 문자열(format)에 지정되어 있는 형태로 출력한다. 형식 문자열 다음에는 출력할 데이터들을 쭈르륵 나열해 주면 된다. `printf` 함수는 적어도 형식 문자열 속에 지정된 데이터 이상의 인자를 받기로 기대한다.



###  인자 (parameter)


형식 문자열(format)형식 문자열에는 `stdout` 에 출력할 문자열이 들어있다. 이 때, 형식 문자열에는 형식 태그(format tag)라 불리는 것이 추가적으로 들어갈 수 있는데, 이는 이에 대응하는 인자를 형식 태그가 지정한 형태로 치환되어 출력된다. (말이 조금 어려울 수 있으니 아래 예제를 보기 바란다).따라서, 형식 문자열 다음으로 오는 인자들의 개수는 반드시 형식 문자열 속의 태그의 개수보다 같거나 많아야 한다.
형식 태그는 아래와 같은 꼴로 생겼다.

```info
%[플래그(flag)][폭(width)][.정밀도][크기(length)]서식 문자(specifier)
```

#### 서식문자

이 때 서식 문자(specifier) 는 대응하는 인자를 어떠한 형태로 표현할지를 결정하는데에 가장 중요한 역할을 한다.

|서식 문자|출력 형태|예시 |
|---------|---------|-----|
|`c`      | 문자    | `a` |
|`d` or `i` | 부호 있는 십진법으로 나타난 정수|`392`|
|`e`      | 지수 표기법(Scientific notation) 으로 출력하되, `e` 문자를 이용한다.| `3.9265e+2`|
|`E`      | 지수 표기법(Scientific notation) 으로 출력하되, `E` 문자를 이용한다.|`3.9265E+2`|
|`f`      | 십진법으로 나타낸 부동 소수점 수| `392.65` |
| `g`     | %e나 `%f` 보다 간략하게 출력 |`392.65`|
| `G`     | %E나 `%f` 보다 간략하게 출력| `392.65`|
|`o`      | 부호 있는 팔진수| `610`|
|`s`      | 문자열 | `sample`|
|`u`      | 부호없는 십진법으로 나타낸 정수|`7235`|
|`x`      | 부호없는 16 진법으로 나타낸 정수 (소문자 사용) |`7fa`|
|`X`      | 부호없는 16 진법으로 나타낸 정수 (대문자 사용) |`7FA`|
|`p`      | 포인터 주소 |B800:0000 |
|`n`      | 아무것도 출력하지 않는다. 그 대신, 인자로 부호 있는 `int` 형을 가리키는 포인터를 전달해야 되는데, 여기에 현재까지 쓰여진 문자 수가 저장된다.||
|`%`      |`%` 다음에 %를 또 붙이면 `stdout` 에 `%` 를 출력한다.||

위 서식 문자를 이용한 다양한 출력 형태는 아래와 같다.
```cpp-formatted
#include <stdio.h>
int main() {
  int integer = 123;
  char character = 'c';
  char string[] = "hello, world";
  int* pointer = &integer;
  double pi = 3.141592;

  printf("integer : (decimal) %d (octal) %o \n", integer, integer);

  printf("character : %c \n", character);

  printf("string : %s \n", string);

  printf("pointer addr : %p \n", pointer);

  printf("floating point : %e // %f \n", pi, pi);

  printf("percent symbol : %% \n");

  return 0;
}
```

출력 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2049BB054B5DA6D6012A5A)

#### 플래그

형식 태그에는 위 말고도 플래그, 폭, .정확도, 제한자(modifier), 부-서식문자(sub-specifiers) 에 관련한 정보들이 포함될 수 있다. 먼저 플래그를 살펴보면 플래그는 기본적으로 출력되는 형태에 대해 조금 더 자세하게 지정할 수 있게 해준다. 플래그는 아래와 같다.

|플래그    |설명|
|`-`      | 폭에 맞추어 왼쪽 정렬을 하여 출력한다. `-` 를 붙이지 않는다면 기본적으로 오른쪽 정렬이 되어 출력한다. (아래 폭 지정자 참조).|
|`+`      | 출력 결과값이 양수인 경우라도 `+` 기호를 앞에 붙여서 출력하도록 한다. (물론 음수면 자동적으로 `-` 가 붙는다). 기본적으로 지정하지 않았을 경우 음수에만 앞에 `-` 가 붙는다.|
|(공백)    | 앞에 부호가 붙지 않는다면 한 칸을 띄어서 출력한다. (다시말해 123 은 " 123" 으로 출력되고 -123 은 "-123" 으로 출력된다)|
| #       |`o, x, X` 서식 문자들과 사용되면 출력되는 값 앞에 각각 `0, 0x, 0X` 가 붙게 된다. (이 때 0 은 제외한다). `e, E, f` 서식 문자들과 사용되면 소수점 아래 수들이 없음에도 불구하고 강제적으로 소수점을 붙이도록 한다. 원래 소수점 아래 수들이 없다면 소수점을 붙이지 않는다. `g` 와 `G` 서식 문자들과 사용되면 `e` 와 `E` 일때와 동일한 작업을 하지만 소수들의 뒷부분에 붙는 0 들 (123.1200 등) 은 제거되지 않는다.|
|`0`      | 수들을 왼쪽으로 정렬하되 빈 칸을 삽입하는 대신에 0 을 삽입한다. (폭 지정자 참조)|

#### 폭

폭은 말그대로 출력되는 데이터의 폭을 지정해준다. 참고로 여기서의 폭(width)은 뒤에 나오는 길이(length) 와는 완전히 다른 개념이므로 유의 하시기 바란다.

|폭 | 설명 |
| (수) | 출력할 최소의 문자 개수. 만일 이 수 보다 출력할 수 보다 작다면 빈칸을 삽입하여 길이를 맞춘다. 대신에, 이 수 보다 출력할 수가 큰 수의 경우 잘려서 출력되지는 않는다.|
|`*`   |폭을 형식 문자열에 지정해서 받지 않지만, 그 대신에 형식 문자열 뒤에 오는 인자들에 넣어서 받는다. 이 때, 이는 정수 값이여야 하며 폭을 지정하는 변수 뒤에 출력할 데이터가 위치하면 된다.|

```cpp-formatted
/* 사용 예 */
#include <stdio.h>
int main() {
  int i = 123;
  int j = -123;
  double f = 3.141592;

  printf("폭 맞추기 \n");
  printf("i : %6d \n", i);
  printf("i : %7d \n", i);
  printf("i : %2d \n\n", i);

  printf("왼쪽 정렬 \n");
  printf("i : %-5d끝 \n", i);
  printf("오른쪽 정렬 \n");
  printf("i : %5d끝 \n\n", i);

  printf("# 문자의 사용 \n");
  printf("i : %#x \n", i);
  printf("i : %#X \n\n", i);

  printf("부호 붙이기 \n");
  printf("%+d, %+d \n", i, j);
  return 0;
}
```

출력결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F18555A374CE4EDDE0AC611)

#### 정밀도 

정밀도는 말그대로 수치 데이터를 출력할 때 어떠한 정밀도로 출력하는지 (즉, 몇 자리 까지 출력해야 되는지) 를 지정해준다. 참고적으로 정밀도를 나타낼 때, 앞에 꼭 마침표(.) 을 찍는 것을 잊지 말기 바란다. 마침표를 찍는 이유는 앞에 폭과 구분을 하기 위해서 이다.

|정밀도|설명|
|.숫자| 정수 지정자 (d,i,o,u,x,X) 의 경우 : 정밀도는 출력되야할 최소의 자리수를 일컫는다. 만일, 어떤 정수의 자리수가 정밀도 보다 작다면 앞에 0 이 붙어서 자리수를 맞추게 된다. 또한 자리수가 더 크다고 해서 정수를 잘라서 출력하지는 않는다. 만일 정밀도가 0 이라면, 소수점 뒤에 자리수를 출력하지 않는다. `e,E, F` 의 경우 : 여기서 정밀도는 소수점 이하 출력될 자리수를 의미한다. `g, G` 의 경우 : 출력될 유효 숫자의 수를 의미한다. `s` 의 경우 : 출력될 문자의 최대 개수를 의미한다. 원래는 널 문자를 만나기 전까지 모든 문자가 출력되었었다. `c` 의 경우 : 아무 효과 없다. 만일 정밀도가 지정되지 않는다면 기본값으로 1 이 된다. 또한, 마침표(.) 을 찍었는데 아무런 숫자를 적지 않았다면 기본적으로 0 이 적혔다고 생각한다.|
|`.*`|형식 문자열에서 정밀도를 나타내지는 않지만 뒤에 인자로 정밀도 값을 준다. 이 때 인자는 형식 태그가 적용되는 데이타 앞에 있어야 한다.|

#### 길이

길이는 출력하는 데이터의 정확한 크기를 지정하는데 사용된다. 예를 들어서 `%d` 서식문자의 경우 막연하게 '정수형 데이터를 십진법으로 출력한다' 였지만 길이를 지정해주면 어떻나 크기로 데이터를 출력해야되는지 (`int` 냐 `short` 냐 등등) 을 지정할 수 있다.

|길이|설명|
|`h`|인자를 `short int` 혹은 `unsigned short int` 로 생각한다. (오직 `i, d, o, u , x, X` 서식 문자에만 적용된다)|
|`l`|정수 서식 문자(i,d,o,u,x, `X)` 에 사용되었을 경우 인자를 `long int` 나 `unsigned long int` 로 생각하며 `c` 나 `s` 에 사용되었을 경우 `wide character` 나 `wide string` 으로 생각한다.|
|`L`|인자를 `long double` 로 생각한다. (오직 부동 소수점 서식 문자인 `e,E,f,g, G` 에만 적용된다)|

```cpp-formatted
/* 사용 예 */
#include <stdio.h>
int main() {
  double f = 3.141592;
  int i = 12345;

  printf("f : %.3f \n", f);
  printf("i : %.10d \n", i);

  return 0;
}
```

출력 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F135054234B5DB76133E080)

#### 부수적인 인자

형식 문자열에 따라 함수는 여러 인자들을 가지며, 각 인자는 형식 문자열의 각 형식 태그에 순차적으로 대응된다. 기본적으로 형식 문자열에 들어 있는 형식 태그의 수와 뒤따라 붙는 인자들의 수는 같아야 한다. (물론 `.*` 이나 `*` 과 같은 예외적인 상황은 제외한다)



###  리턴값




출력에 성공하면 출력된 전체 문자의 개수가 리턴된다. 출력에 실패하면 음수가 리턴된다.

*  `fprintf` :  특정한 형식에 맞추어 데이터를 스트림에 출력한다.

*  [fscanf](http://itguru.tistory.com/65)  :  특정한 형식에 맞추어 스트림에서 데이터를 읽어온다.

*  [fwrite](http://itguru.tistory.com/69)  :  스트림에 데이터 블록을 쓴다.

*  [fputs](http://itguru.tistory.com/40)  :  스트림에 문자열을 쓴다.
Link :  214
2015-08-11 11:29
----------------
title : C 언어 및 강좌 관련 자주 질문되는 것들에 대한 답변
publish_date : 2015-08-11 11:29
--------------




C 언어 및 강좌 관련해서 자주 질문되는 것을을 모아보았습니다 C 언어 및 강좌 관련해서 자주 질문되는 것을을 모아보았습니다.


질문 댓글을 달기 전에 여기를 먼저 확인해보셨으면 좋겠습니다 :)




###  강좌에 관한 질문들


#### 이 블로그는 왜 운영하는 것이지요?

저는 C 와 C++ 을 오로지 책과 인터넷으로만 배웠기 때문에 그 어려움이 상당히 컸습니다. 더군다나, 지금은 물론 양질의 자료들이 매우 많아졌지만 제가 본격적으로 공부를 하던 2006년 그 당시만 해도 인터넷에선 공짜로 컴퓨터 언어를 배운다는 거 그 자체가 꽤나 까다로웠습니다.

물론 영문으로 된 훌륭한 자료들은 많았지만, 한글로 되어 있는 양질의 자료들은 별로 없었습니다. 게다가 혼자서 컴퓨터 언어를 배우다 보니까 아리송하고 이해하기 힘든 부분을 쉽게 설명해주는 강사도 옆에 없었습니다. (포인터 개념을 이해하느라 몇 주를 고생했는지 모르겠습니다...) 그래서 훗날 저는, 혼자서 공부하는 저 같은 사람들을 위해서

1. 인터넷 상에서 무료로 볼 수 있으며
2. 초보자들의 눈높이 상에서 설명하며
3. 어떠한 궁금증도 쉽게 긁어줄 수 있는

그러한 강좌를 써보자 하는 생각을 하였습니다. 그리고 탄생한 그 결실이 '씹어먹는 C 언어' 입니다. C 언어를 배우고자 하는 모든 사람들이 프로그래밍을 할줄 아냐 모르냐에 전혀 구애받지 않고 밑바닥 부터 차근차근 알려주는 그러한 강좌 입니다. 그리고 당연하게도, 지금 여러분들이 보시다 싶이 무료로 제공되고 있고 추후 변경할 계획도 없습니다.후에 이 씹어먹는 C 언어 강좌가 꽤나 성공적이였기에, 저는 좀 더 확대해서 C++ 강좌도 써보고, 여러 레퍼런스들도 자료들도 업로드 하기 시작하였습니다. 그리고 무엇보다도, 영어로 된 훌륭한 자료들을 번역해서 제공하는 '오픈 북 프로젝트' 도 진행하고 있습니다.


####  강좌는 언제 올리시나요?

강좌를 다 써야 올립니다 :) 저도 언제 올릴 수 있는지는 잘 모르겠습니다. 현재 C++ 그 다음 강좌를 작성중에 있는데 이 역시 언제 작성이 완료될 지는 잘 모르겠습니다. 목표는 2017년 안에 C++ 강좌를 완성하는 것입니다!

####  댓글은 언제 다시나요?

강좌는 자주 못올리지만 댓글은 틈틈히 달 수 있도록 노력하고 있습니다. 특히 오타나 잘 이해가 안가는 부분을 지적해주는 댓글은 정말 환영입니다. 물론 생각해보기에 대한 답도 댓글로 달아주시면 감사하겠습니다!

하지만 볼 때 당황스러운 댓글들은, '그냥 이해가 안가요' (그럼 제가 어떻게 도와줘야 되나요!) 나 강좌에 전혀 관련 없는 소스코드나 자신의 숙제를 올려 놓고 '왜 오류가 나는지 모르겠어요', '어떻게 해야해요?' 등 이러한 대책없는 댓글들이 있습니다. 이런 댓글들은 자제해주시면 감사하겠습니다.

#### 누구세요?

[Psi 입니다](http://itguru.tistory.com/notice/107)



###  C 언어

#### C 언어가 무엇인가요?

C 언어는 컴퓨터 언어의 한 종류 입니다. 우리가 다른 사람과 소통할 때 언어가 필요하듯이, 컴퓨터에게 이런 저런 일들을 시키기 위해서는 역시 언어가 필요합니다. 사실 컴퓨터는 잘 알려져 있듯이 0 과 1 을 나타내는 각각의 전기 신호들로 밖에 소통할 수 없습니다. 다시말해, 컴퓨터에게 무언가 이야기 하려면 0 과 1 의 조합으로 얘기를 해야 된다는 것이지요.

하지만 이는 인간에게 너무 불편합니다. 그래서, 좀더 사람이 이해하기 쉽게 만든 것이 C 언어 이고, 이 C 언어로 작성된 코드는 '컴파일' 이라는 과정을 거쳐서 0 과 1 의 언어로 탈바꿈 하게 되는 것입니다 C 언어는 컴퓨터 언어의 한 종류 입니다.

우리가 다른 사람과 소통할 때 언어가 필요하듯이, 컴퓨터에게 이런 저런 일들을 시키기 위해서는 역시 언어가 필요합니다. 사실 컴퓨터는 잘 알려져 있듯이 0 과 1 을 나타내는 각각의 전기 신호들로 밖에 소통할 수 없습니다.

다시말해, 컴퓨터에게 무언가 이야기 하려면 0 과 1 의 조합으로 얘기를 해야 된다는 것이지요. 하지만 이는 인간에게 너무 불편합니다. 그래서, 좀더 사람이 이해하기 쉽게 만든 것이 C 언어 이고, 이 C 언어로 작성된 코드는 '컴파일' 이라는 과정을 거쳐서 0 과 1 의 언어로 탈바꿈 하게 되는 것입니다.\sidenote{정확히 말하면, C 언어 코드 -> 어셈블리어 -> 0 과 1의 언어 의 단계가 있지만 설명의 단순화를 위해 그냥 이렇게 정리하겠습니다}

#### C 언어를 왜 배우나요?

까놓고 말해서 굳이 C 언어를 프로그래밍 입문 용으로 배울 필요는 없습니다. 왜냐하면 C 언어는 제대로 알고 쓰기에굉장히어려운 언어이기 때문이까요. C 언어를 처음 만들었던 시기는 1970년대 입니다. (위키피디아에 따르면 1969 ~ 1973년 이라 하네요) 이 시기에는 프로그래밍은 정말 정말 전문가들이나 할 수 있는 시기였습니다.

이렇게 수염난 아저씨들이나 할 수 있던 시절이였습니다. 이 사람들 한테 굳이 쉽고 이해하기 편한 언어가 필요했을까요? 물론 C 언어의 문법들이 현재의 대부분의 컴퓨터 언어의 기반이 된다는 것은 틀림 없이 맞는 말이지만 그렇다고 해서 이 언어를 반드시 배울 필요는 없는 셈입니다. 하지만 C 언어를 배우고 어느 정도 깊게 이해한다면 여러분들은 다음과 같은 능력을 기룰 수 있습니다.

C 언어를 배움으로써 가장 좋은 점은, 컴퓨터가 대략 어떻게 돌아가는지 이해할 수 있다는 것입니다. 많은 사람들은 흔히 C 언어가 빠르다고 이야기 합니다. 그 이유는 사실 C 언어는 언어 차원에서 많은 것을 하지 않기 때문입니다. 다시 말해 프로그래머가 자기 마음대로 언어의 제약 없이 무언가를 할 수 있습니다. 이 때문에 C 언어로 제대로 코딩하기 위해선 여러분들은 컴퓨터가 어떻게 돌아가는지를 잘 알고 있어야 합니다.

두 번째로 좋은 점은 C 언어로 코딩함으로써 후대에 발전한 언어들을 좀 더 잘 이해할 수 있다는 것입니다. 이게 무슨 말이냐 하면, 후대의 많은 언어들이 C 언어로 프로그램을 설계하였을 때 부족했던 점, 힘들었던 점들을 보완하면서 발전해나갔다는 것입니다. 사실 요즘 유행하고 있는 `Java` 나 C++ 을 바로 먼저 배워도 상관 없지만, '왜 하필 이렇게 했을까?' 라는 고민에 대한 해답을 얻기는 힘듭니다. 

예를 들어 초장부터 객체지향 프로그래밍을 배우면, 왜 도대체 이런 방식을 만들어냈을까 알 수 없습니다. 이런 고민에 대한 해답은 이들 언어가 없었을 적 시절인, C 언어 시절로 돌아가 프로그래밍 함으로써 배울 수 있습니다.

마지막으로 다른 언어들이 범접할 수 없는 영역이 있다면 바로 임베디드 프로그래밍 부분 입니다. 이러한 곳에서는 메모리 사용도 매우 제한되고 속도도 매우 느리기 때문에, 시스템에 가장 가까이에서 최적화 할 수 있는 C 언어가 제격이라 볼 수 있습니다. 또한 대부분의 플랫폼에서는 적어도 C 컴파일러 하나쯤은 지원하기 때문에 C 언어 하나만 알고 있어도 거의 대부분의 환경에서 작동하는 어플리케이션을 만들 수 있습니다.

####  C 언어로 무엇을 할 수 있나요?

간단히 이야기 하자면 여러분이 상상하는 모든 프로그램은 C 로 만들 수 있습니다.

#### 이 강좌를 마치면 스타크래프트나 `MS` 워드 같은 프로그램들을 만들 수 있나요?

안타깝게도 여러분이 이 강좌에서 시작할 때 부터 끝까지 보게될 것은 까만 화면에 나오는 글씨들일 뿐입니다. 저 같은 경우도 처음에 C 언어를 배우기 시작할 때, "아 나도 스타크래프트 같은 게임이나 `MS` 워드 같은 멋진 프로그램들을 만들 수 있겠지?" 라는 꿈을 품었었습니다.

그런데, 처음에 까만 화면에 글자 몇 개 뛰우는 것을 가르쳐주는 것을 보고 "흠, 처음에는 요렇게 간단한 것 부터 배우는 구나" 라고 생각하고, 책을 첨 부터 끝까지 살펴보았습니다. 맨 마지막 페이지에 멋진 프로그램을 만들 줄 알고 기대하였는데, 여전히 까만 화면에 글씨 띄우는 것이였습니다.

이 강좌는 C 언어를 배우는 강좌 입니다. C 언어 역시 하나의 '언어' 입니다. 영어를 처음 배울 때 생각해보세요. 영어를 처음 배울 때에는 단어를 외워야 하고, 문법을 배웁니다. 그리고 간단한 문장 정도를 쓰는 것을 연습합니다. 물론 끝으로 갈 수 록 짧은 영어로 에세이 정도는 쓰겠지요. 어느 누구도 영어를 처음 배우는 당신에게 소설 한 권을 쓰라고 주문하지 않습니다.

C 언어를 배우는 과정도 마찬가지 입니다. 처음에 C 언어의 몇 가지 개념들과 문법들, 그리고 수십 줄 혹은 수백 줄 정도 되는 프로그램 하나를 짜는 것을 연습합니다. 이 정도가 이 강좌에서 다루는 한계 입니다. 스타크래프트나 `MS` 워드 같은 거대한 프로그램을 만드는 것은, 영어로 소설 한 권을 쓰는 것과 비슷한 일입니다. 이를 위해서라면, 조그만 프로그램들도 많이 만들어보고, 무엇보다도 요즘에는 이런 거대한 프로그램을 혼자서 만드는 것이 아니기 때문에 다른 사람들과 협력하면서 코딩하는 법도 배워야 할 것입니다.

그렇다면 여러분은 과연 그런 삐까뻔적 한 프로그램들은 어떻게 만드는지 궁금하실것입니다. 까만 화면에서 탈피해서 무언가 진짜로 윈도우즈 상에서 돌아가고 싶은 애플리케이션을 만들고 싶은 분들은 `Windows API` 혹은 `MFC` 를 공부하던지 (옛날 방식), `Qt` 를 사용 하실 수 도 있습니다. 아니면 요즘 마이크로소프트에서 밀고 있는 C# 을 이용할 수 도 있습니다.

'그걸 왜 이제 말해주냐!' 며 '처음부터 얘네들을 먼저 배우면 좋지 않았냐' 라고 반문 하실 수 도 있는데, 확시리 C 언어를 하나 제대로 알고 딴 언어들을 배우면 확실히 편합니다.. 진짜로요

#### 해킹을 배우고 싶습니다. 무엇을 먼저 배워야 하나요?

어떠한 분야로 나가는지는 모르겠지만 기본적으로 C 언어는 할 줄 알아야 합니다. C 언어 먼저 배우시고 나중에 생각해보세요

#### C 랑 C++ 은 다른 언어인가요?

네. 매우 다른 언어 입니다. 초기에는 C++ 이 C 언어의 단순한 확장팩이라고도 했었지만 (그래서 C++ 초기 이름이 C with `class` 입니다) 그 후에 C++ 이 엄청나게 커져 버려서 사용하는 방식에 있어서 아예 다른 언어가 되버렸습니다. C++ 과 C 와의 문법은 매우 유사하지만 ( [같다고 생각하는 사람들이 있는데 미묘하게 다릅니다](http://web.archive.org/web/20080617183013/http://www.research.att.com/~bs/bs_faq.html#C-is-subset)), 근본적으로 다른 목적을 가지고 만들어진 언어입니다. 물론, C++ 컴파일러로 C 언어 코드를 컴파일 할 수 있기는 합니다.

#### 윈도우즈 `API` 가 무엇인가요?

여러분이 지금 사용하고 있는 운영체제인 Windows 에서 돌아가는 어플리케이션을 제작을 위해서 마이크로소프트에서 제공하는 인터페이스(- 쉽게 말해 여러가지 함수들) 라고 하면 됩니다. 예컨대, 제가 창이 하나가 있는 프로그램을 만들고자 합시다. 그렇다면, '창' 을 만드는 함수를 만들어야 겠지요? 이를 Windows 에서는 함수의 형태로 제공하게 됩니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2551764D55C959F1343CCF)

이런 까만화면에서..!

[](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2121454D55C959F211CF60)

진짜 윈도우를 띄운다!

또한, 제가 제 프로그램의 특정 부분을 클릭 하였다고 합시다. 제가 어디 한 곳을 클릭을 하면, 이 사실은 운영체제에 전달되는데, 운영체제는 이 메세지를 다시 제 프로그램에 뿌려주고, 제 프로그램은 메세지를 받을 준비를 하다가 받게 되면 적절한 처리를 하게 됩니다.

이렇게 운영체제에서 제공하는 기능들을 사용하기 위한 것이 바로 윈도우즈 API 이고, 이를 사용할 줄 알아야 윈도우즈에서 까만 콘솔창이 아닌 우리가 생각하는 그런 프로그램들을 만들 수 있게 되는 것입니다. 윈도우즈 API 는 대부분이 C 로 구성되어 있습니다. 즉, 이 강좌를 마치신 분들은 바로 `Windows API` 를 사용해서 애플리케이션을 만들 수 있습니다!



###  비주얼 스튜디오 (Visual Studio) 사용 관련 문제들


#### Error LNK:1123 COFF로 변환하는 동안 오류가 발생했습니다

[http://www.microsoft.com/ko-kr/download/details.aspx?id=23691](http://www.microsoft.com/ko-kr/download/details.aspx?id=23691)에 들어가서 비주얼스튜디오 2010 서비스팩 1 을 설치하시면 됩니다.

####  화면에 바로 꺼집니다.

비주얼스튜디오 상에서 프로젝트를 생성할 때 '새 콘솔 어플리케이션' 으로 설정해야지, '아무 키나 누르세요' 가 나오는 것이 지원됩니다. 그래도 꺼진다면, 프로그램 맨 마지막에 `scanf` 로 문자 하나 받는 루틴을 넣어보세요. 그러면 이 입력을 대기하느라 종료되지 않을 것입니다.

#### 소스를 한 번에 정렬하고 싶습니다. 

http://itguru.tistory.com/142 를 참조하세요



###  C 언어 공부 관련

####  (첫 생각해보기) 에서 막혔습니다. 도와주세요!

아마 C 언어를 처음 배우신 분들이라면, 이 생각해보기가 처음으로 독자적으로 처음 부터 끝 까지 코딩하게 되는 것일 겁니다. 무언가 여태까지는 남의 도움을 받아서 코딩을 해왔는데 막상 혼자 만들려고 하니까 머리도 하얘지고 뭐가 어떻게 해야 될지 모르겠지요. 그럴 때는 키보드에 손가락을 올리기 보다는 종이와 펜을 꺼내와서 어떤 식으로 구상할 지 생각해보는 것이 좋습니다.

코드를 쓰기 보다는, 어떠한 방식으로, 예를 들어 '음, 반복문을 여기에 놓고, 어떠한 조건에서 어떻게 출력을 해야되니까 여기에 `if` 를 넣어야 겟네' 이런 식으로 구상을 해보세요.

이 과정이 완료되었다면, 종이에 써 놓은 것을 보고 그대로 코드로 옮기기만 하면 됩니다. 물론, 문법이 틀릴 수 있습니다. 틀려서 오류가 발생하였을 경우에는 아래 질문을 봐주시기 바랍니다.

#### 오류가 발생하였습니다. 도와주세요!

초보자의 경우 저지르는 오류들의 대부분은 아마 C 언어 문법을 틀린 것입니다. 대개 문장 끝에 세미콜론 (;) 을 붙이지 않앗더라던지, 아직 C 언어의 사용이 미숙하여 변수 및 함수 정의, `for, if` 등을 제대로 사용하지 못하는 것일 뿐입니다. 그 외로, 0 으로 나눠서 오류가 발생했다던지, 배열의 끝을 제대로 체크하지 않아서 오류가 발생했다던지 등의 이유들이 있습니다.

오류가 발생하였을 때는 당황하지 말고 일단 오류 내용을 그대로 긁어서 `Google` 이나 `Naver` 에 검색해보는 것이 좋습니다. 초보자들이 저지르는 대다수의 오류들은 이미 이전의 수 많은 초보자들이 질문을 올려놓았기 때문이지요. 그 외 컴파일은 깔끔하게 됬는데 프로그램만 실행하면 이상하게 되는 경우에는 [디버깅을 통해 한 스텝 한 스텝 확인](http://itguru.tistory.com/31)하면 됩니다.

#### 컴파일러를 사용할 수 없는 환경입니다. 공부를 어떻게 해야 되나요?

인터넷만 할 수 있다면 온라인 상에서 컴파일 할 수 있습니다. 예를 들어,

https://ideone.com/

에선 C 를 포함한 다양한 언어로 코딩이 가능하며, 심지어 입력 값도 설정이 가능합니다 (stdin 을 눌러서 거기에 원하는 입력값을 써 넣으시면 됩니다)

#### 강좌를 끝냈습니다. 이제 뭘 해야 되나요?

여러분 마음 이겠지만, 저라면 저 만의 독자적인 C 프로젝트 하나 정도는 만들고 싶을 것입니다. 예를 들어, 콘솔용 엑셀 이라 던지 (실제로 사용자가 입력한 수식에 따라 계산도 수행되고..) 아니면 간단한 게임을 만들 수 도 있습니다. 이렇게 C 언어와 친숙해지고 나면 다른 컴퓨터 언어를 배우는 것이 좋아보입니다.

C 언어와 좀 다른 유형의 언어를 배우면서도 C 언어와 좀 다른 유형의 언어를 배우면서도,웹 쪽에서 놀고 싶다면 요즘 대박대박 HOT 한 언어인 자바스크립트라던지, 아니면 파이썬 , 하스켈과같은 언어들도 굉장히 좋아보입니다.

아니면, C 스타일이 괜찮고, 객체지향 프로그래밍에 관심이 있다 하는 분들은 C++ 이나 Java, C# 등을 배우는 것도 좋습니다. 여기 까지 오신 분들이라면 원하는 것은 다 하실 수 있으리라 생각합니다!
Link :  213
2015-05-04 00:46
----------------
title : 씹어먹는 C++ - <7 - 1. C++ 에서의 입출력 (istream, ostream)>
cat_title: 7 - 1. C++ 에서의 입출력 (istream, ostream)
next_page : 215
publish_date : 2015-05-04 00:46
--------------


이번 강좌에서는

* C++ 입출력 라이브러리에 대한 간단한 소개
* `istream` 과 `ostream` 클래스
* `>>` 연산자와 `<<` 연산자
* `streambuf` (스트림) 클래스

에 대해서 알아봅니다.


![](/img/ChewingCpplogo.png)

안녕하세요! 여러분. 정말 오래간만에 강좌를 올리는 것 같습니다. 그 동안 제가 여러가지 하는 일이 매우 많았는데, 물론 아직도 강좌 쓸 시간은 거의 없지만 없는 시간을 짜내며 좋은 강좌를 쓰기 위해서 노력 중입니다. 아무튼, 제가 자주 댓글도 못 달아 드리고 업데이트도 엄청 느리게 하지만 (결코 죽은 것이 아닙니다!!),언제나 제 블로그를 방문해주셔서 강의를 보시는 분들에게 감사의 말을 전하고 싶습니다.


쉽진 않을 것 같지만 적어도 2016년 안에는 완결하는게 목표 입니다.


이번 강좌에서는 여태 까지 우리가 크게 관심을 가지지 않았던 C++ 의 입출력 라이브러리에 대해서 알아보도록 하겠습니다. 맨날 `cout` 과 `cin` 을 쓰면서도, 정작 `cout` 과 `cin` 이 무엇인지는 한 번도 관심을 가지지 않았지요 :(


C++ 을 공부한 사람이라면 입출력 라이브러리를 한 번 쯤은 사용해 보았겠지만, 사실 정확히 어떻게 돌아가는지 이해하는 사람들은 드뭅니다. 그래서 이번 강좌를 시작으로 아마 3 개 강의에 걸쳐서 C++ 입출력 라이브러리에 대해서 자세히 알아보는 시간을 갖도록 할 것입니다 C++ 을 공부한 사람이라면 입출력 라이브러리를 한 번 쯤은 사용해 보았겠지만, 사실 정확히 어떻게 돌아가는지 이해하는 사람들은 드뭅니다. 그래서 이번 강좌를 시작으로 아마 3 개 강의에 걸쳐서 C++ 입출력 라이브러리에 대해서 자세히 알아보는 시간을 갖도록 할 것입니다.



###  C++ 입출력 라이브러리




C++ 의 입출력 라이브러리는 다음과 같은 클래스 들로 구성되어 있습니다 C++ 의 입출력 라이브러리는 다음과 같은 클래스 들로 구성되어 있습니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2361DC4954A0CB38040ED8)

C++ 의 모든 입출력 클래스는 `ios_base` 를 부모 클래스로 하게 됩니다. `ios_base` 클래스는 많은 일은 하지 않고, 스트림의 입출력 형식 관련 데이터를 처리 합니다. 예를 들어서 실수 형을 출력할 때 정밀도를 어떤 식으로 할 것인지에 대해, 혹은 정수형을 출력 시에 10진수로 할지 16진수로 할지 등을 이 클래스에서 처리 합니다 C++ 의 모든 입출력 클래스는 `ios_base` 를 부모 클래스로 하게 됩니다. `ios_base` 클래스는 많은 일은 하지 않고, 스트림의 입출력 형식 관련 데이터를 처리 합니다. 예를 들어서 실수 형을 출력할 때 정밀도를 어떤 식으로 할 것인지에 대해, 혹은 정수형을 출력 시에 10진수로 할지 16진수로 할지 등을 이 클래스에서 처리 합니다.

그 다음으로 `ios` 클래스가 있습니다. 이 클래스에서는 실제로 스트림 버퍼를 초기화 합니다. 스트림 버퍼란, 데이터를 내보내거나 받아들이기 전에 임시로 저장하는 곳이라 볼 수 있습니다. 쉽게 설명하자면, 예를 들어서 우리가 하드디스크에서 파일을 하나 읽는다고 해봅시다. 만일 사용자가, 1 바이트 씩 읽는 다고 했을 때, 실제로 프로그램은 `1 byte` 씩 읽는 것이 아닙니다.

실제로는 한 뭉터기 (예를 들어서 512 바이트) 를 한꺼번에 읽어서 스트림 버퍼에 잠시 저장해 놓은 뒤에 사용자가 요청할 때 마다 1 바이트 씩 꺼내는 것이지요. 만일 버퍼를 다 읽는다면 다시 하드에서 512 바이트를 읽게 되는 것입니다. 이렇게 수행하는 이유는, 하드디스크에서 읽어오는 작업이 매우 느리기 때문에, 한 번 읽을 때 1 바이트 읽으면 엄청난 딜레이가 발생하게 됩니다. 이는 쓰는 작업에서도 마찬가지 입니다. 쓸 때도 우리가 1 문자를 출력 하게 되면, 하드에 바로 쓰는 것이 아니라 일단 버퍼에 보관한 후, 어느 정도 모인 뒤에 출력하게 됩니다.

`ios` 클래스에선 그 외에도, 현재 입출력 작업의 상태를 처리 합니다. 예를 들어, 파일을 읽다가 끝에 도달했는지 안했는지 확인하려면, `eof` 함수를 호출하면 됩니다. 또, 현재 입출력 작업을 잘 수행할 수 있는지 확인하려면 `good` 함수를 호출하면 됩니다.


###  istream 클래스



여태까지 `ios_base` 와 `ios` 클래스들이 입출력 작업을 위해 바탕을 깔아주는 클래스 였다면, `istream` 은 실제로 입력을 수행하는 클래스 입니다. 대표적으로 우리가 항상 사용하던 `operator>>` 가 이 `istream` 클래스에 정의되어 있는 연산자 입니다. 또, `cin` 은 `istream` 클래스의 객체 중 하나 입니다. 그렇기 때문에 우리는
```cpp-formatted
cin >> a;
```



와 같은 작업을 할 수 있었던 것이지요. 우리가, 어떤 타입에 대해서도 `cin` 을 사용할 수 있었던 이유는 (`a` 가 `char` 이냐 `int` 이냐에 상관없이) 바로 `opeartor>>` 가 그런 모든 기본 타입들에 대해서는 정의가 되어있기 때문입니다.

```cpp-formatted
istream& operator>>(bool& val);

istream& operator>>(short& val);

istream& operator>>(unsigned short& val);

istream& operator>>(int& val);

istream& operator>>(unsigned int& val);

istream& operator>>(long& val);

istream& operator>>(unsigned long& val);

istream& operator>>(long long& val);

istream& operator>>(unsigned long long& val);

istream& operator>>(float& val);

istream& operator>>(double& val);

istream& operator>>(long double& val);

istream& operator>>(void*& val);
```



그렇다고 해서, 우리가 언제나 위 타입들 빼고는 `operator>>` 로 받을 수 없는 것이 아닙니다. 실제로 `istream` 클래스의 멤버 함수로는 없지만;

```cpp-formatted
string s;

cin >> s;
```



`string` 클래스의 객체 `s` 도 `cin` 으로 입력 받을 수 있습니다. 이와 같은 일이 가능한 이유는 [이전에 연산자 오버로딩 강좌에서 배웠듯이](http://itguru.tistory.com/203), 멤버 함수를 두는 것 말고도, 외부 함수로 연산자 오버로딩을 할 수 있기 때문입니다.


이 경우에는

```cpp-formatted
istream& operator>>(istream& in, string& s)

{
  // 구현한다
}
```



와 같이 하면 되겠습니다.


`operator>>` 의 또 다른 특징으로는, 모든 공백문자 (띄어쓰기나 엔터, 탭 등)을 입력시에 무시해버린다는 점입니다. 그렇기 때문에, 만일 `cin` 을 통해서 문장을 입력 받는 다면, 첫 단어 만 입력 받고 나머지를 읽을 수 없습니다. 예제로 간단히 살펴보자면

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;
int main() {
  string s;
  while (true) {
    cin >> s;
    cout << "word : " << s << endl;
  }
}
```




성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2330864554A0F4663941FA)



와 같이 문장을 입력하더라도, 공백문자에 따라서 각각을 분리해서 입력받게 되는 것입니다.
위와 같이 비록 `operator>>` 가 매우 편리해보이지만, 반드시 주의해야 할 점이 있는 점이 있습니다.

```cpp-formatted
// 주의할 점
#include <iostream>
usingnamespace std;
int main() {
  int t;
  while (true) {
    cin >> t;
    cout << "입력 :: " << t << endl;
    if (t == 0) break;
  }
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F2714DC4054A0F54E1E1225)



그냥 평범하게 숫자를 잘 입력 받는 프로그램 입니다. 만일 사용자가 숫자만 꼬박 꼬박 잘 입력하면 정말 좋겠지만 문제는 그렇지 않는다는 것입니다. 프로그래머는 언제나 사용자의 기괴한 행동들에 대해서 모두 대응할 수 있어야만 합니다. 만일 사용자가, 숫자가 아니라 문자를 입력했다고 합시다. 그렇다면;


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F26385A3654A0F64C0EEDDB)



위와 같이 기괴한 결과를 보여줌을 알 수 있습니다. (참고로 저는 단순히 'c' 하나만 쳤을 뿐입니다)  왜 이런 무한 루프에 빠지는 것일까요. 그 이유는 `operator>>` 가 어떻게 이를 처리하는지 이해하면 알 수 있습니다.


앞서 `ios` 클래스에서 스트림의 상태를 관리한다고 하였습니다. 이 때, 스트림의 상태를 관리하는 플래그 (flag - 그냥 비트 1 개라 생각하면 됩니다) 는 4 개가 정의되어 있습니다. 이 4 개의 플래그들이 스트림이 현재 어떠한 상태인지에 대해서 정보를 보관한다는 뜻입니다. 이 4 개의 플래그는 각각 `goodbit, badbit, eofbit, failbit` 이렇게 4 개 종류가 있습니다. 각각의 비트들이 켜져있는지, 꺼져있는지 (즉 1 인지 0 인지에 따라)  우리는 스트림의 상태를 알 수 있게 됩니다.



각각의 비트들에 대해 간단히 설명해보자면
* `goodbit` : 스트림에 입출력 작업이 가능할 때

* `badbit`   : 스트림에 복구 불가능한 오류 발생시

* `failbit`    : 스트림에 복구 가능한 오류 발생시

* `eofbit`   :  입력 작업시에 `EOF` 도달시

위와 같은 상황 일 때 각각의 비트들이 켜지는 것입니다. 만일 위와 같이 문자를 입력할 경우 `operator>>` 가 어떤 비트를 켜게 될까요? 일단 `eofbit` 는 확실히 아닙니다. 끝에 도달한 것이 아니니까요. 그렇다면 `badbit` 일까요? `badbit` 는 스트림 상에서 복구할 수 없는 문제시 켜지는데 위 경우는 그렇게 심각한 것은 아닙니다. 그냥 현재 스트림 버퍼에 들어가 있는 'c\n' 이 문자열을 제거해버리면 되기 때문이지요. 위와 같이 타입에 맞지 않는 값을 넣어서 오류가 발생하는 경우에는 `failbit` 가 켜지게 됩니다. 그리고, 입력값을 받지 않고 리턴해버립니다.


문제는 이렇게 그냥 리턴해버리면서 버퍼에 남아 있는 'c\n' 이 문자열에는 손대지 않는다는 것입니다. 그렇기 때문에 다음에 또 읽고, 또 읽고, ... 결국 위와 같은 문제를 일으키게 됩니다.

```cpp-formatted
// 해결 방안
#include <iostream>
#include <string>
using namespace std;
int main() {
  int t;
  while (cin >> t) {
    cout << "입력 :: " << t << endl;
    if (t == 0) break;
  }
}
```

성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F271D064B54A0FA2911A2A5)




위와 같이 무한 루프에 빠지지 않고 제대로 처리됨을 알 수 있습니다. 어떻게 가능한 것일까요? 일단, `while` 문의 조건에 들어가 있는 저 식의 의미 부터 이해를 해봅시다.

```cpp-formatted
while (cin >> t) {
```



위 식을 보기에 앞서, `ios` 에 정의되어 있는 함수들을 살펴보자면 다음과 같은 함수가 있음을 알 수 있습니다.

```cpp-formatted
operator void*() const;
```

이 함수는 `ios` 객체를 `void*` 로 변환해줍니다. 이 때, `NULL` 포인터가 아닌 값을 리턴하는 조건이, `failbit` 와 `badbit` 가 모두 `off` 일 때 입니다. 즉, 스트림에 정상적으로 입출력 작업을 수행 할 수 있을 때 말입니다.

그럼 다시 `while` 문을 살펴보자면, 만일 우리가 '`s`' 를 입력한다면 `operator>>` 는 `cin` 객체의 `failbit` 를 켜게 됩니다. 그리고, `cin >> t` 후에 `cin` 이 리턴되는데 (`operator>>` 는 호출한 자신을 리턴!), 리턴값이 `while` 문의 조건식으로 들어가기 때문에 컴파일러는 적절한 타입 변환을 찾게 되고, 결국 `ios` 객체 -> `void*` -> `bool` 로 가는 2단 변환을 통해서`while` 문을 잘 빠져나오게 됩니다. (※ `NULL` 포인터는 `bool` 상 `false` 입니다)


위와 같이 문제를 해결할 수 있었지만, 입력을 계속 진행 할 수는 없습니다. 왜냐하면 현재 `cin` 에 `fail` 비트가 켜진 상태이므로, 플래그를 초기화해버리지 않는 한 `cin` 을 이용하여 입력 받을 수 없게 됩니다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;
int main() {
  int t;
  cin >> t;  // 고의적으로 문자를 입력하면 failbit 가 켜진다
  cout << "fail 비트가 켜진 상태이므로, 입력받지 않는다" << endl;
  string s;
  cin >> s;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2520414754A0FCFC15F20C)



그렇다면 이 문제를 어떻게 해결 할 수 있을까요?

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;
int main() {
  int t;
  while (true) {
    cin >> t;
    cout << "입력 :: " << t << endl;
    if (cin.fail()) {
      cout << "제대로 입력해주세요" << endl;
      cin.clear();            // 플래그들을 초기화 하고
      cin.ignore(100, '\n');  // 개행문자가 나올 때 까지 무시한다
    }
    if (t == 0) break;
  }
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F264A894254A0FE1E2ADE3E)



위와 같이 잘 처리됩니다. 위 과정이 어떻게 가능한지 자세히 살펴보도록 합시다.


```cpp-formatted
if (cin.fail()) {
```



먼저 `fail` 함수는 `ios` 에 정의되어 있으며, `failbit` 가 `true` 거나 `badbit` 가 `true` 면 `true` 를 리턴합니다. 만일 숫자가 아닌 것을 입력한다면 `failbit` 가 `true` 이므로, `cin.fail()` 은 `true` 가 되어 조건문을 실행하게 됩니다.

```cpp-formatted
cin.clear();  // 플래그들을 초기화 하고

cin.ignore(100, '\n');  // 버퍼를 비워버린다
```



그리고 `clear()` 역시 `ios` 에 정의되어 있으며, 인자를 주지 않을 경우 플래그를 `goodbit` 으로 초기화 시켜 버립니다. 따라서 `fail` 상태를 지울 수 있게 되지요. 그 다음에 `ignore` 함수는 `istream` 에 정의되어 있는데, 최대 첫번째 인자 만큼 (100), 두 번째 인자가 나올 때 까지 ('\n'), 버퍼에서 무시합니다 (두 번째 인자를 포함). 

따라서, 만일 제가 *this is a very bad input* 을 입력하였다면 버퍼에는

```info
this is a very bad input\n
```



이렇게 들어가 있고, `ignore` 함수를 통해 (최대 100 자 까지) 개행문자가 나올 때 까지 무시할 수 있게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F212B393A54A100292F4FA5)





만일 버퍼에 100자 이상을 집어 넣는다면 위와 같이 `ignore` 함수가 총 3번 호출됨을 알 수 있습니다. (버퍼에 남아 있는 문자들이 다 지워질때 까지)





###  형식 플래그(format `flag)` 와 조작자 (Manipulator)


앞서 `ios_base` 클래스에서, 스트림의 입출력 형식을 바꿀 수 있다고 하였습니다. 예를들어서, 여태까지 수를 입력하면 10진수로 처리되었지만, 이번에는 16진수로 처리할 수 있는 법입니다. 이를 어떻게 가능하게 하는지 아래의 예제로 보여드리겠습니다.
```cpp-formatted
#include <string>
using namespace std;
int main() {
  int t;
  while (true) {
    cin.setf(ios_base::hex, ios_base::basefield);
    cin >> t;
    cout << "입력 :: " << t << endl;
    if (cin.fail()) {
      cout << "제대로 입력해주세요" << endl;
      cin.clear();  // 플래그들을 초기화 하고 cin.ignore(100,'n');//개행문자가
                    // 나올 때까지 무시한다
    }
    if (t == 0) break;
  }
}
```

성공적으로 컴파일 하였다면
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F272CC74454A10BD31ADFCB)


위와 같이 16진수 입력을 잘 받는 다는 것을 볼 수 있습니다. (출력 형식은 바꾸지 않았으므로, 10진수로 출력됩니다) 이 처럼 입력 받는 형식을 16진수로 바꿔준 함수는 보시다 싶이, 아래와 같은 스트림의 설정을 바꾸는 `setf` 함수 덕분입니다.
```cpp-formatted
cin.setf(ios_base::hex, ios_base::basefield);
```



`setf` 함수의 버전은 2 개가 있는데, 하나는 인자를 1 개만 받는 것이고, 다른 하나는 위 처럼 인자를 2개 취하는 것입니다. 인자 1 개를 받는 `setf` 는 그냥 인자로 준 형식 플래그를 적용하는 것이지만, 2 개 취하는 것은, 두 번째 인자 (위에서 `basefield`) 의 내용을 초기화 하고, 첫 번째 인자 (hex) 를 적용하는 것입니다. 위 경우, 수를 처리하는 방식은 1 가지 진수 만 한 번에 처리할 수 있으므로, 몇 진법으로 수를 처리할 지 보관하는 `basefield` 의 값을 초기화 하고, 16진법 (hex) 플래그를 적용시킨 것입니다.


물론, 여러분이 16 진법을 처리하는 함수를 그냥 만들어도 됩니다. 수 대신에 문자열로 입력받아서 처리해도 되지요. 그렇지만, 사용자가 `0x` 를 앞에 붙일 수 도 있고 안 붙일 수 도 있고, `a123` 이라 쓸 수도 있고 `A123` 이라 쓸 수 도 있고 등 여러가지 경우가 있기 때문에 차라리 마음 편하게 `IO` 라이브러리에서 지원하는 방식을 사용하는 것이 좋은 것 같습니다.


그런데 흥미롭게도, 비슷하지만 또 다른 방식으로 16진수를 받을 수 있습니다.

```cpp-formatted
// 조작자의 사용
#include <iostream>
#include <string>
usingnamespace std;
int main() {
  int t;
  while (true) {
    cin >> hex >> t;
    cout << "입력 :: " << t << endl;
    if (cin.fail()) {
      cout << "제대로 입력해주세요" << endl;
      cin.clear();           // 플래그들을 초기화 하고
      cin.ignore(100, 'n');  //개행문자가 나올 때까지 무시한다
    }
    if (t == 0) break;
  }
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F272CC74454A10BD31ADFCB)





위와 같이 16진수를 잘 입력받는다는 사실을 알 수 있습니다. 이게 어떻게 된 일 일까요?

```cpp-formatted
cin >> hex >> t;
```



바로 위에서 `hex` 가 `cin` 에서 수를 받는 방식을 바꿔버렸기 때문입니다. 이 때문에 `hex` 와 같이, 스트림을 조작하여 입력 혹은 출력 방식을 바꿔주는 함수를 조작자라고 부릅니다 (그렇습니다! `hex` 는 함수 입니다).참고로, 위에서 사용하였던 형식 플래그 `hex` 와 이 `hex` 는 이름만 같지 아예 다른 것입니다. (그렇기에, 위에서는 `ios_base::hex` 로 사용하였죠)

위의 형식 플래그 `hex` 는 `ios_base` 에 선언되어 있는 단순한 상수 '값' 입니다. 반면에 조작자 `hex` 의 경우 `ios` 에 정의되어 있는 '함수' 입니다. 이 조작자 hex 의 정의를 살펴보자면, 아래와 같이 `ios_base` 객체를 레퍼런스로 받고, 다시 그 객체를 리턴하도록 정의 되어 있습니다.

```cpp-formatted
std::ios_base& hex(std::ios_base& str);
```



그렇다면, `operator>>` 중에서 위 함수를 인자로 가지는 경우도 있을까요? 물론 있습니다.

```cpp-formatted
istream& operator>>(ios_base& (*pf)(ios_base&));
```



이렇게, `operator>>` 에서 조작자를 받는다면 많은 일을 하는 것이 아니라 단순히 `pf(*this)` 를 호출하게 됩니다. 호출된 hex 함수가 하는 일 또한 별로 없습니다. 단순히,

```cpp-formatted
str.setf(std::ios_base::hex, std::ios_base::basefield)
```



를 수행해주는 것이지요.


이렇게, `setf` 를 사용하지 않더라도, 간단하게 조작자를 사용하면 훨씬 쉽게 입력 형식을 바꿀 수 있게 됩니다. 조작자들의 종류는 위에서 설명한 `hex` 말고도, 꽤 많은데, `true` 나 `false` 를 1 과 0 으로 처리하는 대신 문자열 그대로 입력 받는 `boolalpha` 도 있고, 출력 형식으로 왼쪽 혹은 오른쪽으로 정렬 시키는 `left` 와 `right` 조작자 등 여러가지가 있습니다.


그 외에도 우리가 여태까지 아무 생각없이 사용하였던 `endl` 도 있습니다. endl 은 `hex` 와는 달리 출력을 관장하는 `ostream` 에 정의되어 있는 조작자로, 한 줄 개행문자를 출력하는 것 말고도, 버퍼를 모두 내보내는(flush) 역할도 수행합니다. 앞서 말했듯이, 문자 1 개를 내보낸다고 해서 화면에 바로 출력되는 것이 아니라, 버퍼에 모은 다음에 버퍼에 어느 정도 쌓이면 비로소 출력하게 됩니다. 이렇게 한다고 해서 대부분의 경우 문제되지는 않습니다. 하지만 예를 들어 정해진 시간에 딱딱 맞춰서 화면에 출력해야 한다면 어떨까요? 이 경우 버퍼에 저장할 필요없이 화면에 바로 내보내야 할 것입니다.



이럴 경우를 위해서, 버퍼에 데이터가 얼마나 쌓여있든지 간에 바로 출력을 해주는 `flush` 함수가 있습니다. 따라서, `endl` 조작자는, 스트림에 '\n' 을 출력하는 것과 더불어 `flush` 를 수행해준다는 사실을 알 수 있습니다.






###  스트림 버퍼에 대해




모든 입출력 객체들은 이에 대응되는 스트림 객체를 가지고 있게 됩니다. 따라서 C++ 의 입출력 라이브러리에는 이에 대응되는 스트림 버퍼 클래스도 있는데, 이름이 `streambuf` 클래스 입니다. 사실, 스트림이라 하면 그냥 쉽게 말해서 문자들의 순차적인 나열이라 보시면 됩니다. 그냥 문자들이 순차적으로 쭈르륵 들어오는 것이 (마치 냇가에서 물이 졸졸 흐르듯이 **stream** 단어의 사전적 의미는 시냇물입니다) 스트림이라 생각하시면 됩니다.

예를 들어서, 우리가 화면에 입력하는 문자도 스트림을 통해서 프로그램에 전달되는 것이고, 하드디스크에서 파일을 읽는 것도, 다른 컴퓨터와 `TCP/IP` 통신하는 것도 (결국 문자들을 쭈루륵 주고받는 것이니까), 모두 스트림을 통해 이루어진다는 것입니다. 심지어 C++ 에서는 `stringstream` 을 통해서평범한문자열을 마치 스트림인 것 처럼 이용할 수 도 있게 해줍니다.

`streambuf` 클래스는 스트림에 대한 가장 기본적인 제어를 담당하고 있습니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2659F647554622FA21A515)

위 사진은 `streambuf` 클래스에서 스트림을 어떤 식으로 추상화하고 있는지 보여주는 그림입니다. `streambuf` 는 그림과 같이 맨 아래에 나타나있는 스트림에서 입력을 받던지, 출력을 하던지, 혹은 입력과 출력을 동시에 (파일 입출력에서 "rw" 옵션을 생각해보세요) 수행할 수 도 있습니다.

`streambuf` 클래스는 스트림의 상태를 나타내기 위해서 세 개의 포인터를 정의하고 있습니다. 먼저 버퍼의 시작 부분을 가리키는 시작 포인터와, 다음으로 읽을 문자를 가리키고 있는 포인터 (우리가 흔히 말하는 스트림 위치 지정자), 그리고 버퍼의 끝 부분을 가리키고 있는 끝 포인터가 있습니다. `streambuf` 클래스는 입력 버퍼와 출력 버퍼를 구분해서 각각 `get area` 와 `put area` 라 부르는데, 이에 따라 각각을 가리키는 포인터도 `g` 와 `p` 를 붙여서 표현하게 됩니다.

아래 예제를 통해 `streambuf` 를 어떻게 하면 간단히 조작할 수 있는지 보여드리도록 하겠습니다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

int main() {
  string s;
  cin >> s;

  // 위치 지정자를 한 칸 옮기고, 그 다음 문자를 훔쳐본다 (이 때는 움직이지 않음)
  char peek = cin.rdbuf()->snextc();
  if (cin.fail()) cout << "Failed";
  cout << "두 번째 단어 맨 앞글자 : " << peek << endl;
  cin >> s;
  cout << "다시 읽으면 : " << s << endl;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F246E6D4D554635332B1532)



위와 같이 나옴을 알 수 있습니다.

```cpp-formatted
char peek = cin.rdbuf()->snextc();
```



입력 객체 `cin` 의 `rdbuf` 를 호출하게 되면, `cin` 객체가 입력을 수행하고 있던 `streambuf` 객체를 가리키는 포인터를 리턴하게 됩니다. 이 때, `cin` 객체가 `istream` 객체 이므로, 오직 입력만을 수행하고 있기에, 이 `streambuf` 객체에는 오직 `get area` 만 있음을 알 수 있습니다.


`snextc` 함수는, 스트림 위치 지정자를 한 칸 전진시킨 후, 그 자리에 해당하는 문자를 엿봅니다 (읽는 것이 아닙니다). 엿보는 것과 읽는 것의 차이점은, 보통 `streambuf` 객체에서 읽게 되면,스트림 위치 지정자를 한 칸 전진시켜서 다음 읽기 때 다음 문자를 읽을 수 있도록 준비해줍니다. 하지만 엿본다는 것은, 해당 문자를 읽고도 스트림 위치 지정자를 움직이지 않는다는 것이지요. 따라서 다음 읽기 때 엿본 문자를 읽을 수 있게 됩니다.


그렇다면 왜 `peek` 의 결과가 `w` 가 나올까요? 아래 그림을 통해 이해하시면 쉽습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2105593355463709016936)

일단, 우리가 `hello world` 를 친 다음, `cin >> s` 를 한 이후의 `streambuf` 의 상태 입니다. 문자열의 경우 공백문자가 나오기 전 까지 읽어들이기 때문에 위와 같은 상태가 됩니다. 이제, `snextc()` 함수를 호출 했을 때 상태를 보자면;
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F247A463355463704084800)

`snextc` 함수가 스트림 위치 지정자를 한 칸 전진시키므로, 공백 문자를 띄어넘고, `w` 를 가리키게 됩니다. 그리고, 이에 해당하는 문자인 `w` 를 리턴하게 됩니다. 이 때 `snextc` 함수는 스트림 위치 지정자를 건드리지 않기 때문에,

```cpp-formatted
cin >> s;
cout << "다시 읽으면 : " << s << endl;
```



에서 `world` 전체가 나오게 되지요.


`streambuf` 에는 `snextc` 함수 말고도 수 많은 함수들이 정의되어 있습니다. 물론 이 함수들을 직접 사용할 일은 거의 없겠지만, C++ 입출력 라이브러리는 스트림 버퍼도 추상화해서 클래스로 만들었다는 것 정도로만 기억하시면 좋을 것 같습니다. 또한, C++ 에서 `streambuf` 를 도입한 중요한 이유 한 가지는, 1 바이트 짜리 문자 뿐만이 아니라,`wchar_t,` 즉 다중 바이트 문자들 (우리가 흔히 말하는 `UTF-8` 같은 것이지요)에 대한 처리도 용이하게 하기 위해서 입니다.


예를 들어서, 다중 바이트 문자의 경우, 사용자가 문자 한 개만 요구했음에도 스트림에서는 1 바이트만 읽을 수 있고, 2 바이트, 심지어 4 바이트 까지 필요한 경우가 있습니다. C++ 에서는 이러한 것들에 대한 처리를 스트림 버퍼 객체 자체에서 수행하도록 해서, 사용자가 입출력 처리를 이용하는데 훨씬 용이하게 하였습니다.



이상으로 C++ 에서의 입출력 라이브러리에 대해 간단히 알아보았습니다. 다음 강좌에서는 이제 이 라이브러리를 가지고 파일에서 어떠한 방식으로 입출력을 수행할 수 있는지 알아보도록 하겠습니다.

##@ chewing-cpp-end
Link :  211
2014-04-13 14:04
----------------
title : 씹어먹는 C++ - <6 - 3. 가상함수와 상속에 관련한 잡다한 내용들>
cat_title: 6 - 3. 가상함수와 상속에 관련한 잡다한 내용들
next_page : 213
publish_date : 2014-04-13 14:04
--------------

이번 강좌에서는

* `virtual` 소멸자 (가상 소멸자)
* 가상 함수 테이블 (virtual function table)
* 다중 상속
* 가상 상속

에 대해서 배웁니다.

![](/img/ChewingCpplogo.png)

안녕하세요 여러분. 지난 강좌에서는 놀라움의 연속이었던 `virtual` 키워드의 기능에 대해서 설명하였습니다. `virtual` 키워드를 통해서 동적 바인딩이라는 것을 이루어 낼 수 있었지요. 이번 강좌에서는 가상 함수와 상속에 관련하여 잡다한 내용들을 모두 짚고 넘어가도록 하겠습니다.


지난 시간에 배웠던 것을 간단히 정리해보자면 다음과 같습니다. `Parent` 클래스와 `Child` 클래스에 모두  f 라는 가상함수가 정의되어 있고, `Child` 클래스가 `Parent` 를 상속 받는다고 해봅시다. 그런 다음에 동일한 `Parent*` 타입의 포인터들도 각각 `Parent` 객체와 `Child` 객체를 가리킨다고 해봅시다.

```cpp-formatted
Parent* p = new Parent();
Parent* c = new Child();
```



컴퓨터 입장에서 `p` 와 `c` 모두 `Parent` 를 가리키는 포인터들이므로, 당연히

```cpp-formatted
p->f();
c->f();
```



를 했을 때 모두 `Parent` 의 `f()` 가 호출되어야 하겠지만, 실제로는 `f` 가 가상함수므로, '실제로 `p` 와 `c` 가 가리키는 객체의' `f,` 즉 `p->f()` 는 `Parent` 의 `f` 를, `c->f()` 는 `Child` 의 `f` 가 호출됩니다. 이와 같은 일이 가능한 이유는 `f` 를 가상함수로 만들었기 때문입니다.




###  virtual 소멸자


사실 클래스의 상속을 사용함으로써 중요하게 처리해야 되는 부분이 있습니다. 바로, 소멸자를 가상함수로 만들어야 된다는 점입니다.

```cpp-formatted
#include <iostream>
using namespace std;

class Parent {
 public:
  Parent() { cout << "Parent 생성자 호출" << endl; }
  ~Parent() { cout << "Parent 소멸자 호출" << endl; }
};
class Child : public Parent {
 public:
  Child() : Parent() { cout << "Child 생성자 호출" << endl; }
  ~Child() { cout << "Child 소멸자 호출" << endl; }
};
int main() {
  cout << "--- 평범한 Child 만들었을 때 ---" << endl;
  { Child c; }
  cout << "--- Parent 포인터로 Child 가리켰을 때 ---" << endl;
  {
    Parent *p = new Child();
    delete p;
  }
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2372D04753D905142692F7)



와 같이 나옵니다.


일단 평범하게 `Child` 객체를 만든 부분을 살펴봅시다.

```cpp-formatted
cout << "--- 평범한 Child 만들었을 때 ---" << endl;
{ Child c; }
```



생성자와 소멸자의 호출 순서를 살펴보자면, `Parent` 생성자 → `Child` 생성자→ `Child` 소멸자→ `Parent` 소멸자 순으로 호출됨을 알 수 있습니다. 이와 같은 과정이 당연한 이유는 객체를 만들고 소멸시키는 일을 집을 짓고 철거하는 일로 비유할 수 있습니다.

집을 지을 때에는 큰 틀, 즉 기초공사를 하고 건물을 세운 다음에 (`Parent` 생성자 호출), 집 내부 공사, 인테리어, 가구 배치 등을 하게 됩니다 (`Child` 생성자 호출). 그리고 역으로 집을 철거할 때에는 안에 있는 내용물들을 모두 제거한 뒤에 (`Child` 소멸자 호출), 집 구조물을 철거하겠지요 (`Parent` 소멸자 호출).


그런데 문제는 그 아래 `Parent` 포인터가 `Child` 객체를 가리킬 때 입니다.

```cpp-formatted
cout << "--- Parent 포인터로 Child 가리켰을 때 ---" << endl;
{
  Parent *p = new Child();
  delete p;
}
```

`delete p` 를 하더라도, `p` 가 가리키는 것은 `Parent` 객체가 아닌 `Child` 객체 이기 때문에, 위에서 보통의 `Child` 객체가 소멸되는 것과 같은 순서로 생성자와 소멸자들이 호출되어야만 합니다. 그런데 실제로는, `Child` 소멸자가 호출되지 않습니다.


소멸자가 호출되지 않는다면 여러가지 문제가 생길 수 있습니다. 예를 들어서, `Child` 객체에서 메모리를 동적으로 할당하고 소멸자에서 해제하는데, 소멸자가 호출 안됬다면 **메모리 누수(memory leak)**가 생기겠지요.

하지만 `virtual` 키워드를 배운 이상 여러분은 무엇을 해야 하는지 알고 계실 것입니다. 단순히 `Parent` 의 소멸자를 `virtual` 로 만들어버리면 됩니다. `Parent` 의 소멸자를 `virtual` 로 만들면, `p` 가 소멸자를 호출할 때, `Child` 의 소멸자를 성공적으로 호출할 수 있게 됩니다.

```cpp-formatted
#include <iostream>
using namespace std;

class Parent {
 public:
  Parent() { cout << "Parent 생성자 호출" << endl; }
  virtual ~Parent() { cout << "Parent 소멸자 호출" << endl; }
};
class Child : public Parent {
 public:
  Child() : Parent() { cout << "Child 생성자 호출" << endl; }
  ~Child() { cout << "Child 소멸자 호출" << endl; }
};
int main() {
  cout << "--- 평범한 Child 만들었을 때 ---" << endl;
  { Child c; }
  cout << "--- Parent 포인터로 Child 가리켰을 때 ---" << endl;
  {
    Parent *p = new Child();
    delete p;
  }
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2267FE4553D916BC0B6C3C)



와 같이 제대로 `Child` 소멸자가 호출됨을 알 수 있습니다.


여기서 한 가지 질문을 하자면, 그렇다면 왜 `Parent` 소멸자는 호출이 되었는가 인데, 이는 `Child` 소멸자를 호출하면서, `Child` 소멸자가 '알아서' `Parent` 의 소멸자도 호출해주기 때문입니다 (`Child` 는 자신이 `Parent` 를 상속받는다는 것을 알고 있습니다).

반면에 `Parent` 소멸자를 먼저 호출하게 되면, `Parent` 는 `Child` 가 있는지 없는지 모르므로, `Child` 소멸자를 호출해줄 수 없습니다 (Parent 는 자신이 누구에서 상속해주는지 알 수 없지요).


이와 같은 연유로,상속될 여지가 있는 `Base` 클래스들은 (위 경우 `Parent),` 반드시 소멸자를 `virtual` 로 만들어주어야 나중에 문제가 발생할 여지가 없게 됩니다.



###  레퍼런스도 된다


여태 까지 부모 클래스에서 자식 클래스의 함수에 접근할 때 항상 부모 클래스의 포인터를 통해서 접근하였습니다. 하지만, 사실 부모 클래스의 레퍼런스여도 문제 없이 작동합니다. 아래 간단한 예제를 통해 살펴보겠습니다.

```cpp-formatted
#include <iostream>
using namespace std;

class A {
 public:
  virtual void show() { cout << "Parent !" << endl; }
};
class B : public A {
 public:
  void show() { cout << "Child!" << endl; }
};

void test(A& a) { a.show(); }
int main() {
  A a;
  B b;
  test(a);
  test(b);

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F25547A42578C8E63118312)



와 같이 나옵니다.

```cpp-formatted
void test(A& a) { a.show(); }
```



`test` 함수를 살펴보면 `A` 클래스의 레퍼런스를 받게 되어 있지만,

```cpp-formatted
test(b);
```



를 통해서 `B` 클래스의 객체를 전달하였는데도 잘 작동하였습니다. 이는, `B` 클래스가 `A` 클래스를 상속 받고 있기 때문입니다. 즉, 함수에 타입이부모 클래스여도 그 자식 클래스는 타입 변환되어 전달 할 수 있습니다.


따라서 `test` 함수에서 `show()` 를 호출하였을 때 인자로 `b` 를 전달하였다면, 비록 전달된 인자가A의 객체라고 표현되어 있지만 `show` 함수가 `virtual` 으로 정의되어 있기 때문에 알아서 B 의 `show` 함수를 찾아내서 호출하게 됩니다. 물론 `test` 에 `a` 를 전달하였을 때에는 `A` 의 `show` 함수가 호출되겠지요.





###  가상 함수의 구현 원리


여태 까지 `virtual` 키워드의 능력을 본 바로는 이러한 의문이 들 수 도 있을 것입니다.

> 그냥 그럼 모든 함수들을 `virtual` 로 만들어버리면 안되나?

사실 이는 매우 좋은 질문입니다. 왜냐하면 모든 함수들을 `virtual` 로 만들어버린다고 해서 문제될 것이 전혀 없기 때문입니다. 간혹 '가상' 이라는 이름 때문에 혼동하시는 분이 계시는데, `virtual` 키워드를 붙여서 가상 함수로 만들었다 해도 실제로 존재하는 함수이고 정상적으로 호출도 할 수 있습니다. 또한 모든 함수들을 디폴트로 가상 함수로 만듬으로써, 언제나 동적 바인딩이 제대로 동작하게 만들 수 있습니다.

실제로 자바의 경우 모든 함수들이 디폴트로 `virtual` 함수로 선언됩니다.

그렇다면 왜 C++ 에서는 `virtual` 키워드를 이용해 사용자가 직접 `virtual` 로 선언하도록 하였을까요? 그 이유는 가상 함수를 사용하게 되면 약간의 **오버헤드 (overhead)** 가 존재하기 때문입니다. \sidenote{보통의 함수를 호출하는 것 보다 가상 함수를 호출하는 데 걸리는 시간이 조금 더 오래 걸립니다.} 이를 이해하기 위해 가상 함수라는 것이 어떻게 구현되는지, 다시 말해 마술과 같은 동적 바인딩이 어떻게 구현되는지 살펴보도록 합시다.

예를 들어서 다음과 같은 간단한 두 개의 클래스를 생각해봅시다.
```cpp-formatted
class Parent {
 public:
  virtual void func1();
  virtual void func2();
};
class Child : public Parent {
 public:
  virtual void func1();
  void func3();
};
```



C++ 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해서, **가상 함수 테이블(virtual function table; vtable)**을 만들게 됩니다. 가상 함수 테이블은 전화 번호부라고 생각하시면 됩니다.

함수의 이름(전화번호부의 가게명) 과 실제로 어떤 함수 (그 가게의 전화번호) 가 대응되는지 테이블로 저장하고 있는 것입니다 

위 경우 `Parent` 와 `Child` 모두 가상 함수를 포함하고 있기 때문에 두 개 다 가상 함수 테이블을 생성하게 되지요. 그 결과;

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2113164253DB01CF09ACCF)

위와 같이 구성됩니다. 가상 함수와 가상 함수가 아닌 함수와의 차이점을 살펴보자면 `Child` 의 `func3()` 같이 비 가상함수들은 그냥 단순히 특별한 단계를 걸치지 않고, `func3()` 을 호출하면 직접 실행됩니다.

하지만, 가상 함수를 호출하였을 때는 그 실행 과정이 다릅니다. 위에서도 보이다 싶이, 가상 함수 테이블을 한 단계 더 걸쳐서, 실제로 '어떤 함수를 고를지' 결정하게 됩니다. 예를 들어서;


```cpp-formatted
Parent* p = Parent();
p->func1();
```



을 해봅시다. 그러면, 컴파일러는


1. p 가 `Parent` 를 가리키는 포인터 이니까, `func1()` 의 정의를 `Parent` 클래스에서 찾아봐야겠다.
2. `func1()` 이 가상함수네?  그렇다면 `func1()` 을 직접 실행하는게 아니라, 가상 함수 테이블에서 `func1()` 에 해당하는 함수를 실행해야겠다.

그리고 실제로 프로그램 실행시에, 가상 함수 테이블에서 `func1()` 에 해당하는 함수(`Parent::func1()`) 을 호출하게 됩니다.


에 해당하는 코드를 작성하게 됩니다. 그렇다면, 다음의 경우는 어떨까요?

```cpp-formatted
Parent* c = Child();
c->func1();
```



위 처럼 똑같이 프로그램 실행시에 가상 함수 테이블에서 `func1()` 에 해당하는 함수를 호출하게 되는데, 이번에는 `p` 가 실제로는 `Child` 객체를 가리키고 있으므로, `Child` 객체의 가상 함수 테이블을 참조하여, `Child::func1()` 을 호출하게 됩니다. 따라서 성공적으로 `Parent::func1()` 를 오버라이드 할 수 있습니다.


이와 같이 두 단계에 걸쳐서 함수를 호출함을 통해 소프트웨어적으로 동적 바인딩을 구현할 수 있게 됩니다. 이러한 이유로 가상 함수를 호출하는 경우, 일반적인 함수 보다 약간 더 시간이 오래 걸리게 됩니다.

물론 이 차이는 극히 미미하지만, 최적화가 매우 중요한 분야에서는 이를 감안할 필요가 있습니다. 아무튼 이러한 연유로 인해, 다른 언어들과는 다르게, C++ 에서는 멤버 함수가 디폴트로 가상함수가 되도록 설정하지는 않습니다.

###  순수 가상 함수(pure `virtual` function)와 추상 클래스(abstract `class)`


```cpp-formatted
#include <iostream>
using namespace std;

class Animal {
 public:
  Animal() {}
  virtual ~Animal() {}
  virtual void speak() = 0;
};

class Dog : public Animal {
 public:
  Dog() : Animal() {}
  void speak() { cout << "왈왈" << endl; }
};

class Cat : public Animal {
 public:
  Cat() : Animal() {}
  void speak() { cout << "야옹야옹" << endl; }
};

int main() {
  Animal* dog = new Dog();
  Animal* cat = new Cat();

  dog->speak();
  cat->speak();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F226A0B4253DB346C046970)

위 코드를 보면서 한 가지 특이한 점을 눈치 채셨을 것입니다.
```cpp-formatted
class Animal {
 public:
  Animal() {}
  virtual ~Animal() {}
  virtual void speak() = 0;
};
```



`Animal` 클래스의 `speak` 함수를 살펴봅시다. 다른 함수들과는 달리, 함수의 몸통이 정의되어 있지 않고 단순히 `= 0;` 으로 처리되어 있는 가상 함수 입니다.

그렇다면 이 함수는 무엇을 하는 함수 일까요? 그 답은, "무엇을 하는지 정의되어 있지 않는 함수" 입니다. 다시 말해 이 함수는 **반드시 오버라이딩 되어야만 하는 함수** 이지요.

이렇게, 가상 함수에 `= 0;` 을 붙여서, 반드시 오버라이딩 되도록 만든 함수를 완전한 가상 함수라 해서, **순수 가상 함수(pure virtual function)**라고 부릅니다.


당연하게도, 순수 가상 함수는 본체가 없기 때문에, 이 함수를 호출하는 것은 불가능합니다. 그렇기 때문에, `Animal` 객체를 생성하는것 또한 불가능입니다. 왜냐하면,

```cpp-formatted
Animal a;
a.speak();
```

하면 안되기 때문이지요. 물론, `speak()` 함수를 호출하는 것을 컴파일러 상에서 금지하면 되지 않냐고 물을 수 있는데, C++ 개발자들은 이러한 방법 대신에 아예 `Animal` 의 객체 생성을 금지시키는 것으로 택하였습니다. (쉽게 말해 `Animal` 의 인스턴스를 생성할 수 없지요)


만일 `Animal` 의 객체를 생성하려고 한다면 다음과 같은 컴파일 오류를 만날 수 있습니다.


```warning

error C2259: 'Animal' : cannot instantiate abstract class
1>          due to following members:
1>          'void Animal::speak(void)' : is abstract
```



따라서 `Animal` 처럼,순수 가상 함수를 최소 한 개 이상 포함하고 있는 클래스는 객체를 생성할 수 없으며, 인스턴스화 시키기 위해서는 이 클래스를 상속 받는 클래스를 만들어서 모든 순수 가상 함수를 오버라이딩 해주어야만 합니다.

이렇게 순수 가상 함수를 최소 한개 포함하고 있는- 반드시 상속 되어야 하는 클래스를 가리켜 **추상 클래스 (abstract class)**라고 부릅니다. (참고로, 이러한 이유 때문에 순수 가상 함수는 반드시 `public` 이나 `protected` 가 되어야 합니다. `private` 으로 정의될 경우 오버라이드 될 수 가 없기 때문이지요.)


따라서;


```cpp-formatted
class Dog : public Animal {
 public:
  Dog() : Animal() {}
  void speak() { cout << "왈왈" << endl; }
};
```



위 처럼 `speak ()` 를 오버라이딩 함으로써 (- 정확히 말하면 Animal 의 모든 순수 가상 함수를 오버라이딩 함으로써) Dog 클래스의 객체를 생성할 수 있게 됩니다. `Cat` 클래스도 마찬가지 이지요.


그렇다면 추상 클래스를 도대체 왜 사용하는 것일까요? 

추상 클래스 자체로는 인스턴스화 시킬 수 도 없고 (추상 클래스의 객체를 만들 수 없다) 사용하기 위해서는 반드시 다른 누구가 상속 해줘야만 하기 때문이지요. 하지만, 추상 클래스를 '설계도' 라고 생각하면 좋습니다. 

즉, 이 클래스를 상속받아서 사용하는 사람에게 "이 기능은 일반적인 상황에서 만들기 힘드니 너가 직접 특수화 되는 클래스에 맞추어서 만들어서 써라." 라고 말해주는 것이지요.
예를 들어서 위에서 예를 든 `Animal` 클래스의 경우

```cpp-formatted
class Animal {
 public:
  Animal() {}
  virtual ~Animal() {}
  virtual void speak() = 0;
};
```



동물들이 소리를 내는 것은 맞으므로 `Animal` 클래스에 `speak` 함수가 필요합니다. 하지만어떤 소리를 내는지는 동물 마다 다르기 때문에 `speak` 함수를 가상 함수로 만들기는 불가능 합니다. 따라서 `speak` 함수를 순수 가상 함수로 만들게 되면 모든 `Animal` 들은 `speak()` 한다라는 의미 전달과 함께, 사용자가 `Animal` 클래스를 상속 받아서  (위 경우 `Dog` 와 `Cat) speak()` 를 상황에 맞게 구현하면 됩니다.

추상 클래스의 또 한가지 특징은 비록 객체는 생성할 수 없지만, 추상 클래스를 가리키는 포인터는 문제 없이 만들 수 있다는 점입니다. 위 예에서도 살펴보았듯이, 아무런 문제 없이 `Animal*` 의 변수를 생성하였습니다.

```cpp-formatted
Animal* dog = new Dog();
Animal* cat = new Cat();

dog->speak();
cat->speak();
```



그리고 `dog` 와 `cat` 의 `speak` 함수를 호출하였는데, 앞에서도 배웠듯이, 비록 `dog` 와 `cat` 이 `Animal*` 타입 이지만, `Animal` 의 `speak` 함수가 오버라이드 되어서, `Dog` 와 `Cat` 클래스의 `speak` 함수로 대체되서 실행이 됩니다.


###  다중 상속(multiple `inheritance)`


마지막으로 C++ 에서의 상속의 또 다른 특징인 다중 상속에 대해 알아보도록 합시다. C++ 에서는 한 클래스가 다른 여러 개의 클래스들을 상속 받는 것을 허용합니다. 이를 가리켜서 **다중 상속 (multiple inheritance)** 라고 부릅니다.

```cpp-formatted
class A

{
 public:
  int a;
};

class B {
 public:
  int b;
};

class C : public A, public B {
 public:
  int c;
};
```


위 경우, 클래스 C 가 `A` 와 `B` 로 부터 동시에 같이 상속 받고 있습니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F274F493853DD288E298103)

이를 그림으로 표현하자면 위 같은 모양이 되겠지요. 사실 다중 상속은 보통의 상속 하고 똑같이 생각하시면 됩니다. 단순히 그냥 `A` 와 `B` 의 내용이 모두 C 에 들어간다고 생각하시면 됩니다. 따라서;


```cpp-formatted
C c;
c.a = 3;
c.b = 2;
c.c = 4;
```



와 같은 것이 가능하게 되는 것이지요. 다중 상속에서 한 가지 재미있는 점은 생성자들의 호출 순서 입니다. 여러분은 과연 위 예에서 `A` 의 생성자가 먼저 호출될지, `B` 의 생성자가 먼저 호출될 지 궁금할 것입니다. 한 번 확인을 해보도록 하겠습니다.

```cpp-formatted
#include <iostream>
using namespace std;

class A {
 public:
  int a;

  A() { cout << "A 생성자 호출" << endl; }
};

class B {
 public:
  int b;

  B() { cout << "B 생성자 호출" << endl; }
};

class C : public A, public B {
 public:
  int c;

  C() : A(), B() { cout << "C 생성자 호출" << endl; }
};
int main() { C c; }
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2622683553DD2ED529CDF2)



위 처럼 `A -> B -> C` 순으로 호출됨을 알 수 있습니다. 그렇다면 이번에는,

```cpp-formatted
class C : public A, public B
```



에서

```cpp-formatted
class C : public B, public A
```



로 바꾸고 컴파일을 해보세요. 재미있게도;


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2176983F53DD2FCC2A52E0)



로 이번에는 `B` 의 생성자가 `A` 보다 먼저 호출됨을 알 수 있습니다. 몇 번 더 실험을 해보면 이 순서는 다른 것들에 의해 좌우되지 않고 오직 상속하는 순서에만 좌우 됨을 알 수 있습니다.


사실 다중 상속은 실제 프로그래밍에서 많이 쓰이지는 않습니다. 왜냐하면 다음과 같은 위험이 언제나 도사리고 있기 때문이지요.

```cpp-formatted
class A {
 public:
  int a;
};

class B {
 public:
  int a;
};

class C : public B, public A {
 public:
  int c;
};
```



위처럼 만일 두 개의 클래스에서 이름이 같은 멤버 변수나 함수가 있다고 해봅시다. 예를 들어 위 예에서는 클래스 `A` 와 `B` 에 모두 `a` 라는 이름의 멤버 변수가 들어가 있습니다.

```cpp-formatted
int main() {
  C c;
  c.a = 3;
}
```



그렇다면 만일 클래스 C 의 객체를 생성해서, 위 처럼 중복되는 멤버 변수에 접근한다면;

```warning

error C2385: ambiguous access of 'a'
1>          could be the 'a' in base 'B'
1>          or could be the 'a' in base 'A'
```



위 처럼 `B` 의 'a' 인지, `A` 의 'a' 인지 구분할 수 없다는 오류를 발생하게 됩니다. 마찬가지로, 클래스 `A` 와 `B` 에 같은 이름의 함수가 있다면 똑같이 어떤 함수를 호출해야 될 지 구분할 수 없겠지요. 그 외에도 다중 상속은 코드 구조를 매우 복잡하게 만드는 경향이 있기 때문에 C++ 이외에 많은 언어들 (자바, C# 등) 에서는 다중 상속 기능을 지원하고 있지 않습니다.


다중 상속의 또 다른 문제는 일명 **다이아몬드 상속(diamond inheritance)** 혹은 공포의 다이아몬드 상속(dreadful diamond of derivation) 이라고 부르는 형태의 다중 상속에 있습니다. 예를 들어 다음과 같은 형태의 상속 관계를 생각해봅시다.

```cpp-formatted
class Human {
  // ...
};
class HandsomeHuman : public Human {
  // ...
};
class SmartHuman : public Human {
  // ...
};
class Me : public HandsomeHuman, public SmartHuman {
  // ...
};
```



일단 베이스 클래스로 `Human` 이라는 클래스가 있고, `HandsomeHuman` 과 `SmartHuman` 클래스는 `Human` 클래스를 모두 상속 받습니다.

그리고 두 가지 특성을 모두 보유한 나(Me) 라는 클래스는, `HandsomeHuman` 과 `SmartHuman` 클래스를 둘 다 상속 받습니다. 이를 그림으로 표현하자면 아래와 같은 다이아몬드 모양이 나오게 됩니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F27033F4653DD3A87338E99)

상속이 되는 두 개의 클래스가 공통의 베이스 클래스를 포함하고 있는 형태를 가리켜서 다이아몬드 상속이라고 부릅니다. 이러한 형태의 상속에 문제점은 보기에도 명백합니다.

만일 `Human` 에 `name` 이라는 멤버 변수가 있다고 해봅시다. 그러면 `HandsomeHuman` 과 `SmartHuman` 은 모두 `Human` 을 상속 받고 있으므로, 여기에도 `name` 이라는 변수가 들어가게 됩니다.

그런데 `Me` 가 이 두 개의 클래스를 상속 받으니 `Me` 에서는 `name` 이라는 변수가 겹치게 되는 것이지요. 결과적으로 볼 때 `Handsome` 과 `SmartHuman` 을 아무리 안겹치게 만든다고 해도, `Human` 의 모든 내용이 중복되는 문제가 발생하게 됩니다.


다행이도 이를 해결할 수 있는 방법이 있습니다.

```cpp-formatted
class Human {
 public:
  // ...
};
class HandsomeHuman : public virtual Human {
  // ...
};
class SmartHuman : public virtual Human {
  // ...
};
class Me : public HandsomeHuman, public SmartHuman {
  // ...
};
```



이러한 형태로 `Human` 을 `virtual` 로 상속 받는다면, `Me` 에서 다중 상속 시에도, 컴파일러가 언제나 `Human` 을 한 번만 포함하도록 지정할 수 있게 됩니다. 참고로, 가상 상속 시에, `Me` 의 생성자에서 `HandsomeHuman` 과 `SmartHuman` 의 생성자를 호출함은 당연하고, `Human` 의 생성자 또한 호출해주어야만 합니다.


앞에서도 이야기 하였지만 반드시 필요한 경우가 아니라면 다중 상속을 피하는 것이 좋습니다. 왜냐하면 다중 상속을 사용하게 되면 프로그램의 구조가 매우 복잡해질 뿐더러 예상치 못한 오류를 발생할 가능성이 매우 높기 때문이지요. 실제로 다중 상속을 이용해서 해결해야 될 것 같은 문제도 알고보면 단일 상속을 통해 해결할 수 있는 경우가 매우 많습니다 (어떤 사람들은 `100%` 라고 주장하기도 하지요) 다중 상속에 좀 더 자세히 알고 싶은 분들은 이 글을 읽는 것이 많은 도움이 될 것입니다. [http://www.drdobbs.com/cpp/multiple-inheritance-considered-useful/184402074](http://www.drdobbs.com/cpp/multiple-inheritance-considered-useful/184402074)



아무래도 이번 강좌는 상속에 대한 중요한 요소들을 간단 하게 짚고 넘어가는 것이라 실질적인 프로그램은 만들지 않았습니다. 하지만, 가상 함수와 상속이 어떻게 돌아가는지 완벽히 이해하는 것이 좋습니다. 저의 경우, C++ 처음 배울 때, 이 부분에서 많이 헷갈려서 고생을 한 기억이 있습니다. 여러분들도 가상 함수를 포함하는 간단한 프로그램을 작성해서 어떻게 함수들이 호출되는지 살펴보시기 바랍니다.

##@ chewing-cpp-end
Link :  210
2014-03-31 09:05
----------------
title : 씹어먹는 C++ - <6 - 2.  가상(virtual) 함수와 다형성>
cat_title: 6 - 2.  가상(virtual) 함수와 다형성
next_page : 211
publish_date : 2014-03-31 09:05
--------------


이번 강좌에서는

* *is - a* 와 *has - a* 관계
* 오버라이딩(overriding)
* `virtual` 키워드와 가상함수(virtual function)
* 다형성(polymorphism)

에 대해서 배웁니다.


![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 지난번 강좌는 재미있으셨나요. C++ 이란 산을 넘기 위해 아직도 지나가야 할 관문이 앞에 수 없이 많지만, 그래도 이번 강좌를 통해서 그 관문 하나는 지나갈 수 있으리라 생각합니다. 이번 강좌에서는 객체지향프로그래밍의 핵심 개념 하나에 대해서 배울 것입니다. 기대하세요 :)


###  is `- a` 와 `has - a`


일단 이야기를 진행하기 전에, 어떠한 경우에서 상속을 사용하는지 생각해봅시다. C++ 에서 상속을 도입한 이유는 단순히 똑같은 코드를 또 쓰는 것을 막기 위한 *Ctrl + C, Ctrl + V* 방지용으로 위한 것이 아닙니다 (물론 그러한 이유도 약간 있겠지만). 실제 이유는 상속이라는 기능을 통해서 객체지향프로그래밍에서 추구하는 실제 객체의 추상화를 좀 더 효과적으로 할 수 있게 되었습니다.

이게 무슨 말이냐면 상속이란 것이 없던 C 언어에서는 어떠한 구조체 사이의 관계를 표현할 수 있는 방법이 없었습니다. 하지만 C++ 에서 상속이란 것을 도입함으로써, 클래스 사이에 관계를 표현할 수 있게 되었는데, 예를 들어서 `Manager` 가 `Employee` 를 상속한다;

```cpp-formatted
class Manager : public Employee
```

의 의미는,

* `Manager` 클래스는 `Employee` 의 모든 기능을 포함한다
* `Manager` 클래스는 `Employee` 의 기능을 모두 수행할 수 있기 때문에 (Manager 에게는 약간 기분 나쁘겠지만) `Manager` 를 `Employee` 라고 칭해도 무방하다
* 즉, 모든 `Manager` 는 `Employee` 이다
* **Manager is a Employee !!**

따라서, 모든 상속 관계는 *is a* 관계라고 볼 수 있습니다. 당연한 점은, 이를 뒤바꾸면 성립되지 않는 다는 점입니다. 즉 `Manager` 는 `Employee` 이지만 `Employee` 는 `Manager` 가 아닙니다. 이렇기에, `Manager` 를 `Employee` 로 부를 수 있지만, `Employee` 는 `Manager` 로 (미안하게도) 부를 수 없습니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F223ADD465337C5D02236C5)

프로그램 설계 시에 클래스들 간의 상속 관계를 도표로 나타내는 경우가 종종 있는데, 많은 경우 파생 클래스가 부모 클래스를 화살표로 가리키게 그립니다.

실제 세상에서 `is a` 관계로 이루어진 것들은 수 없이 많습니다. 예를 들어, '사람' 이라는 클래스가 있다면, '프로그래머는 사람이다 (A programmer is a human)' 이므로, 만일 우리가 프로그래머 클래스를 만든다면 사람 이라는 클래스를 상속 받을 수 있도록 구성할 수 있습니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F254A344D5337C6D52329FF)

위는 또 다른 `is - a` 관계의 예로, `BankAccount` (은행 계좌) 라는 클래스가 있고 `Checking Account` (자유롭게 입출금이 가능한 계좌지만 이자가 없다) 와 `Savings Account` (비교적 자유롭게 입출금이 불가능하지만, 매 달 이자가 붙음) 가 이를 상속 받고 있습니다. 즉, 같은 계좌지만 기능이 약간 씩 다른 두 계좌 클래스들이 좀 더 '일반적인' `BankAccount` 클래스를 상속 받았지요.

이를 통해서 상속의 또 하나의 중요한 특징을 알 수 있습니다. 바로 클래스가 파생되면 파생될 수 록 좀 더 **특수화 (구체화;specialize)** 된다는 의미 입니다. 즉, `Employee` 클래스가 일반적인 사원을 위한 클래스 였다면 `Manager` 클래스 들은 그 일반적인 사원들 중에서도 좀 더 특수한 부류의 사원들을 의미하게 됩니다.

또, `BankAccount` 도 일반적인 은행 계좌를 위한 클래스 였다면, 이를 상속 받는 `CheckingAccount, SavingsAccount` 들은 좀 더 구체적인 클래스가 되지요. 반대로, 부모 클래스로 거슬러 올라가면 올라갈 수 록 좀 더 **일반화 (generalize)** 된다고 말합니다.

그렇다면 모든 클래스들의 관계를 `is - a` 로만 표현할 수 있을까요? 당연히 그렇지 않습니다. 어떤 클래스들 사이에서는 `is - a` 대신에 `has - a` 관계가 성립하기도 합니다. 예를 들어서, 간단히 자동차 클래스를 생각해봅시다. 자동차 클래스를 구성하기 위해서는 엔진 클래스, 브레이크 클래스, 오디오 클래스 등 수 많은 클래스들이 필요합니다. 그렇다고 이들 사이에 `is a` 관계를 도입 할 수 없습니다. (자동차 `is a` 엔진? 자동차 `is a` 브레이크?) 그 대신, 이들 사이는 `has - a` 관계로 쉽게 표현할 수 있습니다.

즉, 자동차는 엔진을 가진다 (자동차 `has a` 엔진), 자동차는 브레이크를 가진다 (자동차 `has a` 브레이크) 이와 같이 말이지요. 이런 `has - a` 관계는 우리가 흔히 해왔듯이 다음과 같이 클래스로 나타내면 됩니다.

```cpp-formatted
class Car {
 private:
  Engine e;
  Brake b;  // 아마 break 아니냐고 생각하는 사람들이 있을 텐데 :)
  ....
};
```



또 다른 예로 바로 우리의 `EmployeeList` 를 들을 수 도 있습니다. `EmployeeList` 는 `Employee` 들과 `has - a` 관계 이지요. 따라서, 실제로 `EmployeeList` 클래스를 보면

```cpp-formatted
class EmployeeList {
  int alloc_employee;        // 할당한 총 직원 수
  int current_employee;      // 현재 직원 수
  Employee **employee_list;  // 직원 데이터
```

와 같이 `Employee` 를 포함하고 있음을 알 수 있습니다.



###  (다시 보는) 오버라이딩


```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << s << endl; }
};
class Child : public Parent {
  string s;

 public:
  Child() : s("자식"), Parent() { cout << "자식 클래스" << endl; }

  void what() { cout << s << endl; }
};
int main() {
  cout << " === 부모 클래스 생성 ===" << endl;
  Parent p;

  p.what();

  cout << " === 자식 클래스 생성 ===" << endl;
  Child c;

  c.what();

  return 0;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2624F04153385CF40AA08E)



이미 저번 강좌에서도 이야기 했었지만, `Parent` 에서 `what` 을 호출하면 당연히 `Parent` 의 `what` 이 실행되어서 '부모' 라고 나오고, `Parent` 를 상속받는 `Child` 클래스에서 `what` 을 호출하면, `Child` 의 `what` 이 `Parent` 의 `what` 을 오버라이드 해서 `Child` 의 `what` 이 호출되게 됩니다.


이번에는 코드를 약간 변형해보도록 하겠습니다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << s << endl; }
};
class Child : public Parent {
  string s;

 public:
  Child() : s("자식"), Parent() { cout << "자식 클래스" << endl; }

  void what() { cout << s << endl; }
};
int main() {
  Parent p;
  Child c;

  cout << "=== 포인터 버전 ===" << endl;
  Parent* p_c = &c;
  p_c->what();

  return 0;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2504E04353385F071BA9B4)





이번에는 `Child` 의 객체 `c` 를 `Parent` 객체를 가리키는 포인터에 넣었습니다.

```cpp-formatted
Parent* p_c = &c;
```



어떤 분들은 이와 같은 대입이 가능하냐고 물을 수 있습니다. `Parent` 와 `Child` 는 다른 클래스 이니까요. 하지만, 그 분들이 간과하고 있는 점은 `Child` 가 `Parent` 를 상속 받고 있다는 점입니다.상속 받는다면 뭐죠? `==> Child is a Parent`


즉 (말이 조금 이상하지만) `Child` 객체 `c` 도 어떻게 보면 `Parent` 객체이기 때문에 `Parent` 객체를 가리키는 포인터가 `c` 를 가리켜도 무방하다는 것입니다. 이를 그림으로 표현한다면 아래와 같습니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F275E9E4F533861B0087DC4)

그 대신 `p` 는 엄연한 `Parent` 객체를 가리키는 포인터 입니다. 따라서, `p` 의 `what` 을 실행한다면 `p` 는 당연히 '아 `Parent` 의 `what` 을 실행해 주어야 겠구나' 하고, `Parent` 의 `what` 을 실행해서, `Parent` 의 `what` 은 `Parent` 의 `s` 를 출력 하게 됩니다. 따라서 위 처럼 '부모' 가 출력됩니다.



이러한 형태의 캐스팅을 (즉 파생 클래스에서 부모 클래스로 캐스팅 하는 것) 을 업 캐스팅 이라고 부릅니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F25457D33533862EF15CF29)

위 그림을 보면 왜 업 캐스팅이라 부르는지 이해가 확 되지요.



그렇다면 업 캐스팅의 반대인 다운 캐스팅도 있을까요?

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << s << endl; }
};
class Child : public Parent {
  string s;

 public:
  Child() : s("자식"), Parent() { cout << "자식 클래스" << endl; }

  void what() { cout << s << endl; }
};
int main() {
  Parent p;
  Child c;

  cout << "=== 포인터 버전 ===" << endl;
  Child* p_p = &p;
  p_p->what();

  return 0;
}
```



컴파일 한다면 다음과 같은 오류 메세지를 볼 수 있습니다.

```warning

error C2440: 'initializing' : cannot convert from 'Parent *' to 'Child *'
Parent * 에서 Child * 로 변환할 수 없습니다.
```



사실 위와 같은 오류가 발생한 이유는 간단합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F2611D54D53387E4E2FFBBC)

만일 `Child*` 포인터가 `Parent` 객체를 가리킨다고 해봅시다. 그렇다면 `p_p->what()` 하게 된다면 `Child` 의 `what` 함수가 호출되어야만 하는데, 이는 불가능 합니다. (왜냐하면 `p_p` 가 가리키는 객체는 `Parent` 객체 이므로 `Child` 에 대한 정보가 없습니다). 따라서, 이와 같은 문제를 막기 위해서 컴파일러 상에서 함부로 다운 캐스팅 하는 것을 금지하고 있습니다.



하지만 다음과 같은 상황은 어떨까요.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << s << endl; }
};
class Child : public Parent {
  string s;

 public:
  Child() : s("자식"), Parent() { cout << "자식 클래스" << endl; }

  void what() { cout << s << endl; }
};
int main() {
  Parent p;
  Child c;

  cout << "=== 포인터 버전 ===" << endl;
  Parent* p_p = &c;

  Child* p_c = p_p;
  p_c->what();

  return 0;
}
```



컴파일 하였다면

```warning

error C2440: 'initializing' : cannot convert from 'Parent *' to 'Child *'
```



`Child* p_c` 에 `Parent *` 를 대입하면 안된다는 똑같은 오류가 발생합니다. 하지만 우리는 `p_p` 가 가리키는 것이 `Parent` 객체가 아니라 `Child` 객체라는 사실을 알고 있습니다. 그렇기 때문에 비록 `Parent *` 포인터를 다운 캐스팅 함에도 불구하고 `p_p` 가 실제로는 `Child` 객체를 가리키기 때문에

```cpp-formatted
Child* p_c = p_p;
```



를 해도 전혀 문제가 없습니다. 이를 위해서는 아래 처럼 강제적으로 타입 변환을 하면 됩니다.

```cpp-formatted
Child* p_c = static_cast<Child*>(p_p);
```



비록 약간은 위험하지만 (만일 `p_p` 가 사실은 `Child` 객체를 가리키지 않는다면?) 컴파일 오류를 발생시키지 않고 성공적으로 컴파일 할 수 있습니다. 그렇다면 만일 `p_p` 가 사실 `Parent` 객체를 가리키는데 강제적으로 타입 변환을 해서 `what` 을 실행한다면 어떨까요?

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << s << endl; }
};
class Child : public Parent {
  string s;

 public:
  Child() : s("자식"), Parent() { cout << "자식 클래스" << endl; }

  void what() { cout << s << endl; }
};
int main() {
  Parent p;
  Child c;

  cout << "=== 포인터 버전 ===" << endl;
  Parent* p_p = &p;

  Child* p_c = static_cast<Child*>(p_p);
  p_c->what();

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F27029238533880F714CFAC)



와 같은 런타임 오류가 발생하게 됩니다.


이러한 강제적으로 다운 캐스팅을 하는 경우, 컴파일 타임에서 오류를 찾아내기 매우 힘들기 때문에 다운 캐스팅은 작동이 보장되지 않는 한매우매우 추천하지 않는 바입니다.





###  EmployeeList 다시 보기




자, 그럼 이제 위에서 다룬 내용을 가지고 EmployeeList 를 어떻게 하면 좀 더 간단하게 만들 수 있을 지 생각해봅시다.
```cpp-formatted
class EmployeeList {
  int alloc_employee;  // 할당한 총 직원 수

  int current_employee;  // 현재 직원 수
  int current_manager;   // 현재 매니저 수

  Employee **employee_list;  // 직원 데이터
  Manager **manager_list;    // 매니저 데이터
  // ...
```

위와 같은 구성에서 가장 문제가 되는 것이 각 클래스 별로 데이터를 따로 보관해야 된다는 것입니다. 즉 `Employee` 들은 `Employee *` 가 가리켜야 하고, `Manager` 들은 `Manager *` 가 가리켜야 합니다. 만일 무한 상사에서 클래스 하나를 더 추가해달라고 연락이 왔다간 때릴 지도 모르겠지요.


하지만, 한 가지 위에서 배운 사실은, 업 캐스팅은 매우 자유롭게 수행될 수 있다는 점입니다. 즉, `Employee *` 가 `Manager` 객체를 가리켜도 별 문제가 없다는 것이지요. 그렇다면 `manager_list` 를 그냥 지워 버리고, `employee_list` 가 `Employee, Manager` 상관없이 가리키게 해도 될까요? 그러면 참 좋겠지만 다음과 같은 문제점이 있습니다.


```cpp-formatted
void print_employee_info() {
  int total_pay = 0;
  for (int i = 0; i < current_employee; i++) {
    employee_list[i]->print_info();
    total_pay += employee_list[i]->calculate_pay();
  }
  ...
```



바로 여기서, `employee_list[i]->print_info()` 를 하게 되면 무조건 `Employee` 클래스의 `print_info` 함수가 호출된다는 것입니다. 왜냐하면 위에서도 이야기 하였듯이, `employee_list[i]` 는 `Employee` 객체를 가리키는 포인터 이기 때문에 자신이 가리키는 객체가 `Employee` 객체라고 생각합니다.


하지만 우리는 `Manager` 객체와 `Employee` 객체 모두 `Employee*` 가 가리키도록 하였으므로, 만일 `employee_list[i]` 가 가리키는 것이 `Manager` 객체 일 때, Manager 의 `print_info` 함수가 아니라 `Employee` 의 `print_info` 함수가 호출되서 다른 결과를 냅니다.

마찬가지로 `calculate_pay` 함수도 `Manager` 의 `calculate_pay` 가 호출 되어야 하는데 `Employee` 의 `calculate_pay` 가 호출되어서 (월급이 더 적게나오는 ㅠㅠ) 틀린 결과가 나옵니다. 나쁜 회사였으면 환영할 일이였겠지만 착한 우리의 입장에선 이 문제를 꼭 해결해야 합니다.


실제로,


```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Employee {
 protected:
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)

 public:
  Employee(string name, int age, string position, int rank)
      : name(name), age(age), position(position), rank(rank) {}

  // 복사 생성자
  Employee(const Employee& employee) {
    name = employee.name;
    age = employee.age;
    position = employee.position;
    rank = employee.rank;
  }

  // 디폴트 생성자
  Employee() {}

  void print_info() {
    cout << name << " (" << position << " , " << age << ") ==> "
         << calculate_pay() << "만원" << endl;
  }
  int calculate_pay() { return 200 + rank * 50; }
};

class Manager : public Employee {
  int year_of_service;

 public:
  Manager(string name, int age, string position, int rank, int year_of_service)
      : year_of_service(year_of_service), Employee(name, age, position, rank) {}

  // 복사 생성자
  Manager(const Manager& manager)
      : Employee(manager.name, manager.age, manager.position, manager.rank) {
    year_of_service = manager.year_of_service;
  }

  // 디폴트 생성자
  Manager() : Employee() {}

  int calculate_pay() { return 200 + rank * 50 + 5 * year_of_service; }
  void print_info() {
    cout << name << " (" << position << " , " << age << ", " << year_of_service
         << "년차) ==> " << calculate_pay() << "만원" << endl;
  }
};
class EmployeeList {
  int alloc_employee;        // 할당한 총 직원 수
  int current_employee;      // 현재 직원 수
  Employee** employee_list;  // 직원 데이터

 public:
  EmployeeList(int alloc_employee) : alloc_employee(alloc_employee) {
    employee_list = new Employee*[alloc_employee];

    current_employee = 0;
  }
  void add_employee(Employee* employee) {
    // 사실 current_employee 보다 alloc_employee 가 더
    // 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
    // 최대한 단순하게 생각해서 alloc_employee 는
    // 언제나 current_employee 보다 크다고 생각한다.
    // (즉 할당된 크기는 현재 총 직원수 보다 많음)
    employee_list[current_employee] = employee;
    current_employee++;
  }
  int current_employee_num() { return current_employee; }

  void print_employee_info() {
    int total_pay = 0;
    for (int i = 0; i < current_employee; i++) {
      employee_list[i]->print_info();
      total_pay += employee_list[i]->calculate_pay();
    }
    cout << "총 비용 : " << total_pay << "만원 " << endl;
  }
  ~EmployeeList() {
    for (int i = 0; i < current_employee; i++) {
      delete employee_list[i];
    }
    delete[] employee_list;
  }
};
int main() {
  EmployeeList emp_list(10);
  emp_list.add_employee(new Employee("노홍철", 34, "평사원", 1));
  emp_list.add_employee(new Employee("하하", 34, "평사원", 1));
  emp_list.add_employee(new Manager("유재석", 41, "부장", 7, 12));
  emp_list.add_employee(new Manager("정준하", 43, "과장", 4, 15));
  emp_list.add_employee(new Manager("박명수", 43, "차장", 5, 13));
  emp_list.add_employee(new Employee("정형돈", 36, "대리", 2));
  emp_list.add_employee(new Employee("길", 36, "인턴", -2));
  emp_list.print_employee_info();
  return 0;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2276DA3F53389A592E48BC)



와 같이 전부다 `Employee` 의 `print_info` 와 `calculate_pay` 함수가 호출되서 원래 결과와 달라집니다.


그런데 놀랍게도 이러한 문제를 5초 만에 해결할 수 있는 방법이 있습니다.



###  virtual 키워드




`EmployeeList` 문제를 해결하기 전에 좀 더 간단한 예시로 살펴보겠습니다.
```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  virtual void what() { cout << s << endl; }
};
class Child : public Parent {
  string s;

 public:
  Child() : s("자식"), Parent() { cout << "자식 클래스" << endl; }

  void what() { cout << s << endl; }
};
int main() {
  Parent p;
  Child c;

  Parent* p_c = &c;
  Parent* p_p = &p;

  cout << " == 실제 객체는 Parent == " << endl;
  p_p->what();

  cout << " == 실제 객체는 Child == " << endl;
  p_c->what();

  return 0;
}
```



성공적으로 컴파일 하였다면
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F261B5D4B53389F6D0C4748)



어라? 위 결과를 보셨다면 놀라움을 금치 못하셨을 것입니다.
```cpp-formatted
Parent* p_c = &c;
Parent* p_p = &p;

cout << " == 실제 객체는 Parent == " << endl;
p_p->what();

cout << " == 실제 객체는 Child == " << endl;
p_c->what();
```



분명히 여기서 `p_p` 와 `p_c` 모두 `Parent` 객체를 가리키는 포인터 입니다. 따라서, `p_p->what()` 와 `p_c->what()` 을 하면 모두 `Parent` 객체의 `what()` 함수가 실행되서 둘 다 '부모' 라고 출력이 되어야만 했습니다.

그런데, 놀랍게도, 실제 `p_p` 와 `p_c` 가 무엇과 결합해 있는지 아는 것 처럼 (`p_p` 는 `Parent` 객체를 가리키고, `p_c` 는 `Child` 객체를 가리킴) 이에 따른 적절한 `what` 함수를 호출해준 것입니다.


이와 같은 일이 가능해진 이유는 바로;

```cpp-formatted
class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  virtualvoid what() { cout << s << endl; }
};
```



이 `virtual` 키워드 하나 때문입니다. 이 `virtual` 키워드는, 다음과 같은 역할을 합니다.

```cpp-formatted
p_c->what();
```



위 코드를 실행시에 (런타임), 컴퓨터 입장에서;

```info

"흠, p_c 는 Parent 포인터니까 Parent 의 what() 을 실행해야지"
"어 근데 what 이 virtual 이네?"

"잠깐. 이거 실제 Parent 객체 맞어? 아니네 Child 객체네"
"그럼 Child 의 what 을 실행해야지"
```



반면에

```cpp-formatted
p_p->what();
```



였을 경우에는

```info

"흠, p_c 는 Parent 포인터니까 Parent 의 what() 을 실행해야지"
"어 근데 what 이 virtual 이네?"

"잠깐. 이거 실제 Parent 객체 맞어? 어 맞네."
"Parent 의 what 을 실행하자"
```



이렇게 컴파일 시에 어떤 함수가 실행될 지 정해지지 않고 런타임 시에 정해지는 일을 가리켜서 **동적 바인딩(dynamic binding)** 이라고 부릅니다. 즉,

```cpp-formatted
p_c->what();
```



에서 `Child` 의 `what` 을 실행할지, `Parent` 의 `what` 을 실행하지 결정은 런타임에 이루어지게 됩니다. 물론 위 코드에선 컴파일 시에 무조건 `p_c->what()` 이 `Child` 의 `what` 이 실행되도록 정해진 거 아니냐고 물을 수 있지만 다음과 같은 상황을 생각해보세요.

```cpp-formatted
// i 는 사용자로부터 입력받는 변수
if (i == 1) {
  p_p = &c;
} else {
  p_p = &p;
}
p_p->what();
```



이렇게 된다면 `p_p->what()` 이 어떤 `what` 일지에는 런타임에 정해지겠지요? 물론 동적 바인딩의 반대말로 **정적 바인딩(static binding)** 이란 말도 있습니다. 이는 컴파일 타임에 어떤 함수가 호출될 지 정해지는 것으로 여태까지 여러분이 알고 오셨던 함수에 해당합니다.

덧붙여서, `virtual` 키워드가 붙은 함수를 **가상 함수(virtual function)** 라고 부릅니다.


이제 여러분은 그동안 골머리를 썩여왔던 `EmployeeList` 문제도 해결할 수 있게 되었습니다. 단순히 `Employee` 클래스의 `calculate_pay` 함수와 `print_info` 함수 앞에 `virtual` 만 붙여주면 깔끔하게 정리 되지요.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Employee {
 protected:
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)

 public:
  Employee(string name, int age, string position, int rank)
      : name(name), age(age), position(position), rank(rank) {}

  // 복사 생성자
  Employee(const Employee& employee) {
    name = employee.name;
    age = employee.age;
    position = employee.position;
    rank = employee.rank;
  }

  // 디폴트 생성자
  Employee() {}

  virtualvoid print_info() {
    cout << name << " (" << position << " , " << age << ") ==> "
         << calculate_pay() << "만원" << endl;
  }
  virtualint calculate_pay() { return 200 + rank * 50; }
};

class Manager : public Employee {
  int year_of_service;

 public:
  Manager(string name, int age, string position, int rank, int year_of_service)
      : year_of_service(year_of_service), Employee(name, age, position, rank) {}

  int calculate_pay() { return 200 + rank * 50 + 5 * year_of_service; }
  void print_info() {
    cout << name << " (" << position << " , " << age << ", " << year_of_service
         << "년차) ==> " << calculate_pay() << "만원" << endl;
  }
};
class EmployeeList {
  int alloc_employee;        // 할당한 총 직원 수
  int current_employee;      // 현재 직원 수
  Employee** employee_list;  // 직원 데이터

 public:
  EmployeeList(int alloc_employee) : alloc_employee(alloc_employee) {
    employee_list = new Employee*[alloc_employee];
    current_employee = 0;
  }
  void add_employee(Employee* employee) {
    // 사실 current_employee 보다 alloc_employee 가 더
    // 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
    // 최대한 단순하게 생각해서 alloc_employee 는
    // 언제나 current_employee 보다 크다고 생각한다.
    // (즉 할당된 크기는 현재 총 직원수 보다 많음)
    employee_list[current_employee] = employee;
    current_employee++;
  }
  int current_employee_num() { return current_employee; }

  void print_employee_info() {
    int total_pay = 0;
    for (int i = 0; i < current_employee; i++) {
      employee_list[i]->print_info();
      total_pay += employee_list[i]->calculate_pay();
    }

    cout << "총 비용 : " << total_pay << "만원 " << endl;
  }
  ~EmployeeList() {
    for (int i = 0; i < current_employee; i++) {
      delete employee_list[i];
    }
    delete[] employee_list;
  }
};
int main() {
  EmployeeList emp_list(10);
  emp_list.add_employee(new Employee("노홍철", 34, "평사원", 1));
  emp_list.add_employee(new Employee("하하", 34, "평사원", 1));

  emp_list.add_employee(new Manager("유재석", 41, "부장", 7, 12));
  emp_list.add_employee(new Manager("정준하", 43, "과장", 4, 15));
  emp_list.add_employee(new Manager("박명수", 43, "차장", 5, 13));
  emp_list.add_employee(new Employee("정형돈", 36, "대리", 2));
  emp_list.add_employee(new Employee("길", 36, "인턴", -2));
  emp_list.print_employee_info();
  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F240AB8345338A6BF1CB8DE)



와 같이 비록 `Employee*` 가 가리키고 있음에도 불구하고 `Manager` 면 `Manager` 의 함수를, `Employee` 면 `Employee` 의 함수를 잘 호출하고 있음을 알 수 있습니다. 물론 바뀐 것은 단 두 단어. `virtual` 키워들을 `Employee` 의 함수들 앞에 추가해놓은 것 뿐이지요.

```cpp-formatted
employee_list[i]->print_info();
total_pay += employee_list[i]->calculate_pay();
```



이 두 부분은 `employee_list[i]` 가 `Employee` 냐 `Manager` 에 따라서 다르게 동작하게 됩니다. 이렇게 같은 `print_info` 함수를 호출했음에도 불구하고 어떤 경우는 `Employee` 의 것이, 어떤 경우는 `Manager` 의 것이 호출되는 일; 즉 하나의 메소드를 호출했음에도 불구하고 여러가지 다른 작업들을 하는 것을 바로 **다형성(polymorphism)** 이라고 부릅니다.


참고로, 다형성을 뜻하는 영어 단어인 *polymorphism* 은,여러개를 의미하는 그리스어 'poly' 와, 모습, 모양을 뜻하는 그리스어 'morphism' 에서 온 단어로 '여러가지 형태' 라는 의미 입니다.


자 그러면 이번 강좌는 여기에서 마치도록 하겠습니다. 아마도 `virtual` 키워드를 처음 접했더라면 머가 어떻게 되는지 많이 헷갈릴 수 있는데 꼭 여러번 테스트 프로그램을 만들어보아서 확실히 이해하고 넘어가도록 합시다 :)


### 생각해보기

#### 문제 1

그렇다면 프로그램 내부적으로 `virtual` 함수들은 어떻게 처리될까요? 즉, 이 포인터가 어떠한 객체를 가리키는지 어떻게 알 수 있을까요? (난이도 : 上)

##@ chewing-cpp-end
Link :  209
2014-03-30 10:30
----------------
title : 씹어먹는 C++ - <6 - 1. C++ 표준 문자열 & 부모의 것을 물려쓰자 - 상속>
cat_title: 6 - 1. C++ 표준 문자열 & 부모의 것을 물려쓰자 - 상속
next_page : 210
publish_date : 2014-03-30 10:30
--------------


이번 강좌에서는

* C++ 표준 문자열 (string)
* 상속 (inheritance)
* 오버라이딩(overriding)
* `protected` 키워드

에 대해서 배웁니다.

![](/img/ChewingCpplogo.png)


안녕하세요 여러분!! 제가 그간 많이 바빠서 강좌를 진행하지 못하고 있었는데요, 요새 여유가 조금 생겨서 다시 C++ 강좌를 진행할 수 있게 되었습니다. 오랫동안 기다리셨던 분들에게는 정말로 죄송하다고 전하고 싶네요. 이전 강좌까지 클래스와 연산자 오버로딩에 대해 배우면서 C++ 의 새로운 맛을 보았다면, 이제부터는 본격적으로 C++ 의 진한 국물을 우려내는 듯한 강좌가 될 것 같습니다.




###  표준 `string` 클래스


아마 제 강좌를 훌륭하게 따라 오신 분들이라면 지난 강좌에서 `MyString` 클래스를 만드셨던 것이 기억이 나실 것입니다. C 언어 스타일의 문자열은 여러가지 문제점들이 많기 때문에 (예를 들어 문자열의 길이를 한 번에 알 수 없고 마지막 `NULL` 문자까지 하나 하나 읽어야 된다는 든지..) 문자열을 처리할 수 있는 새로운 무언가가 계속 필요해야 했습니다.

사실 우리가 예전에 만든 `MyString` 클래스도 문자열 처리를 꽤나 훌륭하게 하지만, 실제로 속도가 매우 중요한 환경에서 그대로 쓰기에는 부족한 점이 많습니다. 하지만 많은 프로그래머들의 노력 끝에 `string` 이라는 빠르고, 안전하고 사용하기 매우 간단한 문자열 클래스가 표준으로 채택이 됩니다.

(이 `string` 에 들어가 있는 몇 가지 기술을 소개해보자면, 짧은 문자열에 대해서는 동적으로 메모리를 할당하지 않고 그냥 지역 변수로 보관을 하고, 문자열을 복사를 할 때 그 복사된 문자열의 내용이 바뀌지 않는 한 실제로 데이터를 복사하는 것이 아니라 원래 문자열을 가리키기만 한다 등등 속도를 향상시키기 위한 여러 노력이 접목되어 있습니다) \sidenote{물론 이는 string 구현 방식에 따라 다릅니다. 여러분이 어떤 라이브러리를 사용함에 따라 아닐 수도 있습니다.}


```cpp-formatted
#include <iostream>
#include <string>
using namespace std;  // 표준이므로 std 안에 string 이 정의되어 있습니다.

int main() {
  string s = "abc";

  cout << s << endl;

  return 0;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F227DC344533673EB246BCA)



와 같이 `abc` 가 잘 출력됨을 알 수 있습니다.



일단 기본적으로 "abc" 는 컴파일러 상에서는 C 형식 문자열로 인식됩니다. 즉, 위 문장은 `string` 클래스의 인자를 `const char *` 로 받는 생성자를 호출한 것으로 볼 수 있겠지요.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

int main() {
  string s = "abc";
  string t = "def";

  cout << s << " 의 길이 : " << s.length() << endl;
  cout << s << " 뒤에 " << t << " 를 붙이면 : " << s + t << endl;

  if (s == s2) {
    cout << s << " 와 " << s2 << " 는 같다 " << endl;
  }
  if (s != t) {
    cout << s << " 와 " << t << " 는 다르다 " << endl;
  }
  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F231DF44253367A122A0C1F)



위에는 몇 가지 `string` 클래스의 기능들을 간단히 보여드린 것입니다. 예를 들어 문자열의 길이를 출력하는 `length` 함수라던지, 연산자 오버로딩을 사용해서 `+` 연산자가 실제로 문자열을 결합시키는 함수로 사용되고 있습니다.


특히 편리한 점으로 C 형식 문자열이였을 경우 문자열을 비교하기 위해서 `strcmp` 함수를 사용했어야 하고,

```cpp-formatted
if (s == s2) cout << s << " 와 " << s2 << " 는 같다 " << endl;
if (s != t) cout << s << " 와 " << t << " 는 다르다 " << endl;
```



와 같이 `==` 나 `!=` 로 비교하는 것이 불가능 하였습니다. (왜냐하면 이는 문자열의 주소값을 비교하는 것이였으니까요! - 혹시 기억이 잘 나지 않는 분들은 [이 강좌를 다시 보고 오세요](http://itguru.tistory.com/33)`!)` 하지만 이 `string` 클래스는 `==` 와 `!=` 연산자들을 모두 오버로딩해서 제대로 비교를 수행합니다. 뿐만 아니라 크기 비교 `>=, <=` 등도 제대로 수행이 되지요.


사실 `string` 에서 제공하는 함수와 기능들인 제가 소개한 것 말고도 엄청나게 많아서 한 강좌에 다 채워놓지 못할 정도 입니다. 위에서는 가장 많이 쓰는 기능만 소개해놓았고 모든 정보를 원하신다면 [http://en.cppreference.com/w/cpp/string/basic_string](http://en.cppreference.com/w/cpp/string/basic_string)를 참조하시면 됩니다. 여기를 보면 `length` 함수 말고도, 문자열 사이에 문자열을 삽입하는 `insert` 함수나, 특정 위치를 지우는 `erase` 나 문자열을 치환하는 `replace` 등등 수 많은 유용한 함수들이 많습니다.


###  사원 관리 프로그램


자, 이제 여러분은 한 회사의 사원 관리 프로그램을 만들어달라는 의뢰를 받게 됩니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F2705183A533688521A502C)

우리가 만들어야 할 프로그램의 목적은 회사의 사원들의 월급을 계산해서 한달에 총 얼마나 되는 돈을 월급으로 지출해야 하는지 알려주는 단순한 프로그램 입니다. 그렇다면 일단 여러분은 각 사원들에 정보를 클래스로 만들어서 데이터를 보관하도록 하겠지요. 사원들의 필요한 데이터는 이름, 나이, 직책과 직책의 순위에 해당하는 숫자값 (예를 들어 평사원이면 `1,` 대리면 2 이런 식으로) 정도 입니다. 이를 바탕으로 간단히 클래스를 구성해본다면 다음과 같이 짤 수 있을 것입니다.
```cpp-formatted
class Employee {
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)

 public:
  Employee(string name, int age, string position, int rank)
      : name(name), age(age), position(position), rank(rank) {}

  // 복사 생성자
  Employee(const Employee& employee) {
    name = employee.name;
    age = employee.age;
    position = employee.position;
    rank = employee.rank;
  }

  // 디폴트 생성자
  Employee() {}

  void print_info() {
    cout << name << " (" << position << " , " << age << ") ==> "
         << calculate_pay() << "만원" << endl;
  }
  int calculate_pay() { return 200 + rank * 50; }
};
```

일단 저는 3 개의 생성자들을 정의해놓았는데요, 여태까지 강의를 잘 따라오신 분들은 각 생성자가 어떤식으로 동작하는지, 단번에 눈치챌 수 있으셨겠죠?


여기서 눈여겨볼 점은 `calculate_pay` 함수 인데, 기본급 200 에 직위에 따라 50 을 곱해서 더 받도록 하였습니다. (아 이건 물론 제가 임의로 정한것이고 일반적인 회사에서 이렇게 한다고 주장하는 것이 아닙니다 ㅎ)


자 이제 각각의 `Employee` 클래스를 만들었으니, 이 `Employee` 객체들을 관리할 수 있는 무언가가 있어야 겠지요? 물론 단순히 배열을 사용해서 사원들을 관리할 수 있겠지만, 그렇게 된다면 굉장히 불편하겠지요? 그래서 저는 `EmployeeList` 클래스를 만들어서 간단하게 처리하도록 할 것입니다.


일단 우리는 다음과 같은 멤버 변수들을 이용해서 사원 데이터를 처리할 것입니다.

```cpp-formatted
int alloc_employee;        // 할당한 총 직원 수
int current_employee;      // 현재 직원 수
Employee **employee_list;  // 직원 데이터
```

`MyString` 을 만들었던 기억을 되살려보자면, 언제나 동적으로 데이터를 할당하는 것을 처리하기 위해서는 두 개의 변수가 필요 했는데, 하나는 현재 할당된 총 크기고, 다른 하나는 그 중에서 실제로 사용하고 있는 양이지요. 이렇게 해야지만 할당된 크기 보다 더 많은 양을 실수로 사용하는 것을 막을 수 있습니다. 따라서 우리도 `alloc_employee` 가 할당된 크기를 알려주는 배열이고, `current_employee` 는 현재 `employee_list` 에 등록된 사원 수라고 볼 수 있지요.


`employee_list` 가 `Employee**` 타입으로 되어 있는 이유는, 우리가 이를 `Employee*` 객체를 담는 배열로 사용할 것이기 때문입니다. 그렇다면 `EmployeeList` 클래스의 생성자는 아래와 같이 쉽게 구성할 수 있겠지요.

```cpp-formatted
EmployeeList(int alloc_employee) : alloc_employee(alloc_employee) {
  employee_list = new Employee*[alloc_employee];
  current_employee = 0;
}
```



그리고 사원을 추가하는 함수는 아래처럼 단순하게 구성할 수 있습니다.

```cpp-formatted
void add_employee(Employee* employee) {
  // 사실 current_employee 보다 alloc_employee 가 더
  // 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
  // 최대한 단순하게 생각해서 alloc_employee 는
  // 언제나 current_employee 보다 크다고 생각한다.
  // (즉 할당된 크기는 현재 총 직원수 보다 많음)
  employee_list[current_employee] = employee;
  current_employee++;
}
```

물론 위 주석에도 잘 설명되어 있듯이, `alloc_employee` 보다 `current_employee` 가 더 많아진다면 새로 재할당을 하고 데이터를 모두 복사해야겠지만 (여러분의 코드는 그렇게 쓰세요!) 제가 주목하고 싶은 부분은 여기가 아니라서 그냥 위 처럼 간단하게 생각합시다.


그리고 나머지 짜잘한 함수들을 완성해준다면 다음과 같이 `EmployeeList` 클래스를 구성할 수 있게 됩니다.

```cpp-formatted
class EmployeeList {
  int alloc_employee;        // 할당한 총 직원 수
  int current_employee;      // 현재 직원 수
  Employee** employee_list;  // 직원 데이터

 public:
  EmployeeList(int alloc_employee) : alloc_employee(alloc_employee) {
    employee_list = new Employee*[alloc_employee];
    current_employee = 0;
  }
  void add_employee(Employee* employee) {
    // 사실 current_employee 보다 alloc_employee 가 더
    // 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
    // 최대한 단순하게 생각해서 alloc_employee 는
    // 언제나 current_employee 보다 크다고 생각한다.
    // (즉 할당된 크기는 현재 총 직원수 보다 많음)
    employee_list[current_employee] = employee;
    current_employee++;
  }
  int current_employee_num() { return current_employee; }

  void print_employee_info() {
    int total_pay = 0;
    for (int i = 0; i < current_employee; i++) {
      employee_list[i]->print_info();
      total_pay += employee_list[i]->calculate_pay();
    }

    cout << "총 비용 : " << total_pay << "만원 " << endl;
  }
  ~EmployeeList() {
    for (int i = 0; i < current_employee; i++) {
      delete employee_list[i];
    }
    delete[] employee_list;
  }
};
```



그렇다면 실제 프로그램을 구성해볼까요. 현재 무한 상사에는 다음과 같은 사원들이 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F221DE0355336881A25AA62)

따라서 전체 코드는 다음과 같습니다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Employee {
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)

 public:
  Employee(string name, int age, string position, int rank)
      : name(name), age(age), position(position), rank(rank) {}

  // 복사 생성자
  Employee(const Employee& employee) {
    name = employee.name;
    age = employee.age;
    position = employee.position;
    rank = employee.rank;
  }

  // 디폴트 생성자
  Employee() {}

  void print_info() {
    cout << name << " (" << position << " , " << age << ") ==> "
         << calculate_pay() << "만원" << endl;
  }
  int calculate_pay() { return 200 + rank * 50; }
};

class EmployeeList {
  int alloc_employee;        // 할당한 총 직원 수
  int current_employee;      // 현재 직원 수
  Employee** employee_list;  // 직원 데이터

 public:
  EmployeeList(int alloc_employee) : alloc_employee(alloc_employee) {
    employee_list = new Employee*[alloc_employee];
    current_employee = 0;
  }
  void add_employee(Employee* employee) {
    // 사실 current_employee 보다 alloc_employee 가 더
    // 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
    // 최대한 단순하게 생각해서 alloc_employee 는
    // 언제나 current_employee 보다 크다고 생각한다.
    // (즉 할당된 크기는 현재 총 직원수 보다 많음)
    employee_list[current_employee] = employee;
    current_employee++;
  }
  int current_employee_num() { return current_employee; }

  void print_employee_info() {
    int total_pay = 0;
    for (int i = 0; i < current_employee; i++) {
      employee_list[i]->print_info();
      total_pay += employee_list[i]->calculate_pay();
    }

    cout << "총 비용 : " << total_pay << "만원 " << endl;
  }
  ~EmployeeList() {
    for (int i = 0; i < current_employee; i++) {
      delete employee_list[i];
    }
    delete[] employee_list;
  }
};
int main() {
  EmployeeList emp_list(10);
  emp_list.add_employee(new Employee("노홍철", 34, "평사원", 1));
  emp_list.add_employee(new Employee("하하", 34, "평사원", 1));

  emp_list.add_employee(new Employee("유재석", 41, "부장", 7));
  emp_list.add_employee(new Employee("정준하", 43, "과장", 4));
  emp_list.add_employee(new Employee("박명수", 43, "차장", 5));
  emp_list.add_employee(new Employee("정형돈", 36, "대리", 2));
  emp_list.add_employee(new Employee("길", 36, "인턴", -2));
  emp_list.print_employee_info();
  return 0;
}
```

성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2708C43A53371EB53A0963)



와 같이 잘 실행된다는 것을 볼 수 있습니다.


아 이렇게 사원 관리 프로그램을 잘 만들어서 제출해달라는 찰나, 무한 상사로 부터 연락을 한 통 받습니다. 차장 이상 급들은 관리데이터에 근속 년수를 포함시켜서 월급에 추가해달라고 말이지요. 그래서 저는 울며가며 겨자먹기로 `Manager` 클래스를 추가하였습니다. 사실 `Employee` 클래스랑 거의 똑같지만, 어쩔 수 없지요. 더 짜증나는 부분은 `EmployeeList` 클래스에서도 `Employee` 와 `Manager` 를 따로 처리해야 된다는 점입니다. 아무튼, 일단 `Manager` 클래스를 구성해봅시다.

```cpp-formatted
class Manager {
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)
  int year_of_service;

 public:
  Manager(string name, int age, string position, int rank, int year_of_service)
      : year_of_service(year_of_service),
        name(name),
        age(age),
        position(position),
        rank(rank) {}

  // 복사 생성자
  Manager(const Manager& manager) {
    name = manager.name;
    age = manager.age;
    position = manager.position;
    rank = manager.rank;
    year_of_service = manager.year_of_service;
  }

  // 디폴트 생성자
  Manager() {}

  int calculate_pay() { return 200 + rank * 50 + 5 * year_of_service; }
  void print_info() {
    cout << name << " (" << position << " , " << age << ", " << year_of_service
         << "년차) ==> " << calculate_pay() << "만원" << endl;
  }
};
```



기존의 `Employee` 클래스와 다 똑같고, `int year_of_service` 하나만 추가된 것을 볼 수 있습니다. 물론 월급을 계산하는 `calculate_pay` 함수나, 정보를 출력하는 `print_info` 함수가 약간 바뀌게 되었습니다. 이번에는 `EmployeeList` 클래스를 살펴보도록 합시다.


당연하게도 `Employee` 배열과 `Manager` 배열을 따로 만들어야만 합니다. 따라서 각 배열에 사용하고 있는 크기를 나타낼 변수도 따로 지정해야만 하겠지요. 따라서

```cpp-formatted
int alloc_employee;  // 할당한 총 직원 수

int current_employee;  // 현재 직원 수
int current_manager;   // 현재 매니저 수

Employee **employee_list;  // 직원 데이터
Manager **manager_list;    // 매니저 데이터
```

와 같이 바꿔주어야 합니다. (여기서 또한 간단하게 처리하기 위해서 각 배열에 할당한 크기는 모두 동일하다고 생각합니다). 그리고 무엇보다도 `EmployeeList` 클래스의 나머지 부분을 바꿔주면

```cpp-formatted
class EmployeeList {
  int alloc_employee;  // 할당한 총 직원 수

  int current_employee;  // 현재 직원 수
  int current_manager;   // 현재 매니저 수

  Employee** employee_list;  // 직원 데이터
  Manager** manager_list;    // 매니저 데이터

 public:
  EmployeeList(int alloc_employee) : alloc_employee(alloc_employee) {
    employee_list = new Employee*[alloc_employee];
    manager_list = new Manager*[alloc_employee];

    current_employee = 0;
    current_manager = 0;
  }
  void add_employee(Employee* employee) {
    // 사실 current_employee 보다 alloc_employee 가 더
    // 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
    // 최대한 단순하게 생각해서 alloc_employee 는
    // 언제나 current_employee 보다 크다고 생각한다.
    // (즉 할당된 크기는 현재 총 직원수 보다 많음)
    employee_list[current_employee] = employee;
    current_employee++;
  }
  void add_manager(Manager* manager) {
    manager_list[current_manager] = manager;
    current_manager++;
  }
  int current_employee_num() { return current_employee + current_manager; }

  void print_employee_info() {
    int total_pay = 0;
    for (int i = 0; i < current_employee; i++) {
      employee_list[i]->print_info();
      total_pay += employee_list[i]->calculate_pay();
    }
    for (int i = 0; i < current_manager; i++) {
      manager_list[i]->print_info();
      total_pay += manager_list[i]->calculate_pay();
    }
    cout << "총 비용 : " << total_pay << "만원 " << endl;
  }
  ~EmployeeList() {
    for (int i = 0; i < current_employee; i++) {
      delete employee_list[i];
    }
    for (int i = 0; i < current_manager; i++) {
      delete manager_list[i];
    }
    delete[] employee_list;
    delete[] manager_list;
  }
};
```

와 같이 구성할 수 있습니다. 두 개의 배열을 관리하기 때문에 똑같은 코드를 변수 이름만 바꿔서 한 번 더 써야 합니다. 상당히 귀찮기 다름 없지요. 이를 바탕으로 전체 코드를 구성해보면 다음과 같습니다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Employee {
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)

 public:
  Employee(string name, int age, string position, int rank)
      : name(name), age(age), position(position), rank(rank) {}

  // 복사 생성자
  Employee(const Employee& employee) {
    name = employee.name;
    age = employee.age;
    position = employee.position;
    rank = employee.rank;
  }

  // 디폴트 생성자
  Employee() {}

  void print_info() {
    cout << name << " (" << position << " , " << age << ") ==> "
         << calculate_pay() << "만원" << endl;
  }
  int calculate_pay() { return 200 + rank * 50; }
};

class Manager {
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)
  int year_of_service;

 public:
  Manager(string name, int age, string position, int rank, int year_of_service)
      : year_of_service(year_of_service),
        name(name),
        age(age),
        position(position),
        rank(rank) {}

  // 복사 생성자
  Manager(const Manager& manager) {
    name = manager.name;
    age = manager.age;
    position = manager.position;
    rank = manager.rank;
    year_of_service = manager.year_of_service;
  }

  // 디폴트 생성자
  Manager() {}

  int calculate_pay() { return 200 + rank * 50 + 5 * year_of_service; }
  void print_info() {
    cout << name << " (" << position << " , " << age << ", " << year_of_service
         << "년차) ==> " << calculate_pay() << "만원" << endl;
  }
};
class EmployeeList {
  int alloc_employee;  // 할당한 총 직원 수

  int current_employee;  // 현재 직원 수
  int current_manager;   // 현재 매니저 수

  Employee** employee_list;  // 직원 데이터
  Manager** manager_list;    // 매니저 데이터

 public:
  EmployeeList(int alloc_employee) : alloc_employee(alloc_employee) {
    employee_list = new Employee*[alloc_employee];
    manager_list = new Manager*[alloc_employee];

    current_employee = 0;
    current_manager = 0;
  }
  void add_employee(Employee* employee) {
    // 사실 current_employee 보다 alloc_employee 가 더
    // 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
    // 최대한 단순하게 생각해서 alloc_employee 는
    // 언제나 current_employee 보다 크다고 생각한다.
    // (즉 할당된 크기는 현재 총 직원수 보다 많음)
    employee_list[current_employee] = employee;
    current_employee++;
  }
  void add_manager(Manager* manager) {
    manager_list[current_manager] = manager;
    current_manager++;
  }
  int current_employee_num() { return current_employee + current_manager; }

  void print_employee_info() {
    int total_pay = 0;
    for (int i = 0; i < current_employee; i++) {
      employee_list[i]->print_info();
      total_pay += employee_list[i]->calculate_pay();
    }
    for (int i = 0; i < current_manager; i++) {
      manager_list[i]->print_info();
      total_pay += manager_list[i]->calculate_pay();
    }
    cout << "총 비용 : " << total_pay << "만원 " << endl;
  }
  ~EmployeeList() {
    for (int i = 0; i < current_employee; i++) {
      delete employee_list[i];
    }
    for (int i = 0; i < current_manager; i++) {
      delete manager_list[i];
    }
    delete[] employee_list;
    delete[] manager_list;
  }
};
int main() {
  EmployeeList emp_list(10);
  emp_list.add_employee(new Employee("노홍철", 34, "평사원", 1));
  emp_list.add_employee(new Employee("하하", 34, "평사원", 1));

  emp_list.add_manager(new Manager("유재석", 41, "부장", 7, 12));
  emp_list.add_manager(new Manager("정준하", 43, "과장", 4, 15));
  emp_list.add_manager(new Manager("박명수", 43, "차장", 5, 13));
  emp_list.add_employee(new Employee("정형돈", 36, "대리", 2));
  emp_list.add_employee(new Employee("길", 36, "인턴", -2));
  emp_list.print_employee_info();
  return 0;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F27672939533765960CBCD8)




와 같이 잘 실행됩니다.



###  상속 (Inheritance)


여러분도 느꼈겠지만, `Manager` 클래스를 추가하면서 Ctrl + C, Ctrl + V 신공을 참 여러번 반복한다고 느꼈을 것입니다. 이게 어쩔 수 없는 이유가 `Manager` 의 코드 자체가 `Employee` 의 대부분을 포함하고 있기 때문이지요.그런데 놀랍게도 C++ 에서는 이와 같은 일을 가능토록 해줍니다. 바로 '상속' 이라는 것을 통해 말이지요.

사실 상속이라는 단어 속에 무언가를 '물려' 받아서 사용한다는 의미가 있습니다. 즉C++ 에서 상속을 통해 다른 클래스의 정보를 물려 받아서 사용할 수 있습니 C++ 에서 상속을 통해 다른 클래스의 정보를 물려 받아서 사용할 수 있습니다.

일단은 바로 `Employee` 와 `Manager` 클래스에 적용하기 전에 간단한 클래스를 먼저 만들어서 어떻게 C++ 에서 상속이라는 기능이 사용되는지 알아보도록 하겠습니다 . 일단은 바로 `Employee` 와 `Manager` 클래스에 적용하기 전에 간단한 클래스를 먼저 만들어서 어떻게 C++ 에서 상속이라는 기능이 사용되는지 알아보도록 하겠습니다.

```cpp-formatted
class Parent

{
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << s << endl; }
};
```



위는 우리의 설명을 도와줄 부모 클래스 입니다. 그리고, 아래는 `Parent` 를 물려받은 `Child` 클래스 입니다.

```cpp-formatted
class Child : public Parent {
  string s;

 public:
  Child() : Parent(), s("자식") {
    cout << "자식 클래스" << endl;

    // Parent 에서 what() 을 물려 받았으므로
    // Child 에서 당연히 호출 가능하다
    what();
  }
};
```



가장 먼저 눈에 띄는 부분은 바로 맨 위 `class` 의 정의 부분으로

```cpp-formatted
class Child : public Parent
```



와 같이 되어 있습니다. 이는 `Child` 가 `Parent` 를 `public` 형식으로 상속을 받겠다는 의미가 됩니다. `public` 형식으로 상속받는게 무엇인지에 대해서는 좀 있다가 이야기를 하도록 하고, 아무튼 위 처럼 상속을 받은 후에 `Child` 는 다음과 같은 모습이 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F21638C3C53373CF20D7DBF)



마치 `Child` 클래스 안에 `Parent` 클래스의 코드가 그대로 들어가 있는 것 처럼 말이지요. 따라서 아래 처럼 `Child` 클래스에서 `Parent` 클래스의 `what` 함수를 호출 할 수 있게 됩니다.

```cpp-formatted
Child() : Parent(), s("자식") {
  cout << "자식 클래스" << endl;

  // Parent 에서 what() 을 물려 받았으므로
  // Child 에서 당연히 호출 가능하다
  what();
}
```



그리고 또 하나 눈여겨 봐야 할 점은 `Child` 의 생성자 호출 부분 입니다. `Child` 의 생성자는 반드시 위 처럼 초기화자 리스트에서 부모의 생성자를 호출해서 부모의 생성을 먼저 처리 한 다음에, `Child` 의 생성자가 실행되어야 합니다 (마치 부모가 태어나야지 자식들이 태어날 수 있는 것 처럼 말이지요). 따라서 아래 처럼

```cpp-formatted
Child() : Parent(), s("자식")
```

초기화 리스트에서 `Parent` 를 통해 부모의 생성자를 먼저 호출하게 됩니다. 그렇다면 아래의 코드를 살펴보도록 합시다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << s << endl; }
};
class Child : public Parent {
  string s;

 public:
  Child() : Parent(), s("자식") {
    cout << "자식 클래스" << endl;

    // Parent 에서 what() 을 물려 받았으므로
    // Child 에서 당연히 호출 가능하다
    what();
  }
};
int main() {
  cout << " === 부모 클래스 생성 ===" << endl;
  Parent p;

  cout << " === 자식 클래스 생성 ===" << endl;
  Child c;

  return 0;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F235A5E4353374D390E22FF)



와 같이 나옴을 알 수 있습니다.


일단 여러분은 부모 클래스 생성에서 왜 저런식으로 출력되는지는 당연히 알고 계실 것입니다. `Parent` 의 생성자에서 '부모 클래스' 를 출력을 하게 되지요. 그렇다면 이번에는 `Child` 객체를 만들 때 왜 저런식으로 출력되는지 살펴보도록 합시다.

```cpp-formatted
cout << " === 자식 클래스 생성 ===" << endl;
Child c;
```



일단 위와 같이 `Child` 의 인자가 없는 생성자를 호출하게 됩니다.

```cpp-formatted
Child() : Parent(), s("자식") {
  cout << "자식 클래스" << endl;

  // Parent 에서 what() 을 물려 받았으므로
  // Child 에서 당연히 호출 가능하다
  what();
}
```

이제 위에서 `Child` 의 `s` 에 "자식" 을 넣게 되고, `Child` 생성자의 내부를 실행하기 전에 `Parent` 의 생성자를 먼저 호출하게 됩니다. 따라서, '자식 클래스 생성' 바로 아래에 '자식 클래스' 가 출력하기 이전에 `Parent` 의 생성자가 호출되어서 '부모 클래스' 가 먼저 출력하게 되는 것이지요.


그렇다면 이제 `what()` 함수를 호출하는 부분을 살펴봅시다. `Child` 에서 정의되어 있지 않는 `what` 을 어떻게 호출할 수 있냐면, 당연하게도, `Parent` 의 모든 정보를 상속 받았기 때문에 `Child` 에서도 `what` 을 호출 할 수 있게 되는 것입니다.



그런데, `what` 함수를 호출했을 때, "자식" 이 아니라 "부모" 라고 출력이 되었는데, `what` 함수를 보면 `s` 의 값을 출력하도록 되어 있습니다. 이러한 일이 발생한 이유는, what 함수는 `Parent` 에 정의가 되어 있기 때문에 `Child` 의 `s` 가 아니라 `Parent` 의 `s` 가 출력되어 "부모" 라고 나오게 되는 것입니다.



그렇다면 만일 `Child` 에도 `what` 함수를 정의해주면 어떨까요.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
  string s;

 public:
  Parent() : s("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << s << endl; }
};
class Child : public Parent {
  string s;

 public:
  Child() : Parent(), s("자식") {
    cout << "자식 클래스" << endl;

    // Parent 에서 what() 을 물려 받았으므로
    // Child 에서 당연히 호출 가능하다
    what();
  }

  void what() { cout << s << endl; }
};
int main() {
  cout << " === 부모 클래스 생성 ===" << endl;
  Parent p;

  cout << " === 자식 클래스 생성 ===" << endl;
  Child c;

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F222F0242533752B9191DBF)



이번에는 `Child` 와 `Parent` 에 둘다 `what()` 함수가 정의되어 있습니다. 이 경우, `Child` 에서 아래처럼 `what` 을 호출하게 되면 무엇이 호출 될까요? 어떤 분들은 컴파일 상에서 문제가 발생하지 않을까 라고 생각할 수 도 있는데, 사실 두 함수는 같은 이름이지만 (심지어 인자들도 같지만), 다른 클래스에 정의되어 있는 것이기 때문에 다른 함수로 취급됩니다. (물론, `Child` 안에 `what` 에 두 개 정의되어 있다면 문제가 되었겠지요)


위 경우에는 `Child` 에 `what` 함수가 정의되어 있기 때문에 `Child` 의 생성자에서 `what` 을 호출 할 때 (굳이) 멀리 `Parent` 의 함수들 까지 뒤지지 않고, 바로 앞에 있는 `Child` 의 `what` 함수를 호출하게 됩니다.


이런 것을 가리켜 **오버라이딩(overriding)**이라고 합니다. 즉, `Child` 의 `what` 함수가 `Parent` 의 `what` 함수를 오버라이딩 한 것이지요.


\sidenote{간혹 함수의 오버로딩(overloading) 과 혼동하시는 분들이 많은데, 오버로딩은 같은 이름의 함수를 인자를 달리 하여 정의하는 것을 의미하는 것입니다. 상속에서의 오버라이딩과는 전혀 다른 이야기 입니다}



###  새로운 친구 protected



다음과 같은 코드를 생각해봅시다.

```cpp-formatted
class Parent {
  string parent_string;

 public:
  Parent() : parent_string("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << parent_string << endl; }
};
class Child : public Parent {
  string child_string;

 public:
  Child() : child_string("자식"), Parent() {
    cout << "자식 클래스" << endl;

    // 그렇다면 현재 private 인 Parent 의
    // parent_string 에 접근할 수 있을까?
    parent_string = "바꾸기";
  }

  void what() { cout << child_string << endl; }
};
```



만일 컴파일 하였다면 아래와 같은 컴파일 애러를 볼 수 있습니다.

```warning

error C2248: 'Parent::parent_string' : cannot access private member declared in class 'Parent'
(Parent 의 private 멤버에 접근할 수 없습니다)
```



아니 이게 도대체 무슨 말인가요! 기껏 상속 받았더니, 접근할 수 없다니요. 하지만 사실 `private` 멤버 변수들은 그 어떠한 경우에서도 자기 클래스 말고는 접근할 수 없습니다. 하지만, 종종 파생 클래스(상속 받는 클래스 - 위 경우 `Child` 클래스)에서 원래 부모의 클래스 (즉 여기서 `Parent)` 의 데이터에 직접 접근할 필요성이 있습니다. 예를 들어서 우리의 예시의 경우 `Employee` 클래스를 부모 클래스로 해서 `Manager` 클래스가 상속 받았을 때, `name` 이나 `age` 에 접근할 필요성이 있겠지요.하지만 이들은 private 으로 되어 있기 때문에 접근이 불가합니다.


다행이도 C++ 에서는 `protected` 라는 `public` 과 `private` 에 중간 위치에 있는 접근 지시자를 지원합니다. 이 키워드는, '상속받는 클래스에서는 접근 가능하고 그 외의 기타 정보는 접근 불가능' 이라고 보시면 됩니다. 실제 부모와 자식 사이로 쉽게 비유하자면

* `private` : (자식들한테 안가르쳐 주는) 부모님 자신 주민번호
* `protected` : 집 현관문 비밀번호 (자식들과 부모들만 알지만 그 외의 사람들은 접근불가)
* `public` : 집 주소 (부모 자식 뿐만이 아니라 다른 사람들도 알 수 있다)



이렇게 3 단계로 멤버의 접근 허용 범위를 지정할 수 있습니다. 그렇다면 실제로 `private` 을 `protected` 로 바꾼다면 잘 실행됨을 알 수 있습니다.

```cpp-formatted
class Parent {
 protected:
  string parent_string;

 public:
  Parent() : parent_string("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << parent_string << endl; }
};
class Child : public Parent {
  string child_string;

 public:
  Child() : Parent(), child_string("자식") {
    cout << "자식 클래스" << endl;

    // 그렇다면 현재 private 인 Parent 의
    // parent_string 에 접근할 수 있을까?
    parent_string = "바꾸기";
  }

  void what() { cout << child_string << endl; }
};
```



위 코드는 아주 잘 컴파일 됩니다.


그렇다면 이제

```cpp-formatted
class Child : public Parent
```



에서 이 `public` 키워드의 의미를 밝힐 때가 됐군요. 사실 저 키워드가 `public` 이냐 `protected` 냐 `private` 이냐에 따라 상속 받는 클래스에서 부모 클래스의 멤버들이 실제로 어떻게 작동하는지 영향을 줍니다. 이게 무슨 말이냐면;

* 만일 위처럼 `public` 형태로 상속 하였다면 부모 클래스의 접근 지시자들에 영향 없이 그대로 작동합니다. 즉 파생 클래스 입장에서 `public` 은 그대로 `public` 이고, `protected` 는 그대로 `protected` 이고, `private` 은 그대로 `private` 입니다.
* 만일 `protected` 로 상속하였다면 파생 클래스 입장에서 `public` 은 `protected` 로 바뀌고 나머지는 그대로 유지됩니다.
* 만일 `private` 으로 상속하였다면 파생 클래스 입장에서 모든 접근 지시자들이 `private` 가 됩니다.



실제로 아래와 같은 예제를 살펴봅시다.


```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Parent {
 public:
  string parent_string;

  Parent() : parent_string("부모") { cout << "부모 클래스" << endl; }

  void what() { cout << parent_string << endl; }
};
class Child : private Parent {
  string child_string;

 public:
  Child() : child_string("자식"), Parent() { cout << "자식 클래스" << endl; }

  void what() { cout << child_string << endl; }
};
int main() {
  Parent p;
  // Parent 에서는 parent_string 이 public 이므로
  // 외부에서 당연히 접근 가능하다.
  cout << p.parent_string << endl;

  Child c;
  // 반면에 Child 에서는 parent_string 이
  // (private 상속을 받았기 때문에) private 이
  // 되어서 외부에서 접근이 불가능하다.
  cout << c.parent_string << endl;

  return 0;
}
```



컴파일 하였다면

```warning

error C2247: 'Parent::parent_string' not accessible because 'Child' uses 'private' to inherit from 'Parent'
(Parent::parnet_string 은 'Child' 가 'Parent'  에서 private 상속을 하였기 때문에 접근이 불가능합니다.)
```



위에 코드 주석에 잘 설명되어 있지만 `Parent` 객체에서 `parent_string` 을 접근한다면 `public` 이므로 `main` 함수에서도 잘 접근할 수 있지만 `Child` 에서 `parent_string` 을 접근하려고 한다면, `private` 상속을 받았기 때문에 비록 `Parent` 에서 `public` 이더라도, `Child` 에서는 `private` 으로 처리됩니다. 따라서 접근할 수 없지요.


###  사원 관리 프로그램에 적용해보기


그렇다면 이제 우리가 새롭게 습득한 도구인 '상속' 을 `Manager` 와 `Employee` 클래스 사이에 적용해보도록 합시다. 아래는 기존 `Manager` 클래스를 그대로 가져온 것인데, 원래의 `Employee` 클래스와 중복되는 부분을 굵은 글씨로 나타내보았습니다.

```cpp-formatted
class Manager {
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)
  int year_of_service;

 public:
  Manager(string name, int age, string position, int rank, int year_of_service)
      : name(name),
        age(age),
        position(position),
        rank(rank),
        year_of_service(year_of_service) {}

  // 복사 생성자
  Manager(const Manager& manager) {
    name = manager.name;
    age = manager.age;
    position = manager.position;
    rank = manager.rank;
    year_of_service = manager.year_of_service;
  }

  // 디폴트 생성자
  Manager() {}

  int calculate_pay() { return 200 + rank * 50 + 5 * year_of_service; }
  void print_info() {
    cout << name << " (" << position << " , " << age << ", " << year_of_service
         << "년차) ==> " << calculate_pay() << "만원" << endl;
  }
};
```



이제 이를 바꿔보도록 합시다. 참고로, 한 가지 중요한 점은 `Manager` 의 `calculate_pay` 함수나 `print_info` 함수 등에서 `Parent` 의 `name, position` 등을 참조하고 있기 때문에 `Parent` 의 이 멤버 변수들을 `private` 속성으로 놔두면 안되고 `protected` 로 바꿔주어야만 합니다.


아무튼, `Employee` 를 상속받는 버전으로 바꾼 아래의 `Manager` 클래스 입니다.


```cpp-formatted
class Manager : public Employee {
  int year_of_service;

 public:
  Manager(string name, int age, string position, int rank, int year_of_service)
      : year_of_service(year_of_service), Employee(name, age, position, rank) {}

  // 복사 생성자
  Manager(const Manager& manager)
      : Employee(manager.name, manager.age, manager.position, manager.rank) {
    year_of_service = manager.year_of_service;
  }

  // 디폴트 생성자
  Manager() : Employee() {}

  int calculate_pay() { return 200 + rank * 50 + 5 * year_of_service; }
  void print_info() {
    cout << name << " (" << position << " , " << age << ", " << year_of_service
         << "년차) ==> " << calculate_pay() << "만원" << endl;
  }
};
```



먼저  Employee 와 중복되었던 멤버 변수들이 Employee 를 상속함으로써 사라진 것을 볼 수 있습니다. 그리고 `Manager` 의 생성자들이 '부모 클래스의 생성자를 먼저 호출한다' 라는 원칙에 맞게 아래 처럼 바뀐 것을 볼 수 있습니다.


```cpp-formatted
Manager(string name, int age, string position, int rank, int year_of_service)
    : year_of_service(year_of_service), Employee(name, age, position, rank) {}

// 복사 생성자
Manager(const Manager& manager)
    : Employee(manager.name, manager.age, manager.position, manager.rank) {
  year_of_service = manager.year_of_service;
}

// 디폴트 생성자
Manager() : Employee() {}
```



위에 굵은 글씨로 표시한 것이 모두 `Manage` 의 생성자에서 부모 클래스인 `Employee` 의 생성자를 먼저 호출하는 모습입니다. 상속을 통해서 귀찮게 복사 `+` 붙여 넣기를 하던 코드를 훨씬 간결하고 알아보기 쉽게 바꿀 수 있게 되었습니다. 전체 코드는 아래와 같습니다.


```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

class Employee {
 protected:
  string name;
  int age;

  string position;  // 직책 (이름)
  int rank;         // 순위 (값이 클 수록 높은 순위)

 public:
  Employee(string name, int age, string position, int rank)
      : name(name), age(age), position(position), rank(rank) {}

  // 복사 생성자
  Employee(const Employee& employee) {
    name = employee.name;
    age = employee.age;
    position = employee.position;
    rank = employee.rank;
  }

  // 디폴트 생성자
  Employee() {}

  void print_info() {
    cout << name << " (" << position << " , " << age << ") ==> "
         << calculate_pay() << "만원" << endl;
  }
  int calculate_pay() { return 200 + rank * 50; }
};

class Manager : public Employee {
  int year_of_service;

 public:
  Manager(string name, int age, string position, int rank, int year_of_service)
      : Employee(name, age, position, rank), year_of_service(year_of_service) {}

  // 복사 생성자
  Manager(const Manager& manager)
      : Employee(manager.name, manager.age, manager.position, manager.rank) {
    year_of_service = manager.year_of_service;
  }

  // 디폴트 생성자
  Manager() : Employee() {}

  int calculate_pay() { return 200 + rank * 50 + 5 * year_of_service; }
  void print_info() {
    cout << name << " (" << position << " , " << age << ", " << year_of_service
         << "년차) ==> " << calculate_pay() << "만원" << endl;
  }
};
class EmployeeList {
  int alloc_employee;  // 할당한 총 직원 수

  int current_employee;  // 현재 직원 수
  int current_manager;   // 현재 매니저 수

  Employee** employee_list;  // 직원 데이터
  Manager** manager_list;    // 매니저 데이터

 public:
  EmployeeList(int alloc_employee) : alloc_employee(alloc_employee) {
    employee_list = new Employee*[alloc_employee];
    manager_list = new Manager*[alloc_employee];

    current_employee = 0;
    current_manager = 0;
  }
  void add_employee(Employee* employee) {
    // 사실 current_employee 보다 alloc_employee 가 더
    // 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
    // 최대한 단순하게 생각해서 alloc_employee 는
    // 언제나 current_employee 보다 크다고 생각한다.
    // (즉 할당된 크기는 현재 총 직원수 보다 많음)
    employee_list[current_employee] = employee;
    current_employee++;
  }
  void add_manager(Manager* manager) {
    manager_list[current_manager] = manager;
    current_manager++;
  }
  int current_employee_num() { return current_employee + current_manager; }

  void print_employee_info() {
    int total_pay = 0;
    for (int i = 0; i < current_employee; i++) {
      employee_list[i]->print_info();
      total_pay += employee_list[i]->calculate_pay();
    }
    for (int i = 0; i < current_manager; i++) {
      manager_list[i]->print_info();
      total_pay += manager_list[i]->calculate_pay();
    }
    cout << "총 비용 : " << total_pay << "만원 " << endl;
  }
  ~EmployeeList() {
    for (int i = 0; i < current_employee; i++) {
      delete employee_list[i];
    }
    for (int i = 0; i < current_manager; i++) {
      delete manager_list[i];
    }
    delete[] employee_list;
    delete[] manager_list;
  }
};
int main() {
  EmployeeList emp_list(10);
  emp_list.add_employee(new Employee("노홍철", 34, "평사원", 1));
  emp_list.add_employee(new Employee("하하", 34, "평사원", 1));
  emp_list.add_manager(new Manager("유재석", 41, "부장", 7, 12));
  emp_list.add_manager(new Manager("정준하", 43, "과장", 4, 15));
  emp_list.add_manager(new Manager("박명수", 43, "차장", 5, 13));
  emp_list.add_employee(new Employee("정형돈", 36, "대리", 2));
  emp_list.add_employee(new Employee("길", 36, "인턴", -2));
  emp_list.print_employee_info();
  return 0;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F27672939533765960CBCD8)



와 같이 잘 실행됩니다.



자 그럼 이번 강좌는 여기에서 마치도록 하겠습니다. 사실 여기 까지만 읽으면 굳이 상속을 왜 쓰는지 이해하기 어렵다고 생각할 수 있습니다. 상속의 진짜 유용함은다음 강좌에서 다루도록 하겠습니다 :)


##@ chewing-cpp-end
Link :  208
2013-10-02 15:36
----------------
title : C++ 11 자주 질문되는 것들 모음 (C++ 11 FAQs - Bjarne Stroustup)
publish_date : 2013-10-02 15:36
--------------







```warning
오픈북 프로젝트는 인터넷 상의양질의 컴퓨터 문서를 번역하여 우리 말로 공급하는 프로젝트 입니다. 번역된 문서들은 인터넷 상으로어떠한 제한 조건 없이 배포되고 있으며, 다만 원 번역자의 허락 없는 무단 수정을 금합니다.

현재 까지 번역된 문서들의 리스트는 [여기에서 확인하시면 됩니다.](http://itguru.tistory.com/201)
```


```info
이 문서의 내용을 쉽게 이해 하려면일정 수준 이상의 C++ 지식이 필요로 합니다. 아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)를 보시는 것은 어때요?
```


이번에 번역된 문서는 C++ 언어의 창시자 이신 [Bjarne Stroustrup 씨의 개인 홈페이지](http://www.stroustrup.com/C++11FAQ.html)에 올라와 있는 `C++ 11 FAQ` 를 번역한 것입니다. C++ 11 은 출시된지 2년여가 흘렀음에도 불구하고 국내에 양질의 C++ 11 에 추가된 내용들을 다루는 문서가 별로 없습니다. 따라서 저는 `C++ 11 FAQ` 를 한국어로 번역해서 많은 분들이 C++ 11 의 새롭게 추가된 기능과 C++ 표준 위원회에서 하는 일에 대해 전반적으로 훑어보고 이해할 수 있도록 하고자 합니다. 특히 심도 있는 공부나, 각 기능에 관한 전문적인 기술 문서들을 찾으려는 분들은, 각 질문에 대한 답 밑에 있는 '참고자료' 를 이용하시면 쉽게 찾을 수 있습니다.이 문서에는 아래와 같은 질문들이 포함되어 있습니다.


아래는 먼저 위원회와 C++ 11 에 대해 전반적인 내용에 대한 질문들입니다. 아래 모든 질문들에 대한 답변은 첨부된 `pdf` 파일에서 확인할 수 있으며, 조만간 인터넷에서 쉽게 확인할 수 있도록 웹버전으로도 제작할 생각입니다. 오탈자 관련 문제는 kev0960@gmail.com 으로 보내주시면 감사하겠습니다.


###  질문 목록



* 당신은 C++ 11 에 대해 어떻게 생각하시나요?
* `C++ 0x` 가 공식적인 표준이 언제 될까요?
* 컴파일러가 C++ 11 를 언제 구현할까요?
* 새로운 표준 라이브러리를 언제 사용할 수 있을까요?
* C++ 11 에서 제공하는 새로운 언어 기능들은 무엇인가요? (아래 질문들 참조)
* C++ 11 에서 제고공하는 새로운 표준 라이브러리는 무엇인가요? (아래 질문들 참조)
* `C++ 0x` 가 목표했던 것은 무엇인가요?
*  위원회가 추구했던 디자인 목표는 무엇인가요?
* 위원회 보고서들을 어디서 찾을 수 있나요?
* C++ 11 에 대한 전문적이고 기술적인 문서들을 어디서 찾을 수 있나요?
* C++ 11 에 대해 어디서 읽을 수 있나요?
* C++ 11 에 대한 영상 자료들은 있나요?
* C++ 11 은 배우기 어렵나요?• 위원회를 어떻게 운영되나요?
* 누가 위원회에 있나요?• `C++1y` 가 있을 예정인가요?
* “concepts” 에는 무슨 일이 있었나요?
* 당신이 별로 마음에 들지 않는 기능들이 있나요?
    
개개의 언어 기능 자체에 대한 질문들은 아래와 같습니다. 이 역시 `pdf` 파일 내에서 확인할 수 있습니다.

* `__cplusplus`
* `alignments`
* `atomic` 연산들
* `auto` (초기화자(initializer) 로 부터 타입 유추)
* `C99` 기능들
* `enum` 클래스
* `[[carries dependency]]`
* 예외의 복사와 다시 던지기 (rethrow)
* 상수 표현식 (constexpr)
* `decltype`
* 디폴트 조정하기 : `default` 와 `delete`
* 대표 생성자(delegating constructor)
* 동시성(Concurrency) 를 이용한 동적 초기화와 파괴
* 예외의 전파
* 명시적(explicit) 타입 변환 연산자
* `extern` 템플릿
* `for` 문 (range-for 문 참조)
* 후위 리턴 타입 문법 (확장된 함수 선언 문법)
* 클래스 내부 멤버 초기화자• 상속된 생성자들
* 초기화 리스트(initializer list)
* 인라인 네임스페이스(inline namespace)
* 람다(lambda)
* 템플릿 인자로 사용되는 지역 클래스
* `long long integer` (최소 64비트)
* 메모리 모델• 이동 연산 (우측값 레퍼런스 참조)
* 줄어듬(narrowing)• `[[noreturn]]`
* 널 포인터 (nullptr)
* 오버라이드 컨트롤 : `override`
* 오버라이드 컨트롤 : `final`
* `PODs`
* `range-for` 문
* `raw string` 리터럴
* `<>`
* 우측값 참조
* `static assert`
* 템플릿 별명(alias)
* 템플릿 `typedef` (템플릿 별명 참조)
* `thread local`
* 유니코드 문자
* 단일화(uniform) 된 초기화 문법
* `union`
* 사용자 정의 리터럴
* 가변인자(variadic) 템플릿


아래는 라이브러리 측면에서 향상된 부분들에 관한 질문 입니다.


* 표준 알고리즘의 향상된 부분들
* `array`
* `async()`
* `atoming` 작업들
* `condition` 변수들
* 표준 컨테이너의 향상된 부분들
* `function` 과 `bind`
* `foward_list`
* `future` 와 `promise`
* 가비지 컬렛션 `ABI`
* hash tables (unordered map 참조)
* 메타 프로그래밍(meta programming)과 `type traits`
* 상호 배제(Mutual exclusion)
* 난수 생성
* `<regex>` (정규 표현식 라이브러리)
* 범위있는 할당자
* `shared_ptr`
* 스마트 포인터 (`shared_ptr, weak_ptr, unique_ptr`)
* 쓰레드(thread)
* `Time` 기능들
* `tuple`
* `unique_ptr`
* `unordered_map`
* `weak_ptr`


아래는 위 내용들에 대한 모든 대답을 담은 pdf 파일 입니다. 전체 페이지는 103쪽 입니다.

 [ cplusplus_faq.pdf](/attachment/cplusplus_faq.pdf)
Link :  204
2013-09-04 03:12
----------------
title : 씹어먹는 C++ - <5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열>
cat_title: 5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열
next_page : 209
publish_date : 2013-09-04 03:12
--------------

이번 강좌에서는

* C++ 스타일의 캐스팅 (`static_cast` 등등)
* 디폴트 인자 (default argument)
* `N` 차원 배열의 제작
* 반복자(iterator)

에 대해 다룹니다.

![](/img/ChewingCpplogo.png)


```warning
이번 강좌의 내용은 C++ 을 처음 배우는 분들에게는 이해하기 버거울 수 있습니다. 만일 내용이 도저히 이해가 되지 않는 다면, 이전 연산자 오버로딩 강좌 두 개를 꼼꼼히 다시 읽어보신 다음에, 이 강좌 앞부분 (C++ 스타일의 캐스팅) 만 읽고 넘어가셔도 좋습니다. 하지만 C++ 을 어느 정도 배웠고 복습하시는 차원에서 보시는 분들은 꼭 읽어보시기 바랍니다.
```


안녕하세요 여러분~ 지난번 강좌의 생각해보기는 잘 해보셨나요? 아마도 꽤나 어려웠을 것이라 생각합니다. 사실 `n` 차원 배열을 만드는 것 까지는 하셨을 지 모르겟지만, `N` 차원 배열을 `[]` 를 이용해서 원소에 접근하는 것을 구현하는 일은 상당한 수준의 아이디어가 필요하기 마련이지요.

이번 강좌에서는 이 `N` 차원 배열 만들기 프로젝트를 진행하면서, C++ 여러 라이브러리에서 주요하게 사용되는 몇 가지 아이디어들을 살펴보고 갈 것입니다.


본격적으로 프로젝트에 들어가기에 앞서 C++ 에 또 새롭게 추가된 한 가지 내용을 살펴보도록 하겠습니다.



###  C++ 스타일의 캐스팅




기존의 C 언어에서는, 캐스팅은 크게 2 가지 방법으로 발생하였습니다. 하나는 그냥 컴파일러에서 알아서 캐스팅 하는 **암시적(implicit) 캐스팅**과, 우리가 직접 이러이러 하게 캐스팅 하라고 지정하는 **명시적(explicit)** 캐스팅이 있었지요. 

암시적 캐스팅의 경우 `int` 와 `double` 변수와의 덧셈을 수행할 때, `int` 형 변수가 자동으로 `double` 변수로 캐스팅 되는 것과 같은 것을 말하고, 명시적 캐스팅의 경우 예를 들어 `void *` 타입의 주소를 특정 구조체 포인터 타입의 주소로 바꾼다던지 등의 캐스팅이 있습니다.

이 때, 명시적 캐스팅은 다음과 같이 수행되었지요.

```cpp-formatted
ptr = (Something *)other_ptr;
int_variable = (int)float_variable;
```


와 같이 말이지요. 즉, 괄호 안에 원하는 타입을 넣고 변환을 수행한 것입니다. 하지만 이러한 방식을 사용하다 보니까 프로그래머들 사이에서 몇 가지 문제점들을 발견하였습니다. 일단, 괄호 안에 타입을 넣는 방식으로 변환을 수행하는 탓에, 코드의 가독성이 떨어지게 됩니다. 즉,

```cpp-formatted
function((int)variable);
```


와 같이 함수 호출에도 괄호를 사용하는데, 괄호가 너무 많아지게 된다면 읽는 사람이나 코드를 유지보수하는 사람 입장에서 여러모로 불편하겠지요. 하지만, 문제는 그 뿐만이 아닙니다. 사실 우리가 캐스팅을 하는데에는 여러가지 이유가 있기 마련인데, 위와 같은 C 형식 캐스팅에서는 읽는이가 그 캐스팅의 의미를 명확하게 알 수 없습니다.


하지만 C++ 에서는 다음과 같은 4 가지의 캐스팅을 제공하고 있습니다.

* `static_cast` : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
* `const_cast` : 객체의 상수성(const) 를 없애는 타입 변환. 쉽게 말해 `const int` 가 `int` 로 바뀐다.
* `dynamic_cast` : 파생 클래스 사이에서의 다운 캐스팅 (→ 정확한 의미는 나중에 다시 배울 것입니다)
* `reinterpret_cast` : 위험을 감수하고 하는 캐스팅으로 서로 관련이 없는 포인터들 사이의 캐스팅 등

이 때 이러한 캐스팅을 사용하는 방법은 다음과 같습니다.

```info
(원하는 캐스팅 종류)<바꾸려는 타입>(무엇을 바꿀 것인가?)
```


예를 들어서, `static_cast` 로 `float` 타입의 `float_variable` 이라는 변수를 `int` 타입의 변수로 타입 변환하기 위해서는;

```cpp-formatted
static_cast<int>(float_variable);
```



이렇게 해주시면 됩니다. 이는 C 언어에서

```cpp-formatted
(int)(float_variable)
```


을 한 것과 동일한 문장 입니다. 사실 현재까지 배운 내용 정도 에서는, `static_cast` 만 사용하지 나머지 캐스팅들은 별로 신경 안쓰셔도 됩니다. 여러분이 C 언어에서 수행하였던 대부분의 아무런 문제없는 캐스팅들은 모두 `static_cast` 로 해주시면 됩니다. 강좌를 진행하면서 나머지 캐스팅들을 어떠한 상황에서 사용하는지 차근 차근 알아보도록 할 것입니다.




###  N 차원 배열 만들기




`N` 차원 배열을 구현하는 방법은 크게 두 가지 방법이 있다고 생각합니다. 사용자가 원하는 배열을 `arr[x1][x2]...[xn]` 이라고 해본다면, 첫 번째 방법은 말 그대로 `x1 * x2 * ... * xn` 크기의 일 차원 배열을 할당한 뒤에 접근할 때 정확한 위치를 찾아주는 방법이지요. 이러한 방식으로 구현한다면 메모리도 정확히 필요한 만큼만 사용할 수 있기에 좋은 방법이라고 생각합니다.이 방법으로 한번 여러분들이 직접 구현해 보시기 바랍니다.

제가 이 `N` 차원 배열을 구현하는 프로젝트에서 사용할 아이디어는, 이전에 2 차원 배열의 동적할당을 수행하면서 얻은 아이디어와 비슷합니다. 예전에 동적으로 2 차원 배열을 구현할 때 다음과 같이 구성하였습니다. (참고로 아래 코드에서 할당한 2 차원 배열의 크기는 `arr[x1][x2]` 입니다)

```cpp-formatted
int** arr;
arr = new int*[x1];
for (int i = 0; i < x1; i++) arr[x1] = new int[x2];
```


즉 더블 포인터 `arr` 을 정의한 뒤에, `arr` 에 `int*` 타입의 `x1` 크기의 1 차원 배열을 먼저 할당한 다음에, 이 `int*` 배열의 각 원소에 대해서 또 `x2` 크기의 1 차원 배열을 모두 할당한 것이지요. 이와 같은 형태를 그림으로 표현하자면 다음과 같습니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2362853B52220C03152D4C)


위와 같이 문어발 형식으로 맨 처음에는 `x1` 개의 `int*` 배열을 생성한 뒤에, 각 `int*` 에 대해서 `x2` 개의 `int` 배열을 만들게 된다면, 전체적으로 볼 때 마치 `int arr[x1][x2]` 를 한 것과 정확히 동일한 효과를 낼 수 있게 됩니다. 하지만 이와 같은 방식의 문제점으로는 원래 `int arr[x1][x2]` 를 하게 된다면 정확히 `x1 * x2` 만큼의 메모리만 잡아먹게 되지만, 이 방법을 할 경우, 포인터 자체가 잡아먹는 크기 때문에 x1 `* x2 + x1 + 1` 만큼의 메모리를 잡아먹게 된다는 뜻입니다.


하지만 위 방식의 좋은 점은, 메모리가 허용하는 한 크기가 매우 매우 큰 배열도 생성할 수 있다는 점입니다. 첫 번째 방식의 경우 전체 배열의 원소 수가 `int` 크기를 넘어가게 된다면, 따로 큰 수의 정수를 다룰 수 있는 라이브러리를 사용해서 메모리를 동적으로 할당해주어야 할 것입니다. 하지만, 제가 이 `N` 차원 배열 클래스에서 사용할 방식의 경우, 전체 원소 수가 아니라, 한 차원의 수가 `int` 크기만 넘어가지 않으면 됩니다. 다시 말해, `(int 크기) * (int 크기) * ... * (int 크기)` 개의 원소를 사용할 수 있으며, 아마 이 정도 크기는 왠만한 사이즈의 프로젝트에서는 충분할 것입니다. 3 차원 배열의 경우 가능한 최대 원소 개수가 2 의 96승, 즉 79228162514264337593543950336 개나 됩니다.


그런데 여기서 한 가지 문제점이 무엇이냐면, 우리가 만들어야 할 배열은 정해진 상수 차원의 배열이 아니라, `N` 차원의 배열이라는 뜻입니다. 만일 3 차원 배열을 만들었다면 `int***` 을 이용하였을 것이고 4 차원 배열은 `int ****` 을 이용하였을 터인데 (물론 불편하기는 하지만, 쉽게 생각하자면 말입니다.) `N` 차원 배열의 경우 `N` 개의 `*` 들이 들어간 포인터를 정의할 수 없는 터입니다.


하지만 관점을 바꾸어서 조금만 생각해보면 이 문제는 손쉽게 해결할 수 있음을 알 수 있습니다. 위에서 포인터를 사용하는 것이 단순히 다음 레벨의 배열들을 가리키기 위함이라면, 굳이 `N` 포인터를 사용하지 않고도 만들 수 있기 때문입니다.

```cpp-formatted
struct Address {
  int level;
  void* next;
};
```



이 생각을 바탕으로 하나의 작은 구조체를 만들어 보자면 위와 같이 `Address` 라는 구조체를 생각해봅시다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F235A384C52221300300E40)

위와 같이 각각의 행들을 한 개의 레벨이라고 생각했을 때, 맨 처음에 우리가 정의하던 `int **` 변수는 0 레벨, 그 다음에 `int **` 가 가리키던 `int *` 배열들은 1 레벨, 그리고 실제 `int` 형 데이터가 들어가 있는 곳은 2 레벨이라고 생각할 수 있습니다. 그런데 `Address` 구조체를 도입한다면 굳이 `int **` 등으로 귀찬게 할 필요 없이 모두 `void *` 포인터 하나로 정리할 수 있습니다.


이 것이 어떻게 가능하다면, `top` 이라는 `Address` 객체를 도입을 합니다. 이 `top` 은 위 그림에서 맨 위의 레벨 0 에 해당하며 (그래서 이름도 역시 `top` 입니다) 따라서 `top` 의 `level` 값은 0 이 됩니다. 그렇다면 이 `top` 의 `next` 에는 무엇이 들어가게 될까요? 이미 예상하겠지만, 레벨이 1 인 `Address` 배열의 시작 주소가 들어가게 됩니다. 그럼, 이 `top` 이 가리키고 있는 `Address` 배열의 각각 원소들의 `level` 은 당연히 1 이 되겟고, 이들의 `next` 에는 무엇이 들어갈까요. 예상했던 대로, 이번에는 `Address` 배열이 아닌, `int` 배열의 시작 주소가 들어가겠지요. (왜냐하면 2 차원 배열이기 때문이죠!. 실질적으로 데이터는 여기에 보관이 됩니다)



여기서 좋은 점은 포인터라는 것이 타입의 상관없이 모두 `void *` 으로 값을 보관할 수 있으므로 필요할 때에만 적당한 포인터 타입으로 변환하면 됩니다. 정리해보자면, `N` 차원 배열이라고 할때 `Address` 들은 총 0 레벨 부터 `N - 1` 레벨 까지 생성되며, `N - 1` 레벨의 경우 `next` 에 실제로 보관할 데이터에 해당하는 배열(여기서는 `int)` 의 시작 주소값이 들어가게 되고, 나머지 0 부터 `N - 2` 레벨 까지는 그 다음 레벨의 `Address` 배열의 시작 주소값이 들어가게 됩니다.


마지막으로 이해가 가시지 않는 분들을 위해 3차원 배열의 경우 어떻게 이 방법으로 구성할 수 있는지 예시 그림을 첨부하였습니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2669343D5224BD123309D7)

위 그림은 3차원 배열일 때 어떻게 구성할 수 있는지 나타낸 그림입니다. 그림에도 잘 표현되어 있지만, 검은색 선은 `next` 가 가리키고 있는 것을 의미하고, 파란색 테두리는 하나의 배열을 의미하게 됩니다. 마찬가지로 0 레벨의 `next` 는 1 레벨의 `Address` 배열의 시작 주소값을 가리키고 있고, 1 레벨의 `Address` 들의 `next` 는 각각 2 레벨의 `Address` 배열의 시작 주소값을 가리키고 있습니다. 이 때 3 차원 배열이므로, (3 - 1) 레벨인 2 레벨의 `Address` 들의 `next` 들은 `0, 1` 레벨들과는 다르게 `int` 배열의 시작 주소값을 가리키게 됩니다.


이러한 레벨 방식을 도입해서 처리하는 이유는 각 레벨에서의 배열 크기가 모두 다를 수 있기 때문입니다. 예를 들어서, `arr[3][2][1]` 을 했을 경우, 1 레벨의 배열 크기가 `3, 2` 레벨의 배열 크기가 `2,` 그리고 마지막 `int` 배열 (레벨 3에 해당) 크기가 1 이 되면 됩니다. 위 그림의 경우 `arr[4][3][1]` 을 나타낸 것이라 볼 수 있겠지요.



이러한 아이디어를 바탕으로 일단 우리의 `N` 차원 `Array` 배열의 클래스를 대략적으로 설계해보도록 합시다.

```cpp-formatted
class Array {
  const int dim;  // 몇 차원 배열인지
  int* size;  // size[0] * size[1] * ... * size[dim - 1] 짜리 배열이다.

 public:
  Array(int dim, int* array_size) : dim(dim) {
    size = new int[dim];
    for (int i = 0; i < dim; i++) size[i] = array_size[i];
  }
};
```



일단 우리의 `Array` 배열에 들어가야 할 중요한 정보로 '몇 차원' 배열인지에 대한 정보와, 각 차원에서의 크기 정보를 반드시 포함하고 있어야만 할것입니다. 따라서, '몇 차원' 인지는 `dim` 에 아예 상수값으로 저장하도록 하고 (반드시 상수로 정할 필요는 없습니다만, `dim` 을 상수로 정한 것은 외부 사용자들에게 한 번 `Array` 의 차원을 정하면 바꿀 수 없다는 것을 의미합니다. 물론 여러분들이 원하신다면 굳이 상수로 안하는 대신에 배열의 차원을 조절해주는 `resize` 같은 함수를 추가해주어야 겠지요), `size` 배열에 각 차원애 대한 정보를 가지게 하였습니다.


그런데 여기서 중요한 것이 빠진것 같습니다. 바로 실질적으로 데이터를 보관하는 부분인데요, 앞에서도 설명하였듯이 우리의 거대한 `N` 차원 배열은 마치 거대한 나무 처럼 가느다란 줄기로 부터 시작해서 엄청나게 큰 뿌리로 퍼지는 모습입니다. 하지만 이 거대한 배열을 가리키게 위해서 `Array` 에서 필요한 것은 단 하나, 바로 맨 상단의 시작점일 뿐이지요. 이 시작점은 `Address *` 타입으로, 이를 `top` 이라고 부르기로 하였습니다. 따라서 최종적으로 `Array` 에 필요한 `data` 멤버들은 다음과 같습니다.

```cpp-formatted
class Array {
  const int dim;  // 몇 차원 배열인지
  int* size;  // size[0] * size[1] * ... * size[dim - 1] 짜리 배열이다.

  Address* top;

 public:
  Array(int dim, int* array_size) : dim(dim) {
    size = new int[dim];
    for (int i = 0; i < dim; i++) size[i] = array_size[i];
  }
};
```



아 물론, `Address` 라는 새로운 구조체를 도입하였기 때문에 `Address` 의 정의 자체도 넣어야만 합니다. 한 가지 재미있는 점은 클래스 안에도 클래스를 넣을 수 있다는 사실인데, 외부에서 우리 `Array` 배열이 내부적으로 어떻게 작동하는지 공개하고 싶지 않고, 또 내부 정보에 접근하는 것을 원치 않기 때문에 `Array` 안에 `Address` 구조체를 넣어 버리겠습니다. (참고로 C++ 에서 구조체는 모든 멤버 함수, 변수가 디폴트로 `public` 인 클래스라고 생각하시면 됩니다)

```cpp-formatted
class Array {
  const int dim;  // 몇 차원 배열인지
  int* size;  // size[0] * size[1] * ... * size[dim - 1] 짜리 배열이다.

  struct Address {
    int level;
    // 맨 마지막 레벨(dim - 1 레벨) 은 데이터 배열을 가리키고, 그 위 상위
    // 레벨에서는 다음 Address 배열을 가리킨다.
    void* next;
  };
  Address* top;

 public:
  Array(int dim, int* array_size) : dim(dim) {
    size = new int[dim];
    for (int i = 0; i < dim; i++) size[i] = array_size[i];
  }
};
```



따라서 최종적으로 위와 같은 모습이 됩니다.


자 그러면 이제 본격적으로 `top` 을 시작으로 N 차원 배열을 생성해보도록 하겠습니다. 위의 그림과 같은 구조를 구현하기 위해서는 이전에 동적으로 2 차원 배열을 생성하였을 때 처럼 `for` 문으로 간단히 수행할 수 있는 것이 아닙니다. 왜냐하면 일단 `for` 문으로 하기 위해서는 몇 중 `for` 문을 사용할지 컴파일 시에 정해져야 하는데, 이 경우 `N` 차원인 임의의 차원이므로 그럴 수 없기 때문입니다.


하지만 이와 같은 문제를 해결하는 아주 좋은 아이디어가 있는데 바로 재귀 함수를 이용하는 것입니다. 재귀 함수를 구성하기 위해서는 다음과 같은 두 가지 스텝만 머리속으로 생각하고 있으면 됩니다.

* 함수에서 처리하는 것, 즉 현재 단계에서 다음 단계로 넘어가는 과정은 무엇인가?
* 재귀 호출이 종료되는 조건은 무엇인가?

일단 우리는 두 번째 질문에 대한 해답을 이미 알고 있습니다. 재귀 함수 호출이 종료되기 위한 조건은 바로 현재 처리하고 있는 `Address` 배열의 레벨이 `(dim - 1)` 이면 됩니다. 즉, `Address` 배열의 레벨이 `(dim - 1)` 이면, 이 배열의 원소들 (즉 `(dim - 1)` 레벨들의 `Address` 들) 의 `next` 에는 `int` 배열의 데이터가 들어가게 재귀 호출이 끊나게 되지요.


그렇다면 첫 번째 질문에 대한 답, 즉 현재 단계에서 다음 단계로 넘어 가는 과정은 무엇일까요?  이 역시 사실 간단합니다. 현재 `n` 레벨의 `Address` 배열이라면, 이들의 `next` 에 다음 레벨인 `n + 1` 레벨의 `Address` 배열을 지정해주고, 또 이 각각의 원소에 대해 처리하도록 하면 되는 것입니다.


따라서 이 생각들을 정리하면 다음과 같은 코드를 짤 수 있습니다.


```cpp-formatted
// address 를 초기화 하는 함수이다. 재귀 호출로 구성되어 있다.
void initialize_address(Address *current) {
  if (!current) return;
  if (current->level == dim - 1) {  // 두 번째 질문 (종료 조건)
    current->next = new int[size[current->level]];
    return;
  }
  current->next = new Address[size[current->level]];
  for (int i = 0; i != size[current->level];
       i++) {  // 다음 단계로 넘어가는 과정
    (static_cast<Address *>(current->next) + i)->level = current->level + 1;

    initialize_address(static_cast<Address *>(current->next) + i);
  }
}
```



위 `initialize_address` 함수는 인자로 들어온 `current` 를 처리하고 그 다음 단계로 넘어가도록 합니다. 맨 처음의 `if(!current)` 부분은 단순히 `current` 가 `NULL` 일 때 예외적으로 처리하는 부분이니까 무시하도록 하고, 두 번째 if 문은 위에서 설명한 '종료 조건' 이 됩니다. 이 재귀 호출이 끝나기 위한 조건으로 현재 처리하고 있는 `Address` 의 레벨이 `dim - 1` 일 때, 이들의 `next` 에는 `Address` 배열이 아닌 `int` 배열의 시작 주소가 들어가게 됩니다.


반면에 종료 조건에 해당하지 않는 경우 `initialize_address` 함수에서 어떻게 처리하는지 볼까요. 일단;

```cpp-formatted
current->next = new Address[size[current->level]];
```



를 통해서 `current` 의 `next` 에 크기가 `size [current->level]` 인 새로운 시작 주소값을 만들어주고 있습니다. 이 때 왜 배열의 크기가 `size [current->level]` 인지는 여러분도 잘 아실 것이라 생각합니다. 예를 들어서 `arr[3][4][5]` 의 경우 `current` 가 0 레벨이라면 `next` 에 만드는 배열의 크기는 `3, 1` 레벨이라면 `4, 2` 레벨이라면 5 가 되는 것과 같은 이치 입니다.


이렇게 `Address` 배열을 만들게 된다면, 이 각각의 원소들에 대해서도 종료 조건에 도달하기 전까지 동일한 처리를 계속 반복해주어야만 하겠지요? 따라서 아래 처럼 `for` 문으로

```cpp-formatted
for (int i = 0; i != size[current->level]; i++) {  // 다음 단계로 넘어가는 과정
  (static_cast<Address *>(current->next) + i)->level = current->level + 1;
  initialize_address(static_cast<Address *>(current->next) + i);
}
```



새롭게 생성한 각각의 원소들에 대해 `initialize_address` 를 동일하게 수행하고 있습니다.

```cpp-formatted
(static_cast<Address *>(current->next) + i)->level = current->level + 1;
```



위 처럼 그 `current` 의 `next` 가 가리키고 있는 원소들의 레벨 값을 다음 단계로 설정한 다음에

```cpp-formatted
initialize_address(static_cast<Address *>(current->next) + i);
```



각각의 원소들에 대한 `initialize_address` 함수를 호출하게 됩니다. 참고로,

```cpp-formatted
(static_cast<Address *>(current->next) + i)
```



라는 표현이 무슨 뜻인지는 C 언어를 충실히 배운 여러분이라면 무슨 의미인지 잘 알고 계실 것이라 생각합니다. (`current->next` 를 시작 주소로 하는 `Address` 배열의 `i` 번째 원소를 가리키는 포인터)


참고로 말하자면, 이러한 방식으로 함수를 재귀호출하게 된다면, 맨 위의 그림을 '깊이 우선 탐색' 하는 것과 동일합니다. (아래 그림 참조)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F236DD24D5224B08D3357D7)



생성자를 만들었으므로, 소멸자도 비슷한 방식으로 만들어주면 됩니다. 다만, 소멸자의 경우 주의할 점이, 생성자는 '위에서 아래로' 메모리들을 점차 확장 시켜 나갔지만, 소멸자는 '아래에서 위로' 메모리를 점차 소멸시켜 나가야 된다는 점입니다. 물론, 이로 살짝 바꾸는 것은 별로 어려운 일이 아닙니다.

```cpp-formatted
void delete_address(Address *current) {
  if (!current) return;
  for (int i = 0; current->level < dim - 1 && i < size[current->level]; i++) {
    delete_address(static_cast<Address *>(current->next) + i);
  }

  delete[] current->next;
}
```



위와 같이 `delete_address` 함수를 생각해 볼 수 있습니다. (여러분들이 한 번 직접 생각해보세요)


이들을 조합해서, 우리의 `Array` 클래스의 생성자를 수정해보도록 합시다.

```cpp-formatted
Array(int dim, int* array_size) : dim(dim) {
  size = new int[dim];
  for (int i = 0; i < dim; i++) size[i] = array_size[i];

  top = new Address;
  top->level = 0;

  initialize_address(top);
}
Array(const Array& arr) : dim(arr.dim) {
  size = new int[dim];
  for (int i = 0; i < dim; i++) size[i] = arr.size[i];

  top = new Address;
  top->level = 0;

  initialize_address(top);
}
~Array() {
  delete_address(top);
  delete[] size;
}
```



위 두개는 `Array` 의 기본 생성자와 복사 생성자, 그리고 소멸자를 나타낸 것입니다. 재귀 함수의 시작으로 `current` 에 `top` 을 전달하였고, 이 `top` 을 시작으로 함수들이 쭈르륵 재귀 호출 되면서 거대한 `N` 차원 메모리 구조가 생성되거나 소멸 됩니다. 항상 유의할 점은 소멸자에서 동적으로 할당한 모든 것들을 정리해 주어야 한다는 점인데, 재귀 호출로 생성한 메모리 구조만을 소멸해야 되는 것이 아니라 `size` 역시 동적으로 할당한 것이므로 꼭 해제해 주어야만 합니다.





###  operator[] 문제




이제 생성을 하였는데, 문제는 어떻게 `N` 차원 배열의 각각의 원소에 접근하느냐 입니다. 우리의 클래스는 다른 복잡한 방법을 사용하지 않고 마치 진짜 배열을 다루던 것 처럼 `[]` 를 이용해서 원소에 접근하는 기능을 제공하고 싶습니다. 하지만 문제는 C++ 에는 1 개의 `[]` 를 취하는 연산자는 있어도 `N` 개의 `[]` 들을 취하는 연산자는 없다는 점입니다.

그렇다면, 여러개의 `[]` 들을 어떻게 처리하냐면 예를 들어 우리가

```cpp-formatted
arr[1][2][3][4]
```

를 하였을 때, 제일 먼저 `arr[1]` 이 처리되며, 첫 번째 차원으로 1 을 선택했다는 정보가 담긴 어떠한 객체 `T` 를 리턴합니다. 그리고,

```cpp-formatted
(T)[2][3][4]
```



가 수행이 되겠지요. 이 `T` 또한 `operator[]` 가 있어서, 두번째 차원으로 2 를 선택했다는 정보가 담긴 객체 T' 을 리턴합니다. 그렇다면 이제,

```cpp-formatted
(T')[3][4]
```



가 되겠고, 마찬가지로 계속 진행하게 된다면

```cpp-formatted
T'''
```

이 남게 됩니다. 우리는 이 `T'''` 가 `int` 타입임을 바라고 있지요. 그런데 도대체 이를 어떻게 구현해야 할까요?


일단 `Array` 가 아닌 새로운 타입의 객체를 만들어야 한다는 것만은 분명합니다. 왜냐하면, 만일 `operator[]` 가 `Array&` 타입이라면, 1 차원 `Array` 배열에 대해서

```cpp-formatted
arr[1] = 3;
```

과 같은 문장은 말이 안되기 때문입니다. 그렇다고 해서 `operator[]` 가 `int&` 타입을 리턴할 수 도 없는 처지 입니다. 왜냐하면, 만일 `int&` 타입을 리턴하였을 경우에 1 차원 배열인

```cpp-formatted
arr[1] = 3;
```

과 같은 문장은 쉽게 처리할 수 있다고 하지만, 그 보다 고차원 배열에 대해서

```cpp-formatted
arr[1][2] = 3;
```



은 어떻게 처리할 것인가요? `arr[1]` 의 리턴 타입이 `int&` 라면 `int` 에 대한 `operator[]` 는 정의되어 있지도 않고 정의 할 수 도 없습니다. '그렇다면 상황에 따라서 1 차원이면 `int` 를, 그 보다 고차원 배열이면 다른 것을 리턴하면 되지 않냐?' 라고 물을 수 있지만'오버로딩' 의 원칙 상 동일한 인자를 받는 함수에 대해서는 한 가지 리턴 타입만이 가능합니다.


하지만 조금만 기억을 더듬어 올라간다면, 필요할 때 `int` 처럼 작동하지만 `int` 가 아닌 클래스를 만들 수 있었습니다. 바로`int` 의 `Wrapper` 클래스였지요. `int` 의 `Wrapper` 클래스는 타입 변환 연산자를 제공해서 `int` 와의 연산을 수행하거나, 대입등을 할 때 마치 `int` 처럼 작동하도록 만들 수 있습니다. 그렇다면 우리는 `operator[]` 가 `int` 의 `Wrapper` 클래스 객체를 리턴해서, 실제 `int` 값에 접근할 때에는 `int` 변수 처럼 행동하고, 위에서 `T` 나 T' 처럼 원소에 접근해 가는 중간 단계의 산물일 경우, 그 중간 단계의 정보를 포함하는 것으로 사용하면 됩니다.



이러한 생각을 바탕으로 `int` 의 `Wrapper` 클래스 `Int` 의 얼개를 그려보자면 다음과 같습니다.

```cpp-formatted
class Int {
  void* data;

  int level;
  Array* array;
};
```



먼저 `level` 정보는 반드시 포함하고 있어야만 합니다. 왜냐하면, 이 `Int` 가 맨 마지막 '실제 `int` 정보' 를 포함하고 있는 객체인지, 아니면 원소를 참조해 나가는 중간 과정에서의 산물인지를 구별할 수 있어야 하기 때문입니다.


예를 들어서

```cpp-formatted
arr[1][2];
```

를 생각해 볼 때 맨 처음 `arr[1]` 은 `level` 이 1 인 `Int` 가 리턴됩니다. 이 때, 이는 `int` 데이터가 아니라, `[1][2]` 를 참조해 나가기 위한 중간 과정이지요. (이 것을 `Int` 가 어떻게 구별하냐면, `Int` 가 가지고 있는 `array` 의 `dim` 정보를 참조하면 되겠지요!)


이 때의 `Int` 에는 '현재 `arr[1]` 를 가리키고 있음' 에 대한 정보가 `Int` 의 `data` 에 들어가 있습니다. 그 다음에 `Int` 의 `operator[]` 를 수행하게 된다면 (따라서 `Int` 클래스의 `operator[]` 역시 만들어야 합니다), 이번에는 `level` 이 2 인 `Int` 가 리턴이 됩니다. 사용자가 `level` 이 2 인 `Int` 에 대입 연산을 하게 된다면, `void * data` 를 `int` 원소를 가리키고 있는 주소로 해석해서 실제로 `int` 변수 처럼 대입이 수행이 되겟지요.


참고로 `array` 는 어떤 배열의 `Int` 인지 가리키는 역할을 합니다.


먼저 `Int` 의 생성자는 아래와 같이 구성할 수 있습니다.

```cpp-formatted
Int(int index, int _level = 0, void *_data = NULL, Array *_array = NULL)
    : level(_level), data(_data), array(_array) {
  if (_level < 1 || index >= array->size[_level - 1]) {
    data = NULL;
    return;
  }
  if (level == array->dim) {
    // 이제 data 에 우리의 int 자료형을 저장하도록 해야 한다.
    data = static_cast<void *>(
      (static_cast<int *>(static_cast<Array::Address *>(data)->next) + index));
  } else {
    // 그렇지 않을 경우 data 에 그냥 다음 addr 을 넣어준다.
    data = static_cast<void *>(
      static_cast<Array::Address *>(static_cast<Array::Address *>(data)->next) +
      index);
  }
};
```




`Int` 생성자의 내용을 설명하기 전에, 위에 `Int` 생성자의 인자로 이상한 것들이 보이지요? 왜 인자에 값을 미리 대입하고 있는 것인가요?

```cpp-formatted
int index, int _level = 0, void *_data = NULL, Array *_array = NULL
```



이들은 모두 디폴트 인자(default argument)라고 부르는 것이며, 함수에 값을 전달해주지 않는다면 인자에 기본으로 이 값들이 들어가게 됩니다. 예를 들어서 우리가 `Int` 의 생성자에

```cpp-formatted
Int(3)
```



이라고 호출하였다면, `index` 에는 3 이 들어가겠지만, `_level` 에는 0, `_data` 과 `_array` 에는 `NULL` 이 들어가겠지요. 만약에 인자를 지정해 주었다면, 디폴트 값 대신에 지정한 인자가 들어가게 됩니다. 예를 들어서

```cpp-formatted
Int(3, 1)
```



이렇게 한다면 `index` 에는 `3, _level` 에는 `1,` 그리고 나머지에는 디폴트 값인 `NULL` 이 들어갑니다. 또한 한 가지 당연한 사실이지만, 디폴트 인자들은 함수의맨 마지막 인자 부터 '연속적으로'만 사용할 수 있습니다. 왜냐하면 만일 우리가 디폴트 인자를

```cpp-formatted
int index, int _level = 0, void *_data = NULL, Array *_array
```



이렇게 중간에 두었다면 사용자가

```cpp-formatted
Int(3, 1, ptr)
```



을 했을 때, 이 `ptr` 의 의미가 `_data` 는 디폴트 인자인 `NULL` 을 사용하고 `_array` 에는 `ptr` 을 사용하라는 것인지, 아니면 `_data` 에 `ptr` 이 들어가게 `_array` 에 인자를 안주는 오류인지 컴파일러가 알 수 없기 때문입니다. 이렇게 디폴트 인자를 사용하는 경우는 대부분 프로그래머들의 편의를 위해서 인데, 다만 함수의 원형을 정확히 알아야지, 일부 인자를 실수로 누락하게 된다면 디폴트 인자로 경고가 발생하지 않고, 그로 인해 함수가 이상하게 작동할 수 있으므로 주의가 필요합니다.


자 그럼 이제 `Int` 생성자의 내부를 살펴보도록 하겠습니다.

```cpp-formatted
if (_level < 1 || index >= array->size[_level - 1]) {
  data = NULL;
  return;
}
```



일단 위와 같이 오류가 발생하였을 경우 처리하는 모습입니다. 클래스를 구현할 때는 항상 클래스를 사용하는 사용자가 어떠한 이상한 짓을 하더라도 대처할 수 있는 자세가 필요합니다. 위와 같이 꼼꼼하게 발생할 수 있는 예외 상황을 처리하도록 합시다.

```cpp-formatted
if (level == array->dim) {
  // 이제 data 에 우리의 int 자료형을 저장하도록 해야 한다.
  data = static_cast<void *>(
    (static_cast<int *>(static_cast<Array::Address *>(data)->next) + index));
} else {
  // 그렇지 않을 경우 data 에 그냥 다음 addr 을 넣어준다.
  data = static_cast<void *>(
    static_cast<Array::Address *>(static_cast<Array::Address *>(data)->next) +
    index);
}
```



그 다음 부분을 살펴보자면, 상당히 중요한 부분입니다. 먼저 `if` 문에서 이 `Int` 의 `level` 과 `array->dim` 이 같다는 것은 무엇을 의미할까요? 이 말은, 원소에 접근하는 단계의 중간 산물이 아니라, 실질적으로 접근이 완료 되었다는 것입니다. 따라서, `Int` 의 `data` 에는 `(int *)` 타입의 포인터 주소값이 (void* 로 다시 캐스팅 되어서) 들어가겠지요. 즉, `level == array->dim` 이 되는 상황은 예컨대 3 차원 배열에서

```cpp-formatted
arr[1][2][3];
```



을 하였을 때 `arr[1]` 은 `level 1` 짜리 `Int` 객체 `T` 를 리턴해서

```cpp-formatted
T[2][3]
```



이 되고, `T[2]` 는 `level 2` 짜리 `Int` 객체 T' 을 리턴해서

```cpp-formatted
T'[3]
```



이 되고, 다시 `T'[3]` 은 `level 3` 짜리 `Int` 객체 `T''` 을 리턴하게 되는데, 이 `T''` 의 `data` 가 가리키는 포인터가 이전들과는 다르게 `int` 변수의 주소값이라는 것이지요. 그렇다면 당연히도 `else` 부분에서는, `data` 에 다음 `Address` 값이 들어갑니다.

```cpp-formatted
data = static_cast<void *>(
  static_cast<Array::Address *>(static_cast<Array::Address *>(data)->next) +
  index);
```



위와 같이 `data` 를 만들게 된다면, 결과적으로 맨 마지막에서 사용자가 원하는 `int` 데이터를 정확히 찾아낼 수 있겠습니다.


이와 같은 사실을 바탕으로 하면 `Array` 의 `operator[]` 와 `Int` 의 `operator[]` 는 별로 어렵지 않게 만들 수 있습니다. 먼저 `Array` 의 `operator[]` 를 살펴보면

```cpp-formatted
Int Array::operator[](const int index) {
  return Int(index, 1, static_cast<void *>(top), this);
}
```



위와 같이 `Int` 를 리턴하게 되며, `level` 로는 `1,` 그리고 `data` 인자로는 `top` 을 전달합니다. 따라서 `Int` 생성자에서, 생성되는 객체가 `top` 의 `next` 가 가리키고 있는 `index` 번째 원소를 `data` 로 가질 수 있게 되지요.

```cpp-formatted
Int operator[](const int index) {
  if (!data) return 0;
  return Int(index, level + 1, data, array);
}
```



`Int` 의 `operator[]` 의 경우, `level` 에 다음 레벨을 전달함으로써 다음 단계의 `Int` 를 생성합니다. 그리고 위의 `!data` 를 검사하는 문장은 만일 `data` 가 `NULL` 이라면 (즉 예외 상황), 0 을 리턴하도록 하였습니다.


자 이제, `Int` 가 `Wrapper` 클래스로써 동작하기에 가장 필수적인 요소인 타입 변환 연산자를 살펴보면;

```cpp-formatted
operator int() {
  if (data) return *static_cast<int *>(data);
  return 0;
}
```



매우 간단합니다. 타입 변환 연산자가 호출되는 상태에서의 `Int` 객체의 `data` 에는 `int` 원소의 주소값이 들어가 있기 때문에 `void*` 를 `int *` 타입으로 변환에서 그 값을 리턴하면 됩니다.


자 그럼, 실제 전체 코드를 살펴보도록 합시다.

```cpp-formatted
// 대망의 Array 배열
#include <iostream>
using namespace std;

class Array;
class Int;

class Array {
  friend Int;

  const int dim;  // 몇 차원 배열 인지
  int* size;  // size[0] * size[1] * ... * size[dim - 1] 짜리 배열이다.

  struct Address {
    int level;
    // 맨 마지막 레벨(dim - 1 레벨) 은 데이터 배열을 가리키고, 그 위 상위
    // 레벨에서는 다음 Address 배열을 가리킨다.
    void* next;
  };

  Address* top;

 public:
  Array(int dim, int* array_size) : dim(dim) {
    size = new int[dim];
    for (int i = 0; i < dim; i++) size[i] = array_size[i];

    top = new Address;
    top->level = 0;

    initialize_address(top);
  }
  Array(const Array& arr) : dim(arr.dim) {
    size = new int[dim];
    for (int i = 0; i < dim; i++) size[i] = arr.size[i];

    top = new Address;
    top->level = 0;

    initialize_address(top);
  }
  // address 를 초기화 하는 함수이다. 재귀 호출로 구성되어 있다.
  void initialize_address(Address* current) {
    if (!current) return;
    if (current->level == dim - 1) {
      current->next = new int[size[current->level]];
      return;
    }
    current->next = new Address[size[current->level]];
    for (int i = 0; i != size[current->level]; i++) {
      (static_cast<Address*>(current->next) + i)->level = current->level + 1;
      initialize_address(static_cast<Address*>(current->next) + i);
    }
  }
  void delete_address(Address* current) {
    if (!current) return;
    for (int i = 0; current->level < dim - 1 && i < size[current->level]; i++) {
      delete_address(static_cast<Address*>(current->next) + i);
    }

    delete[] current->next;
  }
  Int operator[](const int index);
  ~Array() {
    delete_address(top);
    delete[] size;
  }
};
class Int {
  void* data;

  int level;
  Array* array;

 public:
  Int(int index, int _level = 0, void* _data = NULL, Array* _array = NULL)
      : level(_level), data(_data), array(_array) {
    if (_level < 1 || index >= array->size[_level - 1]) {
      data = NULL;
      return;
    }
    if (level == array->dim) {
      // 이제 data 에 우리의 int 자료형을 저장하도록 해야 한다.
      data = static_cast<void*>(
        (static_cast<int*>(static_cast<Array::Address*>(data)->next) + index));
    } else {
      // 그렇지 않을 경우 data 에 그냥 다음 addr 을 넣어준다.
      data = static_cast<void*>(
        static_cast<Array::Address*>(static_cast<Array::Address*>(data)->next) +
        index);
    }
  };

  Int(const Int& i) : data(i.data), level(i.level), array(i.array) {}

  operator int() {
    if (data) return *static_cast<int*>(data);
    return 0;
  }
  Int& operator=(const int& a) {
    if (data) *static_cast<int*>(data) = a;
    return *this;
  }

  Int operator[](const int index) {
    if (!data) return 0;
    return Int(index, level + 1, data, array);
  }
};
Int Array::operator[](const int index) {
  return Int(index, 1, static_cast<void*>(top), this);
}
int main() {
  int size[] = {2, 3, 4};
  Array arr(3, size);

  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
      for (int k = 0; k < 4; k++) {
        arr[i][j][k] = (i + 1) * (j + 1) * (k + 1);
      }
    }
  }
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
      for (int k = 0; k < 4; k++) {
        cout << i << " " << j << " " << k << " " << arr[i][j][k] << endl;
      }
    }
  }
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F260AAE3B522607B820E9F5)



와 같이 제대로 실행됨을 볼 수 있습니다.


한 가지 중요하게 살펴볼 점은, 두 개의 클래스를 한 파일에서 사용하기 때문에 클래스의 정의 순서가 매우 중요하다는 점입니다. 소스 상단에

```cpp-formatted
class Array;
class Int;
```



와 같이 클래스를 '선언' 하였습니다. 클래스를 선언하지 않는다면, 아래 `Array` 클래스에서

```cpp-formatted
friend Int;
```



를 할 수 없게 됩니다. 왜냐하면 컴파일러 입장에서 `Int` 가 뭔지 알 턱이 없기 때문입니다. 따라서 `friend` 선언을 하기 전에, 이와 같이 `class Int` 를 먼저 맨 위에 선언해서 사용할 수 있도록 해야 합니다. 그럼에도 불구하고, 맨 밑에


```cpp-formatted
Int Array::operator[](const int index) {
  return Int(index, 1, static_cast<void *>(top), this);
}
```



를 `Array` 클래스 안에 넣지 않고 따로 빼 놓은 이유는 `Int` 를 실제로 '이용' 하기 위해서는 클래스 선언 만으로 충분하지 않기 때문입니다. 클래스 선언을 통해서는 클래스의 내부 정보가 필요가 없는 것들, 예컨대 `friend` 선언이나 클래스의 포인터를 정의하는 등의 행동만 가능하지, 위 `Array` 처럼 구체적으로 `Int` 클래스의 내부 정보 (생성자) 를 사용하는 경우에는 반드시 `Int` 클래스의 정의가 선행 되어야만 합니다. 따라서 어쩔 수 없이 `Array` 클래스의 `operator[]` 만 따로 빼 놓았습니다.


자. 여러분들은 아주 훌륭한 `N` 차원 `Array` 클래스를 제작하게 된 것입니다. 정말 놀랍지 않나요? C 언어 배우던 시절에는 정말 상상 조차 할 수 없는 위력적인 기능이 아닐 수 없습니다. C++ 에서 연산자 오버로딩을 지원한 덕택에 이러한 것들을 만들 수 있게 된 것입니다. 하지만, 사실 약간 불편한 점은 하나 있습니다. 모든 원소에 접근하려면 `N` 중 `for` 문을 사용해주어야만 합니다.


사실 2차원이나 3차원 정도의 배열을 사용한다먼 `2~3` 중 `for` 문을 사용하는 것은 기꺼히 승낙할 수 있습니다. 하지만 여러분들 4 중 `for` 문은 한 번이라도 돌려보셨나요? 아마도 이 정도 `for` 문을 중첩해서 돌린다면 보기도 안좋을 뿐더러 복잡하기만 할 것입니다. 따라서, 우리의 `Array` 클래스에 또다른 기능으로,모든 원소들을 순차적으로 접근할 수 있는 **반복자(iterator)** 라는 것을 추가해보도록 할 것입니다.


이를 위해 `Array` 에 `Iterator` 라는 클래스를 추가할 것입니다.

```cpp-formatted
class Iterator {
  int* location;
  Array* arr;
}
```



이 `iterator` 는 배열의 특정한 원소에 대한 포인터라고 생각하면 됩니다. C 언어에서 배열의 어떤 원소를 가리키고 있는 포인터 `ptr` 에 `ptr ++` 을 했다면 다음 원소를 가리켰듯이, 반복자 `itr` 이 `Array` 의 어느 원소를 가리키고 있을 때 `itr ++` 을 하면 그 다음 원소를 가리키게 됩니다. 따라서 사용자는 `N` 중 `for` 문을 사용해서 전체 원소를 참조하는 방법 보다는 단순히 `itr` 을 이용해서 `Array` 의 첫 원소 부터 `itr ++` 을 통해 마지막 원소까지 가리킬 수 있게 할 것입니다.


이를 위해서, 우리의 `Iterator` 클래스에, 현재 `Iterator` 가 어떤 원소를 가리키고 있는지에 대한 정보를 멤버 변수로 가지게 하겠습니다. 이는 `int * location` 에 배열로 보관되는데, 예를 들어 3 차원 배열에서 `Iterator` 가

```cpp-formatted
arr[1][2][3]
```



을 가리키고 있다면 `location` 배열에는 `{1,2,3}` 이렇게 들어가게 되는 것이지요. 상당히 단순한 방법이지요? 그렇기 때문에 `operator++()` 함수 자체도 매우 간단하게 만들 수 있습니다.

```cpp-formatted
Iterator& operator++() {
  if (location[0] >= arr->size[0]) return (*this);

  bool carry = false;  // 받아 올림이 있는지
  int i = arr->dim - 1;
  do {
    // 어차피 다시 돌아온다는 것은 carry 가 true
    // 라는 의미 이므로 ++ 을 해야 한다.
    location[i]++;
    if (location[i] >= arr->size[i] && i >= 1) {
      // i 가 0 일 경우 0 으로 만들지 않는다 (이러면 begin 과 중복됨)
      location[i] -= arr->size[i];
      carry = true;
      i--;
    } else
      carry = false;

  } while (i >= 0 && carry);

  return (*this);
}
```



어떻게 위와 같은 코드가 나왔냐면 예를 들어 우리가 `[2][3][4]` 의 크기를 가지는 배열을 선언했다고 해봅시다. 그리고 어떤 `itr` 가 현재 원소 `[1][1][3]` 을 가리키고 있다고 해봅시다. 그럼 `itr ++` 을 하게 된다면 `[1][1][4]` 가 되는 것이 아니라, 받아 올림이 되며 `[1][2][0]` 이 되겠지요.


이번에는 `itr` 가 `[0][2][3]` 인 상태에서 `itr ++` 을 하면 어떨까요? 일단 `[0][2][4]` 가 되는 것이 아니라 1 받아 올림 되며 `[0][3][0]` 이 되는데, 3 역시 받아 올림 되서 `[1][0][0]` 이 되겠지요? 이와 같은 과정을 위에서 `do - while` 문으로 처리하였습니다. `bool` 변수 `carry` 는 '받아 올림이 있다' 라는 의미 입니다.


참고로 `[1][2][3]` 은 이 배열의 맨 마지막 원소가 됩니다. 그런데 여기서 `itr ++` 을 하면, 원칙상 `[0][0][0]` 이 되어야 하는데, 이렇게 된다면, 이 배열을 사용하는 사람 입장에서 상당히 골치 아파 집니다. 왜냐하면 C++ 의 거의 대부분의 라이브러리에서 그러하지만 어떠한 배열의 시작(begin)은 맨 첫번째 원소를 의미하고, 마지막(end)은 맨 마지막 원소 바로 다음을 의미하기 때문입니다.


만일 우리가 배열의 처음 부터 마지막 까지 쭉 참조해 나가고 싶은데, 마지막 원소 다음에 다시 맨 처음 원소로 돌아온다면 `for` 문에 입장에서 이게 다시 돌아온 것인지, 새로 시작 하는 것인지 구별을 할 수 없기 때문입니다. 하지만 마지막 원소 다음을 '마지막' 이라 한다면, `for` 문의 조건문으로 '마지막에 도달하면 끝내라' 이렇게 명령을 한다면 쉽게 해결할 수 있습니다.


그러한 이유에서, 우리의 `iterator` 는 `[1][2][3]` 다음에는 `[0][0][0]` 이 아닌 `[2][0][0]` 이라 하고, (물론 여기에 해당하는 원소는 당연히 없습니다.) 이를 '마지막' 이라 하기로 하였습니다. 물론 마지막의 값을 참조하려고 하면 오류가 발생하겠지요.


이렇기 때문에 `do - while` 문 안에서도 특별히

```cpp-formatted
if (location[i] >= arr->size[i] && i >= 1) {
  // i 가 0 일 경우 0 으로 만들지 않는다 (이러면 begin 과 중복됨)
  location[i] -= arr->size[i];
  carry = true;
  i--;
} else
  carry = false;
```


에서 `location[i] >= arr->size[i]` 말고도 `i >= 1` 이라는 특별한 조건을 넣어서 처리하도록 하였습니다.


참고로, 전위 증가 연산자를 만들었으므로 후위 증가 연산자도 만드는 것을 잊지 마세요.

```cpp-formatted
Iterator& operator++(int) {
  ++(*this);
  return (*this);
}
```



그렇다면 가장 중요한 `*` 연산자는 어떨까요. (*itr) 을 통해 실제 데이터에 접근해야 하므로, `Int` 를 리턴하게 됩니다. 따라서 그 모양은 다음과 같겠지요.

```cpp-formatted
Int Array::Iterator::operator*() {
  Int start = arr->operator[](location[0]);
  for (int i = 1; i <= arr->dim - 1; i++) {
    start = start.operator[](location[i]);
  }
  return start;
}
```



그냥 우리가 `arr[][][]` 해주던 일을 그냥 `for` 문으로 하는 것에 불과하다는 점을 알 수 있습니다. 매우 간단하지요.


이제 `Array` 클래스에 현재 배열의 시작과 끝을 `Iterator` 객체로 리턴해주는 것만 만들어주면 됩니다. 각각을 `begin` 와 `end` 라고 해보면;

```cpp-formatted
Iterator begin() {
  int* arr = new int[dim];
  for (int i = 0; i != dim; i++) arr[i] = 0;

  Iterator temp(this, arr);
  delete[] arr;

  return temp;
}
Iterator end() {
  int* arr = new int[dim];
  arr[0] = size[0];
  for (int i = 1; i < dim; i++) arr[i] = 0;

  Iterator temp(this, arr);
  delete[] arr;

  return temp;
}
```



매우 단순합니다. `begin` 은 그냥 `{0, 0, ... 0}` 인 `Iterator` 를 리턴해주면 되는 것이고, `end` 는 `{size[0], 0, 0, .. 0}` 을 인 `Iterator` 를 리턴해주면 되는 것이니까요.


그럼 전체 소스 코드는 아래와 같습니다.



```cpp-formatted
// 대망의 N 차원 배열
#include <iostream>
using namespace std;

class Array;
class Int;
class Iterator;

class Array {
  friend Int;
  friend Iterator;

  const int dim;  // 몇 차원 배열 인지
  int* size;  // size[0] * size[1] * ... * size[dim - 1] 짜리 배열이다.

  struct Address {
    int level;
    // 맨 마지막 레벨(dim - 1 레벨) 은 데이터 배열을 가리키고, 그 위 상위
    // 레벨에서는 다음 Address 배열을 가리킨다.
    void* next;
  };

  Address* top;

 public:
  class Iterator {
    int* location;
    Array* arr;

    friend Int;

   public:
    Iterator(Array* arr, int* loc = NULL) : arr(arr) {
      location = new int[arr->dim];
      for (int i = 0; i != arr->dim; i++)
        location[i] = (loc != NULL ? loc[i] : 0);
    }
    Iterator(const Iterator& itr) : arr(itr.arr) {
      location = new int[arr->dim];
      for (int i = 0; i != arr->dim; i++) location[i] = itr.location[i];
    }
    ~Iterator() { delete[] location; }
    // 다음 원소를 가리키게 된다.
    Iterator& operator++() {
      if (location[0] >= arr->size[0]) return (*this);

      bool carry = false;  // 받아 올림이 있는지
      int i = arr->dim - 1;
      do {
        // 어차피 다시 돌아온다는 것은 carry 가 true
        // 라는 의미 이므로 ++ 을 해야 한다.
        location[i]++;
        if (location[i] >= arr->size[i] && i >= 1) {
          // i 가 0 일 경우 0 으로 만들지 않는다 (이러면 begin 과 중복됨)
          location[i] -= arr->size[i];
          carry = true;
          i--;
        } else
          carry = false;

      } while (i >= 0 && carry);

      return (*this);
    }
    Iterator& operator=(const Iterator& itr) {
      arr = itr.arr;
      location = new int[itr.arr->dim];
      for (int i = 0; i != arr->dim; i++) location[i] = itr.location[i];

      return (*this);
    }
    Iterator& operator++(int) {
      ++(*this);
      return (*this);
    }
    bool operator!=(const Iterator& itr) {
      if (itr.arr->dim != arr->dim) return true;

      for (int i = 0; i != arr->dim; i++) {
        if (itr.location[i] != location[i]) return true;
      }

      return false;
    }
    Int operator*();
  };
  Array(int dim, int* array_size) : dim(dim) {
    size = new int[dim];
    for (int i = 0; i < dim; i++) size[i] = array_size[i];

    top = new Address;
    top->level = 0;

    initialize_address(top);
  }
  Array(const Array& arr) : dim(arr.dim) {
    size = new int[dim];
    for (int i = 0; i < dim; i++) size[i] = arr.size[i];

    top = new Address;
    top->level = 0;

    initialize_address(top);
  }
  // address 를 초기화 하는 함수이다. 재귀 호출로 구성되어 있다.
  void initialize_address(Address* current) {
    if (!current) return;
    if (current->level == dim - 1) {
      current->next = new int[size[current->level]];
      return;
    }
    current->next = new Address[size[current->level]];
    for (int i = 0; i != size[current->level]; i++) {
      (static_cast<Address*>(current->next) + i)->level = current->level + 1;
      initialize_address(static_cast<Address*>(current->next) + i);
    }
  }
  void delete_address(Address* current) {
    if (!current) return;
    for (int i = 0; current->level < dim - 1 && i < size[current->level]; i++) {
      delete_address(static_cast<Address*>(current->next) + i);
    }

    delete[] current->next;
  }
  Int operator[](const int index);
  ~Array() {
    delete_address(top);
    delete[] size;
  }

  Iterator begin() {
    int* arr = new int[dim];
    for (int i = 0; i != dim; i++) arr[i] = 0;

    Iterator temp(this, arr);
    delete[] arr;

    return temp;
  }
  Iterator end() {
    int* arr = new int[dim];
    arr[0] = size[0];
    for (int i = 1; i < dim; i++) arr[i] = 0;

    Iterator temp(this, arr);
    delete[] arr;

    return temp;
  }
};
class Int {
  void* data;

  int level;
  Array* array;

 public:
  Int(int index, int _level = 0, void* _data = NULL, Array* _array = NULL)
      : level(_level), data(_data), array(_array) {
    if (_level < 1 || index >= array->size[_level - 1]) {
      data = NULL;
      return;
    }
    if (level == array->dim) {
      // 이제 data 에 우리의 int 자료형을 저장하도록 해야 한다.
      data = static_cast<void*>(
        (static_cast<int*>(static_cast<Array::Address*>(data)->next) + index));
    } else {
      // 그렇지 않을 경우 data 에 그냥 다음 addr 을 넣어준다.
      data = static_cast<void*>(
        static_cast<Array::Address*>(static_cast<Array::Address*>(data)->next) +
        index);
    }
  };

  Int(const Int& i) : data(i.data), level(i.level), array(i.array) {}

  operator int() {
    if (data) return *static_cast<int*>(data);
    return 0;
  }
  Int& operator=(const int& a) {
    if (data) *static_cast<int*>(data) = a;
    return *this;
  }

  Int operator[](const int index) {
    if (!data) return 0;
    return Int(index, level + 1, data, array);
  }
};
Int Array::operator[](const int index) {
  return Int(index, 1, static_cast<void*>(top), this);
}
Int Array::Iterator::operator*() {
  Int start = arr->operator[](location[0]);
  for (int i = 1; i <= arr->dim - 1; i++) {
    start = start.operator[](location[i]);
  }
  return start;
}
int main() {
  int size[] = {2, 3, 4};
  Array arr(3, size);

  Array::Iterator itr = arr.begin();
  for (int i = 0; itr != arr.end(); itr++, i++) (*itr) = i;
  for (itr = arr.begin(); itr != arr.end(); itr++) cout << *itr << endl;

  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
      for (int k = 0; k < 4; k++) {
        arr[i][j][k] = (i + 1) * (j + 1) * (k + 1) + arr[i][j][k];
      }
    }
  }
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
      for (int k = 0; k < 4; k++) {
        cout << i << " " << j << " " << k << " " << arr[i][j][k] << endl;
      }
    }
  }
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F251B68445226200506DD10)



와 같이 잘 실행됨을 알 수 있습니다. 한 가지 눈여겨 볼 점은


```cpp-formatted
Array::Iterator itr = arr.begin();
for (int i = 0; itr != arr.end(); itr++, i++) (*itr) = i;
```



와 같이 수행하는 부분입니다. 이와 같이 반복자를 이용하는 것은 C++ 에서 매우 많이 사용 되고 있는 방법으로, 나중에 표준 라이브러리들에 대해 살펴볼 때 다시 한번 등장하게 됩니다.


자 여러분 수고하셨습니다! 아마 이번 강좌는 제가 여태까지 진행한 강좌 중에 가장 어려웠고 저도 설명하기에 가장 어려운 내용이 아니였나 싶네요. 다음 강좌에서는 C++ 의 또 다른 쇼킹할 만한 기능들에 대해 살펴보도록 하겠습니다. 감사합니다.






###  생각해보기

#### 문제 1

앞서 `N` 차원 배열을 구현하는 또 다른 방법 (그냥 `x1 * ... * xn` 개의 1 차원 배열을 만든 뒤에, `[]` 연산자를 위와 같이 특별한 방법을 이용하여 접근할 수 있게 하는 것) 으로 `N` 차원 배열을 구현해봅시다. (난이도 : 上)

##@ chewing-cpp-end
Link :  205
2013-08-29 18:15
Link :  203
2013-08-29 02:13
----------------
title : 씹어먹는 C++ - <5 - 2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩>
cat_title: 5 - 2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩
next_page : 204
publish_date : 2013-08-29 02:13
--------------

이번 강좌에서는

* 멤버 함수가 아닌 연산자 함수 오버로딩
* 입출력 연산자 오버로딩 (정확히 보면 `<<, >>` 연산자)
* 첨자 연산자 `[]` 오버로딩
* 타입 변환 연산자 오버로딩
* 증감 연산자 `++, --` 오버로딩

에 대해 다룹니다.



![](/img/ChewingCpplogo.png)



안녕하세요 여러분. 잘 지내셨나요? 올해 안으로 C++ 강좌를 끝내기 위한 노력의 일환으로 강좌를 열심히 업로드 하려고 노력중인 Psi 입니다. 그래도 강좌를 읽으시는 여러분들은 꼼꼼히 읽어보시고, 궁금하신 점들은 꼭 댓글로 남겨 주시거나 메일로 질문해 주시기 바랍니다 :)


지난 강좌에서, 마지막에 다음과 같은 문제점을 지적하였습니다.

```cpp-formatted
a = a + "-1.1 + i3.923";  // ①
```



는 잘 컴파일 되서 실행되지만

```cpp-formatted
a = "-1.1 + i3.923" + a;  // ②
```



는 컴파일 되지 않습니다. 왜냐하면, ① 의 경우 `a.operator+("i3.923");` 으로 변환될 수 있지만 ② 는 그렇지 못하기 때문이죠. 하지만, 원칙적으로  클래스를 사용하는 사용자의 입장에서① 이 된다면 당연히② 도 수행될 수 있어야 연산자 오버로딩을 하는 명분이 생깁니다. 다행 스럽게도, 사실 컴파일러는 이항 연산자 (피연산자를 두 개를 취하는 연산자 `-` 예를 들어서 `+, -, *, /, ->, =` 등이 이항 연산자 이다) 를 다음과 같은 두 개의 방식으로 해석합니다.


어떤 임의의 연산자 `@` 에 대해서, `a@b` 는 \sidenote{C++ 에 @ 연산자는 없지만, 여기서 '임의의 연산자' 를 나타내기 위해 잠시 사용하겠습니다.}

```cpp-formatted
*a.operator@(b);
*operator@(a, b);
```

두 가지 방법으로 해석됩니다.

\sidenote{참고로 이는 일부 연산자들에 대해서는 해당되지 않는데 대표적으로 [] 연산자 (첨자), -> 연산자 (멤버 접근), 대입 연산자 (=), () 함수 호출 연산자들의 경우 멤버 함수로만 존재할 수 있습니다. 즉, 따로 멤버 함수가 아닌 전역 함수로 뺄 수 없다는 의미 입니다. 따라서 이들 함수를 오버로딩 할 때 주의하시기 바랍니다.}

즉, 컴파일 시에 둘 중 하나의 가장 가까운 것을 택해서 처리됩니다. `a.operator@(b)` 에서의 `operator@` 는 `a` 의 클래스의 멤버 변수로써 사용되는 것이고, `operator@(a,b)` 에서의 `operator@` 는 그냥 일반적인 함수를 의미하게 됩니다. 따라서 이를 처리하기 위해 함수를 정의하여 봅시다.

```cpp-formatted
Complex operator+(const Complex& a, const Complex& b) {
  Complex temp(a);
  return temp.operator+(b);
}
```



우리의 또 다른 `operator+` 는 두 개의 `const Complex&` 타입의 인자 `a,b` 를 받게 됩니다. 앞에서도 말했지만 컴파일러는 정확히 일치 하지 않는 경우, 가장 가까운 '가능한' 오버로딩 되는 함수를 찾게 되는데, 마침 우리에게는 `Complex(const char *)` 타입의 생성자가 있으므로,

```cpp-formatted
"-1.1 + i3.923" + a;
```



는

```cpp-formatted
operator+(Complex("-1.1 + i3.923"), a);
```



가 되어서 잘 실행되게 됩니다. 실제로 컴파일 해보면

```cpp-formatted
#include <iostream>
using namespace std;

class Complex {
 private:
  double real, img;

  double get_number(const char* str, int from, int to);

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }
  Complex(const char* str);

  Complex operator+(const Complex& c);
  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  Complex& operator+=(const Complex& c);
  Complex& operator-=(const Complex& c);
  Complex& operator*=(const Complex& c);
  Complex& operator/=(const Complex& c);

  Complex& operator=(const Complex& c);

  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};
Complex operator+(const Complex& a, const Complex& b) {
  Complex temp(a);
  return temp.operator+(b);
}
Complex::Complex(const char* str) {
  // 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
  // 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
  // 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

  int begin = 0, end = strlen(str);
  img = 0.0;
  real = 0.0;

  // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
  int pos_i = -1;
  for (int i = 0; i != end; i++) {
    if (str[i] == 'i') {
      pos_i = i;
      break;
    }
  }

  // 만일 'i' 가 없다면 이 수는 실수 뿐이다.
  if (pos_i == -1) {
    real = get_number(str, begin, end - 1);
    return;
  }

  // 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
  real = get_number(str, begin, pos_i - 1);
  img = get_number(str, pos_i + 1, end - 1);

  if (pos_i >= 1 && str[pos_i - 1] == '-') img *= -1.0;
}
double Complex::get_number(const char* str, int from, int to) {
  bool minus = false;
  if (from > to) return 0;

  if (str[from] == '-') minus = true;
  if (str[from] == '-' || str[from] == '+') from++;

  double num = 0.0;
  double decimal = 1.0;

  bool integer_part = true;
  for (int i = from; i <= to; i++) {
    if (isdigit(str[i]) && integer_part) {
      num *= 10.0;
      num += (str[i] - '0');
    } else if (str[i] == '.')
      integer_part = false;
    else if (isdigit(str[i]) && !integer_part) {
      decimal /= 10.0;
      num += ((str[i] - '0') * decimal);
    } else
      break;  // 그 이외의 이상한 문자들이 올 경우
  }

  if (minus) num *= -1.0;

  return num;
}
Complex Complex::operator+(const Complex& c) {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}

Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
Complex& Complex::operator=(const Complex& c) {
  real = c.real;
  img = c.img;
  return *this;
}

int main() {
  Complex a(0, 0);
  a = "-1.1 + i3.923" + a;
  a.println();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F2434EE495218CD59169D96)



와 같이 잘 실행됨을 알 수 있습니다. 그런데, 아마 `operator+` 를 자세히 살펴보신 분들은 아마 다음과 같은 문제점을 확인할 수 있었을 것입니다.

```cpp-formatted
Complex operator+(const Complex& a, const Complex& b) {
  Complex temp(a);
  return temp.operator+(b);
}
```



왜 굳이 귀찮게 `temp` 라는 새로운 `Complex` 객체를 정의하여서 `temp` 와의 `+` 연산을 리턴하느냐 입니다. 그냥 `a + b` 할 것을 불필요 하게 복사 생성을 한 번 더 하게 되서 성능의 하락이 발생하게 됩니다. 하지만, 그냥 `a + b` 를 하게 된다면;

```cpp-formatted
Complex operator+(const Complex& a, const Complex& b) { return a + b; }
```



위 코드를 컴파일 시에 다음과 같은 경고 메세지를 볼 수 있을 것입니다.

```warning
warning C4717: 'operator+' : recursive on all control paths, function will cause runtime stack overflow
```



즉, `a + b` 에서 `a.operator+(b)` 가 호출되는 것이 아니라, `operator+(a,b)` 가 호출 되기 때문에 재귀적으로 무한히 많이 함수가 호출되어 오류가 발생한다는 것이지요. 실제로 실행해 보아도 프로그램이 강제로 종료되는 모습을 볼 수 있습니다. 따라서 이와 같은 문제를 방지하기 위해서 우리는 다음과 같이 강제로 멤버 함수 `operator+` 를 호출하도록 지정하였습니다.

```cpp-formatted
Complex operator+(const Complex& a, const Complex& b) { return a.operator+(b); }
```



이 역시 컴파일 되지 않습니다. 아마 오류의 내용은 다음과 같을 것입니다.

```warning
error C2662: 'Complex::operator +' : cannot convert 'this' pointer from 'const Complex' to 'Complex &'
```



이 말은 즉슨, `a` 가 `const Complex` 인데, 우리가 호출하고자 하는 멤버 함수 `operator+` 는 `const` 함수가 아니기 때문입니다. 상당히 골치아픈 문제가 아닐 수 없습니다. (참고로 [const 함수가 무엇인지 기억이 나지 않으시는 분들은 이 강좌](http://itguru.tistory.com/197)를 다시 읽어보시기 바랍니다)

`const` 객체는 언제나 값이 바뀔 수 없으며, 만일 `const` 객체의 멤버 함수 호출 시에는 그 함수가 객체의 값을 바꾸지 않는 다고 보장할 수 있도록 `const` 함수여야만 합니다. 하지만 멤버 함수 `operator+` 는 `const` 성이 없으므로, `operator+` 를 호출하는 것은 불가능 해지지요.


이 문제를 해결할 수 있는 유일한 방법은`Complex operator+(const Complex& a, const Complex& b)` 내부에서 다른 함수들을 호출하지 않고 직접 덧셈을 수행하면 됩니다. 다만 이 방법도 문제가 있지요. 멤버 함수가 아닌 외부 함수 `operator+` 에서 객체의 `private` 정보에 접근할 수 있어야만 하는데, 이 것이 불가능 하기 때문입니다. 하지만, 놀랍게도 C++ 에서는 이를 가능케 하는 키워드가 있습니다.



###  friend 는 모든 것을 공유한다.


아마 이 글을 읽는 독자 여러분들은 자신의 모든 것을 아낌없이 털어놓을 수 있는 절친한 친구 한 두 명 쯤은 있을 것입니다. 그 친구와 나 사이에는 어떠한 정보도 열람할 수 있는 관계가 되지요.
그런데 재미있는 사실에는 비슷한 역할을 하는 키워드가 C++ 에도 있다는 점입니다. 그 이름도 역시 **friend** 입니다.

```cpp-formatted
class Complex {
 private:
  double real, img;

  double get_number(const char* str, int from, int to);

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }
  Complex(const char* str);

  Complex operator+(const Complex& c);
  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  Complex& operator+=(const Complex& c);
  Complex& operator-=(const Complex& c);
  Complex& operator*=(const Complex& c);
  Complex& operator/=(const Complex& c);

  Complex& operator=(const Complex& c);

  friend Complex operator+(const Complex& a, const Complex& b);

  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};
```



위와 같이 `Complex` 클래스 안에서

```cpp-formatted
friend Complex operator+(const Complex& a, const Complex& b);
```


라 같이 쓰면 우리의`Complex operator+(const Complex& a, const Complex& b);`  함수는 이제 `Complex` 의 `friend` 가 됩니다. 즉, `Complex` 클래스의 입장에서는 자신의 새로운 친구인 `operator+` 에게 마음의 문을 열고 모든 정보에 접근할 수 있도록 허가하는 것입니다.

`private` 냐 `public` 이냐에 관계 없이`Complex operator+(const Complex& a, const Complex&` b); 함수는 이제 어떤 `Complex` 객체라도 그 내부 정보에 접근할 수 있습니다.


따라서, 다음과 같은 코드를 사용하는 것도 가능하지요.

```cpp-formatted
Complex operator+(const Complex& a, const Complex& b) {
  Complex temp(a.real + b.real, a.img + b.img);
  return temp;
}
```



이제 이 `operator+` 함수는 마치 `Complex` 클래스의 멤버 변수인양, 객체들의 정보에 접근할 수 있게 됩니다. `real` 변수는 `private` 이지만, `a.real` 을 해도 무방하지요. 이렇게 된다면, 이전의 `operator+` 에서 불필요하게 `temp` 객체를 생성했던 것 과는 달리 필요한 것만 사용하면 됩니다.


한 가지 재미 있는 사실은 `friend` 키워드는 함수에만 적용할 수 있는 것이 아니라, 다른 클래스 자체도 `friend` 로 지정할 수 있습니다. 예를 들어서,

```cpp-formatted
class A {
 private:
  int x;

  friend B;
};

class B {
 private:
  int y;
};
```



와 같이 할 경우, `A` 는 `B` 를 `friend` 로 지정하게 된 것입니다. 한 가지 주의할 사실은, 우리가 흔히 생각하는 friend 관계와는 다르게, C++ 에서 friend 는 짝사랑과 비슷합니다. 즉, `A` 는 자기 생각에 `B` 가 `friend` 라고 생각하는 것이므로, `B` 에게 `A` 의 모든 것을 공개합니다.

즉 클래스 `B` 에서 `A` 의 `private` 변수인 `x` 에 접근할 수 있게 됩니다. 하지만 `B` 에는 `A` 가 `friend` 라고 지정하지 않았으므로, `B` 의 입장에서는 `A` 에게 어떠한 내용도 공개하지 않습니다 (public 변수들 빼고). 따라서 `A` 는 `B` 의 `private` 변수인 `int y` 에 접근할 수 없게 됩니다.






###  입출력 연산자 오버로딩 하기




아마도, 눈치를 채신 분들이 있겠지만 우리가

```cpp-formatted
cout << a;
```



라고 하는 것은 사실 `cout.operator<<(a)` 를 하는 것과 동일한 명령이었습니다. 즉, 어떤 `cout` 이라는 객체에 멤버 함수 `operator<<` 가 정의되어 있어서 `a` 를 호출하게 되는 것이지요. 그런데, `cout` 이 `int` 나 `double` 변수, 심지어 문자열 까지 자유 자재로 `operator<<` 하나로 출력할 수 있었던 이유는 그 많은 수의 `operator<<` 함수들이 오버로딩 되어 있다는 뜻입니다.


실제로 우리가 `include` 하던 `iostream` 의 헤더파일의 내용을 살펴보면 (실제로는 `ostream` 에 정의되어 있습니다. 다만 `iostream` 이 `ostream` 을 `include` 하고 있음) `ostream` 클래스에

```cpp-formatted
ostream& operator<<(bool val);
ostream& operator<<(short val);
ostream& operator<<(unsigned short val);
ostream& operator<<(int val);
ostream& operator<<(unsigned int val);
ostream& operator<<(long val);
ostream& operator<<(unsigned long val);
ostream& operator<<(float val);
ostream& operator<<(double val);
ostream& operator<<(long double val);
ostream& operator<<(void* val);
```



와 같이 엄청난 수의 `operator<<` 가 정의되어 있는 것을 알 수 있습니다. 이들 덕분에 우리가 편하게 인자의 타입에 관계없이 손쉽게 출력을 사용할 수 있게 되는 것이지요.


그렇다면 한 번 우리의 `Complex` 클래스에서 `ostream` 클래스의 연산자 `operator<<` 를 자유롭게 사용할 수 있으면 어떨까요. 예를 들어서

```cpp-formatted
Complex c;
cout << c;
```



를 하게 되면 마치

```cpp-formatted
Complex c;
c.println();
```



을 한 것과 같은 효과를 내도록 말이지요. 당연하게도, `ostream` 클래스에 `operator<<` 멤버 함수를 새롭게 추가하는 것은 불가능 합니다. 이는 표준 헤더파일의 내용을 수정하는 것과 같기 때문이죠. 대부분의 경우 표준 헤더파일은 읽기만 가능이고, 원칙적으로 표준 라이브러리의 내용을 수정하는 것은 좋지 않습니다 (정확히 말하면 하면 안됩니다!). 따라서, 우리는 `ostream` 클래스에 `Complex` 객체를 오버로딩하는 `operator<<` 연산자 함수를 추가할 수는 없지요.


그 대신에, 여태 까지 배운 내용에 따르면 아예 `operator<<` 전역 함수 하나를 정해서 `Complex` 의 `friend` 로 지정한 다음에 사용할 수 있습니다. 그 함수는 아마 다음과 같이 생겼겟지요.

```cpp-formatted
ostream& operator<<(ostream& os, const Complex& c) {
  os << "( " << c.real << " , " << c.img << " ) ";
  return os;
}
```



여기서 왜 `cout` 이 아니고 `os` 라고 의문을 가질 수 도 있는데, `cout` 자체가 `iostream` 에서 하나 만들어 놓은 `ostream` 객체 입니다. 따라서 `ostream&` 타입으로 `cout` 객체를 받아서 이를 출력하면 됩니다. 마찬가지로, `Complex` 클래스 내부에서 `friend` 선언을 해주시면 됩니다. 참고로 `opreator<<` 에서 `ostream&` 타입을 리턴하는 이유는 다음과 같은 문장을 처리할 수 있기 위해서입니다.

```cpp-formatted
cout << "a 의 값은 : " << a << " 이다. " << endl;
```



`<<` 연산자는 왼쪽 부터 오른쪽 순으로 실행되기 때문에 가장 먼저 `cout.operator<<("a 의 값은?")` 이 실행되고, 그 자리에 `cout` 이 다시 리턴됩니다. 그 다음에는 `cout.operator<<(a);` 가 되서 쭉쭉 이어질 수 있도록 이와 같이 `ostream&` 를 리턴하게 되는 것입니다. 참고로, `Complex` 클래스 내부에는

```cpp-formatted
friend ostream& operator<<(ostream& os, const Complex& c);
```



위와 같이 `friend` 선언을 해주시면 됩니다. 비슷한 방법으로 `Complex` 객체 `c` 에 대해 `cin >>` c; 와 같은 작업을 할 수 있습니다. 다만, 이번에는 `cin` 은 `istream` 객체이고, `opreator>>` 를 오버로딩 해야 된다는 점이 다를 뿐이지요.

```cpp-formatted
#include <iostream>
using namespace std;
class Complex {
 private:
  double real, img;

  double get_number(const char* str, int from, int to);

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }
  Complex(const char* str);

  Complex operator+(const Complex& c);
  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  Complex& operator+=(const Complex& c);
  Complex& operator-=(const Complex& c);
  Complex& operator*=(const Complex& c);
  Complex& operator/=(const Complex& c);

  Complex& operator=(const Complex& c);

  friend Complex operator+(const Complex& a, const Complex& b);
  friend ostream& operator<<(ostream& os, const Complex& c);

  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};
ostream& operator<<(ostream& os, const Complex& c) {
  os << "( " << c.real << " , " << c.img << " ) ";
  return os;
}
Complex operator+(const Complex& a, const Complex& b) {
  Complex temp(a.real + b.real, a.img + b.img);
  return temp;
}
Complex::Complex(const char* str) {
  // 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
  // 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
  // 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

  int begin = 0, end = strlen(str);
  img = 0.0;
  real = 0.0;

  // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
  int pos_i = -1;
  for (int i = 0; i != end; i++) {
    if (str[i] == 'i') {
      pos_i = i;
      break;
    }
  }

  // 만일 'i' 가 없다면 이 수는 실수 뿐이다.
  if (pos_i == -1) {
    real = get_number(str, begin, end - 1);
    return;
  }

  // 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
  real = get_number(str, begin, pos_i - 1);
  img = get_number(str, pos_i + 1, end - 1);

  if (pos_i >= 1 && str[pos_i - 1] == '-') img *= -1.0;
}
double Complex::get_number(const char* str, int from, int to) {
  bool minus = false;
  if (from > to) return 0;

  if (str[from] == '-') minus = true;
  if (str[from] == '-' || str[from] == '+') from++;

  double num = 0.0;
  double decimal = 1.0;

  bool integer_part = true;
  for (int i = from; i <= to; i++) {
    if (isdigit(str[i]) && integer_part) {
      num *= 10.0;
      num += (str[i] - '0');
    } else if (str[i] == '.')
      integer_part = false;
    else if (isdigit(str[i]) && !integer_part) {
      decimal /= 10.0;
      num += ((str[i] - '0') * decimal);
    } else
      break;  // 그 이외의 이상한 문자들이 올 경우
  }

  if (minus) num *= -1.0;

  return num;
}
Complex Complex::operator+(const Complex& c) {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}

Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
Complex& Complex::operator=(const Complex& c) {
  real = c.real;
  img = c.img;
  return *this;
}

int main() {
  Complex a(0, 0);
  a = "-1.1 + i3.923" + a;
  cout << "a 의 값은 : " << a << " 이다. " << endl;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2716843D521A1746343770)



와 같이 잘 실행됨을 알 수 있습니다.







###  첨자 연산자 (operator[])


이번에는 배열에서 원소를 지정할 때 사용되는 첨자 연산자 `[]` 를 오버로딩 해보도록 합시다. \sidenote{참고로 왜 첨자 연산자라고 부르냐면, 배열의 원소를 지정할 때 [] 안에 넣는 수를 첨자(subscript) 라고 부르기 때문입니다} 우리가 전에 만들었던 `MyString` 클래스에서 개개의 문자에 접근하기 위해 `[]` 를 지원해주어야만 하는데요, `[]` 를 이용해서 `str[10]` 과 같이 10 번째 문자에 정확하게 접근할 수 있게 됩니다.

여기서 그렇다면 `MyString` 클래스의 `operator[]` 를 추가해보도록 합시다. `operator[]` 함수는 자명하게도 인자로 몇 번째 문자인지, `int` 형 변수를 인덱스로 받게 됩니다. 따라서 `operator[]` 는 다음과 같은 원형을 가집니다.

```cpp-formatted
char& operator[](const int index);
```



`index` 로 `[]` 안에 들어가는 값을 받게 됩니다. 그리고 `char&` 를 인자로 리턴하는 이유는

```cpp-formatted
str[10] = 'c';
```



와 같은 명령을 수행하기 때문에, 그 원소의 레퍼런스를 리턴하게 되는 것이지요. 실제로 `opreator[]` 의 구현은 아래와 같이 매우 단순합니다.

```cpp-formatted
char& MyString::operator[](const int index) { return string_content[index]; }
```



위와 같이 `index` 번째의 `string_content` 를 리턴해서, `operator[]` 를 사용하는 사용자가, 이의 레퍼런스를 가질 수 있게 되지요. 그렇다면, 전체 소스를 한 번 살펴보도록 합시다.

```cpp-formatted
#include <iostream>
using namespace std;

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  // 문자 하나로 생성
  MyString(char c);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length();
  int capacity();
  void reserve(int size);

  void print();
  void println();

  MyString& assign(MyString& str);
  MyString& assign(const char* str);

  char at(int i);
  char& operator[](const int index);

  MyString& insert(int loc, MyString& str);
  MyString& insert(int loc, const char* str);
  MyString& insert(int loc, char c);

  MyString& erase(int loc, int num);

  int find(int find_from, MyString& str);
  int find(int find_from, const char* str);
  int find(int find_from, char c);

  int compare(MyString& str);
};

MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
  memory_capacity = 1;
  string_length = 1;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

MyString& MyString::assign(MyString& str) {
  if (str.string_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
    memory_capacity = str.string_length;
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
    memory_capacity = str_length;
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
int MyString::capacity() { return memory_capacity; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char* prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    delete[] prev_string_content;
  }

  // 만일 예약하려는 size 가 현재 capacity 보다 작다면
  // 아무것도 안해도 된다.
}
char MyString::at(int i) {
  if (i >= string_length || i < 0)
    return NULL;
  else
    return string_content[i];
}
char& MyString::operator[](const int index) { return string_content[index]; }
MyString& MyString::insert(int loc, MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.

    if (memory_capacity * 2 > string_length + str.string_length)
      memory_capacity *= 2;
    elsememory_capacity = string_length + str.string_length;

    char* prev_string_content = string_content;
    string_content = new char[memory_capacity];

    // 일단 insert 되는 부분 직전까지의 내용을 복사한다.
    int i;
    for (i = 0; i < loc; i++) {
      string_content[i] = prev_string_content[i];
    }

    // 그리고 새롭에 insert 되는 문자열을 넣는다.
    for (int j = 0; j != str.string_length; j++) {
      string_content[i + j] = str.string_content[j];
    }

    // 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
    for (; i < string_length; i++) {
      string_content[str.string_length + i] = prev_string_content[i];
    }

    delete[] prev_string_content;

    string_length = string_length + str.string_length;
    return *this;
  }

  // 만일 초과하지 않는 경우 굳이 동적할당을 할 필요가 없게 된다.
  // 효율적으로 insert 하기 위해, 밀리는 부분을 먼저 뒤로 밀어버린다.

  for (int i = string_length - 1; i >= loc; i--) {
    // 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
    string_content[i + str.string_length] = string_content[i];
  }
  // 그리고 insert 되는 문자 다시 집어넣기
  for (int i = 0; i < str.string_length; i++)
    string_content[i + loc] = str.string_content[i];

  string_length = string_length + str.string_length;
  return *this;
}
MyString& MyString::insert(int loc, const char* str) {
  MyString temp(str);
  return insert(loc, temp);
}
MyString& MyString::insert(int loc, char c) {
  MyString temp(c);
  return insert(loc, temp);
}

MyString& MyString::erase(int loc, int num) {
  // loc 의 앞 부터 시작해서 num 문자를 지운다.
  if (num < 0 || loc < 0 || loc > string_length) return *this;

  // 지운다는 것은 단순히 뒤의 문자들을 앞으로 끌고 온다고
  // 생각하면 됩니다.

  for (int i = loc + num; i < string_length; i++) {
    string_content[i - num] = string_content[i];
  }

  string_length -= num;
  return *this;
}
int MyString::find(int find_from, MyString& str) {
  int i, j;
  if (str.string_length == 0) return -1;
  for (i = find_from; i < string_length - str.string_length; i++) {
    for (j = 0; j < str.string_length; j++) {
      if (string_content[i + j] != str.string_content[j]) break;
    }

    if (j == str.string_length) return i;
  }

  return -1;  // 찾지 못했음
}
int MyString::find(int find_from, const char* str) {
  MyString temp(str);
  return find(find_from, temp);
}
int MyString::find(int find_from, char c) {
  MyString temp(c);
  return find(find_from, temp);
}
int MyString::compare(MyString& str) {
  // (*this) - (str) 을 수행해서 그 1, 0, -1 로 그 결과를 리턴한다
  // 1 은 (*this) 가 사전식으로 더 뒤에 온다는 의미. 0 은 두 문자열
  // 이 같다는 의미, -1 은 (*this) 사 사전식으러 더 앞에 온다는 의미이다.

  for (int i = 0; i < min(string_length, str.string_length); i++) {
    if (string_content[i] > str.string_content[i])
      return 1;

    else if (string_content[i] < str.string_content[i])
      return -1;
  }

  // 여기 까지 했는데 끝나지 않았다면 앞 부분 까지 모두 똑같은 것이 된다.
  // 만일 문자열 길이가 같다면 두 문자열은 아예 같은 문자열이 된다.

  if (string_length == str.string_length) return 0;

  // 참고로 abc 와 abcd 의 크기 비교는 abcd 가 더 뒤에 오게 된다.
  else if (string_length > str.string_length)
    return 1;

  return -1;
}
int main() {
  MyString str("abcdef");
  str[3] = 'c';

  str.println();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F214AAE41521E0EB60BE46C)



와 같이 제대로 `str[3]` 의 'd' 를 'c' 로 잘 바꾸었음을 알 수 있습니다.


이 정도만 하면 `MyString` 클래스는 거의 왠만한 문자열 클래스 뺨치게 완전한 모습을 갖추었다고 볼 수 있습니다. 문자열 삽입, 삭제, 대입 뿐만이 아니라 개개의 문자의 조작 까지 원활하게 수행할 수 있는 훌륭한 문자열 클래스라고 할 수 있지요.



###  int `Wrapper` 클래스 - 타입 변환 연산자



`Wrapper` 라는 것은 원래 우리가 흔히 음식을 포장할 때 '랩(wrap)으로 싼다' 라고 하는 것 처럼, '포장지' 라는 의미의 단어 입니다. 즉 `Wrapper` 클래스는 무언가를 포장하는 클래스라는 의미인데, C++ 에서 프로그래밍을 할 때 어떤 경우에 기본 자료형들을 객체로써 다루어야 할 때가 있습니다. 이럴 때, 기본 자료형들 (`int, float` 등등) 을 클래스로 포장해서 각각의 자료형을 객체로 사용하는 것을 `Wrapper` 클래스를 이용한다는 뜻 입니다.

즉, `int` 자료형을 감싸는 int Wrapper 클래스 `Int` 는 다음과 같이 구성할 수 있습니다.

```cpp-formatted
class Int

{
  int data;
  // some other data

 public:
  Int(int data) : data(data) {}
  Int(const Int& i) : data(i.data) {}
};
```



위 `Int` 클래스에 `int` 형 자료형을 보관하는 `data` 라는 변수를 정의해 놓았는데, 이렇게 한다면 `int` 형 데이터를 저장하는 객체로 `Int` 클래스를 사용할 수 있을 것입니다. 우리는 이 `Int` 객체가 `int` 의 `Wrapper` 클래스의 객체인 만큼, `int` 와 정확히 똑같이 작동하도록 만들고 싶습니다. 다시 말해서 다음과 같은 명령을 내려도 아무 하자 없이 잘 실행될 수 있도록 말이지요.

```cpp-formatted
Int x = 3;      // Wrapper 객체
int a = x + 4;  // 그냥 평범한 int 형 변수 a
```



이를 잘 수행하기 위해서라면, 여태까지 연산자 오버로딩을 열심히 배워오신 여러분 생각이라면


그렇다면 `int` 변수에 사용되는 모든 연산자 함수들을 만들어주면 되겠군!


이라고 생각이 들 것입니다. 물론, 이렇게 해도 잘 작동하는 `Wrapper` 클래스를 만들 수 있을 것입니다. 하지만, 그 수 많은 연산자들을 일일히 오버로딩을 하는 것은 정말로 고통스러운 일이 아닐 수 없습니다.

왜 이러한 일이 고통스러운 것이냐면, `Complex` 클래스를 만들 때만 해도, `Complex` 객체에서 + 나 - 연산자가 하는 일 자체가 `int` 변수 끼리 하는 일과 완전히 달랐기 때문에 반드시 `operator+` 나 `operator-` 등을 만들어주어야만 했을 것입니다. 하지만 이 `int Wrapper` 클래스 객체끼리 하는 일은 그냥 단순히 `int` 형 변수 끼리 하는 일과 정확히 똑같기 때문에 굳이 이미 제공하는 기능을 다시 만들어야 한다는 점이지요.


그렇다면, 그냥 이 `Wrapper` 클래스의 객체를 마치 '`int` 형 변수' 라고 컴파일러가 생각할 수 는 없는 것일까요. 물론 가능합니다. 왜냐하면 우리에게는 타입 변환 연산자가 있기 때문이지요. 만일 컴파일러가 이 클래스의 객체를 `int` 형 변수로 변환할 수 있다면, 비록 `operator+` 등을 정의하지 않더라도 컴파일러가 가장 이 객체를 `int` 형 변수로 변환 한 다음에 `+` 를 수행할 수 있기 때문입니다.


타입 변환 연산자는 다음과 같이 정의합니다.

```info
operator (변환 하고자 하는 타입) ()
```



예를 들어 우리의 `int Wrapper` 클래스의 경우 다음과 같은 타입 변환 연산자를 정의할 수 있지요.

```cpp-formatted
operator int()
```



한 가지 주의할 점은, 생성자 처럼 함수의 리턴 타입을 써주시면 안됩니다. 이는 C++ 에서 변환 연산자를 정의하기 위한 언어 상의 규칙이라고도 볼 수 있습니다. 그렇게 된다면, 우리의 `int` 변환 연산자는 다음과 같이 간단하게 구성할 수 있겠지요.

```cpp-formatted
operator int() { return data; }
```



그냥 단순히 `data` 를 리턴해주면 됩니다. 그렇게 된다면 우리의 `Wrapper` 클래스의 객체를 '읽는' 데에는 아무런 문제가 없게 됩니다. 왜냐하면 컴파일러 입장에서 적절한 변환 연산자로 `operator int` 를 찾아서 결국 `int` 로 변환해서 처리하기 때문이지요. 다만 문제는 '대입' 시에 발생하는데, 다행이도 디폴트 대입 연산자가 이 역시 알아서 잘 처리할 것이기 때문에 걱정 안하셔도 됩니다.

```cpp-formatted
#include <iostream>
using namespace std;

class Int {
  int data;
  // some other data

 public:
  Int(int data) : data(data) {}
  Int(const Int& i) : data(i.data) {}

  operator int() { return data; }
};
int main() {
  Int x = 3;
  int a = x + 4;

  x = a * 2 + x + 4;
  cout << x << endl;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23729548521E20860F2135)



와 같이 `Int` 객체가 `int` 변수 처럼 정확히 동일하게 작동되고 있음을 알 수 있습니다.

###  전위/후위 증감 연산자


마지막으로 살펴볼 연산자로 우리가 흔히 `++, --` 로 사용하는 전위/후위 증감 연산자들 입니다. 아마, 이 연산자를 오버로딩 하기 전에 한 가지 궁금증이 드셨을 텐데요, 과연 C++ 컴파일러는 전위/후위 증감을 구분 해서 오버로딩 시켜주냐 입니다. 다시 말해;
```cpp-formatted
a++;
++a;
```

위 두 `++` 연산자들을 구분해서 오버로딩을 시켜주냐 이말이죠. 사실 우리가 흔히 생각하기에 `++` 연산자는 그냥 1 증가 시켜주는 1 개의 연산자라고 볼 수 있겠지만 놀랍게도 C++ 에서는 `++` 연산자를 전위와 후위를 구분해서 오버로딩 할 수 있도록 제공하고 있습니다. 그렇다면요, 이 둘을 도대체 어떻게 구분할 수 있을까요?


C++ 언어에서는 다음과 같은 재미있는 방법으로 구분합니다. 일단 C++ 언어에서는 다음과 같은 재미있는 방법으로 구분합니다. 일단;

```cpp-formatted
operator++() operator--()
```

은 전위 증감 연산자 (++x, --x) 를 오버로딩 하게 됩니다. 그렇다면 후위 증감 연산자 (x ++, x--) 는 어떨까요. 바로

```cpp-formatted
operator++(int x) operator--(int x)
```


로 구현하게 됩니다. 물론 인자 `x` 에는 0 이 들어가게 됩니다. 즉 단순히 전위와 후위를 구별하기 위해 인자로 `x` 를 넣어주는 것이지요. 실제로 `++` 을 구현하면서 인자로 들어가는 값을 사용하는 경우는 없습니다.

한 가지 주목할 점은 많은 경우 전위 증감이 후위 증감 보다 더 빠르기 때문에 (물론, 엄청나게 빠르다는 것이 아니라 후위 증감 자체가 약간의 연산을 더 수행하게 됩니다) 후위/전위 증감 중 무엇을 사용하던 상관이 없는 경우 (예를 들어서 `for` 문에서 `i ++` 을 한 다던지) 되도록이면 전위 증감을 사용하는 것이 바람직 합니다만, 클래스를 사용하는 사용자의 입장에서는 두 개 모두 지원해야 하므로 우리는 둘 다 만들어야 하겠지요.


따라서 아래와 같은 테스트 클래스를 제작하였습니다.

```cpp-formatted
class Test

{
  int x;

 public:
  Test(int x) : x(x) {}
  Test& operator++() {
    x++;
    cout << "전위 증감 연산자" << endl;
    return *this;
  }
  Test& operator++(int s) {
    x++;
    cout << "후위 증감 연산자" << endl;
    return *this;
  }
};
```



클래스 자체에는 별거 없지만 전위와 후위가 호출될 때를 구별하기 위해 메세지를 출력하도록 하였습니다.

```cpp-formatted
#include <iostream>
using namespace std;

class Test {
  int x;

 public:
  Test(int x) : x(x) {}
  Test& operator++() {
    x++;
    cout << "전위 증감 연산자" << endl;
    return *this;
  }
  Test& operator++(int s) {
    x++;
    cout << "후위 증감 연산자" << endl;
    return *this;
  }
};
int main() {
  Test x(3);

  x++;
  ++x;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2775AA35521E26D0278F37)



와 같이 제대로 골라서 실행되고 있음을 알 수 있습니다.






###  정리




연산자 오버로딩에 대해 다루면서 몇 가지 중요한 포인트 들만 따로 정리해보자면;

* 두 개의 동등한 객체 사이에서의 이항 연산자는 멤버 함수가 아닌 외부 함수로 오버로딩 하는 것이 좋습니다. (예를 들어 `Complex` 의 `operator+(const Complex&, const Complex&)` 와 같이 말입니다.)
* 두 개의 객체 사이의 이항 연산자 이지만 한 객체만 값이 바뀐다던지 등의 동등하지 않는 이항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다. (예를 들어서 `operator+=` 는 이항 연산자 이지만 `operator+=(const Complex&)` 가 낫다)
* 단항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다 (예를 들어 `operator++` 의 경우 멤버 함수로 오버로딩 합니다)
* 일부 연산자들은 반드시 멤버 함수로만 오버로딩 해야 합니다 (강좌 앞 부분 참고)
  

자, 이것으로 가장 많이 사용되는 연산자 함수들에 대해 알아보았습니다. 이제 슬슬 C++ 언어의 강력함이 느껴지시나요? 다음 강좌에서는 여태까지 배운 내용들을 총 망라하는 조그마한 프로젝트를 해볼려고 합니다. 그 프로젝트는 아래 '생각해보기'에 나와 있는데요, 다음 강좌를 보기 전 까지 아래 문제를 한 번 해결해 보시기 (해결은 못해도 최소한 노력은 하시기) 바랍니다.



###  생각해보기


#### 문제 1

`N` 차원 배열을 제공하는 클래스를 만들어보세요. 이는 여러분이 여태까지 배운 내용을 시험할 것입니다. 참고로, 원소에 접근하기 위해서는 `a[1][2][3]` 과 같은 방법으로 접근하겠지요. 다만 `N` 차원 배열이기 때문에 (N은 객체 생성시에 사용자가 입력합니다) 2 차원 배열은 `a[1][2], 3` 차원 배열은 `a[1][2][3]` 과 같은 방식으로 접근할 것입니다. (난이도 : 最上)

#### 문제 2

영어를 잘하시는 분들은 연산자 오버로딩에 관해 정리해 놓은 [다음 글](http://stackoverflow.com/questions/4421706/operator-overloading)을 읽어보시기를 추천합니다. 참고로 이 글에서 다루지만 본 강좌에서는 다루지 않는 일부 내용들은 아직 배운 내용이 아니라 생략한 것이므로 너무 걱정하지 마시고 복습하는 느낌으로 천천히 읽어보시면 좋습니다. (난이도 : 中)

##@ chewing-cpp-end
Link :  202
2013-08-25 18:01
----------------
title : 씹어먹는 C++ - <5 - 1. 내가 만든 연산자 - 연산자 오버로딩>
cat_title: 5 - 1. 내가 만든 연산자 - 연산자 오버로딩
next_page : 203
publish_date : 2013-08-25 18:01
--------------

이번 강좌에서는

* 산술 연산자 오버로딩
* 비교 연산자 오버로딩
* 대입 연산자 오버로딩

에 대해서 다룹니다.



![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 지난 강좌에서 만들었던 `MyString` 을 손 좀 봐주었나요? 아마도 `MyString` 을 이용하여 여러가지 작업을 하면서 다음과 같은 생각을 하셨을 수도 있었을 것입니다.

* `if(str1.compare(str2) == 0)` 하지 말고 `if(str1 == str2)` 하면 어떨까?
* `str1.insert(str1.length(), str2)` 하지 말고 `str1 = str1 + str2;` 하면 어떨까?
* `str1[10] = 'c';` 와 같은 것도 할 수 있을까?


물론 C 언어에서는 이러한 것을 상상조차 할 수 없었습니다. `+, -, ==, []` 와 같은 기본 연산자들은 모두 C 언어에 기본적으로 정의되어 있는 데이터 타입(`int, float` 등)에만 사용 가능한 것들 이였기 때문이죠. 이들을 구조체 변수에 사용한다는 것은 불가능하였습니다.


하지만 놀랍게도 C++ 에서는 사용자 정의 연산자를 사용할 수 있습니다. 어떠한 연산자들이 가능하나면, :: (범위 지정), `.` (멤버 지정), `.*` (멤버 포인터로 멤버 지정) 을 제외한 여러분이 상상하는 모든 연산자를 사용할 수 있다는 것입니다. `+, -, *` 는 물론이고, `+=, -=` 와 같은 축약형들이나 `>=, ==` 와 같은 비교 연산자, `&&` 와 같은 논리 연산자, `->` 와 같은 멤버 선택 연산자, `++, --` 증감 연산자, `[]` 와 심지어 () 까지 (함수 호출 연산자) 도 모두 여러분이 직접 만들 수 있습니다.


이 때 이러한 기본 연산자들을 직접 사용자가 정의하는 것을 연산자를 **오버로딩(overloading)** 한다고 부릅니다. 이전에 같은 이름의 함수를 인자만 다르게 사용하는 것을 '함수를 오버로딩 했다' 라고 불렀던 것 처럼, 기본 연산자를 여러분이 설계한 클래스에 맞게 직접 사용하는 것을 '연산자를 오버로딩 했다' 라고 부릅니다.


###  MyString 의 `==` 연산자 오버로딩




일단 연산자 오버로딩을 사용하기 위해서는, 다음과 같이 오버로딩을 원하는 연산자 함수를 제작하면 됩니다.
```info

(리턴 타입) operator(연산자) (연산자가 받는 인자)
```



(※ 참고적으로 위 방법 외에는 함수 이름으로 연산자를 절대 넣을 수 없습니다) 예를 들어서 우리가 `==` 를 오버로딩 하고 싶다면, `==` 연산자는 그 결과값이 언제나 `bool` 이고, 인자로는 `==` 로 비교하는 것 하나만 받게 됩니다. 따라서 다음과 같이 함수를 정의하면 됩니다.

```info

bool operator== (MyString& str);
```



이제, 우리가 `str1 == str2` 라는 명령을 한다면 이는 `str1.operator==(str2)` 로 내부적으로 변환되서 처리됩니다. 그리고 그 결과값을 리턴하게 되겠지요. 사실 `operator==` 를 만드는 것 자체는 별로 어려운 일은 아닙니다. 왜냐하면 이미 `MyString` 에서 `compare` 라는 좋은 함수를 제공하고 있기 때문이지요. 간단하게 만들어 보면 다음과 같습니다.

```cpp-formatted
bool MyString::operator==(MyString& str) {
  return !compare(str);  // str 과 같으면 compare 에서 0 을 리턴한다.
}
```



여기서 `!compare(str)` 을 리턴하는 이유는 `compare` 함수에서 `str` 과 `*this` 가 같으면 0 을 리턴하도록 하였는데, `operator==` 은 둘이 같으면 `true` 를 리턴해야 되기 때문입니다. 따라서 `NOT` 연산자인 `!` 를 앞에 붙여서 리턴하면 올바르게 작동할 수 있습니다. 그럼, 실제로 우리의 새롭게 오버로딩한 `==` 연산자가 잘 작동하는지 살펴봅시다.

```cpp-formatted
#include <string.h>
#include <iostream>

using namespace std;

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  // 문자 하나로 생성
  MyString(char c);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length();
  int capacity();
  void reserve(int size);

  void print();
  void println();

  MyString& assign(MyString& str);
  MyString& assign(const char* str);

  char at(int i);

  MyString& insert(int loc, MyString& str);
  MyString& insert(int loc, const char* str);
  MyString& insert(int loc, char c);

  MyString& erase(int loc, int num);

  int find(int find_from, MyString& str);
  int find(int find_from, const char* str);
  int find(int find_from, char c);

  int compare(MyString& str);

  bool operator==(MyString& str);
};

MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
  memory_capacity = 1;
  string_length = 1;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

MyString& MyString::assign(MyString& str) {
  if (str.string_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
    memory_capacity = str.string_length;
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
    memory_capacity = str_length;
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
int MyString::capacity() { return memory_capacity; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char* prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    delete[] prev_string_content;
  }

  // 만일 예약하려는 size 가 현재 capacity 보다 작다면
  // 아무것도 안해도 된다.
}
char MyString::at(int i) {
  if (i >= string_length || i < 0)
    return NULL;
  else
    return string_content[i];
}
MyString& MyString::insert(int loc, MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.

    if (memory_capacity * 2 > string_length + str.string_length)
      memory_capacity *= 2;
    elsememory_capacity = string_length + str.string_length;

    char* prev_string_content = string_content;
    string_content = new char[memory_capacity];

    // 일단 insert 되는 부분 직전까지의 내용을 복사한다.
    int i;
    for (i = 0; i < loc; i++) {
      string_content[i] = prev_string_content[i];
    }

    // 그리고 새롭에 insert 되는 문자열을 넣는다.
    for (int j = 0; j != str.string_length; j++) {
      string_content[i + j] = str.string_content[j];
    }

    // 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
    for (; i < string_length; i++) {
      string_content[str.string_length + i] = prev_string_content[i];
    }

    delete[] prev_string_content;

    string_length = string_length + str.string_length;
    return *this;
  }

  // 만일 초과하지 않는 경우 굳이 동적할당을 할 필요가 없게 된다.
  // 효율적으로 insert 하기 위해, 밀리는 부분을 먼저 뒤로 밀어버린다.

  for (int i = string_length - 1; i >= loc; i--) {
    // 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
    string_content[i + str.string_length] = string_content[i];
  }
  // 그리고 insert 되는 문자 다시 집어넣기
  for (int i = 0; i < str.string_length; i++)
    string_content[i + loc] = str.string_content[i];

  string_length = string_length + str.string_length;
  return *this;
}
MyString& MyString::insert(int loc, const char* str) {
  MyString temp(str);
  return insert(loc, temp);
}
MyString& MyString::insert(int loc, char c) {
  MyString temp(c);
  return insert(loc, temp);
}

MyString& MyString::erase(int loc, int num) {
  // loc 의 앞 부터 시작해서 num 문자를 지운다.
  if (num < 0 || loc < 0 || loc > string_length) return *this;

  // 지운다는 것은 단순히 뒤의 문자들을 앞으로 끌고 온다고
  // 생각하면 됩니다.

  for (int i = loc + num; i < string_length; i++) {
    string_content[i - num] = string_content[i];
  }

  string_length -= num;
  return *this;
}
int MyString::find(int find_from, MyString& str) {
  int i, j;
  if (str.string_length == 0) return -1;
  for (i = find_from; i < string_length - str.string_length; i++) {
    for (j = 0; j < str.string_length; j++) {
      if (string_content[i + j] != str.string_content[j]) break;
    }

    if (j == str.string_length) return i;
  }

  return -1;  // 찾지 못했음
}
int MyString::find(int find_from, const char* str) {
  MyString temp(str);
  return find(find_from, temp);
}
int MyString::find(int find_from, char c) {
  MyString temp(c);
  return find(find_from, temp);
}
int MyString::compare(MyString& str) {
  // (*this) - (str) 을 수행해서 그 1, 0, -1 로 그 결과를 리턴한다
  // 1 은 (*this) 가 사전식으로 더 뒤에 온다는 의미. 0 은 두 문자열
  // 이 같다는 의미, -1 은 (*this) 사 사전식으러 더 앞에 온다는 의미이다.

  for (int i = 0; i < min(string_length, str.string_length); i++) {
    if (string_content[i] > str.string_content[i])
      return 1;

    else if (string_content[i] < str.string_content[i])
      return -1;
  }

  // 여기 까지 했는데 끝나지 않았다면 앞 부분 까지 모두 똑같은 것이 된다.
  // 만일 문자열 길이가 같다면 두 문자열은 아예 같은 문자열이 된다.

  if (string_length == str.string_length) return 0;

  // 참고로 abc 와 abcd 의 크기 비교는 abcd 가 더 뒤에 오게 된다.
  else if (string_length > str.string_length)
    return 1;

  return -1;
}
bool MyString::operator==(MyString& str) {
  return !compare(str);  // str 과 같으면 compare 에서 0 을 리턴한다.
}
int main() {
  MyString str1("a word");
  MyString str2("sentence");
  MyString str3("sentence");

  if (str1 == str2)
    cout << "str1 and str2 are same" << endl;
  else
    cout << "st1 and str2 are different" << endl;

  if (str2 == str3)
    cout << "str2 and str3 are same" << endl;
  else
    cout << "st2 and str3 are different" << endl;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F245A6D4B520CF2291D03B6)



와 같이 잘 나옵니다. 위 코드에서도 쉽게 알 수 있지만 `str1` 과 `str2` 은 다르고, `str2` 와 `str3` 는 같기 때문에 위와 같이 제대로 처리되고 있음을 알 수 있습니다.






###  복소수 (Complex number) 클래스 만들기




`MyString` 클래스를 이용해서 설명을 계속 하려고 했지만, `MyString` 자체가 너무 비대한 바람에 좀더 간결하게 설명을 하기 위해 새로운 클래스를 만들어보도록 할 것입니다. 바로 **복소수(Complex Number)** 클래스 인데요, 아마 이 강좌를 보시는 분들 중에서는 복소수가 정확히 무엇인지 모르시는 분들 도 있을 것입니다. 그 분들을 위해서 간략하게 먼저 설명을 하고 가겠습니다.

$$ i = \sqrt{-1} $$

일단 실수의 제곱근에 대해서는 무엇인지 다들 아실 것이라 생각합니다. 그런데 실수의 제곱은 언제나 양수이기 때문에 위와 같이 음수의 제곱근은 실수로 표현할 수 없게 됩니다. 따라서, 음수의 제곱근을 나타내기 위해서 특별한 수를 정의하였는데 이를 **허수(imaginary number)** 이라 부르며, 실제로 존재하지 않는 수학적으로만 존재하는 수라고 볼 수 있습니다. 그리고 특히 -1 의 제곱근을 위의 수식 처럼 `i` 로 표기합니다.

따라서, 이 때문에 예를 들어서 -4 의 제곱근은!

$$ 2i = \sqrt{-4} $$

와 같이 생각할 수 있겠지요. 그리고 복소수는, 이 허수와 실수를 모두 포함하는 수 체계로, 허수와 실수의 합으로 표현할 수 있습니다. 다시 말해서, 임의의 복소수 `z` 는 다음과 같은 꼴입니다.

$$z = a + bi $$

물론 여기서 `a,b` 는 모두 실수 입니다.


우리가 만들고자 하는 것은 이 복소수를 나타내는 클래스를 구성하겠다는 이야기 입니다. 임의의 복소수 하나를 표현하기 위해서 두 개의 값(실수부, 허수부)이 필요하기 때문에 반드시 클래스로 구현을 해야 하겠죠. 따라서, 기본적으로 복소수 클래스 `Complex` 는 다음과 같이 간단하게 만들 수 있습니다.


```cpp-formatted
class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}
};
```



복소수는 언제나 실수부와 허수부로 나뉘어지므로, `Complex` 클래스 역시 실수부의 값과 허수부의 값을 나타내는 `real` 과 `img` 변수가 있습니다. 여기서 문제는 이전에 만들었던 `MyString` 과는 다르게, 사칙 연산이 엄청나게 자주 쓰인다는 것입니다. 당연하게도 문자열의 덧셈 (+ 연산) 까지는 생각할 수 있었다 해도, 곱셈이나 나눗셈 연산 자체는 고려할 필요가 없는데, 복소수의 경우 당연히 클래스 인터페이스 차원에서 곱셈과 나눗셈을 지원해주어야만 합니다.


참고로, 복소수의 사칙 연산은 실수부와 허수부 따로 생각하여 진행됩니다. 간단히 말하면

$$ z_1 + z_2 = (a_1 + ib_1) + (a_2 + ib_2) = (a_1 + a_2) + i (b_1 + b_2) $$
와 같은 관계가 성립한다는 이야기 이죠. 곱셈의 경우는 좀더 복잡한데, 사실 분배법칙과 허수 둘을 곱하면 다시 -1 이 된다는 점만 생각하면 아래의 관계식도 어렵지 않게 생각할 수 있습니다.

$$ z_1 z_2 = (a_1 + ib_1)(a_2 + ib_2) = (a_1a_2 - b_1b_2) + i (a_1b_2 + a_2b_1)$$

나눗셈의 경우, 이전에 무리수의 유리화를 하셨던 것을 생각하면 간단합니다.

$$ \frac{z_1}{z_2} = \frac{a_1 + ib_1}{a_2 + ib_2} = \frac{(a_1+ ib_1)(a_2-ib_2)}{a_2^2 + b_2^2} = \frac{a_1a_2 + b_1b_2 + i(a_2b_1 - a_1b_2)}{a_2^2 + b_2^2}$$

즉 분모를 실수화 할 수 있도록 분모의 켤레를 분자와 분모에 곱함으로써 실수로 나누는 것으로 쉽게 바꿀 수 있습니다. (실수로 나누는 것은 실수부, 허수부의 실수값을 그냥 실수로 나누면 됩니다)


그래서 만일 다음과 같이 연산자의 오버로딩을 모른다고 가정하고 `Complex` 클래스를 구성하여 봅시다.


```cpp-formatted
class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}

  Complex plus(const Complex& c);
  Complex minus(const Complex& c);
  Complex times(const Complex& c);
  Complex divide(const Complex& c);
};
```



이렇게 된다면 만일 `int` 형 변수였다면

```cpp-formatted
a + b / c + d;
```



로 간단하게 쓸 수 있었던 명령을

```cpp-formatted
a.plus(b.divide(c)).plus(d);
```



와 같이 복잡한 함수식을 이용해서 표현해야만 합니다. 이는, 가독성이 떨어질 뿐더러 위 식을 딱 보고 도대체 무슨 작업을 하려고 하는지도 쉽게 알 수 없습니다. 하지만 연산자 오버로딩을 이용해서 `plus` 를 `operator+` 로, `divide` 를 `operator/` 로, 등등 바꿔준다면 단순히 프로그래머가`a + b/c +` d; 게 쓴다고 해도, 컴파일러가a.operator+(b.operator/(c)).operator+(d); 로 알아서 변환시켜서 처리하기 때문에 속도나 다른 면의 어떠한 차이 없이 뛰어난 가독성과 편리함을 얻을 수 있게 됩니다.


이를 바탕으로 간단히 `Complex` 클래스를 만들어본다면


```cpp-formatted
#include <iostream>
using namespace std;

class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }

  Complex operator+(const Complex& c);
  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};

Complex Complex::operator+(const Complex& c) {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}

int main() {
  Complex a(1.0, 2.0);
  Complex b(3.0, -2.0);

  Complex c = a * b;

  c.println();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2160643D520CFD6F1D18E1)

와 같이 잘 나옴을 알 수 있습니다. 여기서 가장 중요하게 봐야 할 부분은 바로, 사칙연산 연산자 함수들의 리턴 타입 입니다.

```cpp-formatted
Complex operator+(const Complex& c);
Complex operator-(const Complex& c);
Complex operator*(const Complex& c);
Complex operator/(const Complex& c);
```



위 4 개의 연산자 함수 모두 `Complex&` 가 아닌 `Complex` 를 리턴하고 있습니다. 간혹가다,


```cpp-formatted
Complex& operator+(const Complex& c) {
  real += c.real;
  img += c.img;
  return *this;
}
```

로 잘못 생각하는 경우도 있습니다. 물론 이렇게 설계하였을 경우, `Complex` 를 리턴하는 연산자 함수는 값의 복사가 일어나기 때문에 속도  저하가 발생하지만 위 처럼 레퍼런스를 리턴하게 되면 값의 복사 대신 레퍼런스만 복사하는 것이므로 큰 속도의 저하는 나타나지 않습니다. 하지만, 위와 같이 `operator+` 를 정의할 경우 다음과 같은 문장이 어떻게 처리되는지 생각해봅시다.
```cpp-formatted
Complex a = b + c + b;
```



아마도 위 문장을 쓴 사람 입장에서는 결과적으로 `a = 2 * b +` c; 를 의도하였을 것입니다. 하지만, 실제로 처리되는 것을 보자면, (b.plus(c)).plus(b) 가 되는데, `b.plus(c)` 를 하면서 `b` 에는 (b + c) 가 들어가고, 거기에 다시 `plus(b)` 를 하게 된다면 값 자체만 보자면 (b + c) `+ (b + c)` 가 되서 (왜냐하면 현재 `b` 에는 `b + c` 가 들어가 있으니까) `a = 2 * b + 2 * c` 가 되기 때문입니다. 이러한 문제를 막기 위해서는 반드시 사칙 연산의 경우 반드시 값을 리턴해야 만 합니다.


또한 함수 내부에서 '읽기' 만 수행되고 값이 바뀌지 않는 인자들에 대해서는 `const` 키워드를 붙여주는 것이 바람직합니다. `operator+` 의 경우, `c` 의 값을 읽기만 하지 `c` 의 값에 어떠한 변화도 주지 않으므로 `const Complex&` 타입으로 인자를 받았습니다.

```warning

인자의 값이 함수 내부에서 바뀌지 않는 다고 확신할 때에는 반드시 const 키워드를 붙여주시기 바랍니다.
```






###  대입 연산자 함수


아마 `Complex` 클래스를 구현하면서 한 가지 빠뜨렸다고 생각하고 있는 것이 있을 것입니다. 바로, 대입 연산자  (=) 이지요. 아마도, 대입 연산자야 말로 가장 먼저 구현했어야 할 연산자 함수가 아니였을까 합니다.
```cpp-formatted
Complex& operator=(const Complex& c);
```



기본적으로 대입 연산자 함수는, 기존의 사칙연산 연산자 함수와는 다르게, `Complex&` 타입을 리턴합니다. 사실 대입 연산자 자체의 의미를 생각해 볼 때 리턴값을 `void` 로 해도 무방하지만, 프로그래머들은 종종 `if((i = x) < y)` 와 같은 문장을 사용하기 때문에 리턴값을 주는 것이 인터페이스 차원에서 더 낫다고 생각합니다.


이 때 `Complex` 타입을 리턴하지 않고 굳이 `Complex&` 타입을 리턴하냐면, 대입 연산 이후에 이 값을 가지고 다른 연산을 수행하지는 않기 때문입니다. 예를 들어서 (i = 3) `+ 4` 와 같은 명령을 내리지는 않기 때문이지요. 그렇기에 값에 의한 복사가 발생하는 것 보다는 레퍼런스를 리턴하는 것이 더 올바른 판단이라고 봅니다.


이와 같은 사실을 바탕으로 `operator=` 함수를 완성시켜 보면 아래와 같습니다.

```cpp-formatted
Complex& Complex::operator=(const Complex& c)

{
  real = c.real;
  img = c.img;
  return *this;
}
```



그럼 제대로 작동하는지 확인해보면

```cpp-formatted
#include <iostream>
using namespace std;

class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }

  Complex operator+(const Complex& c);
  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  Complex& operator=(const Complex& c);
  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};

Complex Complex::operator+(const Complex& c) {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}
Complex& Complex::operator=(const Complex& c) {
  real = c.real;
  img = c.img;
  return *this;
}

int main() {
  Complex a(1.0, 2.0);
  Complex b(3.0, -2.0);
  Complex c(0.0, 0.0);
  c = a * b + a / b + a + b;
  c.println();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2648ED34520D12320A734A)



와 같이 잘 작동함을 알 수 있습니다.


한 가지 재미있는 사실은 굳이 `operator=` 를 만들지 않더라도, 위 소스를 컴파일 하면 잘 작동한다는 점입니다. 이는 컴파일러 차원에서 디폴트 대입 연산자(default assignment operator)를 지원하고 있기 때문인데, 이전에 [복사 생성자를 다룰 때 디폴트 복사 생성자](http://itguru.tistory.com/188)가 있었던 것과 일맥상통합니다.


디폴트 복사 생성자와 마찬가지로 디폴트 대입 연산자 역시 얕은 복사를 수행합니다. 따라서, 깊은 복사가 필요한 클래스의 경우 (예를 들어, 클래스 내부적으로 동적으로 할당되는 메모리를 관리하는 포인터가 있다던지) 대입 연산자 함수를 꼭 만들어주어야 할 필요가 있습니다.



여담이지만, 이제 여러분은 다음 두 문장의 차이를 완벽히 이해 하실 수 있을 것이라 믿습니다.

```cpp-formatted
Some_Class a = b;  // ①
```



와

```cpp-formatted
Some_Class a;  // ②
a = b;
```



말이지요. 이전에 이에 대해서 이야기 하였을 때 연산자 오버로딩을 배우지 못하였기 때문에 대충 두루뭉실하게 넘어갔지만 이제는 제대로 이해할 수 있습니다.① 의 경우, 아예 `a` 의 '복사 생성자' 가 호출되는 것이고,② 의 경우 `a` 의 그냥 기본 생성자가 호출 된 다음, 다음 문장에서 대입 연산자 함수가 실행되는 것입니다. 위 두 문장은 비록 비슷해 보이기는 해도 아예 다른 것이지요.


마찬가지 이유로 대입 사칙연산 함수들인, `+=, -=` 등을 구현할 수 있습니다. 일단 `=` 와 마찬가지로 아래와 같이 `Complex&` 를 리턴하고

```cpp-formatted
Complex& operator+=(const Complex& c);
Complex& operator-=(const Complex& c);
Complex& operator*=(const Complex& c);

Complex& operator/=(const Complex& c);
```



그 내부 구현은 간단히 미리 만들어 놓은 `operator+, operator-` 등을 이용해서 처리하면 됩니다.

```cpp-formatted
Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
```



와 같이 말이지요. 전체 소스를 살펴보자면;

```cpp-formatted
#include <iostream>
using namespace std;

class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }

  Complex operator+(const Complex& c);
  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  Complex& operator+=(const Complex& c);
  Complex& operator-=(const Complex& c);
  Complex& operator*=(const Complex& c);
  Complex& operator/=(const Complex& c);

  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};

Complex Complex::operator+(const Complex& c) {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}
Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
int main() {
  Complex a(1.0, 2.0);
  Complex b(3.0, -2.0);
  a += b;
  a.println();
  b.println();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F26065741520D14F3047A36)



와 같이 잘 출력됨을 알 수 있습니다. `a` 의 값만 바뀐 채 `b` 에는 아무런 영향이 없지요.



참고로, 연산자 오버로딩을 사용하게 된다면 `a+= b` 와 `a = a +` b; 가같다고 보장되지 않는다는 점을 명심해야 합니다. 컴파일러는 `operator+` 와 `operator=` 를 정의해놓았다고 해서 `a+=b` 를 자동으로 `a = a +` b; 로 바꾸어 주지 않습니다. 반드시 `operator+=` 를 따로 만들어야지 `+=` 를 사용할 수 있게 됩니다. 이와 같은 사실은 `++` 을 `+= 1` 로 바꾸어 주지 않는다던지, `--` 를 `-= 1` 로 바꾸어 주지 않는 다는 사실과 일맥상통합니다. 즉, 연산자 오버로딩을 하게 된다면 여러분이 생각하는 모든 연산자들에 대해 개별적인 정의가 필요합니다.






###  문자열로 `Complex` 수와 덧셈하기




이번에는 `operator+` 를 개량해서, 꼭 `Complex` 수를 더하는 것이 아니라, 문자열로도 덧셈을 할 수 있도록 `operator+` 함수를 만드려 보려고 합니다. 다시 말해서,
```cpp-formatted
y = z + "3+i2";
```



이런 문장을 사용하였을 경우 성공적으로 처리할 수 있게 된다는 의미이지요. 참고로, 문자열로 복소수를 어떻게 표현해야 할 지에 대해서는 모종의 약속이 필요한데, 우리 `Complex` 클래스의 경우 다음과 같은 꼴로 표현하도록 정합시다.

```info

(부호) (실수부) (부호) i (허수부)
```



예를 들어서 "2+i3" 은 `Complex` 수 (2 , 3) 을 나타낸 것이라 생각합니다. 또한, "2-i3" 은 (2, -3 ) 을 나타낸 것이 되겠지요. 만일 실수부나 허수부의 값이 0 이라면 굳이 안써주어도 되는데, 예를 들어서 그냥 "3" 은 (3 , 0) 을 나타내며, "-5i" 는 (0, -5) 를 나타내게 됩니다. 참고로 우리의 실수부와 허수부는 `double` 변수 이기 때문에 문자열로 입력 받을 때 단순히 정수 부분만 받는 것이 아니라 소수점 아래 부분도 처리해 주어야만 할 것입니다. 이를 바탕으로 `operator+` 함수를 만들어 보도록 합시다.

```cpp-formatted
Complex Complex::operator+(const char* str) {
  // 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
  // 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
  // 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

  int begin = 0, end = strlen(str);
  double str_img = 0.0, str_real = 0.0;

  // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
  int pos_i = -1;
  for (int i = 0; i != end; i++) {
    if (str[i] == 'i') {
      pos_i = i;
      break;
    }
  }

  // 만일 'i' 가 없다면 이 수는 실수 뿐이다.
  if (pos_i == -1) {
    str_real = get_number(str, begin, end - 1);

    Complex temp(str_real, str_img);
    return (*this) + temp;
  }

  // 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
  str_real = get_number(str, begin, pos_i - 1);
  str_img = get_number(str, pos_i + 1, end - 1);

  if (pos_i >= 1 && str[pos_i - 1] == '-') str_img *= -1.0;

  Complex temp(str_real, str_img);
  return (*this) + temp;
}
```




일단 문자열을 덧셈의 피연산자로 사용하게 되므로, `operator+` 의 인자는 `Complex &` 가 아니라 `const char *` 가 됩니다. 저의 경우, 이제 입력 받은 '문자열 복소수' 를 분석하기 위해서 가장 중요한 'i' 의 위치를 먼저 찾도록 하였습니다. 왜냐하면 이 'i' 를 기준으로 복소수의 실수부와 허수부가 나뉘어지기 때문이지요.

```cpp-formatted
// 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
int pos_i = -1;
for (int i = 0; i != end; i++) {
  if (str[i] == 'i') {
    pos_i = i;
    break;
  }
}
```



따라서 위와 같이 `pos_i` 에 `str` 의 'i' 의 위치를 찾도록 하였습니다. 물론, 입력 받은 문자열에 반드시 'i' 가 있어야만 하는 것은 아닙니다. 왜냐하면 이전에도 말했듯이 복소수가 그냥 실수 라면 굳이 허수 부분을 표현하지 않을 수 있기 때문입니다. 따라서, 아래와 같이 `i` 가 없을 경우 간단히 따로 처리할 수 있습니다.


```cpp-formatted
// 만일 'i' 가 없다면 이 수는 실수 뿐이다.
if (pos_i == -1) {
  str_real = get_number(str, begin, end - 1);

  Complex temp(str_real, str_img);
  return (*this) + temp;
}
```



참고로 우리가 사용하는 `get_number` 함수는 특정 문자열에서 수 부분을 `double` 값으로 반환하는 함수 입니다. 사실 C 언어 표준 라이브러리인 `stdlib.h` 에서 `atof` 라는 함수를 제공해서 우리의 `get_number` 함수와 정확히 똑같은 작업을 하는 함수를 사용할 수 있지만, 한 번 이 함수를 직접 만들어보는 것도 나쁘지 않을 것이라 생각해서 `Complex` 클래스 내의 멤버 함수로 포함시켰습니다. 다만, 이 `get_number` 의 경우 `operator+` 함수의 내부적으로 사용되는 함수이지, 굳이 인터페이스로 제공할 필요는 없기 때문에 `private` 으로 설정하였습니다.

```cpp-formatted
// 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
str_real = get_number(str, begin, pos_i - 1);
str_img = get_number(str, pos_i + 1, end - 1);
```



자 이제, 다시 `operator+` 함수를 돌아와서 살펴보자면 만일 `i` 가 포함되어 있다면 `i` 를 기준으로 왼쪽의 실수부와 오른쪽의 허수부로 나뉘게 됩니다. 이 때 `str_real` 은 `get_number` 함수를 이용해서 정확히 실수 값을 얻을 수 있습니다. (왜냐하면 맨 뒤에 숫자 뒤에 딸려오는 문자들은 `get_number` 에서 알아서 무시된다) 하지만 `str_img` 의 경우 `i` 앞의 부호 부분이 잘리기 때문에 정확한 실수 값을 얻을 수 없기 때문에 따로

```cpp-formatted
if (pos_i >= 1 && str[pos_i - 1] == '-') str_img *= -1.0;
```



로 해서 `str_img` 의 정확한 부호를 처리하도록 하였습니다.


```cpp-formatted
double Complex::get_number(const char *str, int from, int to) {
  bool minus = false;
  if (from > to) return 0;

  if (str[from] == '-') minus = true;
  if (str[from] == '-' || str[from] == '+') from++;

  double num = 0.0;
  double decimal = 1.0;

  bool integer_part = true;
  for (int i = from; i <= to; i++) {
    if (isdigit(str[i]) && integer_part) {
      num *= 10.0;
      num += (str[i] - '0');
    } else if (str[i] == '.')
      integer_part = false;
    else if (isdigit(str[i]) && !integer_part) {
      decimal /= 10.0;
      num += ((str[i] - '0') * decimal);
    } else
      break;  // 그 이외의 이상한 문자들이 올 경우
  }

  if (minus) num *= -1.0;

  return num;
}
```



저의 경우 `get_number` 함수를 위와 같이 구현하였습니다. 만일 `from` 이 `to` 보다 크다면 당연히, 올바르지 않는 입력으로 0 을 반환하도록 하였습니다. (사실 이렇게 모든 예외적인 경우를 세세하게 처리하는 일도 매우 중요합니다) 그리고, 특별히 부호를 처리하기 위해서 `minus` 라는 `bool` 변수를 도입해서 마지막에 `minus` 가 `true` 일 경우에 부호를 음수로 바꾸도록 하였습니다.

```cpp-formatted
if (str[from] == '-' || str[from] == '+') from++;
```



일단 부호 부분은 위와 같이 처리해서 부호 부분 바로 다음 부터 처리하도록 합니다.


```cpp-formatted
for (int i = from; i <= to; i++) {
  if (isdigit(str[i]) && integer_part) {
    num *= 10.0;
    num += (str[i] - '0');
  } else if (str[i] == '.')
    integer_part = false;
  else if (isdigit(str[i]) && !integer_part) {
    decimal /= 10.0;
    num += ((str[i] - '0') * decimal);
  } else
    break;  // 그 이외의 이상한 문자들이 올 경우
}
```



`double` 형 변수로 입력받은 문자열을 처리할 때 유의할 점은, `for` 문에서 맨 앞자리 수 부터 읽는 다는 점입니다. 예를 들어서 `123.456` 이라면 `1,2,3...` 순으로 값을 입력 받게 되는데 이 때문에 소수점 앞 부분과 뒷 부분의 처리를 다르게 해야만 합니다. 소수점 앞 부분을 입력받을 때 (즉, `integer_part` 변수가 `true` 일 때) 에는 간단히


```cpp-formatted
num *= 10.0;
num += (str[i] - '0');
```



를 해서 문자열 부분의 값을 읽어들일 수 있습니다. 즉 `1 -> 12 -> 123` 이 되겠지요. 참고로 `str[i] -` '0' 을 하는 기법은 상당히 자주 쓰이는데, `ASCII` 테이블 상에서 0 부터 9 까지 숫자들이 크기 순으로 연속적으로 배열되어 있기 때문에 단순히 '0' 을 빼버리면 그 숫자에 해당하는 실제 정수 값을 구할 수 있게 됩니다.

```cpp-formatted
else if (isdigit(str[i]) && !integer_part) {
  decimal /= 10.0;
  num += ((str[i] - '0') * decimal);
}
```



그리고 이번에는 소수점 뒷 부분을 읽어들일 차례 입니다. 소수점 뒷 부분의 경우 `decimal` 이란 새로운 변수를 도입하여서, 현재 읽어들이는 위치에 해당하는 값을 구할 수 있게 되는데요, 예를 들어 `123.456` 에서 4 의 경우 `decimal` 은 `0.1, 5` 는 `0.01` 등이 되겠지요. 이와 같은 방식으로 해서 우리는 원래의 문자열을 `double` 값으로 바꿀 수 있게 됩니다.

```cpp-formatted
#include <iostream>
using namespace std;

class Complex {
 private:
  double real, img;

  double get_number(const char* str, int from, int to);

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }

  Complex operator+(const Complex& c);
  Complex operator+(const char* str);

  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  Complex& operator+=(const Complex& c);
  Complex& operator-=(const Complex& c);
  Complex& operator*=(const Complex& c);
  Complex& operator/=(const Complex& c);

  Complex& operator=(const Complex& c);

  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};

Complex Complex::operator+(const Complex& c) {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
double Complex::get_number(const char* str, int from, int to) {
  bool minus = false;
  if (from > to) return 0;

  if (str[from] == '-') minus = true;
  if (str[from] == '-' || str[from] == '+') from++;

  double num = 0.0;
  double decimal = 1.0;

  bool integer_part = true;
  for (int i = from; i <= to; i++) {
    if (isdigit(str[i]) && integer_part) {
      num *= 10.0;
      num += (str[i] - '0');
    } else if (str[i] == '.')
      integer_part = false;
    else if (isdigit(str[i]) && !integer_part) {
      decimal /= 10.0;
      num += ((str[i] - '0') * decimal);
    } else
      break;  // 그 이외의 이상한 문자들이 올 경우
  }

  if (minus) num *= -1.0;

  return num;
}
Complex Complex::operator+(const char* str) {
  // 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
  // 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
  // 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

  int begin = 0, end = strlen(str);
  double str_img = 0.0, str_real = 0.0;

  // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
  int pos_i = -1;
  for (int i = 0; i != end; i++) {
    if (str[i] == 'i') {
      pos_i = i;
      break;
    }
  }

  // 만일 'i' 가 없다면 이 수는 실수 뿐이다.
  if (pos_i == -1) {
    str_real = get_number(str, begin, end - 1);

    Complex temp(str_real, str_img);
    return (*this) + temp;
  }

  // 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
  str_real = get_number(str, begin, pos_i - 1);
  str_img = get_number(str, pos_i + 1, end - 1);

  if (pos_i >= 1 && str[pos_i - 1] == '-') str_img *= -1.0;

  Complex temp(str_real, str_img);
  return (*this) + temp;
}
Complex Complex::operator-(const Complex& c) {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}
Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
Complex& Complex::operator=(const Complex& c) {
  real = c.real;
  img = c.img;
  return *this;
}

int main() {
  Complex a(0, 0);
  a = a + "-1.1 + i3.923";
  a.println();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2579DD3B521706FF295ABE)



와 같이 잘 실행되는 것을 알 수 있습니다.



그런데, `+` 뿐만이 아니라, `-, *` 등의 모든 연산자들에 대해 이 기능을 지원하기 위해서 각각의 코드를 반복적으로 쓰는 것은 매우 귀찮은 일이 아닐 수 없습니다. 이와 같은 완전 불편한 작업을 막기 위해 아예 `const char *` 로 오버로딩되는 `Complex` 생성자를 추가하는 것도 나쁘지 않다고 생각 됩니다.


그렇게 된다면 길고 복잡했었던 `operator+ (const char * str)` 부분을 다음과 같이 간단하게 줄일 수 있기 때문이지요.

```cpp-formatted
Complex Complex::operator+(const char* str) {
  Complex temp(str);
  return (*this) + temp;
}
```



그렇다면, 간단히 `Complex(const char* str)` 을 만들어본다면 아래와 같습니다.

```cpp-formatted
Complex::Complex(const char* str) {
  // 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
  // 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
  // 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

  int begin = 0, end = strlen(str);
  img = 0.0;
  real = 0.0;

  // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
  int pos_i = -1;
  for (int i = 0; i != end; i++) {
    if (str[i] == 'i') {
      pos_i = i;
      break;
    }
  }

  // 만일 'i' 가 없다면 이 수는 실수 뿐이다.
  if (pos_i == -1) {
    real = get_number(str, begin, end - 1);
    return;
  }

  // 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
  real = get_number(str, begin, pos_i - 1);
  img = get_number(str, pos_i + 1, end - 1);

  if (pos_i >= 1 && str[pos_i - 1] == '-') img *= -1.0;
}
```



그렇게 된다면, 나머지 함수들도,

```cpp-formatted
Complex Complex::operator-(const char* str) {
  Complex temp(str);
  return (*this) - temp;
}
Complex Complex::operator*(const char* str) {
  Complex temp(str);
  return (*this) * temp;
}
Complex Complex::operator/(const char* str) {
  Complex temp(str);
  return (*this) / temp;
}
```



로 간단하게 구현할 수 있게 됩니다.

```cpp-formatted
#include <iostream>
using namespace std;

class Complex {
 private:
  double real, img;

  double get_number(const char* str, int from, int to);

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }
  Complex(const char* str);

  Complex operator+(const Complex& c);
  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  Complex operator+(const char* str);
  Complex operator-(const char* str);
  Complex operator*(const char* str);
  Complex operator/(const char* str);

  Complex& operator+=(const Complex& c);
  Complex& operator-=(const Complex& c);
  Complex& operator*=(const Complex& c);
  Complex& operator/=(const Complex& c);

  Complex& operator=(const Complex& c);

  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};
Complex::Complex(const char* str) {
  // 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
  // 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
  // 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

  int begin = 0, end = strlen(str);
  img = 0.0;
  real = 0.0;

  // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
  int pos_i = -1;
  for (int i = 0; i != end; i++) {
    if (str[i] == 'i') {
      pos_i = i;
      break;
    }
  }

  // 만일 'i' 가 없다면 이 수는 실수 뿐이다.
  if (pos_i == -1) {
    real = get_number(str, begin, end - 1);
    return;
  }

  // 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
  real = get_number(str, begin, pos_i - 1);
  img = get_number(str, pos_i + 1, end - 1);

  if (pos_i >= 1 && str[pos_i - 1] == '-') img *= -1.0;
}
double Complex::get_number(const char* str, int from, int to) {
  bool minus = false;
  if (from > to) return 0;

  if (str[from] == '-') minus = true;
  if (str[from] == '-' || str[from] == '+') from++;

  double num = 0.0;
  double decimal = 1.0;

  bool integer_part = true;
  for (int i = from; i <= to; i++) {
    if (isdigit(str[i]) && integer_part) {
      num *= 10.0;
      num += (str[i] - '0');
    } else if (str[i] == '.')
      integer_part = false;
    else if (isdigit(str[i]) && !integer_part) {
      decimal /= 10.0;
      num += ((str[i] - '0') * decimal);
    } else
      break;  // 그 이외의 이상한 문자들이 올 경우
  }

  if (minus) num *= -1.0;

  return num;
}
Complex Complex::operator+(const Complex& c) {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}
Complex Complex::operator+(const char* str) {
  Complex temp(str);
  return (*this) + temp;
}
Complex Complex::operator-(const char* str) {
  Complex temp(str);
  return (*this) - temp;
}
Complex Complex::operator*(const char* str) {
  Complex temp(str);
  return (*this) * temp;
}
Complex Complex::operator/(const char* str) {
  Complex temp(str);
  return (*this) / temp;
}
Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
Complex& Complex::operator=(const Complex& c) {
  real = c.real;
  img = c.img;
  return *this;
}

int main() {
  Complex a(0, 0);
  a = a + "-1.1 + i3.923";
  a.println();
  a = a - "1.2 -i1.823";
  a.println();
  a = a * "2.3+i22";
  a.println();
  a = a / "-12+i55";
  a.println();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F2746124A5217107A221C06)



와 같이 제대로 계산됨을 알 수 있습니다.



한 가지 재미 있는 점은, `Complex(const char *str)` 생성자만 남겨놓고, `operator+(const char *str)` 계열들을 모두 지워보시고 컴파일 해보세요. 다시 말해서;

```cpp-formatted
#include <iostream>
using namespace std;

class Complex {
 private:
  double real, img;

  double get_number(const char* str, int from, int to);

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }
  Complex(const char* str);

  Complex operator+(const Complex& c);
  Complex operator-(const Complex& c);
  Complex operator*(const Complex& c);
  Complex operator/(const Complex& c);

  Complex& operator+=(const Complex& c);
  Complex& operator-=(const Complex& c);
  Complex& operator*=(const Complex& c);
  Complex& operator/=(const Complex& c);

  Complex& operator=(const Complex& c);

  void println() { cout << "( " << real << " , " << img << " ) " << endl; }
};
Complex::Complex(const char* str) {
  // 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
  // 문자열의 꼴은 다음과 같습니다 "[부호](실수부)(부호)i(허수부)"
  // 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)

  int begin = 0, end = strlen(str);
  img = 0.0;
  real = 0.0;

  // 먼저 가장 기준이 되는 'i' 의 위치를 찾는다.
  int pos_i = -1;
  for (int i = 0; i != end; i++) {
    if (str[i] == 'i') {
      pos_i = i;
      break;
    }
  }

  // 만일 'i' 가 없다면 이 수는 실수 뿐이다.
  if (pos_i == -1) {
    real = get_number(str, begin, end - 1);
    return;
  }

  // 만일 'i' 가 있다면,  실수부와 허수부를 나누어서 처리하면 된다.
  real = get_number(str, begin, pos_i - 1);
  img = get_number(str, pos_i + 1, end - 1);

  if (pos_i >= 1 && str[pos_i - 1] == '-') img *= -1.0;
}
double Complex::get_number(const char* str, int from, int to) {
  bool minus = false;
  if (from > to) return 0;

  if (str[from] == '-') minus = true;
  if (str[from] == '-' || str[from] == '+') from++;

  double num = 0.0;
  double decimal = 1.0;

  bool integer_part = true;
  for (int i = from; i <= to; i++) {
    if (isdigit(str[i]) && integer_part) {
      num *= 10.0;
      num += (str[i] - '0');
    } else if (str[i] == '.')
      integer_part = false;
    else if (isdigit(str[i]) && !integer_part) {
      decimal /= 10.0;
      num += ((str[i] - '0') * decimal);
    } else
      break;  // 그 이외의 이상한 문자들이 올 경우
  }

  if (minus) num *= -1.0;

  return num;
}
Complex Complex::operator+(const Complex& c) {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}

Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
Complex& Complex::operator=(const Complex& c) {
  real = c.real;
  img = c.img;
  return *this;
}

int main() {
  Complex a(0, 0);
  a = a + "-1.1 + i3.923";
  a.println();
  a = a - "1.2 -i1.823";
  a.println();
  a = a * "2.3+i22";
  a.println();
  a = a / "-12+i55";
  a.println();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F2746124A5217107A221C06)



놀랍게도 정확히 동일하게 나옵니다. 아니 이게 뭔가요. 고생 고생을 해서


```cpp-formatted
Complex operator+(const char *str);
Complex operator-(const char *str);
Complex operator*(const char *str);
Complex operator/(const char *str);
```



들을 모두 만들어 주었더니, 결과적으로 생성자 하나만 만들면 충분하다는 것이였나요? 놀랍게도, 우리의 컴파일러는 매우 똑똑하기 때문에 이와 같은 일이 가능합니다. 우리가

```cpp-formatted
a = a + "-1.1 + i3.923";
```



와 같은 문장을 사용하였을 때, 앞에서 이야기 해왔듯이 컴파일러가 위 문장을

```cpp-formatted
a = a.operator+("-1.1 + i3.923");
```



로 바꿔줍니다. 하지만, 우리에게는 `operator+(const char *str)` 이 없고, `operator+(const Complex& c)` 밖에 없기 때문에 직접적으로 오버로딩 되지는 않습니다. 그렇지만, 컴파일러는 매우 똑똑하기 때문에 그 다음 순위로 오버로딩 될 수 있는 함수들이 있는지 없는 지 확인해봅니다. 그런데 놀랍게도, 우리에게는 `const char *` 에서 `Complex` 를 생성할 수 있는 생성자

```cpp-formatted
Complex(const char* str);
```



가 있기 때문에 컴파일러는 문자열 리터럴로 부터 `const Complex` 타입의 객체를 새롭게 생성할 수 있게 된다는 것입니다. 즉, 위 문장은 은 다음과 같이 변환됩니다.

```cpp-formatted
a = a.operator+(Complex("-1.1 + i3.923"));
```



그럼 이제 `const Complex` 에 인자로 전달할 수 있게 되어서 제대로 프로그램이 작동을 하게 되지요. 여기서 한 가지 짚고 넘어가야 할 점은, 만일 우리가 `operator+` 함수의 인자가 `const Complex& c` 가 아니라 그냥 `Complex& c` 로 받도록 하였다면 위와 같은 변환은 이루어지지 않습니다. 왜냐하면"-1.1 `+` i3.923" 자체가 문자열 리터럴 이므로, 이를 바탕으로 생성된 객체 역시 상수 여야 하기 때문입니다. 따라서여러 모로 함수 인자의 값을 변형하지 않는다고 확신이 들면 무조건 `const` 인자로 받도록 하는 것이 좋습니다.


이러한 방식으로 여러분의 `Complex` 클래스의 문자열을 이용해서 복소수 덧셈을 수행할 수 있는 훌륭한 기능을 추가하였습니다. 하지만 문제는 다음과 같은 문장은 실행이 될 까요?

```cpp-formatted
a = "-1.1 + i3.923" + a;
```



사실 이 문장이나, 원래의

```cpp-formatted
a = a + "-1.1 + i3.923";
```



문장이나 정확히 동일한 식입니다. 왜냐하면 `+` 연산자는 교환 법칙이 성립해야만 하기 때문이죠. 하지만 여러분도 이미 짐작하셨겠지만 전자의 경우에는 성공적으로 컴파일 되지 않습니다. 왜냐하면 `a + "-1.1+i3.923"` 의 경우 이 문장이 `a.operator+("-1.1+i3.923")` 으로 변환되어서 정확히 수행될 수 있지만 `"-1.1 + i3.923" + a` 의 경우에는 이 같은 변환이 불가능 하기 때문입니다.


그렇다면 이러한 문제를 어떻게 해결할 수 있을까요?


이에 대해서는 다음 시간에 다루어 보도록 하겠습니다.




###  생각해보기

#### 문제 1

 그렇다면 `Complex` 클래스의 연산자 오버로딩을 수행하면서 쌓은 지식을 바탕으로 `MyString` 함수를 완전하게 만들어봅시다. 즉, 강좌 서두에서 지적한 사항들을 모두 구현하시면 됩니다. (난이도 : 下)


```warning
강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면꼭 댓글을 남겨주시기 바랍니다. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요.

현재 여러분이 보신 강좌는<<씹어먹는 C++ - <5 - 1. 내가 만든 연산자 - 연산자 오버로딩>>> 입니다. 이번 강좌의모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전까지 다음 강좌로 넘어가지 말아주세요


 [다음 강좌 보러가기](http://itguru.tistory.com/135)
```
Link :  198
2013-08-15 18:11
----------------
title : 씹어먹는 C++ - <4 - 5. 내가 만드는 String 클래스>
cat_title: 4 - 5. 내가 만드는 String 클래스
next_page : 202
publish_date : 2013-08-15 18:11
--------------

이번 강좌에서는

* 직접 만드는 문자열 클래스(MyString)

에 대해 다룹니다.


![](/img/ChewingCpplogo.png)

안녕하세요? 여러분. C++ 강좌도 벌써 10 번째 강좌입니다. 그 동안 잘 따라오고 있으셨나요? 이번 강좌는 그 동안 배운 내용을 종합해서 하나의 작은 프로젝트를 진행해보도록 할 것입니다. 이 강좌를 통해 여태까지 배운 C++ 클래스의 중요한 내용들을 복습하고 점검할 수 있는 기회가 되었으면 합니다.


이 강좌를 읽기 전에 앞서, 여러분들은 직접 자신만의 문자열 클래스를 만들어보기 바랍니다. 그 문자열 클래스는 아래와 같은 내용들을 지원해야 합니다.

```info
1. 문자(char) 로 부터의 생성, C 문자열 (char *) 로 부터의 생성
1. 문자열 길이를 구하는 함수
1. 문자열 뒤에 다른 문자열 붙이기
1. 문자열 내에 포함되어 있는 문자열 구하기
1. 문자열이 같은지 비교
1. 문자열 크기 비교 (사전 순)

```



만일 위 내용을 다 만드셨다면 아래 내용을 읽으셔도 되고, 그렇지 않다면, 다시 한 번 도전해보시기 바랍니다!


###  문자열 클래스를 만들자




기존 [C 언어에서는 문자열을 나타내기 위해 널 종료 문자열(Null-terminating string)](http://itguru.tistory.com/29)이라는 개념을 도입해서 문자열 끝에 `NULL` 문자를 붙여 문자열을 나타내는 방식을 사용하였습니다.

하지만 C 언어 문자열을 사용하는데에는 번거로움이 많았는데, 예를 들어서 만들어진 문자열의 크기를 바꾼다던지, 문자열 뒤에 다른 문자열을 붙인다던지 등의 작업들은 상당히 프로그래머 입장에서는 귀찮을 수 밖에 없습니다. 이와 같은 작업들을 문자열 클래스를 따로 만들어서 클래스 차원에서 지원해주면 상당히 편할 텐데 말이지요. 그래서 우리는 직접 문자열 클래스를 만들고자 합니다.

사실 C++ 에서는 표준 라이브러리로 `string` 클래스를 지원하고 있습니다. (실제로 `<string>` 헤더파일을 `include` 하면 사용할 수 있습니다.) 하지만 이 막강한 `string` 클래스를 사용하기 이전에 우리는 직접 `string` 클래스를 만들고자 합니다. 일단 간단히 생각해서 우리가 만들 `MyString` 클래스에 멤버 변수로 무엇이 필요할지 생각해봅시다. 아마, 대표적으로 아래 두 개의 데이터들이 필요하다고 볼 수 있습니다.

```info
1. 문자열 데이터가 저장된 공간을 가리키는 포인터
1. 문자열 데이터의 길이

```

왜 객체에 문자열 데이터를 직접 보관하는 것이 아니라, 그 저장된 공간을 가리키는 포인터를 보관하냐고 물을 수 있습니다. 이렇게 하는 이유는 나중에 문자열 데이터의 크기가 바뀔 때, 저장된 공간을 가리키는 방식으로 하면 그 메모리를 해제한 뒤에, 다시 할당할 수 있지만 직접 보관하면 그럴 수 없기 때문이죠.

또한, 문자열 데이터의 길이를 보관하는 이유는 문자열 길이를 사용할 일이 굉장히 많은데, 그 때 마다 계속 길이를 구하는 것은 상당히 불필요한 일이기 때문입니다. 따라서 길이를 한 번 구해놓고 길이가 바뀔 때 까지 변경하지 않는 방법이 유용할 것입니다. 그럼, 위 내용을 바탕으로 한번 `MyString` 을 구성해보도록 하겠습니다.

```cpp-formatted
class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이
};
```


일단 위 두 정보는 `private` 으로 설정하였습니다. 왜냐하면 우리는 다른 프로그래머가 저의 `MyString` 을 이용하면서 위와 같은 중요한 정보들에 함부로 접근하기를 원치 않거든요.

프로그래머가 실수로 `string_length` 를 조작하는 명령을 썼다가 자칫 잘못하기라도 하면 어떻겠습니까. 그렇기에 우리는 다른 프로그래머가 저의 `MyString` 을 `string_length` 나 `string_content` 를 직접 만지작거리지 않고도 그들의 원하는 모든 작업들을 수행할 수 있도록 충분한 '함수' 들을 제공해야 할 것입니다.


그럼 생성자들은 어떨까요. 일단, 위에 제가 구현하고자 요구했던 내용들을 충족시키기 위해서는 아래와 같은 생성자들을 만들어야 합니다.

```cpp-formatted
// 문자 하나로 생성
MyString(char c);

// 문자열로 부터 생성
MyString(const char* str);

// 복사 생성자
MyString(const MyString& str);
```



위와 같은 생성자들을 만들기 전에, 어떠한 방식으로 문자열을 저장할 것인지에 대해 먼저 생각해보도록 합시다. 과연 그대로 `string_content` 에 C 형식의 문자열 (널 종료 문자열) 을 보관하는 것이 좋을까요, 아니면 필요없는 정보들을 빼고 (즉 맨 마지막의 널 문자) 실제 '문자' 만 해당하는 부분만을 넣을까요.

C 형식의 문자열을 그대로 보관한다면, 문자열의 끝 부분을 쉽게 체크할 수 있다는 장점이 있지만 이 문제는 우리가 `string_length` 라는 변수를 같이 도입함으로써 해결할 수 있게 되었습니다. 따라서, 저희 `MyString` 클래스에서는 실제 문자에만 해당하는 내용만을 `string_content` 에 보관하도록 하겠습니다.

```cpp-formatted
MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
  string_length = 1;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
```


위와 같이 3 개의 생성자들을 정의하였고, `string_content` 를 동적 할당으로 처리하였기 때문에 반드시 소멸자에서 이를 동적해제하는 것을 처리해줘야만 합니다. 사실 이것이 클래스의 큰 장점이라고도 볼 수 있는데, C 언어에서 구조체같은 것으로 문자열을 구현하였다면 이를 일일히 동적해제하는 것도 처리해줘야 했었기 때문입니다. 말 그대로, 클래스를 사용하는 사람은 안에서 어떻게 돌아가는지 전혀 신경쓰지 않고도 사용할 수 있게 되는 것입니다.


그럼 이제 매우 쉽게 문자열의 길이를 구하는 함수를 만들 수 있게 되었습니다. 단순히 `string_length` 만 리턴해 주면 되는 것입니다.참고로 내부 변수의 내용을 바꾸지 않거나, 상수 함수들만 호출하는 함수들은 왠만하면 이 `length` 함수 처럼 `const` 함수로 정의해 주는 것이 좋습니다.

```cpp-formatted
int MyString::length() const { return string_length; }
```



다만 이러한 방식으로 문자열의 길이를 구한다면, 문자열 조작시에 `string_length` 의 값을 올바른 값으로 설정해야만 합니다. 예를 들어서, 두 문자열을 서로 더해서 새로운 문자열을 만들 때 새로운 문자열의 `string_length` 는 두 문자열의 `string_length` 의 합이 되겠지요. 마찬가지로 부분 문자열을 추출하거나, 문자 하나를 지우는 등 모든 작업을 할 때 `string_length` 값을 정확하게 조정해야만 합니다.

```cpp-formatted
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
```


그리고 마지막으로, 우리의 `MyString` 클래스의 내용을 보기 위해서, 문자열을 출력하는 함수 `print` 와 `println` 을 만들었습니다. (단지 마지막에 개행을 하느냐 안하느냐의 차이) 그럼, 우리의 현재 임시로 만들어 놓은 `MyString` 클래스가 잘 작동하고 있는지 살펴보도록 합시다.

```cpp-formatted
#include <iostream>

// string.h 는 strlen 때문에 include 했는데, 사실 여러분이 직접 strlen
// 과 같은 함수를 만들어서 써도 됩니다.
#include <string.h>
using namespace std;

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

 public:
  // 문자 하나로 생성
  MyString(char c);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length() const;

  void print();
  void println();
};

MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() const { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}
int main() {
  MyString str1("hello world!");
  MyString str2(str1);

  str1.println();
  str2.println();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F252B213A5208FCDC10EE24)



와 같이 잘 실행됨을 알 수 있습니다.






###  assign 함수


`assign` 함수는 '지정하다' 라는 뜻을 가진 함수로, 우리가 흔히 생각하는 '=' 과 동일한 역할을 하게 됩니다. 예를 들어서 우리의 `MyString` 변수 `str` 에서

```cpp-formatted
str.assign("abc");
```



를 하게 된다면 `str` 에는 원래 있었던 문자열이 지워지고 `abc` 가 들어가게 되겠지요. 그렇다면 우리는 다음과 같은 두 개의 `assign` 함수를 준비할 수 있습니다.

```cpp-formatted
MyString& assign(MyString& str);

MyString& assign(const char* str);
```

물론 이 `assign` 함수들의 구현 자체는 매우 간단하게 할 수 있습니다. 저의 경우 다음과 같이 구현하였습니다.

```cpp-formatted
MyString& MyString::assign(MyString& str) {
  if (str.string_length > string_length) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > string_length) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
```


`string` 의 크기가 작으면 동적 할당을 수행하는데 큰 시간이 필요하지 않겠지만, 우리의 `MyString` 클래스는 어떤 크기의 문자열에 대해서도 좋은 성능을 보여주어야만 하기 때문에 위 처럼 인자로 입력받는 문자열의 크기가, 원래 문자열의 크기 보다 작다면 굳이 동적 할당을 할 필요가 없게 되죠.

따라서 그 경우에는 그냥 그대로 복사하게 됩니다. 하지만, 인자로 입력받는 문자열의 크기가 더 크다면, 현재까지는 이전에 동적으로 할당된 메모리 바로 뒤에 메모리를 추가하는 방법은 없으므로, 새로 동적할당을 해줘야만 합니다.


그런데 이렇나 방식으로 구현하는데에는 약간의 문제가 있습니다. 예를 들어 다음과 같은 상황을 생각해봅시다.

```cpp-formatted
MyString str1("very very very long string");
str1.assign("short string");
str1.assign("very long string");
```



맨 처음에 `str1` 에 아주 긴 문자열을 할당하였습니다. 예를 들어서 그 문자열의 길이가 1000 바이트 라고 생각해봅시다. (물론 위 소스에서는 겨우 몇 바이트 이겠지만 아무튼 아주 긴 문자열이라 생각합시다) 그런 다음에 `str1` 에 다시 짧은 문자열을 `assign` 하였다고 가정합니다.

우리의 `assign` 함수에 따르면 맨 처음에 '아주 긴 문자열' 의 길이가 '짧은 문자열' 보다 훨씬 작을 것이므로 `assign` 시에 특별히 동적 할당을 할 필요 없이 그냥 `string_length` 만을 줄인채 짧은 문자열로 덮어 씌우게 됩니다.


그런데 문제는 다시 `str1` 에 긴 문자열을 `assign` 시에 발생하게 됩니다 (이번의 긴 문자열은 이전의 '아주 긴 문자열' 보다는 약간 짧다고 생각합니다). 비록 `str1` 에 이미 1000 바이트에 달하는 공간이 할당되어 있는데도 불구하고 현재 짧은 문자열이 있기 때문에 새롭게 긴 문자열을 `assign` 시에 이미 1000 바이트가 할당되어 있다는 사실을 알 수 없게 됩니다.

따라서, `assign` 함수는 문자열에 짧은 문자열을 위한 작은 크기에 공간만이 할당되어 있다고 생각하여 메모리를 해제하고 다시 많은 양의 메모리를 할당하는 매우 비효율 적인 작업을 하게 됩니다. 이 과정을 그림으로 나타내면 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2328BB34520B972526BB09)



따라서 이러한 비효율 적인 막기 위해서는 얼마나 많은 공간이 할당되어 있는지 알 수 있는 정보를 따로 보관하는 것이 좋을 것이라 생각됩니다. 이를 위해 `memory_capacity` 라는, 현재 할당된 메모리 공간의 크기를 나타내는 새로운 변수를 추가하였습니다.

```cpp-formatted
MyString& MyString::assign(MyString& str) {
  if (str.string_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
    memory_capacity = str.string_length;
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
    memory_capacity = str_length;
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
```



이렇게 하게 된다면, 앞선 그림에서 나타나는 상황과 같은 문제를 방지할 수 있게 됩니다. 이렇게 `capacity` 를 도입함으로써 여러가지 새로운 함수들을 추가할 수 있게 되었습니다. 예를 들어서, 할당할 문자열의 크기를 미리 예약해 놓는 `reserve` 함수와 현재 문자열의 할당된 메모리 크기를 나타내는 `capacity` 함수를 만들 수 있습니다. 이들은 다음과 같습니다.

```cpp-formatted
int MyString::capacity() { return memory_capacity; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char *prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    delete[] prev_string_content;
  }

  // 만일 예약하려는 size 가 현재 capacity 보다 작다면
  // 아무것도 안해도 된다.
}
```



참고로 `reserve` 함수의 경우, 만일 할당하려는 크기가 현재의 할당된 크기보다 작다면 굳이 할당할 필요가 없게 됩니다. 따라서 위와 같이 `size` 가 `memory_capacity` 보다 클 경우에만 할당하도록 처리하였습니다. 과연 잘 작동하는지 살펴볼까요.

```cpp-formatted
#include <string.h>
#include <iostream>
using namespace std;

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  // 문자 하나로 생성
  MyString(char c);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length() const;
  int capacity() const;
  void reserve(int size);

  void print();
  void println();

  MyString& assign(MyString& str);
  MyString& assign(const char* str);
};

MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
  memory_capacity = 1;
  string_length = 1;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() const { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

MyString& MyString::assign(MyString& str) {
  if (str.string_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
    memory_capacity = str.string_length;
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
    memory_capacity = str_length;
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
int MyString::capacity() const { return memory_capacity; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char* prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    delete[] prev_string_content;
  }

  // 만일 예약하려는 size 가 현재 capacity 보다 작다면
  // 아무것도 안해도 된다.
}
int main() {
  MyString str1("very very very long string");
  str1.reserve(30);

  cout << "Capacity : " << str1.capacity() << endl;
  cout << "String length : " << str1.length() << endl;
  str1.println();
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F273C654F520BA8E209DFC2)



와 같이 잘 나옴을 알 수 있습니다.



마지막으로 추가할 함수는 임의의 위치의 문자를 리턴하는 함수로, 이전 C 언어에서 `[]` 로 구현되었던 것입니다. C 문자열의 경우 구조상 배열의 범위를 벗어나는 위치에 대한 문자를 요구하여도 이를 처리할 수 밖에 없었는데 (이는 결국 심각한 오류로 이루어졌죠) C++ 의 경우 특정 위치의 문자를 얻는 것을 함수로 만들어서 올바르지 않는 위치에 대한 문제를 처리할 수 잇게 되었습니다.

```cpp-formatted
char MyString::at(int i) {
  if (i >= string_length || i < 0)
    return NULL;
  else
    return string_content[i];
}
```



위와 같이 `i` 가 허용되는 범위를 초과한다면 `NULL` 을 리턴하도록 하였습니다.


자 이것으로 해서, 우리가 직접 제작한 문자열 클래스 `MyString` 의 기본적인 함수들은 모두 제작하였다고 볼 수 있습니다.

```info
* 문자 c 혹은 C 형식 문자열 str 에서 생성할 수 있는 생성자와 복사 생성자
* 문자열의 길이를 리턴하는 함수(length)
* 문자열 대입 함수(assign)
* 문자열 메모리 할당 함수(reserve) 및 현재 할당된 크기를 알아오는 함수(capacity)
* 특정 위치의 문자를 리턴하는 함수(at)

```


이제 `MyString` 을 사용하는 다른 프로그래머들은 이 최소한의 인터페이스를 이용해서, 여러가지 문자열에 관련한 모든 작업을 수행할 수 있게 됩니다. 하지만 실제로 여러분이 `MyString` 함수를 널리 편하게 사용하고 싶다면, 더 많은 기능을 제공할 수 있어야 하겠습니다.




###  문자열 삽입하기 (insert)



문자열 처리에서 가장 빈번하게 사용되는 작업으로, 문자열 중간에 다른 문자열을 삽입하는 작업을 들 수 있습니다. 사실 여태까지 만들언 놓은 함수들만을 가지고도 `insert` 작업을 쉽게 구현할 수 있겠지만, 빈번하게 사용되는 작업이다 보니까 미리 만들어 놓아서 인터페이스로 제공하는 것도 나쁘지 않을 것이라 생각됩니다.

```cpp-formatted
MyString& MyString::insert(int loc, MyString& str);
MyString& MyString::insert(int loc, const char* str);
MyString& MyString::insert(int loc, char c);
```



일단 저의 경우 `insert` 작업이 워낙 다양한 용도로 빈번하게 사용되기 때문에 위와 같은 3 개의 `insert` 함수를 준비하였습니다. 참고로 `loc` 을 어떻게 생각할 지 미리 기준을 정해야 하는데, 일반적으로 `insert` 함수에서 입력 위치를 받는 경우, 그 입력 위치 '앞' 에 문자를 `insert` 하는 경우가 많습니다. 예를 들어서 `abc` 라는 문자열에 `insert(1, "d")` 를 하게 된다면, 1 의 위치에 있는 `b` 앞에 (참고로 모든 위치는 배열의 인덱스로 생각합니다. 즉 `a` 는 0 의 위치) `d` 가 삽입됩니다.


저는 맨 위의 `MyString` 을 인자로 받는 함수 하나만 제작할 것입니다. 왜냐하면 이 함수만 제대로 제작한다면 나머지 아래의 두 함수는

```cpp-formatted
MyString& MyString::insert(int loc, const char* str) {
  MyString temp(str);
  return insert(loc, temp);
}
MyString& MyString::insert(int loc, char c) {
  MyString temp(c);
  return insert(loc, temp);
}
```



와 같이 간단하게 처리할 수 있기 때문이지요. 따라서 우리가 제대로 만들어야 할 함수는 맨 위의 `MyString` 을 인자로 받는 함수 입니다.

```cpp-formatted
MyString& MyString::insert(int loc, MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.
    memory_capacity = string_length + str.string_length;

    char* prev_string_content = string_content;
    string_content = new char[memory_capacity];

    // 일단 insert 되는 부분 직전까지의 내용을 복사한다.
    int i;
    for (i = 0; i < loc; i++) {
      string_content[i] = prev_string_content[i];
    }

    // 그리고 새롭에 insert 되는 문자열을 넣는다.
    for (int j = 0; j != str.string_length; j++) {
      string_content[i + j] = str.string_content[j];
    }

    // 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
    for (; i < string_length; i++) {
      string_content[str.string_length + i] = prev_string_content[i];
    }

    delete[] prev_string_content;

    string_length = string_length + str.string_length;
    return *this;
  }

  // 만일 초과하지 않는 경우 굳이 동적할당을 할 필요가 없게 된다.
  // 효율적으로 insert 하기 위해, 밀리는 부분을 먼저 뒤로 밀어버린다.

  for (int i = string_length - 1; i >= loc; i--) {
    // 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
    string_content[i + str.string_length] = string_content[i];
  }
  // 그리고 insert 되는 문자 다시 집어넣기
  for (int i = 0; i < str.string_length; i++)
    string_content[i + loc] = str.string_content[i];

  string_length = string_length + str.string_length;
  return *this;
}
```



제가 만든 `insert` 함수는, 이전의 `assign` 함수 처럼 새로 메모리를 할당해야 할 경우와, 굳이 할당할 필요가 없는 경우를 나누어서 처리하도록 하였습니다. 만일 원 문자열의 길이 `+` 새로 삽입되는 문자열의 길이가, 현재의 할당된 메모리의 크기 보다 크다면 반드시 메모리를 새로 할당해야 하겠지만, 작은 경우에는, 굳이 메모리를 해제하고 재할당하는데 시간을 낭비할 필요가 없게 됩니다.


메모리를 다시 할당해야 하는 경우, 일단 `string_content` 에 새로운 할당된 메모리 주소가 들어가므로, 이전의 메모리 주소를 보관하기 위해 `prev_string_content` 함수를 이용하였습니다. 따라서 이를 이용해서, `string_content` 에 삽입된 문자열을 손쉽게 집어 넣을 수 있었습니다.



반면에, 메모리를 다시 할당할 필요가 없는 경우 원래의 문자열 내용을 이용하며 삽입된 문자열을 `string_content` 에 넣어야 하므로 약간의 트릭을 이용하였습니다. 바로, 자리가 바뀌는 문자열들을 먼저 뒤로 밀어버리는 것입니다. 이미 메모리의 할당된 공간은 충분하기 때문에 뒤로 미는 것을 쉽게 수행할 수 있습니다.

```cpp-formatted
for (int i = string_length - 1; i >= loc; i--) {
  // 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
  string_content[i + str.string_length] = string_content[i];
```



예를 들어서 앞서 `abc` 에서 `d` 를 삽입하는 예에서, 1 의 위치에 `d` 를 넣었으므로, 자리가 바뀌는 것들은 `bc` 가 됩니다. 따라서 먼저 `bc` 를 뒤로 밀어버린 다음, 생긴 공간에 `d` 를 집어 넣으면 되는 것입니다. 즉, 위 작업을 수행하면 `abc` 는 `abbc` 가 되고,

```cpp-formatted
// 그리고 insert 되는 문자 다시 집어넣기
for (int i = 0; i < str.string_length; i++)
  string_content[i + loc] = str.string_content[i];
```



를 수행하면, `insert` 되는 문자가 밀린 문자열 공간에 들어가면서 `abbc` 에서 `adbc` 가 됩니다. 실제로 실행해보면 아래와 같이 잘 작동함을 알 수 있습니다.

```cpp-formatted
#include <string.h>
#include <iostream>

using namespace std;

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  // 문자 하나로 생성
  MyString(char c);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length() const;
  int capacity() const;
  void reserve(int size);

  void print();
  void println();

  MyString& assign(MyString& str);
  MyString& assign(const char* str);

  char at(int i);

  MyString& MyString::insert(int loc, MyString& str);
  MyString& MyString::insert(int loc, const char* str);
  MyString& MyString::insert(int loc, char c);
};

MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
  memory_capacity = 1;
  string_length = 1;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() const { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

MyString& MyString::assign(MyString& str) {
  if (str.string_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
    memory_capacity = str.string_length;
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
    memory_capacity = str_length;
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
int MyString::capacity() const { return memory_capacity; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char* prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    delete[] prev_string_content;
  }

  // 만일 예약하려는 size 가 현재 capacity 보다 작다면
  // 아무것도 안해도 된다.
}
char MyString::at(int i) {
  if (i >= string_length || i < 0)
    return NULL;
  else
    return string_content[i];
}
MyString& MyString::insert(int loc, MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.
    memory_capacity = string_length + str.string_length;

    char* prev_string_content = string_content;
    string_content = new char[memory_capacity];

    // 일단 insert 되는 부분 직전까지의 내용을 복사한다.
    int i;
    for (i = 0; i < loc; i++) {
      string_content[i] = prev_string_content[i];
    }

    // 그리고 새롭에 insert 되는 문자열을 넣는다.
    for (int j = 0; j != str.string_length; j++) {
      string_content[i + j] = str.string_content[j];
    }

    // 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
    for (; i < string_length; i++) {
      string_content[str.string_length + i] = prev_string_content[i];
    }

    delete[] prev_string_content;

    string_length = string_length + str.string_length;
    return *this;
  }

  // 만일 초과하지 않는 경우 굳이 동적할당을 할 필요가 없게 된다.
  // 효율적으로 insert 하기 위해, 밀리는 부분을 먼저 뒤로 밀어버린다.

  for (int i = string_length - 1; i >= loc; i--) {
    // 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
    string_content[i + str.string_length] = string_content[i];
  }
  // 그리고 insert 되는 문자 다시 집어넣기
  for (int i = 0; i < str.string_length; i++)
    string_content[i + loc] = str.string_content[i];

  string_length = string_length + str.string_length;
  return *this;
}
MyString& MyString::insert(int loc, const char* str) {
  MyString temp(str);
  return insert(loc, temp);
}
MyString& MyString::insert(int loc, char c) {
  MyString temp(c);
  return insert(loc, temp);
}
int main() {
  MyString str1("very long string");
  MyString str2("<some string inserted between>");
  str1.reserve(30);

  cout << "Capacity : " << str1.capacity() << endl;
  cout << "String length : " << str1.length() << endl;
  str1.println();

  str1.insert(5, str2);
  str1.println();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F243BAC4F520BC85D06DF34)


와 같이 잘 나옵니다.


훌륭한 `MyString` 클래스를 만들기 위해서, 한 가지 좀 더 생각해보아야 할 점들이 있습니다. 과연 `insert` 를 사용하는 경우는 보통 어떤 경우일까요? 많은 경우 `insert` 는 많은 문자열을 한 꺼번에 집어넣는 것이 아니라, 작은 크기의 문자열들을 자주 집어넣는 경우가 많습니다. 즉, 큰 크기의 문자열을 한 번에 `insert` 하는 작업 보다는 작은 크기의 문자열들을 여러번 `insert` 하는 명령을 많이 수행한다는 뜻이지요. 그런데, 만일 이미 `capacity` 한계에 달한 문자열 클래스에 문자 'a' 를 계속 추가하는 명령을 생각해보도록 합시다.


```cpp-formatted
while (some_condition) {
  str.insert(some_location, 'a');
}
```



마치 위와 같은 명령 말이지요. 이미 `str` 가 `capacity` 한계에 도달했다고 가정했으므로, 매 `insert` 마다 메모리를 해제하고, 1 만큼 큰 메모리를 할당하는 작업을 반복하게 될 것입니다. 이는 `str` 의 크기가 크다면 엄청난 작업의 낭비가 아닐 수 없습니다.

즉, 짜잘하게 계속 `insert` 하는 명령에서 메모리 할당과 해제를 반복하지 않도록 하기 위해서라면, 통 크게 메모리를 미리 `reserve` 해놓는 것이 필요합니다. 물론, 무턱대고 미리 엄청난 크기의 메모리를 할당해 놓을 수 도 없는 일이지요. 만일 10 바이트 밖에 사용하지 않는데, 이와 같이 짜잘하게 `insert` 하는 문제를 피하기 위해 1000 바이트를 미리 할당해 놓는다면 소중한 자원의 낭비가 될 것입니다.


따라서 'insert 작업에서의 잦은 할당/해제를 피하기 위해 미리 메모리를 할당해놓기' 와 '메모리를 할당해 놓되, 많은 자원을 낭비하지 않는다' 라는 두 조건을 모두 만족하는 방법이 있을까요? 물론 있습니다. 메모리를 미리 할당할 경우, 현재 메모리 크기의 두 배 정도를 할당해 놓는 다는 것입니다. 이를 코드로 표현하면 아래와 같습니다.


```cpp-formatted
MyString& MyString::insert(int loc, MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.

    if (memory_capacity * 2 > string_length + str.string_length)
      memory_capacity *= 2;
    elsememory_capacity = string_length + str.string_length;

  // 생략..
```



즉 새로 할당해야 할 메모리 크기(`string_length + str.string_length`) 가 현재의 `memory_capacity` 의 두 배 이하라면, 아예 `memory_capacity` 의 두 배에 달하는 크기를 할당해버리는 것입니다.

그리고 물론 `insert` 되는 문자열의 크기가 엄청 커서 `memory_capacity` 의 두 배를 뛰어 넘어버린다면 그냥 예약을 생각하지 않고 필요한 만큼 할당해버리면 됩니다. 이와 같은 방식으로 처리한다면, 빈번한 메모리의 할당/해제를 막을 수 있고 또 많은 메모리 공간을 낭비하지 않을수 있습니다.


참고로 이러한 방법은 C++ 에서 동적으로 할당되는 메모리를 처리하는데 매우 빈번하게 사용되는 기법중 하나입니다.


```cpp-formatted
#include <string.h>
#include <iostream>

using namespace std;

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  // 문자 하나로 생성
  MyString(char c);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length() const;
  int capacity() const;
  void reserve(int size);

  void print();
  void println();

  MyString& assign(MyString& str);
  MyString& assign(const char* str);

  char at(int i);

  MyString& MyString::insert(int loc, MyString& str);
  MyString& MyString::insert(int loc, const char* str);
  MyString& MyString::insert(int loc, char c);
};

MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
  memory_capacity = 1;
  string_length = 1;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() const { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

MyString& MyString::assign(MyString& str) {
  if (str.string_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
    memory_capacity = str.string_length;
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
    memory_capacity = str_length;
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
int MyString::capacity() const { return memory_capacity; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char* prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    delete[] prev_string_content;
  }

  // 만일 예약하려는 size 가 현재 capacity 보다 작다면
  // 아무것도 안해도 된다.
}
char MyString::at(int i) {
  if (i >= string_length || i < 0)
    return NULL;
  else
    return string_content[i];
}
MyString& MyString::insert(int loc, MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.

    if (memory_capacity * 2 > string_length + str.string_length)
      memory_capacity *= 2;
    elsememory_capacity = string_length + str.string_length;

    char* prev_string_content = string_content;
    string_content = new char[memory_capacity];

    // 일단 insert 되는 부분 직전까지의 내용을 복사한다.
    int i;
    for (i = 0; i < loc; i++) {
      string_content[i] = prev_string_content[i];
    }

    // 그리고 새롭에 insert 되는 문자열을 넣는다.
    for (int j = 0; j != str.string_length; j++) {
      string_content[i + j] = str.string_content[j];
    }

    // 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
    for (; i < string_length; i++) {
      string_content[str.string_length + i] = prev_string_content[i];
    }

    delete[] prev_string_content;

    string_length = string_length + str.string_length;
    return *this;
  }

  // 만일 초과하지 않는 경우 굳이 동적할당을 할 필요가 없게 된다.
  // 효율적으로 insert 하기 위해, 밀리는 부분을 먼저 뒤로 밀어버린다.

  for (int i = string_length - 1; i >= loc; i--) {
    // 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
    string_content[i + str.string_length] = string_content[i];
  }
  // 그리고 insert 되는 문자 다시 집어넣기
  for (int i = 0; i < str.string_length; i++)
    string_content[i + loc] = str.string_content[i];

  string_length = string_length + str.string_length;
  return *this;
}
MyString& MyString::insert(int loc, const char* str) {
  MyString temp(str);
  return insert(loc, temp);
}
MyString& MyString::insert(int loc, char c) {
  MyString temp(c);
  return insert(loc, temp);
}
int main() {
  MyString str1("very long string");
  MyString str2("<some string inserted between>");
  str1.reserve(30);

  cout << "Capacity : " << str1.capacity() << endl;
  cout << "String length : " << str1.length() << endl;
  str1.println();

  str1.insert(5, str2);
  str1.println();

  cout << "Capacity : " << str1.capacity() << endl;
  cout << "String length : " << str1.length() << endl;
  str1.println();
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F27026D45520BCCA7197826)



로 잘 수행됨을 알 수 있습니다.




###  erase 함수




앞서 `insert` 함수를 만들었으니, 이번에는 정 반대의 역할을 하는 `erase` 함수를 만들어보도록 합시다. `erase` 함수는 `insert` 함수보다 만들기 훨씬 쉬운데, 왜냐하면 기본적으로 데이터의 양이 줄어 드는 것이기 때문에 복잡하게 `capacity` 이런 것들을 생각할 필요가 없기 때문입니다.

```cpp-formatted
MyString& erase(int loc, int num);
```

`erase` 함수는 위와 같이 생겼고, `loc` 은 `insert` 와 동일하게 `loc` 의 해당하는 문자 '앞' 을 의미합니다. 그리고 `num` 은 지우는 문자의 수를 의미하죠. 예를 들어서 `abcd` 라는 문자열에서 `erase(1, 2);` 를 하게 된다면, 1 에 해당하는 문자 'b' 의 앞에서 부터 2 문자를 지우게 되어, `bc` 가 지워져서 `ad` 가 리턴됩니다.

```cpp-formatted
MyString& MyString::erase(int loc, int num)

{
  // loc 의 앞 부터 시작해서 num 문자를 지운다.
  if (num < 0 || loc < 0 || loc > string_length) return *this;

  // 지운다는 것은 단순히 뒤의 문자들을 앞으로 끌고 온다고
  // 생각하면 됩니다.

  for (int i = loc + num; i < string_length; i++) {
    string_content[i - num] = string_content[i];
  }

  string_length -= num;
  return *this;
}
```



위와 같이 간단히 처리할 수 있습니다. `string_length` 를 도입하여서 정말 편리한 점이 무엇이냐면, 어차피 `string_length` 뒤에 어떠한 정보가 오든지 간에 별로 신경을 안써도 된다는 점입니다. 위와 같이 앞으로 문자들을 끌고 오면서 뒤의 문자들을 초기화 하지 않았지만, `string_length` 값을 처리하였기 때문에 뒤의 문자들에 신경 쓰지 않아도 됩니다.


물론 실제로 컴파일 해보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F223EB14F520BCEBF0B22EC)



로 아주 잘 작동함을 알 수 있습니다.



###  find 함수


이제 `insert` 와 `erase` 이외에 매우 빈번하게 사용되는 또 다른 작업으로 `find` 함수가 있습니다. 사실 `insert, erase, find` 는 문자열 연산의 기초 중의 기초라고 불러도 과언이 아닐 만큼 필수적인 함수 입니다. 그렇기 때문에 `find` 함수 자체를 어떻게 구현하느냐에 따라 문자열 클래스의 전반적인 성능이 좌지우지 되는 경우도 있습니다.

왜냐하면 `insert` 와 `erase` 는 사실 연산 시간이 크게 오래 걸리지는 않지만 문자열의 크기가 매우 크다면 `find` 연산은 엄청나게 오래 걸릴 수 있게 될 수 있지요.

문자열을 검색하는 알고리즘은 수 없이 많지만, 어떤 상황에 대해서도 좋은 성능을 발휘하는 알고리즘은 없습니다. (예를 들어 짧은 문자열 검색에 최적화 된 알고리즘과 긴 문자열 검색에 최적화 된 알고리즘들 같이 말입니다) 그렇기에 특별한 알고리즘을 사용하는 경우에는 그 클래스의 사용 목적이 명확해서 그 알고리즘이 좋은 성능을 발휘할 수 있는 경우에만 사용하는 것이 보통입니다. 따라서 우리의 `MyString` 의 경우, 가장 간단한 방법으로 `find` 알고리즘을 구현하기로 하였습니다.

```cpp-formatted
int find(int find_from, MyString& str);

int find(int find_from, const char* str);
int find(int find_from, char c);
```



일단 우리는 앞서 `insert` 함수를 구현한 방법처럼, 맨 위의 `MyString` 을 인자로 받는 `find` 만 제대로 구현한 후에, 아래 두 개의 `find` 는 맨 위의 함수를 이용해서 구현하는 방식으로 처리하였습니다.


참고로 `find` 함수는 `find_from` 에서 부터 시작해서 가장 첫 번째 `str` 의 위치를 리턴하게 됩니다. 그리고 `str` 이 문자열에 포함되어 있지 않다면, -1 을 리턴하게 되지요. 이러한 방법으로, 어떤 문자열 내에 있는 모든 `str` 들을 찾을 수 있는 `for` 문을 생각할 수 도 있을 것입니다.

```cpp-formatted
int MyString::find(int find_from, MyString& str) {
  int i, j;
  if (str.string_length == 0) return -1;
  for (i = find_from; i < string_length - str.string_length; i++) {
    for (j = 0; j < str.string_length; j++) {
      if (string_content[i + j] != str.string_content[j]) break;
    }

    if (j == str.string_length) return i;
  }

  return -1;  // 찾지 못했음
}
```



저의 경우 위와 같이 간단한 방법으로 `find` 함수를 구현하였습니다. `find_from` 부터  시작해서 `string_content` 와 `str` 가 완벽히 일치하는 부분이 생긴다면 그 위치를 리턴하고, 찾지 못할 경우 -1 을 리턴하도록 말이지요. 그럼 잘 작동하는지 살펴보도록 합시다.

```cpp-formatted
#include <string.h>
#include <iostream>

using namespace std;

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  // 문자 하나로 생성
  MyString(char c);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length() const;
  int capacity() const;
  void reserve(int size);

  void print();
  void println();

  MyString& assign(MyString& str);
  MyString& assign(const char* str);

  char at(int i);

  MyString& insert(int loc, MyString& str);
  MyString& insert(int loc, const char* str);
  MyString& insert(int loc, char c);

  MyString& erase(int loc, int num);

  int find(int find_from, MyString& str);
  int find(int find_from, const char* str);
  int find(int find_from, char c);
};

MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
  memory_capacity = 1;
  string_length = 1;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() const { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

MyString& MyString::assign(MyString& str) {
  if (str.string_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
    memory_capacity = str.string_length;
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
    memory_capacity = str_length;
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
int MyString::capacity() const { return memory_capacity; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char* prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    delete[] prev_string_content;
  }

  // 만일 예약하려는 size 가 현재 capacity 보다 작다면
  // 아무것도 안해도 된다.
}
char MyString::at(int i) {
  if (i >= string_length || i < 0)
    return NULL;
  else
    return string_content[i];
}
MyString& MyString::insert(int loc, MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.

    if (memory_capacity * 2 > string_length + str.string_length)
      memory_capacity *= 2;
    elsememory_capacity = string_length + str.string_length;

    char* prev_string_content = string_content;
    string_content = new char[memory_capacity];

    // 일단 insert 되는 부분 직전까지의 내용을 복사한다.
    int i;
    for (i = 0; i < loc; i++) {
      string_content[i] = prev_string_content[i];
    }

    // 그리고 새롭에 insert 되는 문자열을 넣는다.
    for (int j = 0; j != str.string_length; j++) {
      string_content[i + j] = str.string_content[j];
    }

    // 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
    for (; i < string_length; i++) {
      string_content[str.string_length + i] = prev_string_content[i];
    }

    delete[] prev_string_content;

    string_length = string_length + str.string_length;
    return *this;
  }

  // 만일 초과하지 않는 경우 굳이 동적할당을 할 필요가 없게 된다.
  // 효율적으로 insert 하기 위해, 밀리는 부분을 먼저 뒤로 밀어버린다.

  for (int i = string_length - 1; i >= loc; i--) {
    // 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
    string_content[i + str.string_length] = string_content[i];
  }
  // 그리고 insert 되는 문자 다시 집어넣기
  for (int i = 0; i < str.string_length; i++)
    string_content[i + loc] = str.string_content[i];

  string_length = string_length + str.string_length;
  return *this;
}
MyString& MyString::insert(int loc, const char* str) {
  MyString temp(str);
  return insert(loc, temp);
}
MyString& MyString::insert(int loc, char c) {
  MyString temp(c);
  return insert(loc, temp);
}

MyString& MyString::erase(int loc, int num) {
  // loc 의 앞 부터 시작해서 num 문자를 지운다.
  if (num < 0 || loc < 0 || loc > string_length) return *this;

  // 지운다는 것은 단순히 뒤의 문자들을 앞으로 끌고 온다고
  // 생각하면 됩니다.

  for (int i = loc + num; i < string_length; i++) {
    string_content[i - num] = string_content[i];
  }

  string_length -= num;
  return *this;
}
int MyString::find(int find_from, MyString& str) {
  int i, j;
  if (str.string_length == 0) return -1;
  for (i = find_from; i < string_length - str.string_length; i++) {
    for (j = 0; j < str.string_length; j++) {
      if (string_content[i + j] != str.string_content[j]) break;
    }

    if (j == str.string_length) return i;
  }

  return -1;  // 찾지 못했음
}
int MyString::find(int find_from, const char* str) {
  MyString temp(str);
  return find(find_from, temp);
}
int MyString::find(int find_from, char c) {
  MyString temp(c);
  return find(find_from, temp);
}
int main() {
  MyString str1("this is a very very long string");
  cout << "Location of first <very> in the string : " << str1.find(0, "very")
       << endl;
  cout << "Location of second <very> in the string : "
       << str1.find(str1.find(0, "very") + 1, "very") << endl;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2427513A520C79810311EE)



와 같이 잘 처리되고 있음을 알 수 있습니다. 참고로 첫 번째 `str1.find(0, "very")` 에서는, 맨 처음 부터 시작해서 "very" 를 찾습니다. 그 결과 10 의 위치에 있음을 알 수 있었지요. 그 다음 "very" 를 찾기 위해 이전의 검색 한 위치 바로 다음 부터 시작하여 또 "very" 를 찾습니다. 그 결과 15 의 위치에 있는 "very" 를 찾을 수 있게 됩니다.


###  크기 비교 함수 `compare`


마지막으로 만들 함수는 문자열 간의 크기를 비교하는 `compare` 함수 입니다. 여기서 '크기' 를 비교한다는 의미는 사전식으로 배열해서 어떤 문자열이 더 뒤에 오는지 판단한다는 의미가 됩니다. 이 함수를 이용해서 문자열 전체를 정렬하는 함수라던지, 기존의 C 언어에서 `strcmp` 함수 등으로 지원하였던 것들을 그대로 사용할 수 있게 됩니다.

```cpp-formatted
int compare(MyString& str);
```



일단 함수의 원형은 위와 같이 `*this` 와 `str` 을 비교하는 형태로 이루어집니다.

```cpp-formatted
int MyString::compare(MyString& str)

{
  // (*this) - (str) 을 수행해서 그 1, 0, -1 로 그 결과를 리턴한다
  // 1 은 (*this) 가 사전식으로 더 뒤에 온다는 의미. 0 은 두 문자열
  // 이 같다는 의미, -1 은 (*this) 사 사전식으러 더 앞에 온다는 의미이다.

  for (int i = 0; i < min(string_length, str.string_length); i++) {
    if (string_content[i] > str.string_content[i])
      return 1;

    else if (string_content[i] < str.string_content[i])
      return -1;
  }

  // 여기 까지 했는데 끝나지 않았다면 앞 부분 까지 모두 똑같은 것이 된다.
  // 만일 문자열 길이가 같다면 두 문자열은 아예 같은 문자열이 된다.

  if (string_length == str.string_length) return 0;

  // 참고로 abc 와 abcd 의 크기 비교는 abcd 가 더 뒤에 오게 된다.
  else if (string_length > str.string_length)
    return 1;

  return -1;
}
```



참고로 말하면 `abc` 와 `abcd` 의 크기를 비교하면 `abc` 가 `abcd` 보다 사전식으로 더 앞에 오게 됩니다. 따라서 이에 대한 처리는 뒷부분에서 따로 하게 됩니다. 그리고 한 가지 더 말하자면 `min` 과 `max` 함수는 `iostream` 를 `include` 하면 사용할 수 있는 함수들 이므로, 굳이 귀찮게 만드실 필요는 없습니다.

```cpp-formatted
#include <string.h>
#include <iostream>

// min 함수를 사용하기 위한 헤더
// 사실 min 정도는 여러분이 간단히 만들어서 써도
// 됩니다.
#include <algorithm>

using namespace std;

class MyString {
  char* string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  // 문자 하나로 생성
  MyString(char c);

  // 문자열로 부터 생성
  MyString(const char* str);

  // 복사 생성자
  MyString(const MyString& str);

  ~MyString();

  int length() const;
  int capacity() const;
  void reserve(int size);

  void print();
  void println();

  MyString& assign(MyString& str);
  MyString& assign(const char* str);

  char at(int i);

  MyString& insert(int loc, MyString& str);
  MyString& insert(int loc, const char* str);
  MyString& insert(int loc, char c);

  MyString& erase(int loc, int num);

  int find(int find_from, MyString& str);
  int find(int find_from, const char* str);
  int find(int find_from, char c);

  int compare(MyString& str);
};

MyString::MyString(char c) {
  string_content = new char[1];
  string_content[0] = c;
  memory_capacity = 1;
  string_length = 1;
}
MyString::MyString(const char* str) {
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString& str) {
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
int MyString::length() const { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

MyString& MyString::assign(MyString& str) {
  if (str.string_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str.string_length];
    memory_capacity = str.string_length;
  }
  for (int i = 0; i != str.string_length; i++) {
    string_content[i] = str.string_content[i];
  }

  // 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
  // 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.

  string_length = str.string_length;

  return *this;
}
MyString& MyString::assign(const char* str) {
  int str_length = strlen(str);
  if (str_length > memory_capacity) {
    // 그러면 다시 할당을 해줘야만 한다.
    delete[] string_content;

    string_content = new char[str_length];
    memory_capacity = str_length;
  }
  for (int i = 0; i != str_length; i++) {
    string_content[i] = str[i];
  }

  string_length = str_length;

  return *this;
}
int MyString::capacity() const { return memory_capacity; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char* prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    delete[] prev_string_content;
  }

  // 만일 예약하려는 size 가 현재 capacity 보다 작다면
  // 아무것도 안해도 된다.
}
char MyString::at(int i) {
  if (i >= string_length || i < 0)
    return NULL;
  else
    return string_content[i];
}
MyString& MyString::insert(int loc, MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.

    if (memory_capacity * 2 > string_length + str.string_length)
      memory_capacity *= 2;
    elsememory_capacity = string_length + str.string_length;

    char* prev_string_content = string_content;
    string_content = new char[memory_capacity];

    // 일단 insert 되는 부분 직전까지의 내용을 복사한다.
    int i;
    for (i = 0; i < loc; i++) {
      string_content[i] = prev_string_content[i];
    }

    // 그리고 새롭에 insert 되는 문자열을 넣는다.
    for (int j = 0; j != str.string_length; j++) {
      string_content[i + j] = str.string_content[j];
    }

    // 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
    for (; i < string_length; i++) {
      string_content[str.string_length + i] = prev_string_content[i];
    }

    delete[] prev_string_content;

    string_length = string_length + str.string_length;
    return *this;
  }

  // 만일 초과하지 않는 경우 굳이 동적할당을 할 필요가 없게 된다.
  // 효율적으로 insert 하기 위해, 밀리는 부분을 먼저 뒤로 밀어버린다.

  for (int i = string_length - 1; i >= loc; i--) {
    // 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
    string_content[i + str.string_length] = string_content[i];
  }
  // 그리고 insert 되는 문자 다시 집어넣기
  for (int i = 0; i < str.string_length; i++)
    string_content[i + loc] = str.string_content[i];

  string_length = string_length + str.string_length;
  return *this;
}
MyString& MyString::insert(int loc, const char* str) {
  MyString temp(str);
  return insert(loc, temp);
}
MyString& MyString::insert(int loc, char c) {
  MyString temp(c);
  return insert(loc, temp);
}

MyString& MyString::erase(int loc, int num) {
  // loc 의 앞 부터 시작해서 num 문자를 지운다.
  if (num < 0 || loc < 0 || loc > string_length) return *this;

  // 지운다는 것은 단순히 뒤의 문자들을 앞으로 끌고 온다고
  // 생각하면 됩니다.

  for (int i = loc + num; i < string_length; i++) {
    string_content[i - num] = string_content[i];
  }

  string_length -= num;
  return *this;
}
int MyString::find(int find_from, MyString& str) {
  int i, j;
  if (str.string_length == 0) return -1;
  for (i = find_from; i < string_length - str.string_length; i++) {
    for (j = 0; j < str.string_length; j++) {
      if (string_content[i + j] != str.string_content[j]) break;
    }

    if (j == str.string_length) return i;
  }

  return -1;  // 찾지 못했음
}
int MyString::find(int find_from, const char* str) {
  MyString temp(str);
  return find(find_from, temp);
}
int MyString::find(int find_from, char c) {
  MyString temp(c);
  return find(find_from, temp);
}
int MyString::compare(MyString& str) {
  // (*this) - (str) 을 수행해서 그 1, 0, -1 로 그 결과를 리턴한다
  // 1 은 (*this) 가 사전식으로 더 뒤에 온다는 의미. 0 은 두 문자열
  // 이 같다는 의미, -1 은 (*this) 사 사전식으러 더 앞에 온다는 의미이다.

  for (int i = 0; i < min(string_length, str.string_length); i++) {
    if (string_content[i] > str.string_content[i])
      return 1;

    else if (string_content[i] < str.string_content[i])
      return -1;
  }

  // 여기 까지 했는데 끝나지 않았다면 앞 부분 까지 모두 똑같은 것이 된다.
  // 만일 문자열 길이가 같다면 두 문자열은 아예 같은 문자열이 된다.

  if (string_length == str.string_length) return 0;

  // 참고로 abc 와 abcd 의 크기 비교는 abcd 가 더 뒤에 오게 된다.
  else if (string_length > str.string_length)
    return 1;

  return -1;
}
int main() {
  MyString str1("abcdef");
  MyString str2("abcde");

  cout << "str1 and str2 compare : " << str1.compare(str2) << endl;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F26015949520C84A512589D)



와 같이 잘 나옴을 알 수 있습니다.


이것으로, 여태까지 배운 C++ 에 대한 내용을 종합해서 훌륭한 `MyString` 클래스를 만들었다고 볼 수 있습니다. 우리의 `MyString` 클래스는 다음과 같은 인터페이스를 제공합니다.

* 문자 c 혹은 C 형식 문자열 str 에서 생성할 수 있는 생성자와 복사 생성자
* 문자열의 길이를 리턴하는 함수(length)
* 문자열 대입 함수(assign)
* 문자열 메모리 할당 함수(reserve) 및 현재 할당된 크기를 알아오는 함수(capacity)
* 특정 위치의 문자를 리턴하는 함수(at)
* 특정 위치에 특정 문자열을 삽입하는 함수(insert)
* 특정 위치의 특정 개수의 문자를 지우는 함수(erase)
* 특정 위치를 시작으로 특정 문자열을 검색하는 함수(find)
* 두 문자열을 사전식 비교하는 함수(compare)


이 정도면 괜찮은 문자열 클래스라고 볼 수 있지 않나요 ㅎㅎ. 이번 강좌를 통해서 현재 까지 배운 C++ 클래스에 좀더 친숙해 질 수 있는 좋은 경험이 되었으면 합니다. 자, 그럼 이것으로 이번 강좌를 마치도록 하겠습니다.


###  생각해보기

#### 문제 1

여러가지 검색 알고리즘(KMP, Boyer - Moore) 들을 이용하는 `find` 함수를 만들어보세요. 어떤 알고리즘의 경우 미리 계산된 테이블이 필요할 텐데, 이러한 정보들 역시 `class` 변수로 처리하셔도 됩니다. (난이도 : 上)

##@ chewing-cpp-end
Link :  199
2013-08-04 22:49
----------------
title : 모든 컴퓨터 과학자가 알아야 할 부동 소수점의 모든 것(What Every Computer Scientists Should Know About Floating Point Arithmetic)
publish_date : 2013-08-04 22:49
--------------




```warning

오픈북 프로젝트는 인터넷 상의양질의 컴퓨터 문서를 번역하여 우리 말로 공급하는 프로젝트 입니다. 번역된 문서들은 인터넷 상으로어떠한 제한 조건 없이 배포되고 있으며, 다만 원 번역자의 허락 없는 무단 수정을 금합니다.


현재 까지 번역된 문서들의 리스트는 [여기에서 확인하시면 됩니다.](http://itguru.tistory.com/201)

```






이번에 번역된 문서는 '모든 컴퓨터 과학자가 알아야 할 부동 소수점의 모든 것(`What Every Comp``uter Scientists Should Know About Floating Point` Arithmetic)' 으로, 제목 그대로 컴퓨터를 공부하는 사람이라면 적어도 한 번은 읽어야 하는 부동 소수점 분야의 대부분의 내용을 망라하고 있는 문서입니다. 부동 소수점(floating `point)` 은 우리가 정말 많이 코딩하고 사용하는 것이지만 (C 의 float, double) 사실 이 자료형이 컴퓨터 내부에서 어떻게 처리되고 있는지 자세히 알고 있는 사람은 정말 드뭅니다. 물론 간단한 프로그래밍을 위해서 그 자세한 내용까지 모두 알라는 이야기는 아니지만, 적어도 부동 소수점을 사용하는 큰 프로젝트를 개발한다면, 대략적인 부동 소수점 연산의 원리 정도는 알고 있어야지 효율적인 프로그래밍을 할 수 있습니다.


이 문서는 크게 세 장으로 나뉘어 있는데, 첫 번째 장에서는 부동소수점에서 가장 중요한 부분인 반올림과, 오차를 계산하는 방법에 대해 알아봅니다. 그리고 두 번째 장에서는 `IEEE` 부동 소수점 표준에 대해 알아볼 것이고, 마지막 장에서는 이러한 부동 소수점에 관련된 정보를 시스템 적 측면에서 알아볼것입니다.


이 문서의 주요 키워드들은 다음과 같습니다 : 비정규화 수 (Denormalized number), 예외 (Exception), 부동 소수점 (Floating-point), 부동 소수점 표준 (Floating-point standard), 점진적 언더플로우(Gradual underflow), 보호 숫자 (Guard digit), `NaN,` 오버플로우 (Overflow), 상대 오차(Relative error), 반올림 오차 (Rounding error), 반올림 모드 (Rounding mode), `Ulps,` 언더 플로우 (Underflow)


아마 이 문서를 한 번 정도만 꼼꼼하게 정독하시면, 여러분이 프로그래밍을 하면서 필요한 부동 소수점 관련 지식은 거의 얻을 수 있을것입니다.


오탈자나, 틀린 내용은 댓글로 달아주시거나, kev0960@gmail.com 으로 보내주시면 감사하겠습니다.

파일 다운로드는 아래 pdf 파일을 받으시면 됩니다. 전체 페이지 수는 60 페이지 가량 됩니다.

 [ 모든 컴퓨터 과학자가 알아야 할 부동 소수점의 모든것.pdf](/attachment/모든 컴퓨터 과학자가 알아야 할 부동 소수점의 모든것.pdf)
Link :  201
2013-08-04 22:48
----------------
title : 오픈북 프로젝트 - 양질의 컴퓨터 문서 공급 프로젝트
publish_date : 2013-08-04 22:48
--------------

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2109C74751FE5B5311F6B3)


안녕하세요 :) 제가 블로그에 수년동안 강좌를 올려면서 절실히 느껴왔던 것은 바로, 우리 말로 된 훌륭한 컴퓨터 문서들이 부족하다는 점이었습니다. 구글에 영어로 원하는 자료를 조금만 찾아도 수두룩 하게 나오는 반면, 한글로 검색하면 전문적인 자료는 거의 찾아 볼 수 가 없습니다.

저는 그래서, 앞으로 양질의 컴퓨터 문서를 한글로 번역하여 혹은 자체 제작해서 공급하는 오픈북 프로젝트를 실시하려고 합니다. 사실, 예전에 한 번 어셈블리어에 관련한 문서를 번역한 적이 있었는데요([여기](https://pacman128.github.io/static/pcasm-book-korean.pdf)), 그 경험을 살려서 여러 컴퓨터 분야에 관한 양질의 한글 문서들을 무료로공급할 것입니다.


### PC 어셈블리 언어(PC Assembly Language)

[여기](https://pacman128.github.io/static/pcasm-book-korean.pdf) 에서 다운로드


PC 하드웨어(CPU, RAM) 등에 대해 다루면서 PC 어셈블리어의 기초적인 내용을 다루고 있습니다. 특히 후반부에서는 C 언어와 어셈블리어와의 연동 뿐만이 아니라 C++ 까지 폭 넓은 범위를 다루고 있기에, 초보자들이 PC 어셈블리어에 대한 기초를 다지는데에 훌륭한 문서라고 볼 수 있습니다.


### 모든 컴퓨터 과학자가 알아야 하는 부동 소수점의 모든 것 (What Every Computer Scientists Should Know About Floating Point Arithmetic)

[여기](http://itguru.tistory.com/199) 에서 다운로드


부동 소수점(Floating point) 는 컴퓨터에 있어서 매우 중요한 분야임에도 불구하고 그 중요성이 낮게 평가되는 경우가 많습니다. 하지만 우리는 C++ 에서 `float, double` 을 밥먹듯이 쓰는 만큼,부동 소수점 수를 매일 같이 이용하고 있습니다.

이 문서는 컴퓨터 과학자라면, 아니 컴퓨터 프로그래머라면 알아야 하는 부동 소수점의 모든 내용을 세세하고, 또 친절히 설명해 주고 있습니다. 이 문서를 읽고 난 다음에, 여러분들은 결코 이전의 '아무 생각 없이' 짜던 코드를 더이상 짜지 않을 것입니다.


### 씹어먹는 C 언어

[여기](http://itguru.tistory.com/187) 에서 다운로드


C 언어를 처음 배우시는 분이라면 꼭 읽어보셔야 될 문서라고 생각합니다. C 언어의 모든 분야에 걸쳐서 전반적으로 다루고 있습니다. 특히, 다른 C 언어 책들에서 설명하는 것 보다 더 자세하고 쉽게 설명하고 있기 때문에 혹시라도 평소에 이해가 되지 않았던 부분이 있으셨던 분들은 꼭 다운 받아서 읽어보셨으면 합니다.


### C++ 11` 자주 질문되는 것 모음 - C++ 11FAQs

[여기](http://itguru.tistory.com/208) 에서 다운로드


C++ 11 이 출시된지 2 년이 지났지만, 여러분들은 C++ 11 의 기능을 얼마나 사용하고 계시나요? 안타깝게도 한국어로 C++ 11 의 전반적인 기능을 모두 설명해 놓은 자료는 드뭅니다.

이 문서는 C++ 의 제작자이신 `Bjarne Stroustup` 씨의 개인 홈페이지에 올라온, 그간 이분이 받아왔던 C++ 11 에 관련된 질문들에 대해 답변 해놓은 것을 모은 것입니다. 물론, 단순한 질문-답변이 아니라, C++ 11 에 새롭게 추가된 전반적인 모든 기능들에 대한 설명과 함께, 더 자세한 기술적인 문서를 원한다면 그 문서들에 '참고자료' 형태로 링크가 달려있기에 유용하게 사용할 수 있을 것입니다.
Link :  197
2013-05-26 18:14
----------------
title : 씹어먹는 C++ - <4 - 4. 스타크래프트를 만들자 ② (const, static)>
cat_title: 4 - 4. 스타크래프트를 만들자 ② (const, static)
next_page : 198
publish_date : 2013-05-26 18:14
--------------

이번 강좌에서는

* 생성자 초기화 리스트(initializer list)
* 클래스의 `const, static` 변수
* 레퍼런스 타입을 리턴하는 함수
* `this` 포인터
* `const` 멤버 함수



등에 대해 배웁니다.


![](/img/ChewingCpplogo.png)


안녕하세요 여러분. 무려 5 개월 만의 컴백 입니다! 최근 들어서 그동안 바뻣던 일이 잘 풀려서 여러 강좌들을 폭풍 업로드 하려 합니다. 아무쪼록 2013년 안으로 저의 씹어먹는 C++ 강좌가 완결될 수 있도록 노력하겠습니다 :) 그 동안 기다려 주셔서 정말로 감사합니다~ . 아무쪼록 2013년 안으로 저의 씹어먹는 C++ 강좌가 완결될 수 있도록 노력하겠습니다 :) 그 동안 기다려 주셔서 정말로 감사합니다~~


이번 강좌에서는 지난 강좌에서 만들었던 `Marine` 클래스를 변형하는것 부터 시작하도록 하겠습니다.



###  생성자의 초기화 리스트(initializer `list)`


```cpp-formatted
#include <iostream>
using namespace std;

class Marine {
  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  int damage;            // 공격력
  bool is_dead;

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.
};

Marine::Marine() : hp(50), coord_x(0), coord_y(0), damage(5), is_dead(false) {}

Marine::Marine(int x, int y)
    : coord_x(x), coord_y(y), hp(50), damage(5), is_dead(false) {}

void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return damage; }
void Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;
}
void Marine::show_status() {
  cout << " *** Marine *** " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}

int main() {
  Marine marine1(2, 3);
  Marine marine2(3, 5);

  marine1.show_status();
  marine2.show_status();
}
```

성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1277033A50EFAD3713AECF)

와 같이 됩니다.

예전에 만들었던 `Marine` 클래스와 달라진 것은 딱 하나인데, 바로 생성자에서 무언가 특이한 것을 도입했다는 것입니다. 한 번 살펴보도록 할까요.

```cpp-formatted
Marine::Marine() : hp(50), coord_x(0), coord_y(0), damage(5), is_dead(false) {}
```


놀랍게도 함수 본체에는 아무것도 없습니다. 오직, 위에 추가된 이상한 것들이 기존의 생성자가 했던 일과 동일한 작업을 하고 있을 뿐입니다. 기존의 생성자는
```cpp-formatted
Marine::Marine() {
  hp = 50;
  coord_x = coord_y = 0;
  damage = 5;
  is_dead = false;
}
```



게 생겼는데, 그 내부에서 하던 멤버 변수들의 초기화 작업들을 새롭게 추가한 것들이 대신해서 하고 있을 뿐입니다.


위와 같이 생성자 이름 뒤에


```cpp-formatted
: hp(50), coord_x(0), coord_y(0),
damage(5), is_dead(false) {}
```



로 오는 것을 **초기화 리스트 (initializer list)** 라고 부르며, 생성자 호출과 동시에 멤버 변수들을 초기화해주게 됩니다.


```cpp-formatted
Marine::Marine(int x, int y)
    : coord_x(x), coord_y(y), hp(50), damage(5), is_dead(false) {}
```



위에서 `coord_x` 는 `x` 로 초기화 되고, `is_dead` 는 `false` 로 초기화 되게 됩니다.


멤버 초기화 리스트의 일반적인 꼴은 아래와 같습니다.

```cpp-formatted
(생성자 이름) : var1(arg1), var2(arg2) {}
```



여기서 `var` 들은 클래스의 멤버 변수들을 지칭하고, `arg` 는 그 멤버 변수들을 무엇으로 초기화 할 지 지칭하는 역할을 합니다. 한 가지 흥미로운 점은 `var1` 과 `arg1` 의 이름이 같아도 되는데, 실제로 아래의 예제는


```cpp-formatted
Marine::Marine(int coord_x, int coord_y)
    : coord_x(coord_x), coord_y(coord_y), hp(50), damage(5), is_dead(false) {}
```



정상적으로 작동합니다. 왜냐하면 `coord_x ( coord_x )` 에서 바깥쪽의 `coord_x` 는 무조건 멤버 변수를 지칭하게 되는데, 이 경우 `coord_x` 를 지칭하는 것이고, 괄호 안의 `coord_x` 는 원칙상 `Marine` 이 인자로 받은 `coord_x` 를 우선적으로 지칭하는 것이기 때문입니다.

따라서 실제로, 인자로 받은 `coord_x` 가 클래스의 멤버 변수 `coord_x` 를 초기화 하게 됩니다. 아래는 당연한 얘기 겠지만



```cpp-formatted
Marine::Marine(int coord_x, int coord_y) {
  coord_x = coord_x;
  coord_y = coord_y;
  hp = 50;
  damage = 5;
  is_dead = false;
}
```



컴파일러가 두 `coord_x` 모두 인자로 받은 `coord_x` 로 구분해서 오류가 나겠지요.


그렇다면, 왜 도대체 초기화 리스트를 사용해야 되냐고 물을 수 있습니다. 왜냐하면


```cpp-formatted
Marine::Marine() {
  hp = 50;
  coord_x = coord_y = 0;
  damage = 5;
  is_dead = false;
}
```



나


```cpp-formatted
Marine::Marine() : hp(50), coord_x(0), coord_y(0), damage(5), is_dead(false) {}
```

는 하는 일이 똑같아 보이기 때문이죠. 하지만 실제로 약간의 차이가 있습니다. 왜냐하면, 초기화 리스트를 사용한 버전의 경우 **생성과 초기화를 동시에** 하게 됩니다.

반면에 초기화 리스트를 사용하지 않는다면 **생성을 먼저 하고 그 다음에 대입** 을 수행하게 됩니다. 쉽게 말하면 초기화 리스트를 사용하는 것은

```cpp-formatted
int a = 10;
```



이라 하는 것과 같고, 그냥 예전 버전의 생성자를 사용하는 것은

```cpp-formatted
int a;
a = 10;
```



이라 하는 것과 동일하다는 것입니다. 만약에 `int` 가 대신에 클래스 였다면, 전자의 경우 '복사 생성자' 가 호출되는데, 후자의 경우 '디폴트 생성자' 가 호출된 뒤 대입이 수행된다는 이야기 이겠지요.

딱 보아도 후자가 조금 더 하는 작업이 많게 됩니다. 따라서 초기화 리스트를 사용하는 것이조금 더 효율적인 작업이라는 사실을 알 수 있지요. 그 뿐만 아니라, 우리 경험상 반드시 '생성과 동시에 초기화 되어야 하는 것들' 이 몇 가지 있었습니다. 대표적으로 레퍼런스와 상수가  있지요.


앞서 배운 바에 따르면 상수와 레퍼런스들은 모두 생성과 동시에 초기화가 되어야 합니다.

```warning

const int a;
a = 3;

int& ref; // 이것이 왜 안되는지 기억이 안난다면
ref = c; // [http://itguru.tistory.com/141](http://itguru.tistory.com/141) 를 참조
```


모두 컴파일 오류가 나겠지요. 따라서 만약에 클래스 내부에 레퍼런스 변수나 상수를 넣고 싶다면 이들을 생성자에서 무조건 초기화 리스트를 사용해서 초기화 시켜주어야만 합니다.


```cpp-formatted
#include <iostream>
using namespace std;

class Marine {
  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  bool is_dead;

  const int default_damage;  // 기본 공격력

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.
};
Marine::Marine()
    : hp(50), coord_x(0), coord_y(0), default_damage(5), is_dead(false) {}

Marine::Marine(int x, int y)
    : coord_x(x), coord_y(y), hp(50), default_damage(5), is_dead(false) {}

void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return default_damage; }
void Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;
}
void Marine::show_status() {
  cout << " *** Marine *** " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}

int main() {
  Marine marine1(2, 3);
  Marine marine2(3, 5);

  marine1.show_status();
  marine2.show_status();

  cout << endl << "마린 1 이 마린 2 를 공격! " << endl;
  marine2.be_attacked(marine1.attack());

  marine1.show_status();
  marine2.show_status();
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F122A983A50EFB93B1314D5)



이 됩니다.


위 마린 클래스는 프로그래머들의 실수로 마린의 공격력이 이상하게 변하는 것을 막기 위해서 기본 공격력이라는 상수 멤버를 도입해서, 딱 고정 시켜 버리고 마음 편하게 프로그래밍 할 수 있도록 하였습니다. 따라서 이를 위해 생성자에서 초기화 리스트를 도입해서


```cpp-formatted
Marine::Marine()
    : hp(50), coord_x(0), coord_y(0), default_damage(5), is_dead(false) {}
```



와 같이, `default_damage` 를 생성과 동시에 초기화 할 수 있도록 하였습니다. 따라서 우리는 상수인 `default_damage` 를 5 로 초기화 할 수 있고, 이 값은 영원히 바뀌지 않게 됩니다.


```cpp-formatted
Marine marine1(2, 3);
Marine marine2(3, 5);

marine1.show_status();
marine2.show_status();
```



위와 같이 `Marine` 의 객체들 (`marine1, marine2`) 를 생성하면서 생성자 오버로딩에 따라 `Marine(int x, int y)` 가 호출되는데, 이를 통해 각각 (2,3) 과 (3,5) 에 위치해 있는 마린 객체들을 만들 수 있게 되었습니다. 그리고, `show_status` 를 호출해 보면 이들이 제대로 정의 되어 있다는 사실을 알 수 있습니다.


```cpp-formatted
cout << endl << "마린 1 이 마린 2 를 공격! " << endl;
marine2.be_attacked(marine1.attack());
```



마찬가지로 `Marine` 객체들이 서로 공격하는 과정도 잘 실행되고 있음을 알 수 있습니다.


위와 같이 중요한 값들을 상수로 처리하는 것은 매우 유용한 일입니다. 다른 프로그래머가 이 클래스를 사용하면서 실수로 `marine` 의 `default_damage` 를 변경하는 명령을 집어 넣더라고 컴파일 오류가 발생하기 때문에 프로그램을 실행해서 지루한 디버깅 과정을 거쳐서 알아 내는 것 보다 훨씬 효율적으로 오류를 발견할 수 있겠지요.


```cpp-formatted
#include <iostream>
using namespace std;

class Marine {
  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  bool is_dead;

  const int default_damage;  // 기본 공격력

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성
  Marine(int x, int y, int default_damage);

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.
};
Marine::Marine()
    : hp(50), coord_x(0), coord_y(0), default_damage(5), is_dead(false) {}

Marine::Marine(int x, int y)
    : coord_x(x), coord_y(y), hp(50), default_damage(5), is_dead(false) {}

Marine::Marine(int x, int y, int default_damage)
    : coord_x(x),
      coord_y(y),
      hp(50),
      default_damage(default_damage),
      is_dead(false) {}

void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return default_damage; }
void Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;
}
void Marine::show_status() {
  cout << " *** Marine *** " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}

int main() {
  Marine marine1(2, 3, 10);
  Marine marine2(3, 5, 10);

  marine1.show_status();
  marine2.show_status();

  cout << endl << "마린 1 이 마린 2 를 공격! " << endl;
  marine2.be_attacked(marine1.attack());

  marine1.show_status();
  marine2.show_status();
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F22711E4451A0F8170A9E8A)



이 예제에서는 생성자 하나를 새로 더 추가하였는데 한 번 살펴보도록 합시다.


```cpp-formatted
Marine::Marine(int x, int y, int default_damage)
    : coord_x(x),
      coord_y(y),
      hp(50),
      default_damage(default_damage),
      is_dead(false) {}
```



이전에는 `default_damage` 에 초기화 리스트로 5 를 전달하였는데, 이 생성자의 경우 어떤 값을 전달할 지 인자로 받은 다음에 그 내용을 상수에 넣어주었습니다. 마찬가지로 이는

```cpp-formatted
const int default_damage = (인자로 받은 default_damage);
```



를 실행한 것과 마찬가지 이기 때문에 잘 작동됨을 알 수 있습니다. 그리고, 실제로 5 가 아닌 10 의 `HP` 가 깎였음을 `show_status` 를 통해 확인 할 수 있습니다.





###  생성된 총 `Marine` 수 세기 (static 변수)





자, 이번에는 여태까지 만들어지는 총 `Marine` 의 수를 알아내기 위해 코드를 짠다고 생각해봅시다. 이를 위해서는 많은 방법이 있겠지만 가장 단순한 두 방식을 생각해본다면


1. 어떠한 배열에 `Marine` 을 보관해 놓고, 생성된 마린의 개수를 모두 센다.
2. 어떤 변수를 만들어서 `Marine` 의 생성시에 1 을 추가하고, 소멸시에 1 을 뺀다.


을 생각할 수 있을 것입니다. 첫 번째 방법의 경우, (물론 `vector` 라는 자료형을 이용하면 쉽게 할 수 있겠지만 나중에 이야기 하도록 합시다.) 따로 크기가 자유자재로 변할 수 있는 배열을 따로 만들어야 하는 문제점이 있고, 두 번째의 같은 경우 만일 어떠한 함수 내에서 이런 변수를 정의하였다면 다른 함수에서도 그 값을 이용하기 위해 인자로 계속 전달해야 하는 귀찮음이 있습니다.

물론 전역 변수로 만들면 되지 않겠냐고 물을 수 도 있겠지만, 전역 변수의 경우 프로젝트의 크기가 커질 수 록 프로그래머의 실수로 인해 서로 겹쳐서 오류가 날 가능성이 다분하기에 반드시 필요한 경우가 아니면 사용을 하지 않습니다. (실제로 꼭 필요한 경우가 아니면 전역변수는 사용하지 맙시다)


하지만 C++ 에서는 위와 같은 문제를 간단하게 해결 할 수 있는 기능을 제공하고 있습니다. 마치 전역 변수 같지만 클래스 하나에만 종속되는 변수인 것인데요, 바로 `static` 멤버 변수입니다.

예전에 C 언어에서 어떠한 함수의 `static` 변수( [http://itguru.tistory.com/83](http://itguru.tistory.com/83) 참조) 가 지역 변수들 처럼 함수가 종료될 때 소멸되는 것이 아니라 프로그램이 종료될 때 소멸되는 것 처럼, 어떤 클래스의 `static` 멤버 변수의 경우, 멤버 변수들 처럼, 객체가 소멸될 때 소멸되는 것이 아닌, 프로그램이 종료될 때 소멸되는 것입니다.


또한, 이 `static` 멤버 변수의 경우, 클래스의 모든 객체들이 '공유' 하는 변수로써 각 객체 별로 따로 존재하는 멤버 변수들과는 달리 모든 객체들이 '하나의' `static` 멤버 변수를 사용하게 됩니다. 그럼 바로 아래의 예제를 살펴 보도록 합시다.

```cpp-formatted
// static 멤버 변수의 사용

#include <iostream>
using namespace std;

class Marine {
  static int total_marine_num;

  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  bool is_dead;

  const int default_damage;  // 기본 공격력

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성
  Marine(int x, int y, int default_damage);

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.

  ~Marine() { total_marine_num--; }
};
int Marine::total_marine_num = 0;

Marine::Marine()
    : hp(50), coord_x(0), coord_y(0), default_damage(5), is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y)
    : coord_x(x), coord_y(y), hp(50), default_damage(5), is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y, int default_damage)
    : coord_x(x),
      coord_y(y),
      hp(50),
      default_damage(default_damage),
      is_dead(false) {
  total_marine_num++;
}

void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return default_damage; }
void Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;
}
void Marine::show_status() {
  cout << " *** Marine *** " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
  cout << " 현재 총 마린 수 : " << total_marine_num << endl;
}

void create_marine() {
  Marine marine3(10, 10, 4);
  marine3.show_status();
}
int main() {
  Marine marine1(2, 3, 5);
  marine1.show_status();

  Marine marine2(3, 5, 10);
  marine2.show_status();

  create_marine();

  cout << endl << "마린 1 이 마린 2 를 공격! " << endl;
  marine2.be_attacked(marine1.attack());

  marine1.show_status();
  marine2.show_status();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F23493B3451A0FC9111D803)

와 같이 나오게 됩니다.
```cpp-formatted
static int total_marine_num;
```

먼저 위와 같이 클래스 `static` 변수를 정의하였습니다. 모든 전역 및 `static` 변수들은 정의와 동시에 값이 자동으로 0  으로 초기화 되기 때문에 이 경우 우리가 굳이 따로 초기화 하지 않아도 되지만 클래스 `static` 변수들의 경우 아래와 같은 방법으로 초기화 합니다.

```cpp-formatted
int Marine::total_marine_num = 0;
```



간혹 어떤 사람들의 경우 클래스 내부에서


```cpp-formatted
class Marine {
  static int total_marine_num = 0;
```

와 같이 초기화 해도 되지 않냐고 묻는 경우가 있는데, 멤버 변수들을 위와 같이 초기화 시키지 못하는 것처럼 `static` 변수 역시 클래스 내부에서 위와 같이 초기화 하는 것은 불가능 합니다. 위와 같은 꼴이 되는유일한 경우는 `const static` 변수일 때만 가능한데, 실제로


```cpp-formatted
class Marine {
  const static int x = 0;
```

으로 쓸 수 있습니다.


그럼 실제로 `total_marine_sum` 이 잘 작동하고 있는지 살펴보도록 합시다. 클래스의 편한 점이 생성자와 소멸자를 제공한다는 점인데, 덕분에 `Marine` 이 생성될 때, 그리고 소멸될 때 굳이 따로 처리하지 않고도, 생성자와 소멸자 안에 `total_marine_num` 을 조작하는 문장을 넣어주면 편하게 처리할 수 있습니다. 그 결과


```cpp-formatted
Marine::Marine()
    : hp(50), coord_x(0), coord_y(0), default_damage(5), is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y)
    : coord_x(x), coord_y(y), hp(50), default_damage(5), is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y, int default_damage)
    : coord_x(x),
      coord_y(y),
      hp(50),
      default_damage(default_damage),
      is_dead(false) {
  total_marine_num++;
}
```

로 각 생성자 호출 시에 `total_marine_num` 을 1 씩 증가시키는 문장을 넣었고,

```cpp-formatted
~Marine() { total_marine_num--; }
```



소멸 될때는 1 감소시키는 문장을 넣었습니다.


```cpp-formatted
Marine marine1(2, 3, 5);
marine1.show_status();

Marine marine2(3, 5, 10);
marine2.show_status();
```

따라서 위를 실행하면 실제로 총 `Marine` 의 수가 `1, 2` 늘어나는 것을 확인할 수 있고, 그 다음에 `create_marine` 을 실행하였을 때


```cpp-formatted
void create_marine() {
  Marine marine3(10, 10, 4);
  marine3.show_status();
}
```

역시 `marine3` 을 생성함으로써 총 `marine` 의 수가 3 이 됨을 확인할 수 있는데, `marine3` 은 `create_marine` 의 지역 객체이기 때문에 `create_marine` 이 종료될 때 소멸되게 됩니다. 따라서 다시 `main` 함수로 돌아와서


```cpp-formatted
cout << endl << "마린 1 이 마린 2 를 공격! " << endl;
marine2.be_attacked(marine1.attack());

marine1.show_status();
```



에서 총 마린수를 표시할 때 2 명으로 나오게 됩니다.


그런데 클래스 안에 `static` 변수 만 만들 수 있는 것이 아닙니다. 놀랍게도 클래스 안에는 `static` 함수도 정의할 수 있는데, `static` 변수가 어떠한 객체에 종속되는 것이 아니라, 그냥 클래스 자체에 딱 1 개 존재하는 것인 것 처럼, `static` 함수 역시 어떤 특정 객체에 종속되는 것이 아니라 클래스 전체에 딱 1 개 존재하는 함수입니다.


즉, `static` 이 아닌 멤버 함수들의 경우 객체를 만들어야지만 각 멤버 함수들을 호출할 수 있지만 `static` 함수의 경우, 객체가 없어도 그냥 클래스 자체에서 호출할 수 있게 됩니다. 그럼, 아래 예제를 살펴볼까요.

```cpp-formatted
// static 함수

#include <iostream>
using namespace std;

class Marine {
  static int total_marine_num;
  const static int i = 0;

  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  bool is_dead;

  const int default_damage;  // 기본 공격력

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성
  Marine(int x, int y, int default_damage);

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.
  static void show_total_marine();
  ~Marine() { total_marine_num--; }
};
int Marine::total_marine_num = 0;
void Marine::show_total_marine() {
  cout << "전체 마린 수 : " << total_marine_num << endl;
}
Marine::Marine()
    : hp(50), coord_x(0), coord_y(0), default_damage(5), is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y)
    : coord_x(x), coord_y(y), hp(50), default_damage(5), is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y, int default_damage)
    : coord_x(x),
      coord_y(y),
      hp(50),
      default_damage(default_damage),
      is_dead(false) {
  total_marine_num++;
}

void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return default_damage; }
void Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;
}
void Marine::show_status() {
  cout << " *** Marine *** " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
  cout << " 현재 총 마린 수 : " << total_marine_num << endl;
}

void create_marine() {
  Marine marine3(10, 10, 4);
  Marine::show_total_marine();
}
int main() {
  Marine marine1(2, 3, 5);
  Marine::show_total_marine();

  Marine marine2(3, 5, 10);
  Marine::show_total_marine();

  create_marine();

  cout << endl << "마린 1 이 마린 2 를 공격! " << endl;
  marine2.be_attacked(marine1.attack());

  marine1.show_status();
  marine2.show_status();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F0225E15051A162F122F9E0)



와 같이 나옵니다.


`static` 함수는 앞에서 이야기 한 것과 같이, 어떤 객체에 종속되는 것이 아니라 클래스에 종속되는 것으로, 따라서 이를 호출하는 방법도 `(객체).(멤버 함수)` 가 아니라,


```cpp-formatted
Marine::show_total_marine();
```



와 같이 `(클래스)::(static 함수)` 형식으로 호출하게 됩니다. 왜냐하면 어떠한 객체도 이 함수를 소유하고 있지 않기 때문이죠. 그러하기에, `static` 함수 내에서는 클래스의 `static` 변수 만을 이용할 수 밖에 없습니다. 만일 `static` 함수 내에서 아래처럼 그냥 클래스의 멤버 변수들을 이용한다면


```cpp-formatted
void Marine::show_total_marine() {
  cout << default_damage << endl;  // default_damage 는 멤버 변수
  cout << "전체 마린 수 : " << total_marine_num << endl;
}
```



`default_damage` 가 누구의 `default_damage` 인지 아무도 모르는 상황이 발생합니다. 즉, 어떤 객체의 `default_damage` 인지 `static` 변수인 `show_total_marine()` 은 알 수 없겟죠. 왜냐하면 앞에서 계속 말해왔듯이 어떤 객체에도 속해이지 않기 때문이니까요!



###  this


```cpp-formatted
// 자기 자신을 가리키는 포인터 this
#include <iostream>
using namespace std;

class Marine {
  static int total_marine_num;
  const static int i = 0;

  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  bool is_dead;

  const int default_damage;  // 기본 공격력

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성
  Marine(int x, int y, int default_damage);

  int attack();                          // 데미지를 리턴한다.
  Marine& be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);               // 새로운 위치

  void show_status();  // 상태를 보여준다.
  static void show_total_marine();
  ~Marine() { total_marine_num--; }
};
int Marine::total_marine_num = 0;
void Marine::show_total_marine() {
  cout << "전체 마린 수 : " << total_marine_num << endl;
}
Marine::Marine()
    : hp(50), coord_x(0), coord_y(0), default_damage(5), is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y)
    : coord_x(x),
      coord_y(y),
      hp(50),

      default_damage(5),
      is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y, int default_damage)
    : coord_x(x),
      coord_y(y),
      hp(50),
      default_damage(default_damage),
      is_dead(false) {
  total_marine_num++;
}

void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return default_damage; }
Marine& Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;

  return *this;
}
void Marine::show_status() {
  cout << " *** Marine *** " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
  cout << " 현재 총 마린 수 : " << total_marine_num << endl;
}

int main() {
  Marine marine1(2, 3, 5);
  marine1.show_status();

  Marine marine2(3, 5, 10);
  marine2.show_status();

  cout << endl << "마린 1 이 마린 2 를 두 번 공격! " << endl;
  marine2.be_attacked(marine1.attack()).be_attacked(marine1.attack());

  marine1.show_status();
  marine2.show_status();
}
```




성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F257CA24D51A1684431CF90)



와 같이 나옵니다.


일단 가장 먼저 눈에 띄는 것은 바로 레퍼런스를 리턴하는 함수와 `this` 라는 것인데, 차근 차근 살펴 보도록 하겠습니다.


```cpp-formatted
Marine& Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;

  return *this;
}
```

일단 `this` 라는 것이 C++ 언어 차원에서 정의되어 있는 키워드 인데, 이는 객체 자신을 가리키는 포인터의 역할을 합니다. 즉, 이 멤버 함수를 호출하는 객체 자신을 가리킨다는 것이지요. 따라서, 실제로 위 내용은


```cpp-formatted
Marine& Marine::be_attacked(int damage_earn) {
  this->hp -= damage_earn;
  if (this->hp <= 0) this->is_dead = true;

  return *this;
}
```



과 동일한 의미가 됩니다. (구조체 포인터 변수에서 `->` 를 이용해서 구조체 원소들에 접근했던 것을 상기해보세요) 실제로 모든 멤버 함수 내에서는 `this` 키워드가 정의되어 있으며 클래스 안에서 정의된 함수 중에서 `this` 키워드가 없는 함수는 (당연하게도) `static` 함수 뿐입니다.


그러면 이제 `Marine&` 을 리턴한다는 말이 도대체 무엇인지 생각해봅시다. 이전 강좌에서 배운 바에 따르면 레퍼런스라는 것이 어떤 변수의 다른 별명이라고 했습니다. (실제로 레퍼런스를 **별명(alias)** 라고 부르기도 합니다)

그런데, 그 별명을 리턴한다니, 무슨 말일까요? '레퍼런스를 리턴하는 함수' 에 대해 알아보기 위해 아래와 같은 짤막한 예제 클래스를 살펴보도록 합시다.


###  레퍼런스를 리턴하는 함수


```cpp-formatted
// 레퍼런스를 리턴하는 함수
#include <iostream>
using namespace std;

class A {
  int x;

 public:
  A(int c) : x(c) {}

  int& access_x() { return x; }
  int get_x() { return x; }
  void show_x() { cout << x << endl; }
};

int main() {
  A a(5);
  a.show_x();

  int& c = a.access_x();
  c = 4;
  a.show_x();

  int d = a.access_x();
  d = 3;
  a.show_x();

  // 아래는 오류
  // int& e = a.get_x();
  // e = 2;
  // a.show_x();

  int f = a.get_x();
  f = 1;
  a.show_x();
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F011F503951A175F824DDF6)

와 같이 나옵니다.
일단 위 클래스 `A` 는 아래와 같이 `int` 와 `int` 의 레퍼런스를 리턴하는 두 개의 함수를 가지고 있습니다.


```cpp-formatted
int& access_x() { return x; }
int get_x() { return x; }
```

`access_x` 는 `x` 의 레퍼런스를 리턴하게 되고, `get_x` 는 `x` 의 '값' 을 리턴하게 되지요. 실제로 이들이 어떻게 작동하는지 살펴보도록 하겠습니다.


```cpp-formatted
int& c = a.access_x();
c = 4;
a.show_x();
```

여기서 레퍼런스 `c` 는 `x` 의 레퍼런스, 즉 `x` 의 별명을 받았습니다. 따라서, `c` 는 `x` 의 별명으로 탄생하게 되는 것이지요.레퍼런스를 리턴하는 함수는 그 함수 부분을 원래의 변수로 치환했다고 생각해도 상관이 없습니다. 다시 말해서

```cpp-formatted
int &c = x;  // 여기서 x 는 a 의 x
```



와 동일한 말이라는 것입니다. 따라서 `c` 의 값을 바꾸는 것은 `a` 의 `x` 의 값을 바꾸는 것과 동일한 의미이므로 (c 는 단순히 x 에 다른 이름을 붙여준 것일뿐!) `show_x` 를 실행 시에 `x` 의 값이 5 에서 4 로 바뀌었음을 알 수 있습니다. 그렇다면 아래 예도 살펴볼까요.


```cpp-formatted
int d = a.access_x();
d = 3;
a.show_x();
```



이번에는 `int&` 가 아닌 그냥 `int` 변수에 'x 의 별명' 을 전달하였습니다. 만일 `d` 가 `int&` 였다면 `x` 의 별명을 받아서 `d` 역시 또 다른 `x` 의 별명이 되었겠지만, `d` 가 그냥 `int` 변수 이므로, 값의 복사가 일어나 d 에는 `x` 의 값이 들어가게 됩니다. 그리고 당연히, `d` 는 `x` 의 별명이 아닌 또 다른 독립적인 변수 이기에, `d =` 3; 을 해도 `x` 의 값은 바뀌지 않은 채, 그냥 4 가 출력되게 되죠.

```warning

// 아래는 오류
// int& e = a.get_x();
// e = 2;
// a.show_x();
```



그럼 주석 처리된 위 예를 살펴봅시다. 주석을 풀면 컴파일이 안되므로 주석 처리 해 놓은 것인데, 실제로 주석을 풀고 컴파일을 해보면

```warning

error C2440: 'initializing' : cannot convert from 'int' to 'int &' (int 를 int& 로 바꿀 수 없습니다)
```



아래와 같은 오류가 발생합니다. 그 이유는 레퍼런스가 아닌 타입을 리턴하는 경우는 '값' 의 복사가 이루어지기 때문에 임시 객체가 생성되는데, 임시객체의 레퍼런스를 가질 수 없기 때문입니다. (임시객체는 문장이 끝나게 되면 소멸됩니다) 이 과정을 그림으로 그려보면 아래와 같습니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F272F193851A18E5A29B569)

`get_x` 의 리턴으로 인해 임시로 '복사생성' 된 `int` 는 `a.get_x()` 부분을 대체하며 위 그림의 경우
```cpp-formatted
int &e = x'
```



과 같이 되는데, x' 은 문장이 끝날 때 자동으로 소멸되는 임시 객체 이기 때문에 레퍼런스를 만들 수 없습니다. 설사 레퍼런스를 만들었다고 해도 '이미 존재하지 않는 것에 대한 별명' 이 되므로 이 레퍼런스에 접근하는 것은 오류이겠지요. 아무튼 이러한 이유로 `int` 를 리턴하는 `a.get_x` 에 대해서는 레퍼런스를 만들 수 없습니다. (정확한 설명을 하자면 `int&` 는 좌측값에 대한 레퍼런스 이고, `a.get_x()` 는 우측값 이기 때문에 레퍼런스를 만들 수 없습니다. 좌측값, 우측값 내용은 나중에 더 자세히 다루겠지만 [궁금하신 분들은 이 글을 읽어보세요](http://itguru.tistory.com/189)`!)`


```cpp-formatted
int f = a.get_x();
f = 1;
a.show_x();
```



마지막으로 위 코드는 익히 보왔던 것 처럼, 임시로 생성된 `int` 변수 (위 그림에서는 `x'`) 이 `f` 에 복사되는데, 역시 `f = 1` 한 것이 실제 객체 `a` 의 `x` 에게는 아무런 영향을 끼칠 수 없겠지요. 한 가지 재미있는 점은

```cpp-formatted
a.access_x() = 3;
```



위 문장이 잘 작동한다는 점인데, 앞에서도 말했지만 '레퍼런스를 리턴하는 함수는 그 함수 부분을 리턴하는 원래 변수로 치환해도 됀다' 라는 말이 명확히 들어맞는 다는 점입니다. 즉, 위 문장은 결국

```cpp-formatted
a.x = 3;
```



과 동일한 말이 됩니다. 그 에 반면, 잘 알고 있듯이

```cpp-formatted
a.get_x() = 3;
```



은 역시 오류가 나게 되는데, 왜냐하면  a.get_x() 는 `get_x()` 가 리턴하면서 생성되는 임시 객체 (x') 으로 치환되며 임시객체에 대입을 하게 되는 모순적인 상황이 발생하게 됩니다.


그럼 이제 다시 예전의 `Marine` 예제로 돌아가보도록 합시다.


```cpp-formatted
Marine& Marine::be_attacked(int damage_earn) {
  this->hp -= damage_earn;
  if (this->hp <= 0) this->is_dead = true;

  return *this;
}
```



위 경우 `be_attacked` 함수는 `Marine&` 타입을 리턴하게 되는데, 위 경우, `*this` 를 리턴하게 됩니다. 앞에서도 말했지만 `this` 가 지금 이 함수를 호출한 객체를 가리키는 것은 기억 하시죠? 그렇기 때문에 `*this` 는 그 객체 자신을 의미하게 됩니다. 따라서,

```cpp-formatted
marine2.be_attacked(marine1.attack()).be_attacked(marine1.attack());
```



문장의 경우, 먼저 `marine2.be_attacked(marine1.attack())` 이 먼저 실행되고 리턴되는 것이 다시 `marine2` 이므로 그 다음에 또 한 번`marine2.be_attacked(marine1.attack`()) 가 실행된다고 생각할 수 있습니다. 간단하죠? 만일, `be_attacked` 함수의 리턴 타입이 `Marine&` 이 아니라 그냥 `Marine` 이라고 해봅시다. 즉, 만일 `be_attacked` 함수가 아래와 같이 바뀌었다고 가정한다면


```cpp-formatted
MarineMarine::be_attacked(int damage_earn) {
  this->hp -= damage_earn;
  if (this->hp <= 0) this->is_dead = true;

  return *this;
}
```



위로 바뀐 함수를 가지고

```cpp-formatted
marine2.be_attacked(marine1.attack()).be_attacked(marine1.attack());
```



를 실행해보면 `marine2` 는 실제로 두 번 공격이 아닌 1 번 공격으로 감소한 `HP` 만을 보입니다. (즉 40 이 아닌 45 로 나옴) 이는 앞에서도 설명했듯이 리턴타입이 `Marine` 이므로, 임시 객체 `Marine` 을 생성해서, `*this` 의 내용으로 복사가 되고 (즉, `Marine` 의 복사 생성자 호출) 이 임시 객체에 대한 `be_attacked` 함수가 호출되게 되는 것입니다.

따라서 결국 두 번째 `be_attacked` 는 `marine2` 가 아닌 엉뚱한 임시 객체에 대해 호출되는 것이므로 결국 `marine2` 는 `marine1` 의 공격을 1 번만 받게 됩니다.





###  const 함수




C++ 에서는 변수들의 값을 바꾸지 않고 읽기 만 하는, 마치 상수 같 C++ 에서는 변수들의 값을 바꾸지 않고 읽기 만 하는, 마치 상수 같은멤버 함수를 '상수 함수' 로써 선언할 수 있습니다. 아래의 예제를 살펴봅시다.
```cpp-formatted
// 상수 멤버 함수

// 자기 자신을 가리키는 포인터 this
#include <iostream>
using namespace std;

class Marine {
  static int total_marine_num;
  const static int i = 0;

  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  bool is_dead;

  const int default_damage;  // 기본 공격력

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성
  Marine(int x, int y, int default_damage);

  int attack() const;                    // 데미지를 리턴한다.
  Marine& be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);               // 새로운 위치

  void show_status();  // 상태를 보여준다.
  static void show_total_marine();
  ~Marine() { total_marine_num--; }
};
int Marine::total_marine_num = 0;
void Marine::show_total_marine() {
  cout << "전체 마린 수 : " << total_marine_num << endl;
}
Marine::Marine()
    : hp(50), coord_x(0), coord_y(0), default_damage(5), is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y)
    : coord_x(x),
      coord_y(y),
      hp(50),

      default_damage(5),
      is_dead(false) {
  total_marine_num++;
}

Marine::Marine(int x, int y, int default_damage)
    : coord_x(x),
      coord_y(y),
      hp(50),
      default_damage(default_damage),
      is_dead(false) {
  total_marine_num++;
}

void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() const { return default_damage; }
Marine& Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;

  return *this;
}
void Marine::show_status() {
  cout << " *** Marine *** " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
  cout << " 현재 총 마린 수 : " << total_marine_num << endl;
}

int main() {
  Marine marine1(2, 3, 5);
  marine1.show_status();

  Marine marine2(3, 5, 10);
  marine2.show_status();

  cout << endl << "마린 1 이 마린 2 를 두 번 공격! " << endl;
  marine2.be_attacked(marine1.attack()).be_attacked(marine1.attack());

  marine1.show_status();
  marine2.show_status();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F257CA24D51A1684431CF90)



와 같이 나옵니다. 사실 위 소스는 거의 바뀐 것은 없고, 단순히 예시를 위해 아래와 같이 `attack` 함수를 살짝 바꾸었습니다.

```cpp-formatted
int attack() const;  // 데미지를 리턴한다.
```



일단 상수 함수는 위와 같은 형태로 선언을 하게 됩니다. 즉,

```cpp-formatted
(기존의 함수의 정의) const;
```



그리고 함수의 정의 역시 `const` 키워드를 꼭 넣어주어야 하는데, 아래와 같이 말이지요.


```cpp-formatted
int Marine::attack() const { return default_damage; }
```



그렇게 하였으면 위 `attack` 함수는 '상수 멤버 함수' 로 정의된 것입니다. 우리는 상수 함수로 이 함수를 정의함으로써, 이 함수는 다른 변수의 값을 바꾸지 않는 함수라고 다른 프로그래머에게 명시 시킬 수 있습니다. 당연하게도, 상수 함수 내에서는 객체들의 '읽기' 만이 수행되며, 상수 함수 내에서 호출 할 수 있는 함수로는 다른 상수 함수 밖에 없습니다.


사실 많은 경우 클래스를 설계할 때, 멤버 변수들은 모두 `private` 에 넣고, 이 변수들의 값에 접근하는 방법으로 `get_x` 함수 처럼 함수를 `public` 에 넣어 이 함수를 이용해값을 리턴받는 형식을 많이 사용합니다. 이렇게 하면 멤버 변수들을 `private` 에 넣음으로써 함부로 변수에 접근하는 것을 막고, 또 그 값은 자유롭게 구할 수 있게 됩니다.


그럼 이번 강좌는 여기서 마치도록 하겠습니다!






###  생각해보기

#### 문제 1

아래와 같은 코드에서 `copy constructor` 는 몇 번 이나 표시될까요?
```cpp-formatted
class A {
  int x;

 public:
  A(int c) : x(c) {}
  A(const A& a) {
    x = a.x;
    cout << "복사생성" << endl;
  }
};

class B {
  A a;

 public:
  B(int c) : a(c) {}
  B(const B& b) : a(b.a) {}
  A get_A() { return a; }
};

int main() {
  B b(10);
  A a1 = b.get_A();
}
```



(난이도 : 上 -사실 이 글을 잘 읽었더라면 틀리게 답하는 것이 맞습니다. 컴파일러는 불필요한 복사를 막기 위해 _copy elision_ 이라는 기술을 사용하고 있는데, 이에 관해서는 추후에 이야기 하도록 하겠습니다. 정 궁금하신 분들은 [http://en.wikipedia.org/wiki/Copy_elision](http://en.wikipedia.org/wiki/Copy_elision) 를 읽어보시기 바랍니다.)


##@ chewing-cpp-end
Link :  196
2013-01-08 03:36
----------------
title : 씹어먹는 C++ 토막글 ② - 람다(lambda) 함수
publish_date : 2013-01-08 03:36
--------------

```warning
이 글은 http://ciere.com/cppnow12/lambda.pdf 에서 가져왔고 한국말로 번역되었습니다. 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
이 글을 이해하기 위해서는 초보 이상의 C++ 지식이 필요합니다.
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```




안녕하세요? 이 글은 지난번에 우측값 레퍼런스에 관련한 글에 이어서 두 번째로 쓰는 C++ 토막글 입니다. C++ 토막글에서는 주로 C++ 11 에 추가된 최신 기술들을 다루고 있는데요, 아직 국내에 자료가 많이 부족하다 보니 체계적으로 쓰인 외국 자료들을 번역하는 형태로 제공하고 있습니다. 이 글은 http://ciere.com/cppnow12/lambda.pdf 에 올라온 `pdf` 자료를 바탕으로 번역된 글입니다. 사실 이 `pdf` 는 내용은 없고 소스만 있는 발표 자료이지만, 제가 발표자가 되었다고 가정해서 내용을 소개해보고자 합니다. 이 글이 C++ 11 의 강력한 기술인 `Lambda` 를 이해하는데 많은 도움이 되기를 바라겠습니다 :)


###  서론


어떤 벡터의 원소들의 모든 곱을 계산하는 코드를 구성한다고 생각해봅시다. 아마 가장 초보적으로 이 코드를 구성하는 방법은 아마 아래와 같을 것입니다.


```cpp-formatted
vector<int>::const_iterator iter = cardinal.begin();
vector<int>::const_iterator iter_end = cardinal.end();
int total_elements = 1;
while (iter != iter_end) {
  total_elements *= *iter;
  ++iter;
}
```



위는 반복자(iterator) 를 이용해서 `cardinal` 이라는 `vector<int>` 의 각 원소들을 순차적으로 참조해가며 `total_elements` 에 곱해나가는 코드입니다. 아주 직관적이고 단순하지만, C++ 을 처음 배우는, 아직 C++ 의 기능을 전부 접해보지 못한 초보자 수준의 코드이겠죠?


만일 "나는 C++ 쫌 해" 정도 되는 사람이라는 `Functor` 를 이용해서 아래와 같은 코드를 짜냈을 것입니다.


```cpp-formatted
int total_elements = 1;
for_each(cardinal.begin(), cardinal.end(), product<int>(total_elements));
template <typename T>
struct product {
  product(T& storage) : value(storage) {}
  template <typename V>
  void operator()(V& v) {
    value *= v;
  }
  T& value;
};
```



위 코드는 C++ 고수 답게 `for_each` 와 Functor 를 이용한 코드를 짜냈습니다. `for_each` 를 사용해서 이전 코드의 `while` 문 부분을 싸그리 없앨 수 있지만, 이를 위해 필요한 `Functor` 를 구성하는 코드가 훨씬 깁니다. 마치 배보다 배꼽이 더 큰 격이군요.

물론 전체적인 코드의 질이 높아졌다고 볼 수 있지만, `Functor` 을 이용하기 위해 `product` 라는 구조체를 생성하면서 구질구질하게 생성자도 만들고, 또 `void operator()` 도 정의해주어야겠죠. 상당히 귀찮은 일이 아닐 수 없습니다.


```cpp-formatted
int total_elements = 1;
for_each(cardinal.begin(), cardinal.end(),
         [&total_elements](int i) { total_elements *= i; });
```



자. 그럼 위 코드를 한번 봅시다. 짧고 간결하며, 무엇 보다도 `while` 문이나 `functor` 와 같은 구질구질한 코드 없이 깔끔하게 `for_each` 의 특징을 그대로 살려주었다고 볼 수 있습니다. 즉 `Functor` 에 들어갈 내용을 `product` 라는 구조체를 정의하면서 쭉 써내려갈 내용을 한 번에 깔끔하게 정리해놓은 것이지요. 이것이 바로 `Lambda` 의 위력입니다.

간단히 `Functor` 를 이용한 코드와 `Lambda` 를 이용한 코드를 비교해 보아도 그 차이를 실감할 수 있을 것입니다.
```cpp-formatted
// Functor 사용

struct mod {
  mod(int m) : modulus(m) {}
  int operator()(int v) { return v % modulus; }
  int modulus;
};
int my_mod = 8;
transform(in.begin(), in.end(), out.begin(), mod(my_mod));
```


```cpp-formatted
// Lambda 사용
int my_mod = 8;
transform(in.begin(), in.end(), out.begin(),
          [my_mod](int v) -> int { return v % my_mod; });
```



###  람다(Lambda) 의 구성


자 그럼 `Lambda` 를 사용하기 위해 `Lambda` 를 어떻게 C++ 에서 정의하는지 살펴보도록 합시다.![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1152175050EB03B514EB55)
람다는 위 그림과 같이 4 개의 부분으로 구성되어 있습니다.

그 4 개의 부분은 각각 개시자 (introducer), 인자(parameters), 반환 타입 (return type), 그리고 함수의 몸통 (statement) 라 합니다. 일단, 람다 맨 처음에 나타나는 `[]` 는 개시자로, 그 안에 어떤 외부 변수를 써 넣는다면 람다 함수가 이를 `Capture` 해서, 이 변수를 람다 내부에서 이용할 수 있게 됩니다 (이에 대한 이야기는 뒤에서...) 위 경우 `my_mod` 라는 변수를 람다 내부에서 이용할 수 있게 됩니다.

그 다음의 () 는 람다가 실행시 받을 인자들을 써 넣습니다. 위 람다는 `int` 형의 `v_` 를 인자로 받는 군요. 여기는 그냥 실제로 함수에서 사용하는 인자 리스트와 동일하게 적어주면 됩니다. 이제, 그 옆으로 보면 `->` 가 있고 반환 타입을 적어주시면 됩니다. 위 람다의 경우 `int` 를 리턴합니다. 마지막으로 람다 내부에서 실행할 내용을 적어주면 되는데, 위 람다의 경우 `v_` 와 `my_mod` 를 모듈러 연산해서 그 결과를 리턴하네요.
만일 우리가

```cpp-formatted
[my_mod](int v_) -> int { return v_ % my_mod; }
```

위와 같이 코드 상에 `Lambda` 를 썼다고 해봅시다. 그러면 런타임시 이름은 없지만, 메모리 상에  임시적으로 존재하는 클로져 (Closure) 객체가 생성됩니다. 이 클로져 객체는 함수 객체(function object) 처럼 행동합니다. (이러한 연유로 람다를 람다 함수라고 부르는 경우가 있습니다 - 사실 엄밀히 말하면 클로져 객체지 함수는 아닙니다)


그렇다면

```cpp-formatted
[]() { cout << "foo" << endl; }()
```



를 실행하였을 때 어떠한 결과가 나올까요? 일단

```cpp-formatted
[]() { cout << "foo" << endl; }
```



로 임시적인 클로져 객체가 생성되었는데 () 를 붙여서 바로 이 임시 클로져 객체를 실행시켜 버리지요. 위 람다는 `Capture` 하는 변수들도 없고, 인자로 받는 것도 없고 리턴 타입도 없고 (참고로 리턴 타입이 `void` 일 경우 `->` 를 생각 가능합니다) 함수 몸통만 덜렁 있기에 특별히 생각할 것도 없이 함수 몸통만 덜렁 실행되서




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F21748B4950EB08B1045CC5)



라고 나오게 됩니다.


그러면 조금 더 복잡한 예제를 살펴볼까요?

```cpp-formatted
[](int v) { cout << v << "*6=" << v * 6 << endl; }(7);
```



는 어떨까요.

```cpp-formatted
[](int v) { cout << v << "*6=" << v * 6 << endl; }
```



부분에서 인자로 `v` 를 받는 클로져가 생성되었는데, (7) 로 이 클로져에 인자로 7 을 전달시키면서 실행시켜버립니다. 따라서 모두가 예상 하였던 결과인




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2018AC3850EB090B0AB195)

가 나오겠네요.



람다 자체가 함수 처럼 자유롭게 사용할 수 있는 것이기 때문에 인자로 (당연히) 레퍼런스 들도 전달 가능합니다. 예를 들어


```cpp-formatted
int i = 7;
[](int& v) { v *= 6; }(i);
cout << "the correct value is: " << i << endl;
```



를 실행해보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1809903350EB09F003B36C)



가 나옵니다.


참고로 받는 인자가 없을 경우, 예컨대

```cpp-formatted
[]() { cout << "foo" << endl; }
```



의 경우 인자 () 를 생략 할 수 있습니다. 즉,

```cpp-formatted
[] { cout << "foo" << endl; }
```



도 동일한 의미입니다. (하지만 `[]` 는 지울 수 없습니다!)



###  Capture




사실 많은 경우 우리의 람다 안에서 람다 밖에 있는 변수들에게 접근하고 싶을 때가 있을 것입니다. 물론 "그렇다면 그 변수들을 그냥 인자로 받아버리면 되자나!" 라고 반문할 수 도 있겠지만, `for_each` 나 `fill, transform` 등의 C++ 의 파워풀한 `STL` 을 수행하기 위해서는 인자들을 맞추어 주어야 하는데 이 때문에 함수 내부로 전하고 싶어도 전달하지 못하는 인자들이 있기 마련 입니다.
따라서 이를 방지하기 위해, 람다 내부와 소통할 수 있는 또다른 문, `Capture` 를 제공하고 있습니다. `Capture` 하고자 하는 내용은 앞에서 말했듯이 `[]` 안에 들어오게 되는데, 대표적으로 아래의 4 개의 형태들이 있습니다.

1. `[&]() { . . . }` 외부의 모든 변수들을 레퍼런스로 가져온다. (함수의 `Call - by - reference` 를 생각)
2. `[=]() { . . . }` 외부의 모든 변수들을 값으로 가져온다. (함수의 `Call - by - value` 를 생각)
3. `[=, &x, &y] { . . .` }, [&, `x, y] { . . .` } 외부의 모든 변수들을 값/레퍼런스로 가져오되, `x` 와 `y` 만 레퍼런스/값으로 가져온다
4. `[x, &y, &z] { . . . }` 지정한 변수들을 지정한 바에 따라 가져온다.



그렇다면 한 번 예제를 살펴볼까요.


```cpp-formatted
int total_elements = 1;
vector<int> cardinal;

cardinal.push_back(1);
cardinal.push_back(2);
cardinal.push_back(4);
cardinal.push_back(8);

for_each(cardinal.begin(), cardinal.end(), [&](int i) { total_elements *= i; });

cout << "total elements : " << total_elements << endl;
```



위 코드에서 `cardinal` 에는 `1, 2, 4, 8` 이라는 원소들이 들어있고 그것을 `for_each` 를 통해 순회하면서 `total_elements` 에 곱하게 됩니다. 이 때 `Capture` 는 `&` 로 이므로 `total_elements` 를 `Capture` 할 수 있고, 람다 외부 변수인 `total_elements` 를 성공적으로 바꿀 수 있었던 것이죠. 위 코드를 실행하면 예상하던대로


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F225BF04D50EB0D6502D937)



가 나오게 됩니다.


이번에는 조금 더 복잡한 예제를 살펴보도록 합시다.


```cpp-formatted
template <typename T>
void fill(vector<int>& v, T done) {
  int i = 0;
  while (!done()) {
    v.push_back(i++);
  }
}

vector<int> stuff;
fill(stuff, [&]() -> bool { return stuff.size() >= 8; });

for_each(stuff.begin(), stuff.end(), [](int i) { cout << i << " "; });
```



참고로 클로져 객체는 분명 특정 타입의 객체 이므로 위와 같이 `template` 에서 `typename T` 로 받을 수 있습니다. 위의 `fill` 함수는 특정 타입 `T` 의 변수 `done` 으로 클로져 객체를 받았습니다. 이 때, 클로져 객체 자체는 이미 `stuff` 를 `Capture` 해서 `stuff` 에 대한 레퍼런스를 계속 가지고 있는 상태이고, `fill` 의 `while` 문에서 돌면서 `stuff` 의 크기가 8 이하 일 때 까지 수행되게 됩니다. 따라서


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1707A94C50EB0EA003B06B)

로 출력됩니다.


```cpp-formatted
void fill(vector<int>& v, T done) {
  int i = 0;
  while (!done()) {
    v.push_back(i++);
  }
}

vector<int> stuff;

fill(stuff, [&]() -> bool {
  int sum = 0;
  for_each(stuff.begin(), stuff.end(), [&](int i) { sum += i; });
  return sum >= 10;
});
for_each(stuff.begin(), stuff.end(), [](int i) { cout << i << " "; });
```



머리를 쫌만 굴려보면, 현재 `stuff` 의 원소 합이 10 이하일 때 까지 `stuff` 의 원소를 추가하는 람다라고 볼 수 있습니다.
당연히 그 결과는
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1306BC4C50EB0FDD05EF5B)

 한 가지 흥미로운 점은 `Capture` 를 레퍼런스가 아닌 값으로 할 때 언제 `Capture` 가 되냐는 것입니다.
```cpp-formatted
int v = 42;
auto func = [=] { cout << v << endl; };
v = 8;
func();
```



과연 위 소스에서 `v` 는 `func` 이 처음 정의될 때, 즉 클로져 객체가 생성될 때 `Capture` 될까요, 아니면 `func` 이 실행될 때 일까요? 만일 전자라면 42 가 출력될 것이고 후자라면 8 이 출력될 것입니다.


과연!
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1907E73550EB10780D78B0)



흥미롭게도 람다는 클로져 객체가 처음 생성될때 변수들의 값을 `Capture` 합니다.


`Capture` 를 값으로 할 때 주의점은 그 변수들에는 자동으로 `const` 속성이 붙는 다는 것입니다. 즉 값으로 `Capture` 시 그 변수들의 내용을 바꿀 수 없습니다. 따라서 아래와 같은 코드는


```cpp-formatted
int i = 10;
auto two_i = [=]() -> int {
  i *= 2;
  return i;
};
cout << "2i:" << two_i() << " i:" << i << endl;
```



컴파일 오류 "'i': a by-value capture cannot be modified in a non-mutable lambda" 가 나게 됩니다.

위 코드에서 `i` 는 분명히 값으로 받았으므로 `const` 인데, `i *= 2` 를 통해 `i` 의 값을 바꾸려 하고 있으니 오류가 발생한 것입니다. 하지만, 함수 내부에서 `i` 의 값을 바꾸고자 하면 어떨까요? (물론 실제 외부의 `i` 의 값은 바뀌지 않습니다... 함수 내부에서만 - 마치 지역 변수처럼 말이죠)


답은 간단합니다. 람다에 `mutable` 속성을 추가해주면 됩니다.


```cpp-formatted
int i = 10;
auto two_i = [=]() mutable -> int {
  i *= 2;
  return i;
};
cout << "2i:" << two_i() << " i:" << i << endl;
```



이로써 람다 내부에서 `i` 의 값을 변경할 수 있습니다. 물론, 다시 말하지만 외부의 `i` 의 값이 바뀌는 것이 아닙니다. 오직 람다 함수 내에서  '어떤 다른 `i` ' 의 값이 두 배가 되는 것이지요. 그 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2464234B50EB12140C1189)





로 나타남을 알 수 있습니다.


이제 그럼 조금 복잡한 코드를 살펴볼까요.


```cpp-formatted
class gorp {
  vector<int> values;
  int m_;

 public:
  gorp(int mod) : m_(mod) {}
  gorp& put(int v) {
    values.push_back(v);
    return *this;
  }
  int extras() {
    int count = 0;
    for_each(values.begin(), values.end(),
             [=, &count](int v) { count += v % m_; });
    return count;
  }
};

gorp g(4);
g.put(3).put(7).put(8);
cout << "extras: " << g.extras();
```


사실 위 코드는 상당히 재미있는 코드입니다. `extras` 함수를 호출하면 람다가 각 원소를 4 로 나눈 나머지들의 합을 구해서 더해주는데요, 한 가지 궁금한점! 과연 람다에서 어떻게 `m_` 을 `capture` 할 수 있었을까요? 람다는 여기서 암묵적으로 클래스의 `this` 를 Capture 했기 때문에 `m_` 을 접근할 수 있었던 것입니다.


따라서 위 코드는

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F027A864E50EB146609F056)



으로 성공적인 결과를 보여줍니다.


이렇게 `this` 를 암묵적으로 `Capture` 할 수 있기에 아래와 같은 놀라운 일도 발생할 수 있습니다.

```cpp-formatted
struct foo {
  foo() : i(0) {}
  void amazing() {
    [=] { i = 8; }();
  }
  int i;
  는
};
foo f;
f.amazing();
cout << "f.i : " << f.i;
```



위 코드를 언뜻 보면 `i` 를 값으로 `capture` 햇는데 어떻게 8 을 대입할 수 있냐고 물을 수 있는데, 사실 `this` 를 Capture 해서 `this.i = 8` 을 통해 `mutable` 없이도 값을 바꿀 수 있습니다. 왜냐하면 분명 this.i `= 8` 에서 상수인 `this` 를 변경한 것은 아니기 때문이죠.




###  Capture 의 범위


`Capture` 되는 개체들은 모두 람다가 정의된 위치에서 접근 가능해야만 합니다. 예를 들어
```cpp-formatted
int i = 8;
{
  int j = 2;
  auto f = [=] { cout << i / j; };
  f();
}
```


의 코드는 람다의 위치에서 `i, j` 모두 접근 가능하기 때문에 Capture 가능하므로 정상적으로


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728)

가 나옵니다.


그렇다면 아래 코드는 어떨까요?

```cpp-formatted
int i = 8;
auto f = [i]() {
  int j = 2;
  auto m = [=] { cout << i / j; };
  m();
};
f();
```



바깥의 람다에서 `i` 를 `Capture` 하였기에, 바깥의 람다 몸통 안에서 `i` 를 사용할 수 있겠지요. 따라서 내부의 람다는 `i` 를 `Capture` 할 수 있게 됩니다. 그렇기에, 위와 동일한 결과인





![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728)



가 나오게 됩니다. 하지만, 만일 바깥의 람다에서 `i` 를 `Capture` 하지 않았다면 어떨까요.



```cpp-formatted
int i = 8;
auto f = []() {
  int j = 2;
  auto m = [=] { cout << i / j; };
  m();
};
f();
```



그러면 예상했던 대로 컴파일 오류 error C3493: 'i' cannot be implicitly captured because no default capture mode has been specified 가 나오게 됩니다.


조금 더 복잡한 예로 아래의 코드를 살펴봅시다.


```cpp-formatted
int i = 8;
auto f = [=]() {
  int j = 2;
  auto m = [&] { i /= j; };
  m();
  cout << "inner: " << i;
};

f();
cout << " outer: " << i;
```



일단 바깥의 람다는 `i` 를 값으로 `Capture` 하였기 때문에 바깥의 람다(f) 몸통에서는 `i` 에 `const` 속성이 붙습니다. 그런데, 내부의 람다(m) 가 그 `i` 를 레퍼런스로 `Capture` 해서 값을 변경하려고 했습니다. 그렇다면, 당연히 오류가 나겠지요. 실제로 컴파일 오류 'i': a by-value capture cannot be modified in a non-mutable lambda 가 발생하게 됩니다.


이를 해결하려면, 당연히도 `mutable` 속성을 붙여주면 됩니다.


```cpp-formatted
int i = 8;
auto f = [i]() mutable {
  int j = 2;
  auto m = [&, j]() mutable { i /= j; };
  m();
  cout << "inner: " << i;
};
f();
cout << " outer: " << i;
```



`i` 자체가 값으로 입력 되었기 때문에 `outer i` 의 값은 바뀌지 않고 8 로 남아 있고, 값으로 받은 `i` 가 `m` 에 의해서 2 로 나눠지므로 4 가 됩니다. 따라서, 그 결과



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F131AC44150EB84D7352A7C)



로 나오게 되죠.





###  클로져 객체의 복사 생성자와 소멸자




모든 클로져 객체들은 암묵적으로 정의된 복사 생성자(copy constructor)와 소멸자(destructor)를 가지고 있습니다. 이 때 클로져 객체가 복사 생성 될 때 값으로 `Capture` 된 것들의 복사 생성이 일어나겠지요. 아래의 예를 한번 보도록 하겠습니다.

일단
```cpp-formatted
struct trace {
  trace() : i(0) { cout << "construct\n"; }
  trace(trace const&) { cout << "copy construct\n"; }
  ~trace() { cout << "destroy\n"; }
  trace& operator=(trace&) {
    cout << "assign\n";
    return *this;
  }
  int i;
};
```



와 같이 생성, 복사 생성, 소멸, 그리고 대입 연산을 확인할 수 있는 `trace` 라는 구조체를 정의해놓고


```cpp-formatted
trace t;
int i = 8;

auto f = [=]() { return i / 2; };
```



를 한다면 어떻게 나올까요? `f` 에서 `t` 를 사용하지 않았으므로, `t` 를 Capture 하지 않게 됩니다. 따라서 그냥




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F261D453650EB88920DF3B7)

이 나오게 됩니다.


그렇다면 아래의 예는 어떨까요

```cpp-formatted
trace t;
int i = 8;

auto m1 = [=]() { int i = t.i; };

cout << " --- make copy --- " << endl;

auto m2 = m1;
```



먼저 `m1` 을 생성하면서, 람다가 `t` 를 Capture 하였으므로 `t` 의 복사 생성자가 호출되게 됩니다. 왜냐하면 값으로 받았기 때문이지요. 만일 레퍼런스로 받았다면 복사 생성자가 호출되지 않았을 것입니다 (확인해보세요!) 그리고 아래의 `auto m2 =` m1; 에서 클로져 객체의 복사 생성이 일어나는데, 이 때, 클로져 객체의 복사 생성자가 값으로 Capture 된 객체들을 똑같이 복사 생성 해주게 됩니다. 따라서 또 한번 `t` 의 복사 생성자가 호출되겠지요. 그 결과 아래와 같이 출력됩니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197BFB3C50EB898B363D62)



###  람다의 전달 및 저장




람다를 저장 및 전달하는 방식으로 앞에서 두 가지 방법을 보았습니다. 바로
```cpp-formatted
template <typename T>
void foo(T f) auto f = [] {};
```



이지요. 우리가 만들어낸 클로져 객체의 타입이 정확히 무엇인지 몰라도 위와 같은 방법으로 성공적으로 처리할 수 있습니다.


또 다른 방법으로는 함수 포인터를 이용하는 방법이 있는데요, 이 경우 람다가 Capture 하는 것이 없어야만 합니다.


```cpp-formatted
typedef int (*f_type)(int);
f_type f = [](int i) -> int { return i + 20; };
cout << f(8);
```



(참고로 위 기능은 `Visual Studio 2010` 에서 지원되지 않습니다 - 그 후의 버전에서만 가능합니다)


위 역시 성공적으로 28 을 출력함을 알 수 있습니다.


그런데, C++ 11 에서는 클로져 객체를 전달하고 또 저장할 수 있는 막강한 기능이 제공됩니다. 바로 `std::function` 인데요, 그 어떤 클로져 객체나 함수 등을 모두 보관할 수 있는 만능 저장소 입니다. (참고로 `std::function` 은 Visual Studio 2010 에서 `<functional>` 을 include 해야 합니다)


```cpp-formatted
std::function<int(std::string const &)> f;
f = [](std::string const &s) -> int { return s.size(); };
int size = f("http://itguru.tistory.com");

cout << size << endl;
```


`std::function` 은 위와 같이 `std::function<반환 타입 ( 인자 )>` 와 같은 형태로 쓰며, Capture 가 있어도 상관이 없습니다. 물론 위 코드는 실행하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1921313750EB9004276F3E)



와 같이 잘 나오지요.


이 `std::function` 을 통해 아래와 같이 재밌는 코드도 짤 수 있습니다.

```cpp-formatted
std::function<int(int)> f1;
std::function<int(int)> f2 = [&](int i) -> int {
  cout << i << " ";
  if (i > 5) {
    return f1(i - 2);
  }
};
f1 = [&](int i) -> int {
  cout << i << " ";
  return f2(++i);
};
f1(10);
```


이것이 가능한 이유는 만일 `auto` 를 이용하였더라면 `auto f1` 을 한 시점에서 `f1` 이 명확히 구현이 되어야 컴파일러에서 타입을 추정할 수 있는데, 위와 같은 경우 `f1` 을 구현하려면 `f2` 를 먼저 구현해야 하고, 또 `f2` 를 구현하려면 다시 `f1` 을 먼저 구현해야 하는 순환적인 논리 딜레마에 빠지게 됩니다. 따라서 `function` 을 이용해서 `f1` 을 선언만 해 놓은 뒤, `f2` 를 구현하고, 다시 `f1` 을 구현하면 됩니다.


위 코드를 실행하면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1507053350EB90CD276602)



와 같이 잘 나옴을 알 수 있습니다.



마찬가지로 아래와 같은 재귀 호출 함수도 구현할 수 있습니다.


```cpp-formatted
std::function<int(int)> fact;
fact = [&fact](int n) -> int {
  if (n == 0) {
    return 1;
  } else {
    return (n * fact(n - 1));
  }
};
cout << "factorial(4) : " << fact(4) << endl;
```



이 역시 `auto` 를 이용했더라면, 처음 Capture 부분에서 Capture 하는 대상의 타입이 명확히 정해지지 않은 상태이므로 컴파일러가 타입을 추정할 수 없게 됩니다. 하지만 `function` 을 이용해서 성공적으로 구현할 수 있습니다. 위 계산 결과는 당연히




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1309CB3950EB91601B0E2A)



가 나오겠지요.





###  마치며


C++ 에 새롭게 추가된 람다는 기존의 C++ 과 전혀 다른 새로운 개념 입니다. 하지만 람다를 이용하면 수십줄의 코드도 한 두 줄로 간추릴 수 있는, 엄청난 기능이 아닐 수 없습니다 C++ 에 새롭게 추가된 람다는 기존의 C++ 과 전혀 다른 새로운 개념 입니다. 하지만 람다를 이용하면 수십줄의 코드도 한 두 줄로 간추릴 수 있는, 엄청난 기능이 아닐 수 없습니다.
이제 여러분들 손에는 람다라는 막강한 도구가 주어졌습니다. 이를 어떻게 사용하느냐는 여러분의 몫이지요 :)
그리고 이런 훌륭한 강의를 제공해주신 `Michael Caisse` 님에게 감사의 말을 전합니다.
Link :  229
2018-03-30 23:09
Link :  228
2018-03-27 19:16
----------------
title : 씹어먹는 C++ - <11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)>
cat_title: 11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)
next_page: 230
publish_date : 2018-03-27 19:16
--------------


이번 강좌에서는
* `move` 문법 (move semantics)

* 완벽한 전달 (perfect forwarding)

* 레퍼런스 겹침 (reference collapsing)


등에 대해 다룹니다.

![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 지난번의 우측값 레퍼런스 강의는 어떠셨나요? 우측값 레퍼런스를 통해서, 기존에는 불가능하였던 우측값에 대한 복사가 아닌 이동의 구현이 가능하게 되었습니다.


하지만, 만약에 좌측값도 이동을 시키고 싶다면 어떨까요? 예를 들어서 아래와 같이 두 변수의 값을 바꾸는 `swap` 함수를 생각해보세요.

```cpp-formatted
template <typename T>
void my_swap(T &a, T &b) {
  T tmp(a);
  a = b;
  b = tmp;
}
```

위 `my_swap` 함수에서 `tmp` 라는 임시 객체를 생성한 뒤에, `b` 를 `a` 에 복사하고, `b` 에 `a` 를 복사하게 됩니다. 문제는 무려 복사를 쓸데없이 3 번이나 한다는 점입니다. 예를 들어서 `T` 가 `MyString` 인 경우를 생각해봅시다.

```cpp-formatted
#include <iostream>
using namespace std;

class MyString {
  char *string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  MyString();

  // 문자열로 부터 생성
  MyString(const char *str);

  // 복사 생성자
  MyString(const MyString &str);

  // 이동 생성자
  MyString(MyString &&str);

  void reserve(int size);
  MyString operator+(const MyString &s);
  MyString &operator=(const MyString &s);
  ~MyString();

  int length() const;

  void println();
};

MyString::MyString() {
  cout << "생성자 호출 ! " << endl;
  string_length = 0;
  memory_capacity = 0;
  string_content = NULL;
}

MyString::MyString(const char *str) {
  cout << "생성자 호출 ! " << endl;
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString &str) {
  cout << "복사 생성자 호출 ! " << endl;
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::MyString(MyString &&str) {
  cout << "이동 생성자 호출 !" << endl;
  string_length = str.string_length;
  string_content = str.string_content;
  memory_capacity = str.memory_capacity;

  // 임시 객체 소멸 시에 메모리를 해제하지
  // 못하게 한다.
  str.string_content = nullptr;
}
MyString::~MyString() {
  if (string_content) delete[] string_content;
}
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char *prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    if (prev_string_content != NULL) delete[] prev_string_content;
  }
}
MyString MyString::operator+(const MyString &s) {
  MyString str;
  str.reserve(string_length + s.string_length);
  for (int i = 0; i < string_length; i++)
    str.string_content[i] = string_content[i];
  for (int i = 0; i < s.string_length; i++)
    str.string_content[string_length + i] = s.string_content[i];
  str.string_length = string_length + s.string_length;
  return str;
}
MyString &MyString::operator=(const MyString &s) {
  cout << "복사!" << endl;
  if (s.string_length > memory_capacity) {
    delete[] string_content;
    string_content = new char[s.string_length];
    memory_capacity = s.string_length;
  }
  string_length = s.string_length;
  for (int i = 0; i != string_length; i++) {
    string_content[i] = s.string_content[i];
  }

  return *this;
}
int MyString::length() const { return string_length; }
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}
template <typename T>
void my_swap(T &a, T &b) {
  T tmp(a);
  a = b;
  b = tmp;
}

int main() {
  MyString str1("abc");
  MyString str2("def");
  cout << "Swap 전 -----" << endl;
  str1.println();
  str2.println();

  cout << "Swap 후 -----" << endl;
  my_swap(str1, str2);
  str1.println();
  str2.println();
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99115F3E5AB8FD86061B59)



와 같이 나옵니다.

```cpp-formatted
template <typename T>
void my_swap(T &a, T &b) {
  T tmp(a);
  a = b;
  b = tmp;
}
```



위 `my_swap` 함수를 살펴봅시다. 일단, 첫번째 줄에서, `a` 가 좌측값이기 때문에 `tmp` 의 복사 생성자가 호출됩니다. 따라서 1 차적으로 `a` 가 차지하는 공간 만큼 메모리 할당이 발생한 후 `a` 의 데이터가 복사됩니다.

```cpp-formatted
a = b;
```



두 번째로 `a =` b; 에서 2 차적으로 복사가 발생합니다. 그리고 마지막으로,

```cpp-formatted
b = tmp;
```



에서 또 한번 문자열 전체의 복사가 이루어지게 됩니다. 무려 `swap` 을 하기 위해 문자열 전체 복사를 3번이나 해야 합니다. 아래 그림처럼 말입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F9960ED4D5AB96B7D09D8A7)

하지만 우리는 굳이 문자열 내용을 복사할 필요 없이 각 `MyString` 객체의 `string_content` 주소값만 서로 바꿔주면 되는 것을 알고 있습니다. (물론 `string_length` 와 `memory_capacity` 도 바꿔야겠지만, 이들은 단순히 4바이트 `int` 복사 이기 때문에 속도에 영향을 주지는 않습니다).

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F997263435AB96BB9085570)


하지만 위를 `my_swap` 에서 구현하기 위해서는 여러가지 문제가 있습니다. 일단 첫번째로 `my_swap` 함수는 `generic` 한 함수 입니다. 다시 말해,

```cpp-formatted
template <typename T>
void my_swap(T &a, T &b)
```



위 함수가 일반적인 타입 `T` 에 대해 작동해야 한다는 의미이지요. 하지만 위 `string_content` 의 경우 `MyString` 에만 존재하는 필드이기 때문에 일반적인 타입 `T` 에 대해서는 작동하지 않습니다. 물론 그렇다고 해서 불가능 한 것은 아닙니다. 아래 처럼 템플릿 특수화를 이용하면 되기 때문이죠.

```cpp-formatted
template <>
void my_swap(MyString &a, MyString &b) {
  // ...
}
```



문제는 `string_content` 가 `private` 이기 때문에, 이를 위해 `MyString` 내부에 `swap` 관련한 함수를 만들어야 된다는 것입니다. 사실 이렇게 된다면 굳이 `my_swap` 이라는 함수를 정의할 필요가 없게 됩니다.


위 문제를 원래의 `my_swap` 함수를 사용하면서 좀 더 깔끔하게 해결할 수 있는 방법은 없을까요?

```cpp-formatted
T tmp(a);
```



먼저 기존의 `my_swap` 함수를 다시 살펴봅시다. 우리는 위 문장이 복사 생성자 대신에, 이동 생성자가 되기를 원합니다. 왜냐하면 `tmp` 를 복사생성 할 필요 없이, 단순히 `a` 를 잠깐 옮겨놓기만 하면 되기 때문이지요. 하지만 문제는 `a` 가 좌측값이라는 점입니다 ('a' 라는 실체가 있으므로). 따라서 지금 이 상태로는 우리가 무얼 해도 이동 생성자는 오버로딩 되지 않습니다.


그렇다면, 좌측값이 우측값으로 취급될 수 있게 바꿔주는 함수 같은 것이 있을까요? 즉, 어떠한 좌측값이 이동 될 수 있도록 말이죠.



###  move 문법 (move semantics)




```cpp-formatted
#include <iostream>
using namespace std;

class MyString {
  char *string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  MyString();

  // 문자열로 부터 생성
  MyString(const char *str);

  // 복사 생성자
  MyString(const MyString &str);

  // 이동 생성자
  MyString(MyString &&str);

  void reserve(int size);
  MyString operator+(const MyString &s);
  MyString &operator=(const MyString &s);
  ~MyString();

  int length() const;

  void println();
};

MyString::MyString() {
  cout << "생성자 호출 ! " << endl;
  string_length = 0;
  memory_capacity = 0;
  string_content = NULL;
}

MyString::MyString(const char *str) {
  cout << "생성자 호출 ! " << endl;
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString &str) {
  cout << "복사 생성자 호출 ! " << endl;
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::MyString(MyString &&str) {
  cout << "이동 생성자 호출 !" << endl;
  string_length = str.string_length;
  string_content = str.string_content;
  memory_capacity = str.memory_capacity;

  // 임시 객체 소멸 시에 메모리를 해제하지
  // 못하게 한다.
  str.string_content = nullptr;
  str.string_length = 0;
  str.memory_capacity = 0;
}
MyString::~MyString() {
  if (string_content) delete[] string_content;
}
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char *prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    if (prev_string_content != NULL) delete[] prev_string_content;
  }
}
MyString MyString::operator+(const MyString &s) {
  MyString str;
  str.reserve(string_length + s.string_length);
  for (int i = 0; i < string_length; i++)
    str.string_content[i] = string_content[i];
  for (int i = 0; i < s.string_length; i++)
    str.string_content[string_length + i] = s.string_content[i];
  str.string_length = string_length + s.string_length;
  return str;
}
int MyString::length() const { return string_length; }
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

int main() {
  MyString str1("abc");
  cout << "이동 전 -----" << endl;
  cout << "str1 : ";
  str1.println();

  cout << "이동 후 -----" << endl;
  MyString str2(move(str1));
  cout << "str1 : ";
  str1.println();
  cout << "str2 : ";
  str2.println();
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99BE55345AB99D231E151B)



와 같이 나옵니다.

```cpp-formatted
cout << "이동 후 -----" << endl;
MyString str2(move(str1));
```



부분을 살펴보도록 합시다. 놀랍게도 `str2` 의 복사 생성자가 아닌 이동 생성자가 호출되었습니다. C++ 11 에 새롭게 추가된 `move` 함수는 입력받은 좌측값을 이동 가능한 값으로 캐스팅 해줍니다.사실 `move` 함수가 수정하는 것은 아무 것도 없습니다. 다만 컴파일러가 `move` 함수가 리턴하는 값을 '이동 가능 하구나' 라고 생각하게 해주지요.

```cpp-formatted
cout << "str1 : ";
str1.println();
cout << "str2 : ";
str2.println();
```



그렇게 이동 된 후에 문자열들을 출력해보면 `str1` 에는 빈 문자열이, `str2` 에는 원래의 `str1` 의 문자열이 들어있음을 알 수 있습니다. 이 과정에서 문자열 전체 복사는 한 번도 발생하지 않고 단순히 `string_content` 의 값만 복사되었을 뿐입니다.


자 이제 이 새로운 `move` 를 이용해서 위 `my_swap` 함수를 수정해보도록 합시다.

```cpp-formatted
#include <iostream>
using namespace std;

class MyString {
  char *string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  MyString();

  // 문자열로 부터 생성
  MyString(const char *str);

  // 복사 생성자
  MyString(const MyString &str);

  // 이동 생성자
  MyString(MyString &&str);

  void reserve(int size);
  MyString operator+(const MyString &s);
  MyString &operator=(const MyString &s);
  ~MyString();

  int length() const;

  void println();
};

MyString::MyString() {
  cout << "생성자 호출 ! " << endl;
  string_length = 0;
  memory_capacity = 0;
  string_content = NULL;
}

MyString::MyString(const char *str) {
  cout << "생성자 호출 ! " << endl;
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString &str) {
  cout << "복사 생성자 호출 ! " << endl;
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::MyString(MyString &&str) {
  cout << "이동 생성자 호출 !" << endl;
  string_length = str.string_length;
  string_content = str.string_content;
  memory_capacity = str.memory_capacity;

  // 임시 객체 소멸 시에 메모리를 해제하지
  // 못하게 한다.
  str.string_content = nullptr;
  str.string_length = 0;
  str.memory_capacity = 0;
}
MyString::~MyString() {
  if (string_content) delete[] string_content;
}
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char *prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    if (prev_string_content != NULL) delete[] prev_string_content;
  }
}
MyString MyString::operator+(const MyString &s) {
  MyString str;
  str.reserve(string_length + s.string_length);
  for (int i = 0; i < string_length; i++)
    str.string_content[i] = string_content[i];
  for (int i = 0; i < s.string_length; i++)
    str.string_content[string_length + i] = s.string_content[i];
  str.string_length = string_length + s.string_length;
  return str;
}
MyString &MyString::operator=(const MyString &s) {
  cout << "복사!" << endl;
  if (s.string_length > memory_capacity) {
    delete[] string_content;
    string_content = new char[s.string_length];
    memory_capacity = s.string_length;
  }
  string_length = s.string_length;
  for (int i = 0; i != string_length; i++) {
    string_content[i] = s.string_content[i];
  }

  return *this;
}
int MyString::length() const { return string_length; }
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

template <typename T>
void my_swap(T &a, T &b) {
  T tmp(move(a));
  a = move(b);
  b = move(tmp);
}
int main() {
  MyString str1("abc");
  MyString str2("def");
  cout << "Swap 전 -----" << endl;
  cout << "str1 : ";
  str1.println();
  cout << "str2 : ";
  str2.println();

  cout << "Swap 후 -----" << endl;
  my_swap(str1, str2);
  cout << "str1 : ";
  str1.println();
  cout << "str2 : ";
  str2.println();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99BA0F435AB9A114146E55)



와 같이 나옵니다.


위에서 보시다싶이 `swap` 은 잘 되었지만, 공교롭게도 두 번의 복사를 수행하였습니다.

```cpp-formatted
a = move(b);
b = move(tmp);
```



왜냐하면 바로 위 두 줄 때문이지요. 비록 `move` 를 시키고자 하였지만, 오버로딩 된 `operator=` 가 복사를 수행하였습니다. 그 이유는 현재 정의된 `operator=` 가

```cpp-formatted
MyString& MyString::operator=(const MyString& s)
```



꼴 이므로, `s` 를 그대로 복사하기 때문이지요. 따라서 우리는 우측값에만 특이적으로 오버로딩 되는 `operator=` 를 정의해줘야만 합니다. 아래와 같이 말이지요.

```cpp-formatted
MyString& MyString::operator=(MyString&& s) {
  cout << "이동!" << endl;
  string_content = s.string_content;
  memory_capacity = s.memory_capacity;
  string_length = s.string_length;

  s.string_content = nullptr;
  s.memory_capacity = 0;
  s.string_length = 0;
  return *this;
}
```



그리고 성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F99ABCE4F5AB9A225263122)



와 같이 제대로 이동을 시키고 있음을 알 수 있습니다.


새롭게 정의한 `operator=` 를 살펴보면 매우 간단합니다. 굳이 문자열 전체를 복사할 필요가 없이, 단순히 `string_content` 값만 복사해주면 되기 때문이지요. 물론 s 에 있던 문자열은 사라지게 됩니다. 하지만 상관 없습니다. 어차피 우측값 이니까요!




###  완벽한 전달
 (perfect forwarding)




`C++ 11` 에 우측값 레퍼런스가 도입되기 전 까지 해결할 수 없었던 문제가 있었습니다. 예를 들어서 아래와 같은 `wrapper` 함수를 생각해봅시다 C++ 11 에 우측값 레퍼런스가 도입되기 전 까지 해결할 수 없었던 문제가 있었습니다. 예를 들어서 아래와 같은 `wrapper` 함수를 생각해봅시다.
```cpp-formatted
template <typename T>
void wrapper(T u) {
  g(u);
}
```



이 함수는 인자로 받은 `u` 를 그대로 `g` 라는 함수에 인자로 '전달' 해줍니다. 물론 왜 저런 함수가 필요하나고 생각할 수 있습니다. 그냥 저런 `wrapper` 함수를 만들지 말고 그냥 `g(u)` 를 호출하면 되잖아요?


하지만 실제로 저러한 형태의 전달 방식이 사용되는 경우가 종종 있습니다. 예를 들어 `STL` 의 `vector` 에는 `emplace_back` 이라는 함수가 있습니다. 예를 들어서 클래스 `A` 를 원소로 가지는 벡터의 뒤에 원소를 추가하기 위해서는

```cpp-formatted
vec.push_back(A(1, 2, 3));
```



과 같이 객체를 생성한 뒤에 인자로 전달해줘야만 합니다. 하지만 이 과정에서 불필요한 이동 혹은 복사가 발생하게 됩니다. 그렇다면, 아예 벡터에 인자를 전달해준 다음, 벡터 내부에서 자체적으로 객체를 생성한 뒤에 벡터 뒤에 추가하면 어떨까요? 이를 가능하게 하는게 `emplace_back` 함수 입니다.

```cpp-formatted
vec.emplace_back(1, 2, 3);  // 위와 동일한 작업을 수행한다.
```



`emplace_back` 함수는 인자를 직접 전달받아서, 내부에서 `A` 의 생성자를 호출한 뒤에 이를 벡터 원소 뒤에 추가하게 되지요. 이 과정에서 불필요한 이동/복사 모두 발생하지 않습니다. 참고로 새로 생성한 객체를 벡터 뒤에 추가할 경우 위와 같이 `push_back` 을 이용하는 것 보다 `emplace_back` 을 이용하는 것이 권장되는 방식입니다.


그렇다면 문제는 `emplace_back` 함수가 받은 인자들을 `A` 의 생성자에 제대로 전달해야 합니다. 그렇지 않을 경우 사용자가 의도하지 않은 생성자가 호출될 수 있기 때문입니다. 그렇다면 위와 같은 `wrapper` 함수를 어떻게 하면 잘 정의할 수 있을까요?

```cpp-formatted
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
void wrapper(T u) {
  g(u);
}

class A {};

void g(A& a) { cout << "좌측값 레퍼런스 호출" << endl; }
void g(const A& a) { cout << "좌측값 상수 레퍼런스 호출" << endl; }
void g(A&& a) { cout << "우측값 레퍼런스 호출" << endl; }

int main() {
  A a;
  const A ca;

  cout << "원본 --------" << endl;
  g(a);
  g(ca);
  g(A());

  cout << "Wrapper -----" << endl;
  wrapper(a);
  wrapper(ca);
  wrapper(A());
}
```



성공적으로 컴파일 하였다면
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F99ADBC435AB9C1621B4011)



와 같이 나옵니다.

```cpp-formatted
cout << "원본 --------" << endl;
g(a);
g(ca);
g(A());
```



먼저 위 경우 우리의 예상대로 좌측값 레퍼런스, 좌측값 상수 레퍼런스, 우측값 레퍼런스가 각각 호출되었습니다. 반면에 `wrapper` 함수를 거쳐갔을 경우, 공교롭게도 위 세 경우 모두 좌측값 레퍼런스를 받는 `g` 함수가 호출되었습니다.


이러한 일이 발생한 이유는 C++ 컴파일러가 템플릿 타입을 추론할 때,템플릿 인자 `T` 가 레퍼런스가 아닌 일반적인 타입이라면 `const` 를 무시하기 때문입니다. 다시 말해,

```cpp-formatted
template <typename T>
void wrapper(T u) {
  g(u);
}
```



에서 `T` 가 전부 다 `class A` 로 추론됩니다. 따라서 위 세 경우 전부 다 좌측값 레퍼런스를 호출하는 `g` 를 호출하였습니다.


```cpp-formatted
template <typename T>
void wrapper(T& u) {
  g(u);
}
```



그렇다면 위 경우는 어떨까요?

```warning

error: cannot bind non-const lvalue reference of type 'A&' to an rvalue of type 'A'
  wrapper(A());
          ^~~
```



위와 같은 컴파일 오류가


g(A());


에서 발생합니다. (참고로 이 오류는 `gcc` 와 `clang` 컴파일러에서 모두 발생하는데, 비주얼 스튜디오에서는 발생하지 않습니다. 하지만 원칙적으로 위와 같은 오류를 발생시켜야 하는 것이 맞습니다)


왜 위와 같은 오류가 발생하는지 생각해보자면 다음과 같습니다. 일단, `A()` 자체는 `const` 속성이 없으므로 템플릿 인자 추론에서 `T` 가 `class A` 로 추론됩니다. 하지만 `A&` 는 우측값의 레퍼런스가 될 수 없기 때문에 컴파일 오류가 발생하는 것입니다.



그렇다면 아예 우측값을 레퍼런스로 받을 수 있도록 `const A&` 와 `A&` 따로 만들어주는 방법이 있습니다. 아래와 같이 말이지요.

```cpp-formatted
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
void wrapper(T& u) {
  cout << "T& 로 추론됨" << endl;
  g(u);
}

template <typename T>
void wrapper(const T& u) {
  cout << "const T& 로 추론됨" << endl;
  g(u);
}

class A {};

void g(A& a) { cout << "좌측값 레퍼런스 호출" << endl; }
void g(const A& a) { cout << "좌측값 상수 레퍼런스 호출" << endl; }
void g(A&& a) { cout << "우측값 레퍼런스 호출" << endl; }

int main() {
  A a;
  const A ca;

  cout << "원본 --------" << endl;
  g(a);
  g(ca);
  g(A());

  cout << "Wrapper -----" << endl;
  wrapper(a);
  wrapper(ca);
  wrapper(A());
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F99DB5A3A5ABA0364292293)



와 같이 나옵니다.


일단 `a` 와 `ca` 의 경우 각각 `T&` 와 `const T&` 로 잘 추론되서 올바른 함수를 호출하고 있음을 알 수 있습니다. 반면에 `A()` 의 경우 `const T&` 로 추론되면서 `g(const T&)` 함수를 호출하게 됩니다. 물론 이는 예상했던 일입니다. 우리가 무엇을 해도 `wrapper` 안에 `u` 가 좌측값이라는 사실은 변하지 않고 이에 언제나 좌측값 레퍼런스를 받는 함수들이 오버로딩 되겠지요.



뿐만이 아니라 다음과 같은 문제가 있습니다. 예를 들어서 함수 `g` 가 인자를 한 개가 아니라 2 개를 받는다고 가정합니다. 그렇다면 우리는 다음과 같은 모든 조합의 템플릿 함수들을 정의해야합니다.

```cpp-formatted
template <typename T>
void wrapper(T& u, T& v) {
  g(u, v);
}
template <typename T>
void wrapper(const T& u, T& v) {
  g(u, v);
}

template <typename T>
void wrapper(T& u, const T& v) {
  g(u, v);
}
template <typename T>
void wrapper(const T& u, const T& v) {
  g(u, v);
}
```



매우 귀찮은 일입니다. 위와 같이 짜야하는 이유는 단순히 일반적인 레퍼런스가 우측값을 받을 수 없기 때문입니다. 그렇다고 해서 디폴트로 상수 레퍼런스만 받게 된다면, 상수가 아닌 레퍼런스도 상수 레퍼런스로 캐스팅되서 들어간다는 점이지요.


하지만 놀랍게도 C++ 11 에서는 이를 간단하게 해결할 수 있습니다.

```cpp-formatted
#include <iostream>
using namespace std;

template <typename T>
void wrapper(T&& u) {
  g(forward<T>(u));
}

class A {};

void g(A& a) { cout << "좌측값 레퍼런스 호출" << endl; }
void g(const A& a) { cout << "좌측값 상수 레퍼런스 호출" << endl; }
void g(A&& a) { cout << "우측값 레퍼런스 호출" << endl; }

int main() {
  A a;
  const A ca;

  cout << "원본 --------" << endl;
  g(a);
  g(ca);
  g(A());

  cout << "Wrapper -----" << endl;
  wrapper(a);
  wrapper(ca);
  wrapper(A());
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F99772B4C5ABA05F832FD06)



와 같이 잘 작동함을 알 수 있습니다.


```cpp-formatted
template <typename T>
void wrapper(T&& u) {
  g(forward<T>(u));
}
```



일단 우리의 `wrapper` 함수는 인자로 아예 `T&&` 를 받아버리고 있습니다. 아니 이렇게 된다면 도대체 좌측값은 어떻게 받겠다는 것일까요? 사실 C++ 11 에서 템플릿 인자들 간에 다음과 같은 레퍼런스 겹침 규칙 (reference collapsing rule) 을 정하였습니다.

```info

typedef int& T;
T& r1; // int& &; r1 은 int&
T&& r2; // int & &&;  r2 는 int&


typedef int&& U
U& r3; // int && &; r3 는 int&
U&& r4; // int && &&; r4 는 int&&
```



즉 쉽게 생각하면 `&` 는 1 이고 `&&` 은 0 이라 둔 뒤에, `OR` 연산을 한다고 보면 됩니다. 그렇다면,

```cpp-formatted
wrapper(a);
wrapper(ca);
```



위 두 개의 호출의 경우 `T` 가 각각 `A&` 와 `const A&` 로 추론될 것이고,

```cpp-formatted
wrapper(A());
```



의 경우에는 `T` 가 단순히 `A&&` 로 추론되겠지요.


그런데 문제는 이제 직접 `g` 에 이 인자를 전달하는 방법입니다. 왜 그냥

```cpp-formatted
g(u)
```



로 하지 않았는지 생각해봅시다. 앞서도 말했듯이 여기서 `u` 는 좌측값 입니다. `u` 가 우측값 레퍼런스임에도 불구하고, const `int&` 를 오버로딩하는 `g` 가 호출되게 됩니다. 물론 우리는 좌측값을 어떻게 하면 우측값으로 캐스팅 시킬지 알고 있습니다. 바로 `move` 를 이용하는 것입니다.


하지만 위 경우 아무때나 `move` 를 하면 안됩니다. 인자로 받은 `u` 가 우측값 레퍼런스 일 때 에만 `move` 를 해줘야만 하는 것입니다. 만일 좌측값 레퍼런스일 때 `move` 를 해버린다면 좌측값에 오버로딩 되는 `g` 가 아닌 우측값에 오버로딩 되는 `g` 가 호출되겠지요.


```cpp-formatted
g(forward<T>(u));
```



이 문제를 해결해주는 것이 `forward` 함수 입니다. 이 함수는 `u` 가 우측값 레퍼런스 일 때 에만 마치 `move` 를 적용한 것 처럼 작동합니다. 실제로 `forward` 가 어떻게 생겼나면,


```cpp-formatted
template <class S>
S&& forward(typename remove_reference<S>::type& a) noexcept {
  return static_cast<S&&>(a);
}
```



와 같이 생겼는데, `S` 가 `A&` 라면 (참고로 `remove_reference` 는 타입의 레퍼런스를 지워주는 템플릿 메타 함수 입니다)



```cpp-formatted
A&&& forward(typename remove_reference<A&>::type& a) noexcept {
  return static_cast<A&&&>(a);
}
```



가 되어 레퍼런스 겹침 규칙에 따라



```cpp-formatted
A& forward(A& a) noexcept { return static_cast<A&>(a); }
```



가 되버리고, `S` 가 그냥 `A` 라면, (퀴즈! 여기서 왜 `forward` 의 인자가 `A&&` 가 아니라 A& 일까요?)



```cpp-formatted
A&& forward(A& a) noexcept { return static_cast<A&&>(a); }
```



가 되어 성공적으로 우측값으로 캐스팅해줍니다. 따라서 결과적으로 위 그림 처럼 원본과 `Wrapper` 을 사용했을 때 모두 호출되는 함수가 동일함을 알 수 있습니다. 성공적으로 인자를 전달한 것이지요!


자 그럼 이것으로 이번 강좌를 마치도록 하겠습니다. 다음 강좌에서는 여태까지 배운 내용을 바탕으로 스마트 포인터를 사용하는 방법에 대해서 다루어보도록 하겠습니다.





###  생각 해보기

#### 문제 1

실제로 `move` 와 `forward` 가 어떠한 방식으로 구현되어 있는지 궁금하신 분들은 [여기를 참고하시면 됩니다](https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-api-4.5/a00936_source.html) 한 번 코드를 보시고 왜 이런 방식으로 구현되어 있는지 생각해보세요. (난이도 : 중)

##@ chewing-cpp-end
Link :  227
2018-03-24 22:06
----------------
title : 씹어먹는 C++ - <11 - 1. 우측값 레퍼런스와 이동 생성자>
cat_title: 11 - 1. 우측값 레퍼런스와 이동 생성자
next_page : 228
publish_date : 2018-03-24 22:06
--------------

이번 강좌에서는
* 복사 생략 (Copy elision)

* 우측값 레퍼런스 (rvalue reference)

* 이동 생성자 (move constructor)

![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 지난번 `STL` 강좌는 어떠셨나요? 이번 강좌에서는 C++ 11 에서 추가된 우측값 레퍼런스에 대해서 다루어보도록 하겠습니다. 처음에 보면 약간 생소할 수 있는데 천천히 읽어보시기 바랍니다.



###  복사 생략(Copy `Elision)`




아래 코드를 실행해보면 결과가 어떻게 나올까요?
```cpp-formatted
#include <iostream>

using namespace std;

class A {
  int data_;

 public:
  A(int data) : data_(data) { cout << "일반 생성자 호출!" << endl; }

  A(const A& a) : data_(a.data_) {
    data_ = a.data_;
    cout << "복사 생성자 호출!" << endl;
  }
};

int main() {
  A a(1);  // 일반 생성자 호출
  A b(a);  // 복사 생성자 호출

  // 그렇다면 이것은?
  A c(A(2));
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F9936A83359A3A1A72E5EDB)



와 같이 나옵니다.


뭔가 예상했던 것과 조금 다르지요?

```cpp-formatted
// 그렇다면 이것은?
A c(A(2));
```



이 부분에서 "일반 생성자 호출!" 한번 만 출력되었습니다. 아마 정석대로 였다면,

```cpp-formatted
A(2)
```



를 만들면서 "일반 생성자 호출!" 이 한 번 출력되어야 되고, 생성된 임시 객체로 `c` 가 복사 생성되면서 "복사 생성자 호출!" 이 될 것이기 때문이지요. 그런데 왜 "일반 생성자 호출!" 한 번 밖에 출력되지 않았을 까요? 복사 생성자가 왜 불리지 않았을까요?


사실 생각해보면 굳이 임시 객체를 한 번 만들고, 이를 복사 생성할 필요가 없습니다. 어차피 `A(2)` 로 똑같이 `c` 를 만들거면, 차라리 `c` 자체를 `A(2)` 로 만들어진 객체로 해버리는 것이랑 똑같기 때문이지요.



따라서 똑똑한 컴파일러는 복사 생성을 굳이 수행하지 않고, 만들어진 임시로 만들어진 `A(2)` 자체를 `c` 로 만들어버립니다. 이렇게, 컴파일러 자체에서 복사를 생략해 버리는 작업을 복사 생략(copy `elision)` 이라고 합니다.


컴파일러가 복사 생략을 하는 경우는 (함수의 인자가 아닌) 함수 내부에서 생성된 객체를 그래도 리턴할 때, 수행할 수 있습니다. 물론 C++ 표준을 읽어보면 반드시 복사 생략을 해라 라는 식이 아니라, '복사 생략을 할 수 도 있다' 라는 뜻으로 써 있습니다. 즉, 경우에 따라서는 복사 생략을 해도 되는 경우에, 복사 생략을 하지 않을 수도 있다는 뜻이지요.


이전에 만들어 놓았던 `MyString` 클래스를 다시 살펴보도록 해봅시다.

```cpp-formatted
#include <iostream>
using namespace std;

class MyString {
  char *string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  MyString();

  // 문자열로 부터 생성
  MyString(const char *str);

  // 복사 생성자
  MyString(const MyString &str);

  void reserve(int size);
  MyString operator+(const MyString &s);
  ~MyString();

  int length() const;

  void print();
  void println();
};

MyString::MyString() {
  cout << "생성자 호출 ! " << endl;
  string_length = 0;
  memory_capacity = 0;
  string_content = NULL;
}

MyString::MyString(const char *str) {
  cout << "생성자 호출 ! " << endl;
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString &str) {
  cout << "복사 생성자 호출 ! " << endl;
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::~MyString() { delete[] string_content; }
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char *prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    if (prev_string_content != NULL) delete[] prev_string_content;
  }
}
MyString MyString::operator+(const MyString &s) {
  MyString str;
  str.reserve(string_length + s.string_length);
  for (int i = 0; i < string_length; i++)
    str.string_content[i] = string_content[i];
  for (int i = 0; i < s.string_length; i++)
    str.string_content[string_length + i] = s.string_content[i];
  str.string_length = string_length + s.string_length;
  return str;
}
int MyString::length() const { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

int main() {
  MyString str1("abc");
  MyString str2("def");
  cout << "-------------" << endl;
  MyString str3 = str1 + str2;
  str3.println();
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F99E2F6505AB50C7A30ED98)



와 같이 나옵니다.

```cpp-formatted
MyString str3 = str1 + str2;
```



이 부분에서 두 개의 문자열을 더한 새로운 문자열로 `str3` 를 생성하고 있습니다.

```cpp-formatted
MyString MyString::operator+(const MyString &s) {
  MyString str;
  str.reserve(string_length + s.string_length);
  for (int i = 0; i < string_length; i++)
    str.string_content[i] = string_content[i];
  for (int i = 0; i < s.string_length; i++)
    str.string_content[string_length + i] = s.string_content[i];
  str.string_length = string_length + s.string_length;
  return str;
}
```



위 함수가 `str1 + str2` 를 실행 시에 호출되는데, 먼저 빈 `MyString` 객체인 `str` 을 생성합니다. (생성자 호출! 출력됨) 그 후에, `reserve` 함수를 이용해서 공간을 할당하고, `str1` 과 `str2` 를 더한 문자열을 복사하게 됩니다.


이렇게 리턴된 `str` 은 `str3` 을 생성하는데 전달되어서, `str3` 의 복사 생성자가 호출 됩니다.



하지만, 이미 예상했겠지만, 굳이 `str3` 의 복사 생성자를 또 호출할 필요가 없습니다. 왜냐하면, 어차피 똑같이 복사해서 생성할 것이면, 이미 생성된 `(str1 + str2)` 가 리턴한 객체를 `str3` 셈 치고 사용하면 되기 때문이지요. 이전의 예제에서는 컴파일러가 불필요한 복사 생성자 호출을 복사 생략을 통해 수행하지 않았지만, 이 예제의 경우, 컴파일러가 복사 생략 최적화를 수행하지 않았습니다.


위 과정을 그림으로 간단히 살펴보면 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F996BBA465AB638B019DAE7)



만약에 `str1` 과 `str2` 의 크기가 엄청 컸다면 어떨까요? 쓸데 없는 복사를 두 번 하는데 상당한 자원이 소모될 것입니다.


그렇다면 이러한 문제를 C++ 에서는 어떠한 방식으로 해결하고 있을까요?


###  좌측값 (lvalue) 와 우측값 (rvalue)

모든 C++ 표현식 (expression) 의 경우 두 가지 카테고리로 구분할 수 있습니다. 하나는 이 구문이 어떤 타입을 가지냐 이고, 다른 하나는 어떠한 종류의 '값' 을 가지냐 입니다. 값에 종류가 있어? 라고 생각 하실 수 있는데, 아래 예시를 살펴보도록 합시다.

```cpp-formatted
int a = 3;
```



위 표현식에서 먼저 'a' 를 살펴보도록 합시다. 우리는 `a` 가 메모리 상에서 존재하는 변수 임을 알고 있습니다. 즉 'a' 의 주소값을 `&` 연산자를 통해 알아 낼 수 있다는 것입니다. 우리는 보통 이렇게 주소값을 취할 수 있는 값을 **좌측값 (lvalue)** 라고 부릅니다. 그리고 좌측값은 어떠한 표현식의 왼쪽 오른쪽 모두에 올 수 있습니다 (왼쪽에만 와야 하는게 아닙니다).


반면에 오른쪽에 있는 '3' 을 살펴보도록 합시다. 우리가 '3' 의 주소값을 취할 수 있나요? 아닙니다. '3' 은 왼쪽의 'a' 와는 다르게, 위 표현식을 연산할 때만 잠깐 존재할 뿐 위 식이 연산되고 나면 사라지는 값입니다. 즉, '3' 은 실체가 없는 값입니다.

이렇게, 주소값을 취할 수 없는 값을 **우측값 (rvalue)** 라고 부릅니다. 이름에도 알 수 있듯이, 우측값은 식의 오른쪽에만 항상 와야 합니다. 좌측값이 식의 왼쪽 오른쪽 모두 올 수 있는반면, 우측값은 식의 오른쪽에만 존재해야 합니다.

```cpp-formatted
int a;         // a 는 좌측값
int& l_a = a;  // l_a 는 좌측값 레퍼런스

int& r_b = 3;  // 3 은 우측값. 따라서 오류
```


여태까지 우리가 다루어왔던 레퍼런스는 '좌측값' 에만 레퍼런스를 가질 수 있습니다. 예를 들어서, `a` 의 경우 좌측값 이기 때문에, `a` 의 좌측값 레퍼런스인 `l_a` 를 만들 수 있습니다.


반면에 3 의 경우 우측값이기 때문에, 우측값의 레퍼런스인 `r_b` 를 만들 수 없습니다. 따라서 이 문장은 오류가 발생하게 됩니다.



이와 같이 `&` 하나를 이용해서 정의하는 레퍼런스를 **좌측값 레퍼런스 (lvalue reference)** 라고 부르고, 좌측값 레퍼런스 자체도 좌측값이 됩니다.


그럼 다른 예제를 살펴보도록 합시다.

```cpp-formatted
int& func1(int& a) { return a; }

int func2(int b) { return b; }

int main() {
  int a = 3;
  func1(a) = 4;
  cout << &func1(a) << endl;

  int b = 2;
  a = func2(b);               // 가능
  func2(b) = 5;               // 오류 1
  cout << &func2(b) << endl;  // 오류 2
}
```



컴파일 하였다면 위 오류 `1, 2,` 줄에서 각각 다음과 같은 오류를 볼 수 있습니다.

```warning

ErrorC2106'=': left operand must be l-value
ErrorC2102'&' requires l-value
```



일단 `func1` 의 경우 좌측값 레퍼런스를 리턴합니다. 앞서, 좌측값 레퍼런스의 경우 좌측값에 해당하기 때문에,

```cpp-formatted
func1(a) = 4;
```



의 경우 '`func(a)` 가 리턴하는 레퍼런스의 값을 4' 로 해라 라는 의미로, 실제로 변수 `a` 의 값이 바뀌게 됩니다. 또한, `func1(a)` 가 좌측값 레퍼런스를 리턴하므로, 그 리턴값의 주소값 역시 취할 수 있습니다.


하지만 `func2` 를 살펴볼까요? `func2` 의 경우, 레퍼런스가 아닌, 일반적인 `int` 값을 리턴하고 있습니다. 이 때 리턴되는 값은


```cpp-formatted
a = func2(b);
```



이 문장이 실행 될 때 잠깐 존재할 뿐 그 문장 실행이 끝나면 사라지게 됩니다. 즉, 실체가 없는 값이라는 뜻이지요. 따라서 `func2(b)` 는 우측값이 됩니다. 따라서 위와 같이 우측값이 실제 표현식의 오른쪽에 오는 경우는 가능하지만,

```cpp-formatted
func2(b) = 5;
```



위 문장 처럼 우측값이 왼쪽의 오는 경우는 가능하지 않습니다.

```cpp-formatted
cout << &func2(b) << endl;  // 오류 2
```



마찬가지로 우측값의 주소값을 취할 수 없기 때문에 위 문장은 허용되지 않습니다.


그렇다면 앞선 예제에서

```cpp-formatted
MyString str3 = str1 + str2;
```



를 다시 살펴보도록 합시다. 위 문장은

```cpp-formatted
MyString str3(str1.operator+(str2));
```



와 동일합니다. 그런데, `operator+` 의 정의를 살펴보면,

```cpp-formatted
MyString MyString::operator+(const MyString &s)
```



로 우측값을 리턴하고 있는데, 이 우측값이 어떻게 좌측값 레퍼런스를 인자로 받는,

```cpp-formatted
MyString(const MyString &str);
```



를 호출 시킬 수 있었을까요? 이는 `&` 가 좌측값 레퍼런스를 의미하지만, 예외적으로

```cpp-formatted
const T&
```



의 타입의 한해서만, 우측값도 레퍼런스로 받을 수 있습니다. 그 이유는 `const` 레퍼런스 이기 때문에 임시로 존재하는 객체의 값을 참조만 할 뿐 이를 변경할 수 없기 때문입니다.



###  그렇다면 이동은 어떻게?




그렇다면 앞서 `MyString` 에서 지적한 문제를 해결할 생성자의 경우 어떠한 방식으로 작동해야 할까요?

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F99DC5E435AB639BF0D7DD5)
위와 같이 간단합니다. `str3` 생성 시에 임시로 생성된 객체의 `string_content` 가리키는 문자열의 주소값을 `str3` 의 `string_content` 로 해주면 됩니다.

문제는 이렇게 하게 되면, 임시 객체가 소멸 시에 `string_content` 를 메모리에서 해제하게 되는데, 그렇게 되면 `str3` 가 가리키고 있던 문자열이 메모리에서 소멸되게 됩니다. 따라서 이를 방지 하기 위해서는, 임시 생성된 객체의 `string_content` 를 `NULL` 로 바꿔주고, 소멸자에서 `string_content` 가 `NULL` 이면 소멸하지 않도록 해주면 됩니다. 매우 간단하지요?

하지만, 이 방법은 기존의 복사 생성자에서 사용할 수 없습니다. 왜냐하면 우리는 인자를 `const MyString&` 으로 받았기 때문에, 인자의 값을 변경할 수 없게 되지요. 즉 임시 객체의 `string_content` 값을 수정할 수 없기에 문제가 됩니다.

이와 같은 문제가 발생한 이유는 `const MyString&` 이 좌측값과 우측값 모두 받을 수 있다는 점에서 비롯되었습니다. 그렇다면, 좌측값 말고 우측값만 특이적으로 받을 수 있는 방법은 없을까요? 바로 C++ 11 부터 제공하는 우측값 레퍼런스를 이용하면 됩니다. (참고로 C++ 11 가 기본으로 설정되어 있지 않는 컴파일러는 사용 불가능 합니다. 비주얼 스튜디오 2017 버전의 경우 자동으로 `on` 되어 있으니 걱정하실 필요 없습니다.)


###  우측값 레퍼런스




```cpp-formatted
#include <iostream>
using namespace std;

class MyString {
  char *string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이

  int memory_capacity;  // 현재 할당된 용량

 public:
  MyString();

  // 문자열로 부터 생성
  MyString(const char *str);

  // 복사 생성자
  MyString(const MyString &str);

  // 이동 생성자
  MyString(MyString &&str);

  void reserve(int size);
  MyString operator+(const MyString &s);
  ~MyString();

  int length() const;

  void print();
  void println();
};

MyString::MyString() {
  cout << "생성자 호출 ! " << endl;
  string_length = 0;
  memory_capacity = 0;
  string_content = NULL;
}

MyString::MyString(const char *str) {
  cout << "생성자 호출 ! " << endl;
  string_length = strlen(str);
  memory_capacity = string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++) string_content[i] = str[i];
}
MyString::MyString(const MyString &str) {
  cout << "복사 생성자 호출 ! " << endl;
  string_length = str.string_length;
  string_content = new char[string_length];

  for (int i = 0; i != string_length; i++)
    string_content[i] = str.string_content[i];
}
MyString::MyString(MyString &&str) {
  cout << "이동 생성자 호출 !" << endl;
  string_length = str.string_length;
  string_content = str.string_content;
  memory_capacity = str.memory_capacity;

  // 임시 객체 소멸 시에 메모리를 해제하지
  // 못하게 한다.
  str.string_content = nullptr;
}
MyString::~MyString() {
  if (string_content) delete[] string_content;
}
void MyString::reserve(int size) {
  if (size > memory_capacity) {
    char *prev_string_content = string_content;

    string_content = new char[size];
    memory_capacity = size;

    for (int i = 0; i != string_length; i++)
      string_content[i] = prev_string_content[i];

    if (prev_string_content != NULL) delete[] prev_string_content;
  }
}
MyString MyString::operator+(const MyString &s) {
  MyString str;
  str.reserve(string_length + s.string_length);
  for (int i = 0; i < string_length; i++)
    str.string_content[i] = string_content[i];
  for (int i = 0; i < s.string_length; i++)
    str.string_content[string_length + i] = s.string_content[i];
  str.string_length = string_length + s.string_length;
  return str;
}
int MyString::length() const { return string_length; }
void MyString::print() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];
}
void MyString::println() {
  for (int i = 0; i != string_length; i++) cout << string_content[i];

  cout << endl;
}

int main() {
  MyString str1("abc");
  MyString str2("def");

  cout << "-------------" << endl;
  MyString str3 = str1 + str2;
  str3.println();
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F995166505AB63D112FF31F)



와 같이 나옵니다.


먼저 우측값 레퍼런스를 사용한 이동 생성자의 정의 부분 부터 살펴봅시다.

```cpp-formatted
MyString::MyString(MyString&& str) {
  cout << "이동 생성자 호출 !" << endl;
  string_length = str.string_length;
  string_content = str.string_content;
  memory_capacity = str.memory_capacity;

  // 임시 객체 소멸 시에 메모리를 해제하지
  // 못하게 한다.
  str.string_content = nullptr;
}
```



우측값의 레퍼런스를 정의하기 위해서는 좌측값과는 달리 `&` 를 두 개 사용해서 정의해야 합니다. 즉, 위 생성자의 경우 `MyString` 타입의 우측값을 인자로 받고 있습니다.


그렇다면 한 가지 퀴즈! 과연 `str` 자체는 우측값 일까요 좌측값 일까요? 당연히도 좌측값 입니다. 실체가 있기 때문이지요 (`str` 이라는 이름이 있잖아요). 다시 말해 `str` 은 타입이 '`MyString` 의 우측값 레퍼런스' 인 좌측값 이라 보면 됩니다. 따라서 표현식의 좌측에 올 수도 있습니다. (마지막 줄 처럼)

```cpp-formatted
string_content = str.string_content;
```



이제 위와 같이 우리가 바라던 대로 임시 객체의 `string_content` 가 가리키는 메모리를 새로 생성되는 객체의 메모리로 옮겨주기만 하면 됩니다. 기존의 복사 생성자의 경우 문자열 전체를 새로 복사해야 했지만, 이동 생성자의 경우 단순히 주소값 하나만 달랑 복사해주면 끝이기 때문에 매우 간단합니다.

```cpp-formatted
// 임시 객체 소멸 시에 메모리를 해제하지
// 못하게 한다.
str.string_content = nullptr;
```



한 가지 중요한 부분은 인자로 받은 임시 객체가 소멸되면서 자신이 가리키고 있던 문자열을 `delete` 하지 못하게 해야 합니다. 만약에 그 문자열을 지우게 된다면, 새롭게 생성된 문자열 `str3` 도 같은 메모리를 가리키고 있기 때문에 `str3` 의 문자열도 같이 사라지는 셈이 되기 때문입니다.


따라서 `str` 의 `string_content` 를 `nullptr` 로 바꿔줍니다. 참고로 `nullptr` 역시 C++ 11 에 새로 추가된 키워드로, 기존의 `NULL` 대체합니다. C 언어에서의 `NULL` 은 단순히 #define 으로 정의되어 있는 상수값 0 인데, 이 때문에 이 `NULL` 이 값 0 을 의미하는 것인지, 아니면 포인터 주소값 0 을 의미하는 것인지 구분할 수 가 없었습니다. 하지만 `nullptr` 로 '포인터 주소값 0' 을 정확히 명시해 준다면 미연에 발생할 실수를 줄여 줄 수 있게 됩니다.

```cpp-formatted
MyString::~MyString() {
  if (string_content) delete[] string_content;
}
```



그리고 물론 소멸자 역시 바꿔줘야만 합니다. `string_content` 가 `nullptr` 가 아닐 때 에만 `delete` 를 하도록 말이죠.


일반적으로 우측값 레퍼런스는 아래와 같은 방식으로 사용할 수 있습니다.

```cpp-formatted
int a;
int& l_a = a;
int& ll_a = 3;  // 불가능

int&& r_b = 3;
int&& rr_b = a;  // 불가능
```



일단 우측값 레퍼런스의 경우 반드시 우측값의 레퍼런스만 가능합니다. 따라서, `r_b` 의 경우 우측값 '3' 의 레퍼런스가 될 수 있겠지만, `rr_b` 의 경우 `a` 가 좌측값이기 때문에 컴파일 되지 않습니다.


우측값 레퍼런스의 재미있는 특징으로 레퍼런스 하는 임시 객체가 소멸되지 않도록 붙들고 있는다는 점입니다. 예를 들어서,

```cpp-formatted
MyString&& str3 = str1 + str2;
str3.println();
```



의 경우 `str3` 이 `str1 + str2` 에서 리턴되는 임시 객체의 레퍼런스가 되면서 그 임시 객체가 소멸되지 않도록 합니다. 실제로, 아래 `println` 함수에서 더해진 문자열이 잘 보여집니다.


자 이것으로 이번 강좌는 여기서 마치도록 하겠습니다. 다음 강좌에서는 C++ 11 에 우측값 레퍼런스와 함께 새로 추가된 `move` 에 대해 살펴보도록 하겠습니다.



###  생각 해보기

#### 문제 1

사실 C++ 에서 값의 종류로 좌측값 우측값 만이 있는게 아니라 조금 더 세부적으로 나눠어집니다. 이에 대해 자세히 알아보고 싶으신 분들은 [여기를 참조해주세요](https://medium.com/@barryrevzin/value-categories-in-c-17-f56ae54bccbe)(난이도 : 상)

##@ chewing-cpp-end
Link :  226
2017-07-23 15:03
Link :  225
2017-07-09 04:44
----------------
title : 씹어먹는 C++ - <10 - 3. C++ STL - 알고리즘(algorithm)>
cat_title: 10 - 3. C++ STL - 알고리즘(algorithm)
next_page : 227
publish_date : 2017-07-09 04:44
--------------


이번 강좌에서는
* 람다 함수(lambda function)

* 정렬 알고리즘

* 원소 삭제 알고리즘

* 원소 탐색 알고리즘


등등에 대해 다룹니다.

![](/img/ChewingCpplogo.png)

안녕하세요 여러분! 이번 강좌에서는 STL 의 알고리즘(algorithm) 라이브러리에 대해서 알아보도록 하겠습니다. 알고리즘 라이브러리는 앞선 강좌에서 이야기 했었던 대로, 컨테이너에 반복자들을 가지고 이런 저런 작업을 쉽게 수행할 수 있도록 도와주는 라이브러리 입니다.


여기서 말하는 이런 저런 작업이란, 정렬이나 검색과 같이 단순한 작업들 말고도, '이런 조건이 만족하면 컨테이너에서 지워줘' 나 '이런 조건이 만족하면 1 을 더해' 와 같은 복잡한 명령의 작업들도 알고리즘 라이브러리를 통해 수행할 수 있습니다.


우리는 알고리즘에 정의되어 있는 여러가지 함수들로 작업을 수행하게 됩니다. 이 때 이 함수들은 크게 아래와 같은 두 개의 형태를 가지고 있습니다.

```info

template <typename Iter>
void do_something (Iter begin, Iter end);
```



거나

```info

template <typename Iter, typename Pred>
void do_something (Iter begin, Iter end, Pred pred)
```



와 같은 꼴을 따르고 있습니다. 전자의 경우, 알고리즘을 수행할 반복자의 시작점과 끝점 바로 뒤를 받고, 후자의 경우 반복자는 동일하게 받되, '특정한 조건' 을 추가 인자로 받게 됩니다. 이러한 '특정한 조건'을 **서술자(Predicate)** 이라고 부르며 저기 `Pred` 에는 보통 `bool` 을 리턴하는 **함수 객체(Functor)** 를 전달하게 됩니다. (이번 강좌에서 함수 객체를 매우 편리하게 만들어주는 람다 함수에 대해 다룰 것입니다!)



###  정렬 (sort, stable_sort, partial_sort)



첫번째로 알고리즘 라이브러리에서 지원하는 정렬(sort) 에 대해서 알아보도록 하겠습니다. 사실 정렬이라 하면 한 가지 밖에 없을 것 같은데 정렬 알고리즘에서는 무려 3 가지 종류의 함수를 지원하고 있습니다. 이를 살펴보자면 각각 다음과 같습니다.

* `sort` : 일반적인 정렬 함수라 생각하시면 됩니다.

* `stable_sort` : 정렬을 하되 원소들 간의 순서를 보존합니다. 이 말이 무슨 말이냐면, 만약에 벡터에 `[a, b]` 순으로 있었는데, `a` 와 `b` 가 크기가 같다면 정렬을 `[a,b]` 혹은 `[b,a]` 로 할 수 있습니다. `sort` 의 경우 그 순서가 랜덤으로 정해집니다. 하지만 `stable_sort` 의 경우 그 순서를 반드시 보존합니다. 즉 컨테이너 상에서 `[a,b]` 순으로 있엇다면 정렬 시에도 (크기가 같다면) `[a,b]` 순으로 나오게 됩니다. 이 때문에 `sort` 보다 좀 더 느립니다.


* `partial_sort` : 배열의 일부분만 정렬합니다 (아래 자세히 설명하겠습니다)




그렇다면 각각의 함수들을 사용해보도록 하겠습니다!


```cpp-formatted
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << *begin << " ";
    begin++;
  }
  cout << endl;
}
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(6);
  vec.push_back(4);
  vec.push_back(7);
  vec.push_back(2);

  cout << "정렬 전 ----" << endl;
  print(vec.begin(), vec.end());
  sort(vec.begin(), vec.end());

  cout << "정렬 후 ----" << endl;
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F247F2434596A50D706E894)



위와 같이 잘 정렬되서 나옴을 알 수 있습니다.

```cpp-formatted
sort(vec.begin(), vec.end());
```



`sort` 함수는 위와 같이 정렬할 원소의 시작 위치와, 마지막 위치 바로 뒤를 반복자로 받습니다. 참고로 `sort` 에 들어가는 반복자의 경우 반드시 임의접근 반복자(RandomAccessIterator) 타입을 만족해야 하므로, 우리가 봐왔던 컨테이너들 중에서 벡터와 데크만 가능하고 나머지 컨테이너는 `sort` 함수를 적용할 수 었습니다. (예를 들어 리스트의 경우 반복자 타입이 양방향 반복자(BidirectionalIterator) 이므로 안됩니다)

```cpp-formatted
list<int> l;
sort(l.begin(), l.end());
```



만약에 위 처럼 리스트를 정렬하려고 했다간;

```warning

ErrorC2784'unknown-type std::operator -(const std::move_iterator<_RanIt> &,const std::move_iterator<_RanIt2> &)': could not deduce template argument for 'const std::move_iterator<_RanIt> &' from 'std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<int>>'
```



위와 같은 무지막지한 컴파일 오류를 맛보게 될 것입니다!


`sort` 함수는 기본적으로 오름차순으로 정렬을 해줍니다. 그렇다면 만약에 내림 차순으로 정렬하고 싶다면 어떻게 할까요? 만약에 여러분이 직접 만든 타입이였다면 단순히 `operator<` 를 반대로 바꿔준다면 오름차순에서 내림차순이 되었겠지만, 이 경우 `int` 이기 때문에 이는 불가능 합니다.


하지만 앞서 대부분의 알고리즘은 3 번째 인자로 특정한 조건을 전달한다고 하였는데, 여기에 우리가 비교를 어떻게 수행할 것인지에 대해 알려주면 됩니다.

```cpp-formatted
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << *begin << " ";
    begin++;
  }
  cout << endl;
}
struct int_compare {
  bool operator()(const int& a, const int& b) const { return a > b; }
};
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(6);
  vec.push_back(4);
  vec.push_back(7);
  vec.push_back(2);

  cout << "정렬 전 ----" << endl;
  print(vec.begin(), vec.end());
  sort(vec.begin(), vec.end(), int_compare());

  cout << "정렬 후 ----" << endl;
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F26787847596A53AF08DEF7)



와 같이 내림 차순으로 정렬되서 나옵니다.

```cpp-formatted
struct int_compare {
  bool operator()(const int& a, const int& b) const { return a > b; }
};
```



일단 위와 같이 함수 객체를 위한 구조체를 정의해주시고, 그 안에 `operator()` 함수를 만들어주면 함수 객체 준비는 땡입니다.

```cpp-formatted
sort(vec.begin(), vec.end(), int_compare());
```



그리고 위와 같이 생성된 함수 객체를 전달하면 됩니다. 그런데 말입니다. 사실 `int` 나 `string` 과 같은 기본 타입들은 모두 `<` 혹은 `>` 연산자들이 기본으로 내장되어 있습니다. 그렇다면 굳이 그렇게 귀찮게 함수 객체를 만들 필요는 없을 것 같습니다. 템플릿도 배운 마당에 그냥

```cpp-formatted
template <typename T>
struct greater_comp {
  bool operator()(const T& a, const T& b) const { return a > b; }
};
```



요런게 있어서 굳이 귀찮게 `int` 따로 `string` 따로 만들 필요가 없을 것 같습니다. 다행이도 `functional` 해더에 다음과 같은 템플릿 클래스가 존재합니다.

```cpp-formatted
sort(vec.begin(), vec.end(), greater<int>());
```



저 `greater` 에 우리가 사용하고자 하는 타입을 넣게 되면 위와 같은 함수 객체를 자동으로 만들어줍니다. 물론 그 해당하는 타입의 `>` 연산자가 존재해야겠지요. `int` 의 경우 기본 타입이기 때문에 당연히 존재합니다.


다음으로 살펴볼 함수는 `partial_sort` 함수 입니다.

```cpp-formatted
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << *begin << " ";
    begin++;
  }
  cout << endl;
}
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(6);
  vec.push_back(4);
  vec.push_back(7);
  vec.push_back(2);

  cout << "정렬 전 ----" << endl;
  print(vec.begin(), vec.end());
  partial_sort(vec.begin(), vec.begin() + 3, vec.end());

  cout << "정렬 후 ----" << endl;
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2303CE37596AC6E10EF012)



와 같이 나옵니다. 앞서 `partial_sort` 함수는 일부만 정렬하는 함수라고 하였습니다. `partial_sort` 는 인자를 아래와 같이 3 개를 기본으로 받습니다.

```cpp-formatted
partial_sort(start, middle, end)
```



이 때 정렬을 `[stard, end)` 전체 원소들 중에서 `[start, middle)` 까지 원소들이 전체 원소들 중에서 제일 작은애들 순으로 정렬 시킵니다. 예를 들어서 위 경우

```cpp-formatted
partial_sort(vec.begin(), vec.begin() + 3, vec.end());
```



위와 같이 `vec.begin()` 부터 `vec.end()` 까지 (즉 벡터 전체에서) 원소들 중에서, `vec.begin()` 부터 `vec.begin() + 3` 까지에 전체에서 가장 작은 애들만 순서대로 저장하고 나머지 위치는 상관 없다! 이런 식입니다. 따라서 위와 같이

```info

5 3 1 6 4 7 2
```



에서 가장 작은 3개 원소인 `1, 2, 3` 만이 정렬되어서

```info

1 2 3 6 5 7 4
```




앞에 나타나게 되고 나머지 원소들은 그냥 랜덤하게 남아있게 됩니다. 전체 원소의 개수가 `N` 개이고, 정렬하려는 부분의 크기가 `M` 이라면 `partial_sort` 의 복잡도는 `O(N log M)` 가 됩니다.


만약에 우리가 전체 배열을 정렬할 필요가 없을 경우, 예를 들어서 100 명의 학생 중에서 상위 10 명의 학생의 성적순을 보고 싶다, 이런 식이면 굳이 `sort` 로 전체를 정렬 할 필요 없이 `partial_sort` 로 10 개만 정렬 하는 것이 더 빠르게 됩니다.


마지막으로 `stable_sort` 에 대해 살펴보도록 하겠습니다.

```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}
struct User {
  string name;
  int age;

  User(string name, int age) : name(name), age(age) {}

  bool operator<(const User& u) const { return age < u.age; }
};

ostream& operator<<(ostream& o, const User& u) {
  o << u.name << " , " << u.age;
  return o;
}
int main() {
  vector<User> vec;
  for (int i = 0; i < 100; i++) {
    string name = "";
    name.push_back('a' + i / 26);
    name.push_back('a' + i % 26);
    vec.push_back(User(name, static_cast<int>(rand() % 10)));
  }

  vector<User> vec2 = vec;

  cout << "정렬 전 ----" << endl;
  print(vec.begin(), vec.end());

  sort(vec.begin(), vec.end());

  cout << "정렬 후 ----" << endl;
  print(vec.begin(), vec.end());

  cout << "stable_sort 의 경우 ---" << endl;
  stable_sort(vec2.begin(), vec2.end());
  print(vec2.begin(), vec2.end());
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F226EDD3B596B1338093545)



와 같이 나옵니다.


앞서 `stable_sort` 는 원소가 삽입되어 있는 순서를 보존하는 정렬 방식이라고 하였습니다. `stable_sort` 가 확실히 어떻게 `sort` 와 다른지 보여주기 위해서 다음과 같은 클래스를 만들었습니다.

```cpp-formatted
struct User {
  string name;
  int age;

  User(string name, int age) : name(name), age(age) {}

  bool operator<(const User& u) const { return age < u.age; }
};
```



이 `User` 클래스는 `name` 과 `age` 를 멤버로 갖는데, 크기 비교는 이름과 관계없이 모두 `age` 로 하게 됩니다. 즉 `age` 가 같다면 크기가 같다고 볼 수 있습니다.

```cpp-formatted
for (int i = 0; i < 100; i++) {
  string name = "";
  name.push_back('a' + i / 26);
  name.push_back('a' + i % 26);
  vec.push_back(User(name, static_cast<int>(rand() % 10)));
}
```



처음에 벡터에 원소들을 쭈르륵 삽입하는 부분인데, 이름은 `aa, ab, ac, ...` 순으로 하되 `age` 의 경우 0 부터 10 사이의 랜덤한 값을 부여하였습니다. 즉 `name` 의 경우 `string` 순서대로 되어있고, `age` 의 경우 랜덤한 순서로 되어 있습니다.


앞서 말했듯이 `stable_sort` 는 삽입되어 있던 원소들 간의 순서를 보존한다고 하였습니다. 따라서 같은 `age` 라면 반드시 삽입된 순서, 즉 `name` 순으로 나올 것입니다. (왜냐하면 애초에 `name` 순으로 넣었기 때문!)


그 결과를 살펴보면 확연히 다름을 알 수 있습니다. 먼저 `sort` 의 경우

```info

dh, ck, cx, ad, cw, cu, co
```



순으로 나와 있고 (age 가 0 일 때) `stable_sort` 의 경우 `age` 가 0 일 때

```info

ad, ck, co, cu, cw, cx, dh
```



순으로 나오게 됩니다. 다시 말해 `sort` 함수의 경우 정렬 과정에서 원소들 간의 상대적 위치를 랜덤하게 바꿔버리지만 `stable_sort` 의 경우 그 순서를 처음에 넣었던 상태 그대로 유지함을 알 수 있습니다.


당연히도 이러한 제약 조건 때문에 `stable_sort` 는 그냥 `sort` 보다 좀 더 오래걸립니다. C++ 표준에 따르면 `sort` 함수는 최악의 경우에서도 `O(n log n)` 이 보장되지만 `stable_sort` 의 경우 최악의 경우에서 `O(n (log n)^2)` 으로 작동하게 됩니다. 조금 더 느린 편이지요.



###  원소 제거 (remove, remove_if)




다음으로 살펴볼 함수는 원소를 제거하는 함수 입니다. 사실 이미 대부분의 컨테이너에서는 원소를 제거하는 함수를 지원하고 있습니다. 예를 들어서,
```cpp-formatted
vector<int> vec;
// ....
vec.erase(vec.begin() + 3);
```



을 하게 되면, `vec[3]` 에 해당하는 원소를 제거하게 됩니다.



그런데 사실 이 함수 하나로는 많은 작업들을 처리하기에 부족합니다. 예를 들어서 벡터에서 값이 3 인 원소를 제거하려면 어떻게 해야 할까요? 이전 강좌에서 다루었지만 아마 아래와 같이 할 수 있을 것입니다.

```cpp-formatted
vector<int>::iterator itr = vec.begin();

for (; itr != vec.end(); itr++) {
  if (*itr == 20) {
    vec.erase(itr);
    itr = vec.begin();
  }
}
```



이렇게 했던 이유는 바로 원소가 제거될 때 마다 기존에 제거하였던 반복자들이 초기화 되기 때문입니다. 따라서 해당 위치를 가리키는 반복자를 다시 가져와야 되지요. 물론 굳이 반복자를 쓰지 않고 그냥 일반 변수를 이용해서 배열을 다루듯이 처리할 수 도 있겠지만 '원소 접근은 반복자로 수행한다' 에 따른 약속에는 충실한 방법이 아닙니다.


그렇다면 어떻게 이를 해결할 수 있을까요?

```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  cout << "처음 vec 상태 ------" << endl;
  print(vec.begin(), vec.end());

  cout << "벡터에서 값이 3 인 원소 제거 ---" << endl;
  vec.erase(remove(vec.begin(), vec.end(), 3), vec.end());
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F24655B33596D9F901A91A1)




와 같이 나옵니다.


위 코드가 어떻게 작동하는지 설명하기에 앞서 `erase` 함수를 살펴보도록 합시다. 벡터의 `erase` 함수는 2 가지 형태가 있는데, 하나는 우리가 잘 알고 있는

```cpp-formatted
Iterator erase(Iterator pos);
```



와 같은 형태가 있고, 다른 하나는

```cpp-formatted
Iterator erase(Iterator first, Iterator last);
```



와 같은 형태가 있습니다. 전자의 경우 그냥 `pos` 가 가리키는 원소를 벡터에서 지우지만 후자의 경우 `first` 부터 `last` 사이에 있는 모든 원소들을 지우는 형태 입니다. 물론 이 두 함수 모두 우리의 목표인 '값이 3 인 원소 제거' 를 수행하는데 부족함이 있습니다. 물론 후자의 함수를 사용하면 좋겠지만, 값이 3 인 원소들이 벡터에서 연속적으로 존재하지 않기 때문이지요.


하지만 어떤 편리한 함수가 있어서 값이 3 인 원소들을 벡터에서 연속적으로 존재할 수 있게 해주면 어떨까요?


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F274D394B596DAF0E3878BF)

위와 같이, 만일 값이 3 인 원소를 만나면 그 뒤에 있는 원소들로 쭈르륵 쉬프트 해주게 됩니다. 따라서, 자연스럽게 알고리즘이 끝나게 되면은 해당하는 위치에서 전 까지 3 이 제외된 원소들로 쭈르륵 채워지게 되겠지요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F236E4B4E596DB71722C406)

다시말해, 반복이 끝나는 위치 부터 벡터 맨 뒤 까지 제거해버리면 3 이 싹 제거된 벡터만 남게 되지요. `remove` 함수는 원소의 이동만을 수행하지 실제로 원소를 삭제하는 연산을 수행하지는 않습니다. 따라서 벡터에서 실제로 원소를 지우기 위해서는 반드시 `erase` 함수를 호출하여 실제로 원소를 지워줘야만 합니다.


`vec.erase(remove(vec.begin(), vec.end(), 3),` vec.end());



따라서 위 처럼 `remove` 함수를 이용해서 값이 3 인 원소들을 뒤로 보내버리고, 그 원소들을 벡터에서 삭제해버리게 됩니다.


참고로 말하자면 `remove` 함수의 경우 반복자의 타입이 `ForwardIterator` 입니다. 즉, 벡터 뿐만이 아니라, 리스트, 혹은 셋이나 맵에서도 모두 사용할 수 있습니다!


그렇다면 이번에는 값이 딱 얼마로 정해진 것이 아니라 특정한 조건을 만족하는 원소들을 제거하려면 어떻게 해야 할까요? 당연히도 이 원소가 그 조건을 만족하는지 아닌지를 판단할 함수를 전달해야 됩니다. 이를 위해선 `remove_if` 함수를 사용해야 합니다.

```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}
struct is_odd {
  bool operator()(const int& i) { return i % 2 == 1; }
};
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  cout << "처음 vec 상태 ------" << endl;
  print(vec.begin(), vec.end());

  cout << "벡터에서 홀수 인 원소 제거 ---" << endl;
  vec.erase(remove_if(vec.begin(), vec.end(), is_odd()), vec.end());
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F270A7D4F596DC13035CC07)



와 같이 나옵니다.

```cpp-formatted
vec.erase(remove_if(vec.begin(), vec.end(), is_odd()), vec.end());
```



`remove_if` 함수는 세번째 인자로 조건을 설명할 함수 객체를 전달받습니다.

```cpp-formatted
struct is_odd {
  bool operator()(const int& i) { return i % 2 == 1; }
};
```



위와 같이 `is_odd` 구조체에 `operator()` 를 만들어서 함수 객체를 전달하시면 됩니다. 당연히도, 함수 객체로 실제 함수를 전달할 수 도 있습니다. 이 경우

```cpp-formatted
template <typename Iter, typename Pred>
remove_if(Iter first, Iter last, Pred pred)
```



에서 `Pred` 가 함수 포인터 타입이 되겠지요.

```cpp-formatted
bool odd(const int& i) { return i % 2 == 1; }
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  cout << "처음 vec 상태 ------" << endl;
  print(vec.begin(), vec.end());

  cout << "벡터에서 홀수 인 원소 제거 ---" << endl;
  vec.erase(remove_if(vec.begin(), vec.end(), odd), vec.end());
  print(vec.begin(), vec.end());
}
```



위와 같이 실제 함수를 전달한다면 앞서 만들었던 함수 객체와 정확히 동일하게 동작합니다. 그렇다면 굳이 귀찮게 위와 같이 함수 객체를 사용할 이유가 있을까요? 물론 있습니다.


예를 들어서 홀수인 원소들을 삭제하되 처음 2개만 삭제한다고 해봅시다. 함수 객체의 경우 사실 클래스의 객체이기 때문에 멤버 변수를 생각할 수 있습니다.

```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}
struct is_odd {
  int num_delete;

  is_odd() : num_delete(0) {}

  bool operator()(const int& i) {
    if (num_delete >= 2) return false;

    if (i % 2 == 1) {
      num_delete++;
      return true;
    }

    return false;
  }
};
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  cout << "처음 vec 상태 ------" << endl;
  print(vec.begin(), vec.end());

  cout << "벡터에서 홀수인 원소 앞의 2개 제거 ---" << endl;
  vec.erase(remove_if(vec.begin(), vec.end(), is_odd()), vec.end());
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F23445F3D596DC7D932E721)



와 같이 나옵니다.

```cpp-formatted
struct is_odd {
  int num_delete;

  is_odd() : num_delete(0) {}

  bool operator()(const int& i) {
    if (num_delete >= 2) return false;

    if (i % 2 == 1) {
      num_delete++;
      return true;
    }

    return false;
  }
};
```



이것이 가능한 이유는 위 처럼 `num_delete` 라는 멤버 변수를 만들어서 몇 개를 지웠는지 카운트 하기 때문이지요. 물론 함수의 경우에도 `static` 변수를 이용하면 위와 같은 효과를 낼 수 있습니다. 하지만 여러개의 벡터에 저 작업을 하게 된다면 꽤나 골치아프겠지요. (호출할 때 마다 `static` 변수의 값을 0 으로 초기화 해줘야 합니다)


하지만 함수 객체를 이용하면 위 처럼 함수만으로는 쉽게 하지 못했던 일들을 손쉽게 처리할 수 있게 됩니다.



그런데 한 가지 안좋은 점은 이렇게 `STL` 을 사용할 때 마다 외부에 클래스나 함수를 하나 씩 만들어줘야 된다는 점입니다. 물론 프로젝트의 크기가 작다면 크게 문제가 되지는 않겠지만 프로젝트의 크기가 커진다면, 만약 다른 사람이 코드를 읽을 때 '이 클래스는 뭐하는 거지?' 혹은 '이 함수는 뭐하는 거지?' 와 같은 궁금증이 생길 수 도 있고 심지어 잘못 사용할 수 도 있습니다.


따라서 가장 이상적인 방법은 `STL` 알고리즘을 사용할 때 그 안에 직접 써놓는 것입니다. 마치

```cpp-formatted
vec.erase(remove_if(vec.begin(), vec.end(),
                    bool is_odd(int i) { return i % 2 == 1; }),
          vec.end());
```



뭐 이런 식으로 말이지요. 문제는 위 문법이 C++ 에서 허용되지 않다는 점입니다. 하지만 놀랍게도 C++ 11 부터 위 문제를 해결할 방법이 나타났습니다.



###  람다 함수(lambda `function)`


람다 함수는 C++ 에서는 C++ 11 에서 처음으로 도입되었습니다. 람다 함수를 통해 쉽게 이름이 없는 함수 객체를 만들수 없게 되었습니다. 그렇습니다.익명의 함수 객체 말입니다.

람다 함수를 사용한 예제 부터 먼저 살펴보겠습니다.
```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  cout << "처음 vec 상태 ------" << endl;
  print(vec.begin(), vec.end());

  cout << "벡터에서 홀수인 원소 제거 ---" << endl;
  vec.erase(
    remove_if(vec.begin(), vec.end(), [](int i) -> bool { return i % 2 == 1; }),
    vec.end());
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2577DF3359703AE92B620A)

와 같이 나옵니다.



람다 함수를 정의한 부분부터 살펴보도록 합시다.

```cpp-formatted
[](int i) -> bool { return i % 2 == 1; }
```



람다 함수는 위와 같은 꼴로 정의됩니다. 일반적인 꼴을 살펴보자면

```info

[capture list] (받는 인자) -> 리턴 타입 { 함수 본체 }
```



와 같은 형태 입니다. `capture_list` 가 뭔지는 아래에서 설명하도록 하고, 위 함수 꼴을 살펴보자면 인자로 `int i` 를 받고, `bool` 을 리턴하는 람다 함수를 정의한 것입니다. 리턴 타입을 생략한다면 컴파일러가 알아서 함수 본체에서 `return` 문을 보고 리턴 타입을 추측해줍니다. (만약에 `return` 경로가 여러군데여서 추측할 수 없다면 컴파일 오류가 발생하지요)


리턴 타입을 생략할 경우

```info

[capture list] ( 받는 인자) {함수 본체}
```



이런 식으로 더 간단히 쓸 수 있습니다. 위 예제의 경우

```cpp-formatted
[](int i) { return i % 2 == 1; }
```



로 쓴다면 알아서 "아 `bool` 타입을 리턴하는 함수구나" 라고 컴파일러가 만들어줍니다.


앞서 람다 함수가 이름이 없는 함수라 했는데 실제로 위를 보면 함수에 이름이 붙어 있지 않습니다! 즉 임시적으로 함수를 생성한 것이지요. 만약에 이 함수를 사용하고 싶다면

```cpp-formatted
[](int i) { return i % 2 == 1; }(3);  // true
```



와 같이 그냥 바로 호출할 수 도 있고

```cpp-formatted
auto func = [](int i) { return i % 2 == 1; };
func(4);  // false;
```



람다 함수로 func 이라는 함수 객체를 생성한 후에 호출할 수 도 있지요.


하지만 람다 함수도 말 그대로 함수 이기 때문에 자기 자신만의 스코프를 가집니다. 따라서 일반적인 상황이라면 함수 외부에서 정의된 변수들을 사용할 수 없겠지요. 예를 들어서 최대 2 개 원소만 지우고 싶은 경우

```cpp-formatted
cout << "벡터에서 홀수인 원소 최대 2 개 제거 ---" << endl;
int num_erased = 0;
vec.erase(remove_if(vec.begin(), vec.end(),
                    [](int i) {
                      if (num_erased >= 2)
                        return false;
                      else if (i % 2 == 1) {
                        num_erased++;
                        return true;
                      }
                      return false;
                    }),
          vec.end());
print(vec.begin(), vec.end());
```



위와 같이 람다 함수 외부에 몇 개를 지웠는지 변수를 정의한 뒤에 사용해야만 하는데 (함수 안에 정의하면 함수 호출될 때 마다 새로 생성되니까요!) 문제는 그 변수에 접근할 수 없다는 점입니다. 하지만 놀랍게도 람다 함수의 경우 그 변수에 접근할 수 있습니다. 바로 **캡쳐 목록(capture list)**을 사용하는 것입니다.

```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}
int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  cout << "처음 vec 상태 ------" << endl;
  print(vec.begin(), vec.end());

  cout << "벡터에서 홀수인 원소 ---" << endl;
  int num_erased = 0;
  vec.erase(remove_if(vec.begin(), vec.end(),
                      [&num_erased](int i) {
                        if (num_erased >= 2)
                          return false;
                        else if (i % 2 == 1) {
                          num_erased++;
                          return true;
                        }
                        return false;
                      }),
            vec.end());
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2205F5485970470C1C5FA7)

와 같이 잘 됨을 알 수 있습니다.

```cpp-formatted
 [&num_erased](int i) {
  if (num_erased >= 2)
    return false;
  else if (i % 2 == 1) {
    num_erased++;
    return true;
  }
  return false;
})
```



위와 같이 캡쳐 목록에는 어떤 변수를 캡쳐할 지 써주면 됩니다. 위 경우 `num_erased` 를 캡쳐하였습니다. 즉 람다 함수 내에서 `num_erased` 를 마치 같은 스코프 안에 있는 것 처럼 사용할 수 있게 됩니다.


이 때 `num_erased` 앞에 `&` 가 붙어있는데 이는 실제 `num_erased` 의 레퍼런스를 캡쳐한다는 의미입니다. 즉 함수 내부에서 `num_erased` 의 값을 바꿀 수 있게 되지요. 만약에 아래처럼

```cpp-formatted
[num_erased](int i){
  if (num_erased >= 2)
    return false;
  else if (i % 2 == 1) {
    num_erased++;
    return true;
  }
  return false;
})
```



`&` 를 앞에 붙이지 않는다면 `num_erased` 의 복사본을 얻게 되는데, 그 복사본의 형태는 `const` 입니다. 따라서 위 처럼 함수 내부에서 `num_erased` 의 값을 바꿀 수 없게 되지요. 그렇다면 클래스의 멤버 함수 안에서 람다를 사용할 때 멤버 변수들을 참조하려면 어떻게 해야 할까요?

```cpp-formatted
class SomeClass {
  vector<int> vec;

  int num_erased;

 public:
  SomeClass() {
    vec.push_back(5);
    vec.push_back(3);
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);
    vec.push_back(4);

    num_erased = 1;

    vec.erase(remove_if(vec.begin(), vec.end(),
                        [&num_erased](int i) {
                          if (num_erased >= 2)
                            return false;
                          else if (i % 2 == 1) {
                            num_erased++;
                            return true;
                          }
                          return false;
                        }),
              vec.end());
  }
};
```



예를 들어 위와 같은 예제를 생각해봅시다. 쉽게 생각해보면 그냥 똑같이 `num_erased` 를 `&` 로 캡쳐해서 람다 함수 안에서 사용할 수 있을 것 같지만 실제로는 컴파일 되지 않습니다. 왜냐하면 `num_erased` 가 일반 변수가 아니라 객체에 종속되어 있는 멤버 변수 이기 때문이지요. 즉 람다 함수는 `num_erased` 를 캡쳐해! 라고 하면 이 `num_erased` 가 이 객체의 멤버 변수가 아니라 그냥 일반 변수라고 생각하게 됩니다.


이를 해결하기 위해선 직접 멤버 변수를 전달하기 보다는 `this` 를 전달해주면 됩니다.

```cpp-formatted
num_erased = 0;

vec.erase(remove_if(vec.begin(), vec.end(),
                    [this](int i) {
                      if (this->num_erased >= 2)
                        return false;
                      else if (i % 2 == 1) {
                        this->num_erased++;
                        return true;
                      }
                      return false;
                    }),
          vec.end());
```



위와 같이 `this` 를 복사본으로 전달해서 (참고로 `this` 는 레퍼런스로 전달할 수 없습니다) 함수 안에서 `this` 를 이용해서 멤버 변수들을 참조해서 사용하면 됩니다.


위에 설명한 경우 말고도 캡쳐 리스트의 사용 방법은 꽤나 많은데 아래 간단히 정리해보도록 하겠습니다.
* `[]` : 아무것도 캡쳐 안함

* `[&a, b]` : `a` 는 레퍼런스로 캡쳐하고 `b` 는 (변경 불가능한) 복사본으로 캡쳐

* `[&]` : 외부의 모든 변수들을 레퍼런스로 캡쳐

* `[=]` : 외부의 모든 변수들을 복사본으로 캡쳐


와 같이 되겠습니다.



###  원소 수정하기 (transform)



다음으로 살펴볼 함수는 원소들을 수정하는 함수들 입니다. 많은 경우 컨테이너 전체 혹은 일부를 순회하면서 값들을 수정하는 작업을 많이 할 것입니다. 예를 들어서 벡터의 모든 원소에 1 씩 더한다던지와 같은 작업들을 말이지요. 이러한 작업을 도와주는 함수는 바로 `transform` 함수 입니다.
```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}

int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  cout << "처음 vec 상태 ------" << endl;
  print(vec.begin(), vec.end());

  cout << "벡터 전체에 1 을 더한다" << endl;
  transform(vec.begin(), vec.end(), vec.begin(), [](int i) { return i + 1; });
  print(vec.begin(), vec.end());
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2423F74D5971875012B157)



와 같이 나옵니다.


`transform` 함수는 다음과 같은 꼴로 생겼습니다.

```info

transform (시작 반복자, 끝 반복자, 결과를 저장할 컨테이너의 시작 반복자, Pred)
```



우리가 사용한 예의 경우

```cpp-formatted
transform(vec.begin(), vec.end(), vec.begin(), [](int i) { return i + 1; });
```



로 하였으므로 `vec` 의 시작(begin) 부터 끝(end) 까지 각 원소에 `[] (int i) {return i + 1}` 함수를 적용시킨 결과를 `vec.begin()` 부터 저장하게 됩니다. 즉 결과적으로 각 원소에 1 을 더한 결과로 덮어 씌우게 되는 것이지요. 상당히 간단합니다. 한 가지 주의할 점은 값을 저장하는 컨테이너의 크기가 원래의 컨테이너보다 최소한 같거나 커야 된다는 점입니다. 예를 들어서 단순하게

```cpp-formatted
transform(vec.begin(), vec.end(), vec.begin() + 1, [](int i) { return i + 1; });
```



이렇게 썻다고 해봅시다. `transform` 함수는 `vec` 의 처음 부터 끝까지 쭈르륵 순회하지만 저장하는 쪽의 반복자는 `vec` 의 두 번째 원소 부터 저장하기 때문에 결과적으로 마지막에 한 칸이 모잘라서



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F24E5C63359718B1B071A2B)



위와 같은 오류를 발생하게 됩니다.

```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}

int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  // vec2 에는 6 개의 0 으로 초기화 한다.
  vector<int> vec2(6, 0);

  cout << "처음 vec 과 vec2 상태 ------" << endl;
  print(vec.begin(), vec.end());
  print(vec2.begin(), vec2.end());

  cout << "vec 전체에 1 을 더한 것을 vec2 에 저장 -- " << endl;
  transform(vec.begin(), vec.end(), vec2.begin(), [](int i) { return i + 1; });
  print(vec.begin(), vec.end());
  print(vec2.begin(), vec2.end());
}
```



성공적으로 컴파일 하였으면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2128514F59718DC02F2950)




와 같이 나옵니다.

```cpp-formatted
transform(vec.begin(), vec.end(), vec2.begin(), [](int i) { return i + 1; });
```



위와 같이 `vec` 의 처음 부터 끝 까지 읽으면서 1 씩 더한 결과를 `vec2` 에 저장하게 됩니다. 간단하지요! 물론 저 `transform` 함수 하나 덕분에 귀찮에 `for` 문을 쓸 필요도 없어질 뿐더러, 내가 이 코드에서 무슨 일을 하는지 더 간단 명료하게 나타낼 수 도 있습니다.





###  원소를 탐색하는 함수(find, `find_if, any_of, all_of` 등등)




마지막으로 살펴볼 함수들은 원소들을 탐색하는 계열의 함수들 입니다.
```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}

int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  auto result = find(vec.begin(), vec.end(), 3);
  cout << "3 은 " << distance(vec.begin(), result) + 1 << " 번째 원소" << endl;
}
```



성공적으로 컴파일 하였으면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2403B13A5973A8441A3B1E)

와 같이 나옵니다.


`find` 함수는 단순히

```cpp-formatted
template <class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value)
```



와 같이 생겼는데, `first` 부터 `last` 까지 쭈르륵 순회하면서 `value` 와 같은 원소가 있는지 확인하고 있으면 이를 가리키는 반복자를 리턴합니다.  위 경우
```cpp-formatted
auto result = find(vec.begin(), vec.end(), 3);
```



`vec` 에서 값이 3 과 같은 원소를 찾아서 리턴하게 되지요. 반복자에 따라서 `forward_iterator` 면 앞에서 부터 찾고, `reverse_iterator` 이면 뒤에서 부터 거꾸로 찾게 됩니다. 물론 컨테이너에 중복되는 값이 있더라도 가장 먼저 찾은 것을 리턴합니다. 만약에 위 `vec` 에서 모든 3 을 찾고 싶다면 아래와 같이 하면 됩니다.


```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}

int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  auto current = vec.begin();
  while (true) {
    current = find(current, vec.end(), 3);
    if (current == vec.end()) break;
    cout << "3 은 " << distance(vec.begin(), current) + 1 << " 번째 원소"
         << endl;
    current++;
  }
}
```





성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244C3D335973AC8A107754)

위와 같이 나옵니다.

```cpp-formatted
current = find(current, vec.end(), 3);
```



위 처럼 마지막으로 찾은 위치 바로 다음 부터 계속 순차적으로 탐색해 나간다면 컨테이너에서 값이 3 인 원소들을 모두 찾을 수 있게 됩니다.


다만 `find` 계열의 함수들을 사용할 때 한 가지 주의해야 할 점은, 만약에 컨테이너에서 기본적으로 `find` 함수를 지원한다면 이를 사용하는 것이 훨씬 빠릅니다. 왜냐하면 알고리즘 라이브러리에서의 `find` 함수는 그 컨테이너가 어떠한 구조를 가지고 있는지에 대한 정보가 하나도 없기 때문입니다.


예를 들어 `set` 의 경우, `set` 에서 사용하는 `find` 함수의 경우 O(log `n)` 으로 수행될 수 있는데 그 이유는 셋 내부에서 원소들이 정렬되어 있기 때문입니다. 또 `unordered_set` 의 경우 `find` 함수가 `O(1)` 로 수행될 수 있는데 그 이유는 `unordered_set` 내부에서 자체적으로 해시 테이블을 이용해서 원소들을 빠르게 탐색해 나갈 수 있기 때문입니다.


하지만 그냥 알고리즘 라이브러리의 `find` 함수의 경우 이러한 추가 정보가 있는 것을 하나도 모른채 우직하게 처음 부터 하나 씩 확인해 나가므로 평범한 `O(n)` 으로 처리됩니다. 따라서 알고리즘 라이브러리의 `find` 함수를 사용할 경우 벡터와 같이 기본적으로 `find` 함수를 지원하지 않는 컨테이너에 사용하시기 바랍니다!


```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}

int main() {
  vector<int> vec;
  vec.push_back(5);
  vec.push_back(3);
  vec.push_back(1);
  vec.push_back(2);
  vec.push_back(3);
  vec.push_back(4);

  auto current = vec.begin();
  while (true) {
    current = find_if(current, vec.end(), [](int i) { return i % 3 == 2; });
    if (current == vec.end()) break;
    cout << "3 으로 나눈 나머지가 2 인 원소는 : " << *current << " 이다 "
         << endl;
    current++;
  }
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2474D4335973AF631A1737)



와 같이 나옵니다.

```cpp-formatted
current = find_if(current, vec.end(), [](int i) { return i % 3 == 2; });
```



`find` 함수가 단순한 값을 받았다면 `find_if` 함수의 경우 함수 객체를 인자로 받아서 그 결과가 참인 원소들을 찾게 됩니다. 위 경우 3 으로 나눈 나머지가 2 인 원소들을 컨테이너에서 탐색하였습니다. 람다 함수로 사용하니 엄청 간결하지요?


```cpp-formatted
#include <algorithm>
#include <functional>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

template <typename Iter>
void print(Iter begin, Iter end) {
  while (begin != end) {
    cout << "[" << *begin << "] ";
    begin++;
  }
  cout << endl;
}

struct User {
  string name;
  int level;

  User(string name, int level) : name(name), level(level) {}
  bool operator==(const User& user) const {
    if (name == user.name && level == user.level) return true;
    return false;
  }
};

class Party {
  vector<User> users;

 public:
  bool add_user(string name, int level) {
    User new_user(name, level);
    if (find(users.begin(), users.end(), new_user) != users.end()) {
      return false;
    }
    users.push_back(new_user);
    return true;
  }

  // 파티원 모두가 15 레벨 이상이여야지 던전 입장 가능
  bool can_join_dungeon() {
    return all_of(users.begin(), users.end(),
                  [](User& user) { return user.level >= 15; });
  }

  // 파티원 중 한명 이라도 19렙 이상이면 특별 아이템 사용 가능
  bool can_use_special_item() {
    return any_of(users.begin(), users.end(),
                  [](User& user) { return user.level >= 19; });
  }
};
int main() {
  Party party;
  party.add_user("철수", 15);
  party.add_user("영희", 18);
  party.add_user("민수", 12);
  party.add_user("수빈", 19);

  cout << boolalpha;
  cout << "던전 입장 가능 ? " << party.can_join_dungeon() << endl;
  cout << "특별 아이템 사용 가능 ? " << party.can_use_special_item() << endl;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2581B7335973B48811EF46)


와 같이 나옵니다.


마지막으로 살펴볼 함수들은 `any_of` 와 `all_of` 입니다. `any_of` 는 인자로 받은 범위안의 모든 원소들 중에서 조건을 하나라도 충족하는 것이 있다면 `true` 를 리턴하고 `all_of` 의 경우 모든 원소들이 전부 조건을 충족해야 `true` 를 리턴합니다. 즉 `any_of` 는 `OR` 연산과 비슷하고 `any_of` 는 `AND` 연산과 비슷하다고 볼 수 있지요.


```cpp-formatted
bool add_user(string name, int level) {
  User new_user(name, level);
  if (find(users.begin(), users.end(), new_user) != users.end()) {
    return false;
  }
  users.push_back(new_user);
  return true;
}
```



먼저 간단히 유저들의 정보를 담고 있는 `User` 구조체를 정의하였고, 그 `User` 들이 파티를 이룰 때 만들어지는 `Party` 클래스를 정의하였습니다. 그리고 위 `add_user` 함수를 사용하면 파티원을 추가할 수 있지요. 물론 중복되는 파티원이 없도록 벡터에 원소를 추가하기 전에 확인합니다.


```cpp-formatted
// 파티원 모두가 15 레벨 이상이여야지 던전 입장 가능
bool can_join_dungeon() {
  return all_of(users.begin(), users.end(),
                [](User& user) { return user.level >= 15; });
}
```



따라서 이 파티가 어떤 던전에 참가하고 싶은 경우 모든 파티원의 레벨이 15 이상 이어야 하므로 위와 같이 `all_of` 함수를 사용해서 모든 원소들이 조건에 만족하는지 확인할 수 있습니다. 위 경우 민수가 12 레벨이여서 `false` 가 리턴되겠지요.


```cpp-formatted
// 파티원 중 한명 이라도 19렙 이상이면 특별 아이템 사용 가능
bool can_use_special_item() {
  return any_of(users.begin(), users.end(),
                [](User& user) { return user.level >= 19; });
}
```



비슷하게도 한 명만 조건을 만족해도 되는 경우 위와 같이 `any_of` 함수를 사용하면 간단히 처리할 수 있습니다.


자 그러면 이번 강좌는 여기서 마치도록 하겠습니다. 사실 알고리즘 라이브러리를  살펴보면 이것 보다도 훨씬 많은 수의 여러가지 유용한 함수들이 정의되어 있습니다. 하지만 이 모든 함수들을 강좌에서 다루기에는 조금 무리가 있고, 이 정도 함수들만 알아놓아도 매우 편리하게 사용하실 수 있을 것이라 생각합니다!

##@ chewing-cpp-end
Link :  224
2017-07-08 18:30
----------------
title : 씹어먹는 C++ - <10 - 2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map>
cat_title: 10 - 2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map
next_page : 225
publish_date : 2017-07-08 18:30
--------------

이번 강좌에서는* `set, map, multiset, multimap`
* `unordered_set, unordered_map`
* 커스텀 클래스 객체를 `set/map` 혹은 `unordered_set/map` 에 추가하기

에 대해 다룹니다.

![](/img/ChewingCpplogo.png)

안녕하세요 여러분! 지난 강좌에서 시퀀스 컨테이너들 (`vector, list, deque`) 에 대해서 다루어보았습니다. 시퀀스 컨테이너들은 말 그대로 '원소' 자체를 보관하는 컨테이너들 입니다.


이번 강좌에서는 다른 종류의 컨테이너인 **연관 컨테이너(associative container)** 에 대해서 다루어볼 것입니다. 연관 컨테이너는 시퀀스 컨테이너와는 다르게 키(key) - 값(value) 구조를 가집니다. 다시 말해 특정한 키를 넣으면 이에 대응되는 값을 돌려준다는 것이지요. 물론 템플릿 라이브러리 이기 때문이 키와 값 모두 임의의 타입의 객체가 될 수 있습니다.


예를 들어서 어떤 웹사이트에서 회원 관리를 한다고 생각해봅시다. 사용자의 로그인을 처리하기 위해서는 아이디를 키로 가지고, 비밀번호를 값으로 가지는 데이터 구조가 필요할 것입니다. 왜냐하면 사용자가 로그인을 할 때 올바르게 입력하였는지 확인하기 위해선, 입력한 아이디에 대응되어 있던 비밀번호를 가지고, 실제 사용자가 입력한 비밀번호와 비교를 해야 되기 때문이지요.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F246B794A595BF6A32B7970)

위 처럼 연관 컨테이너는 키를 바탕으로 이에 대응되는 값을 얻을 수 있는 구조 입니다.



우리는 위와 같이 주어진 자료에서 보통 두 가지 종류의 질문을 할 수 있습니다.

* 박명순이 데이터에 존재하나요?  (특정 키가 연관 컨테이너에 존재하는지 유무) → True
* 만약 존재한다면 이에 대응되는 값이 무엇인가요? (특정 키에 대응되는 값이 무엇인지 질의) → 46


C++ 에서는 위 두 가지 작업을 처리할 수 있 C++ 에서는 위 두 가지 작업을 처리할 수 있는 연관 컨테이너라는 것을 제공합니다. 전자의 경우 **셋(set)** 과 **멀티셋(multiset)** 이고, 후자의 경우 **맵(map)** 과 **멀티맵(multimap)** 입니다. 물론 맵과 멀티맵을 셋 처럼 사용할 수 있습니다. 왜냐하면 해당하는 키가 맵에 존재하지 않으면 당연히 대응되는 값을 가져올 수 없기 때문이지요.


하지만 맵의 경우 셋 보다 사용하는 메모리가 크기 때문에 키의 존재 유무 만 궁금하다면 셋을 사용하는 것이 좋습니다. 그렇다면 셋 부터 어떻게 사용하는지 살펴보겠습니다.

###  셋(set)

```cpp-formatted
#include <iostream>
#include <set>
using namespace std;

template <typename T>
void print_set(set<T>& s) {
  // 셋의 모든 원소들을 출력하기
  cout << "[ ";
  for (typename set<T>::iterator itr = s.begin(); itr != s.end(); itr++) {
    cout << *itr << " ";
  }
  cout << " ] " << endl;
}
int main() {
  set<int> s;
  s.insert(10);
  s.insert(50);
  s.insert(20);
  s.insert(40);
  s.insert(30);

  cout << "순서대로 정렬되서 나온다" << endl;
  print_set(s);

  cout << "20 이 s 의 원소인가요? :: ";
  auto itr = s.find(20);
  if (itr != s.end()) {
    cout << "Yes" << endl;
  } else {
    cout << "No" << endl;
  }

  cout << "25 가 s 의 원소인가요? :: ";
  itr = s.find(25);
  if (itr != s.end()) {
    cout << "Yes" << endl;
  } else {
    cout << "No" << endl;
  }
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F23527038595C0AFD1E4645)



와 같이 나옵니다.

```cpp-formatted
s.insert(10);
s.insert(50);
s.insert(20);
s.insert(40);
s.insert(30);
```

셋에 원소를 추가하기 위해서는 시퀀스 컨테이너 처럼 `insert` 함수를 사용하면 됩니다. 한 가지 다른점은, 시퀀스 컨테이너 처럼 '어디에' 추가할지에 대한 정보가 없다는 점입니다. 시퀀스 컨테이너가 상자 하나에 원소를 한 개 씩 담고, 각 상자에 번호를 매긴 것이라면, 셋은 그냥 큰 상자 안에 모든 원소들을 쑤셔 넣은 것이라 보면 됩니다. 그 상자 안에 원소가 어디에 있는지는 중요한게 아니고,그 상자 안에 원소가 '있냐/없냐' 만이 중요한 정보입니다.


셋에 원소를 추가하거나 지우는 작업은 $$O(log N)$$ 에 처리됩니다. 시퀀스 컨테이너의 경우 임의의 원소를 지우는 작업이 $$O(N)$$ 으로 수행되었다는 점을 생각하면 훨씬 빠르다고 볼 수 있습니다.

```cpp-formatted
template <typename T>
void print_set(set<T>& s) {
  // 셋의 모든 원소들을 출력하기
  cout << "[ ";
  for (typename set<int>::iterator itr = s.begin(); itr != s.end(); itr++) {
    cout << *itr << " ";
  }
  cout << " ] " << endl;
}
```



셋 역시 셋에 저장되어 있는 원소들에 접근하기 위해 반복자를 제공하며, 이 반복자는 `BidirectionalIterator` 입니다. 즉, 시퀀스 컨테이너의 리스트 처럼 임의의 위치에 있는 원소에 접근하는 것은 불가능 하고 순차적으로 하나 씩 접근하는 것 밖에 불가능 합니다.


한 가지 흥미로운 점은 우리 셋에 원소를 넣었을 때 `10 -> 50 -> 20 -> 40 -> 30` 으로 넣었지만 실제로 반복자로 원소들을 모두 출력했을 때 나온 순서는 `10 -> 20 -> 30 -> 40 -> 50` 순으로 나왔다는 점입니다.다시 말해 셋의 경우 내부에 원소를 추가할 때 정렬된 상태를 유지하며 추가합니다.



앞서 셋을 큰 상자라 생각하고 그 안에 원소들을 쑤셔 넣은 것이라 했는데, 실제로 마구 쑤셔넣지는 않고 순서를 지키면서 쑤셔 넣습니다. 이 때문에 시퀀스 컨테이너와는 다르게 원소를 추가하는 작업이 $$O(log N)$$ 으로 진행됩니다.


또한 셋의 진가는 앞서 말했듯이 원소가 있냐 없냐를 확인할 때 드러납니다.

```cpp-formatted
cout << "20 이 s 의 원소인가요? :: ";
auto itr = s.find(20);
if (itr != s.end()) {
  cout << "Yes" << endl;
} else {
  cout << "No" << endl;
}
```



셋에는 `find` 함수가 제공되며, 이 `find` 함수를 통해 이 셋에 원소가 존재하는지 아닌지 확인할 수 있습니다. 만일 해당하는 원소가 존재한다면 이를 가리키는 반복자를 리턴하고 (`set<>::iterator` 타입입니다) 만일 존재하지 않는다면 `s.end()` 를 리턴하게 되지요.


만일 벡터였다면 원소가 존재하는지 아닌지 확인하기 위해 벡터의 처음 부터 끝 까지 하나씩 비교해가면서 찾았어야 했겠죠. 만일 원소가 없었더라면 벡터에 있는 모든 원소를 확인하였을 것입니다 (즉 벡터에서 `find` 는 $$O(N)$$ 이라 볼 수 있습니다).


하지만셋의 경우 놀랍게도 $$O(log N)$$ 으로 원소가 존재하는지 확인할 수 있습니다. 이것이 가능한 이유는 셋 내부적으로 원소들이 정렬된 상태를 유지하기 때문에 비교적 빠르게 원소의 존재 여무를 확인할 수 있습니다.


따서 20 을 찾았을 때 `Yes` 가 나오고 셋에 없는 원소인 25 를 찾는다면 `No` 가 출력됩니다.


셋이 이러한 방식으로 작업을 수행할 수 있는 이유는 바로 내부적으로 트리 구조로 구성되어 있기 때문입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F22108538595C295C210FFE)



위 그림은 흔히 볼 수 있는 트리 구조를 나타냅니다. 각각의 원소들은 트리의 각 노드들에 저장되어 있고, 다음과 같은 규칙을 지키고 있습니다.

* 왼쪽에 오는 모든 노드들은 나보다 작다
* 오른쪽에 있는 모든 노드들은 나보다 크다



예를 들어 오른쪽의 30 을 살펴볼까요 (위 그림에서 점선으로 표시한 부분). 30 왼쪽에 오는 노드는 25 로 30 보다 작고, 오른쪽에 오는 노드들은 33, 45, 60 으로 모두 30 보다 큽니다. 어떤 노드들을 살펴보아도 이러한 규칙을 지키고 있음을 알 수 있습니다.


그렇다면 위 구조에서 25 를 찾으려면 어떻게 할까요?

1. 일단 최상위 노드 (루트 노드라 합니다) 와 비교 : 25 > 20 → 오른쪽 노드로 간다
2. 30 과 비교 : 25 < 30 → 왼쪽 노드로 간 30 과 비교 : 25 < 30 → 왼쪽 노드로 간다
3. 25 와 비교 : 25 == 25 → 당첨 25 와 비교 : 25 == 25 → 당첨!



전체 원소 개수는 8개 이지만, 단 3번의 비교로 원소를 정확히 찾을 수 있습니다.


그렇다면 12 를 찾으려면 어떻게 할까요? 참고로 12 는 위 셋에 들어있지 않은 원소 입니다.

1. 루트 노드와 비교 : 12 < 20 → 왼쪽 노드로 간다
1. 15 와 비교 : 12 < 15 → 왼쪽 노드로 간 15 와 비교 : 12 < 15 → 왼쪽 노드로 간다
1. 10 과 비교 : 12 > 10 → 오른쪽 노드로 가야하지만 오른쪽에 아무것도 없다. 따라서 이 원소는 존재하지 않는다 10 과 비교 : 12 > 10 → 오른쪽 노드로 가야하지만 오른쪽에 아무것도 없다. 따라서 이 원소는 존재하지 않는다.



만일 벡터 였다면 원소들을 처음 부터 끝까지 확인해봐야 했지만 셋의 경우 단 3번의 비교만으로 12 가 셋에 존재하는지 아닌지 여부를 판단할 수 있었습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F25566243595C2B600E335B)

아마 깨달으신 분들도 있겠지만, 원소를 검색하는데 필요한 횟수는 트리의 높이와 정확히 일치합니다. 즉, 15 는 단 2번의 비교로 찾아낼 수 있고, 맨 밑에 있는 60 이나 33 의 경우 총 4번의 비교가 필요하겠지요. 따라서, 트리의 경우 최대한 모든 노드들을 꽉 채우는 것이 중요합니다. 예를 들어서


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F25339935595C2C382057B8)

어쩌다 보니 트리가 위 처럼 되버렸다면 사실상 시퀀스 컨테이너와 검색 속도가 동일할 것입니다. 위와 같이 한쪽으로 아예 치우쳐버린 트리를 군형잡히지 않은 트리 (unbalanced tree) 라고 부릅니다. 실제 셋의 구현을 보면 위와 같은 상황이 발생하지 않도록 앞서 말한 두 개의 단순한 규칙 보다 더 많은 규칙들을 도입해서 트리를 항상 균형 잡히도록 유지하고 있습니다.


따라서 셋의 구현 상$$O(log N)$$ 으로 원소를 검색할 수 있다는 것이 보장됩니다. (궁금하신 분들만! [대부분의 셋 구현에서 사용하고 있는 트리 구조는 여기서 볼 수 있습니다](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)`)`



또한 셋의 중요한 특징으로 바로 셋 안에는 중복된 원소들이 없다는 점이 있습니다.

```cpp-formatted
#include <iostream>
#include <set>
#include <string>
using namespace std;

template <typename T>
void print_set(set<T>& s) {
  // 셋의 모든 원소들을 출력하기
  cout << "[ ";
  for (auto itr = s.begin(); itr != s.end(); itr++) {
    cout << *itr << " ";
  }
  cout << " ] " << endl;
}

int main() {
  set<int> s;
  s.insert(10);
  s.insert(20);
  s.insert(30);
  s.insert(20);
  s.insert(10);

  print_set(s);
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F224D6A4E595C37E3337F98)



와 같이 나옵니다. 분명히

```cpp-formatted
s.insert(10);
s.insert(20);
s.insert(30);
s.insert(20);
s.insert(10);
```



위와 같이 10 과 20 을 두 번씩 넣었지만 실제로는 한 번씩 밖에 나오지 않습니다. 이는 셋 자체적으로 이미 같은 원소가 있다면 이를 `insert` 하지 않기 때문입니다. 따라서 마지막 두 `insert` 작업은 무시되었을 것입니다.


만약에 중복된 원소를 허락하고 싶다면 멀티셋(multiset) 을 사용하면 되는데, 이는 후술 하겠습니다.



###  여러분이 만든 클래스 객체를 셋에 넣고 싶을 때




위와 같이 기본 타입들 말고, 여러분이 만든 클래스의 객체를 셋의 원소로 사용할 때 한 가지 주의해야 할 점이 있습니다. 아래는 할 일 (Todo) 목록을 저장하기 위해 셋을 사용하는 예시 입니다. `Todo` 클래스는 2 개를 멤버 변수로 가지는데 하나는 할 일의 중요도이고, 하나는 해야할 일의 설명 입니다.
```cpp-formatted
#include <iostream>
#include <set>
#include <string>
using namespace std;

template <typename T>
void print_set(set<T>& s) {
  // 셋의 모든 원소들을 출력하기
  cout << "[ ";
  for (typename set<T>::iterator itr = s.begin(); itr != s.end(); itr++) {
    cout << *itr << " ";
  }
  cout << " ] " << endl;
}
class Todo {
  int priority;  // 중요도. 높을 수록 급한것!
  string job_desc;

 public:
  Todo(int priority, string job_desc)
      : priority(priority), job_desc(job_desc) {}
};
int main() {
  set<Todo> todos;

  todos.insert(Todo(1, "농구 하기"));
  todos.insert(Todo(2, "수학 숙제 하기"));
  todos.insert(Todo(1, "프로그래밍 프로젝트"));
  todos.insert(Todo(3, "친구 만나기"));
  todos.insert(Todo(2, "영화 보기"));
}
```

그런데 컴파일 하였다면 아래와 같은 오류가 발생합니다.

```warning
binary '<': no operator found which takes a left-hand operand of type 'const Todo' (or there is no acceptable conversion)
```

왜 발생하였을까요? 생각을 해봅시다. 앞서 셋은 원소들을 저장할 때 내부적으로 정렬된 상태를 유지한다고 하였습니다. 즉 정렬을 하기 위해서는 반드시 원소 간의 비교를 수행해야 겠지요. 하지만, 우리의 `Todo` 클래스에는 `operator<` 가 정의되어 있지 않습니다. 따라서 컴파일러는 `<` 연산자를 찾을 수 없기에 위와 같은 오류를 뿜어내는 것입니다.


그렇다면 직접 `Todo` 클래스에 `operator<` 를 만들어주는 수 밖에 없습니다.

```cpp-formatted
#include <iostream>
#include <set>
#include <string>
using namespace std;

template <typename T>
void print_set(set<T>& s) {
  // 셋의 모든 원소들을 출력하기
  for (auto itr = s.begin(); itr != s.end(); itr++) {
    cout << *itr << " " << endl;
  }
}
class Todo {
  int priority;
  string job_desc;

 public:
  Todo(int priority, string job_desc)
      : priority(priority), job_desc(job_desc) {}

  bool operator<(const Todo& t) const {
    if (priority == t.priority) {
      return job_desc < t.job_desc;
    }
    return priority > t.priority;
  }

  friend ostream& operator<<(ostream& o, const Todo& td);
};

ostream& operator<<(ostream& o, const Todo& td) {
  o << "[ 중요도: " << td.priority << "] " << td.job_desc;
  return o;
}
int main() {
  set<Todo> todos;

  todos.insert(Todo(1, "농구 하기"));
  todos.insert(Todo(2, "수학 숙제 하기"));
  todos.insert(Todo(1, "프로그래밍 프로젝트"));
  todos.insert(Todo(3, "친구 만나기"));
  todos.insert(Todo(2, "영화 보기"));

  print_set(todos);

  cout << "-------------" << endl;
  cout << "숙제를 끝냈다면!" << endl;
  todos.erase(todos.find(Todo(2, "수학 숙제 하기")));
  print_set(todos);
}
```



컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F217D3D41595C3A441DDAC9)



와 같이 잘 실행됩니다.


먼저 `<` 연산자를 어떻게 구현하였는지 살펴보겠습니다.

```cpp-formatted
bool operator<(const Todo& t) const {
  if (priority == t.priority) {
    return job_desc < t.job_desc;
  }
  return priority > t.priority;
}
```


셋이서 `<` 를 사용하기 위해서는 반드시 위와 같은 형태로 함수를 작성해야 합니다. 즉 `const Todo` 를 레퍼런스로 받는 `const` 함수로 말이지요. 이를 지켜야 하는 이유는 셋 내부적으로 정렬 시에 상수 반복자를 사용하기 때문입니다. (상수 반복자는 상수 함수만을 호출할 수 있습니다 . 이를 지켜야 하는 이유는 셋 내부적으로 정렬 시에 상수 반복자를 사용하기 때문입니다. (상수 반복자는 상수 함수만을 호출할 수 있습니다)


우리의 `Todo <` 연산자는 중요도가 다르면,

```cpp-formatted
return priority > t.priority;
```



로 해서 중요도 값이 높은 일이 위로 가게 하였습니다. 만약 중요도가 같다면

```cpp-formatted
return job_desc < t.job_desc;
```



로 비교해서 `job_desc` 가 사전상에서 먼저 오는것이 먼저 나오게 됩니다.


한 가지 유의해야 할 점은 셋 내부에서 두 개의 원소가 같냐 다르냐를 판별하기 위해서 `==` 를 이용하지 않는다는 점입니다. 두 원소 `A` 와 `B` 가 셋 내부에서 같다는 의미는 `A.operator<(B)` 와 `B.operator<(A)` 가 모두 `false` 라는 뜻입니다. (예를 들어서 `int a = b=` 2; 이라고 하면 `a < b` 가 `false` 이고 `b < a` 도 `false` 이므로 `a == b` 이라 생각함)


만약에 우리가 중요도가 같을 때 따로 처리하지 않고 그냥

```cpp-formatted
bool operator<(const Todo& t) const { return priority > t.priority; }
```



게 했다면 어떻게 되었을까요? 그 결과는 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2107C344595C3A6F3910F7)




위와 같이 중요도가 같은 애들은 추가 되지 않습니다. 왜냐하면 앞서 말했듯이 셋에는 중복된 원소를 허락하지 않습니다. 그런데, 셋의 입장에서

```cpp-formatted
Todo(1, "농구 하기")
```



와

```cpp-formatted
Todo(1, "프로그래밍 프로젝트")
```



를 보았을 때

```info
Todo(1, "농구 하기") < Todo(1, "프로그래밍 프로젝트")
Todo(1, "프로그래밍 프로젝트") > Todo(1, "농구 하기")
```

가 둘다 `false` 이므로, 두 개의 원소는 같은 것이라 생각하기 때문입니다! 따라서 나중에 추가된 '프로그래밍 프로젝트' 는 셋에 추가되지 않습니다. 같은 이유로 영화 보기도 추가되지 않습니다.


따라서 `operator<` 를 설계할 때 반드시 다른 객체는 `operator<` 상에서도 구분될 수 있도록 만들어야 합니다. 다시 말해 `A` 랑 `B` 가 다른 객체라면, `A < B` 혹은 `B < A` 중 하나는 반드시 `True` 여야 합니다.


엄밀히 말하자면 `operator<` 는 다음과 같은 조건들을 만족해야 합니다. (A 랑 B 가 다른 객체라면)

* `A < A` 는 거짓
* `A < B != B < A`
* `A < B` 이고 `B < C` 이면 `A < C`
* `A == B` 이면 `A < B` 와 B `< A` 둘 다 거짓
* `A == B` 이고 `B == C` 이면 `A == C`


위와 같은 조건을 만족하는 `<` 연산자는 *strict weak ordering* 을 만족한다고 합니다. 지켜야 할 조건들이 꽤나 많이 보이는데 사실, 상식적으로 `operator<` 를 설계하였다면 위 조건들은 모두 만족할 수 있습니다.


만약에, 위 중 하나라도 조건이 맞지 않는면 `set` 이 제대로 동작하지 않고 (컴파일 타임에는 오류가 발생하지 않습니다), 런타임 상에서 오류가 발생할 텐데 정말 디버깅 하기 힘들 것입니다 :(


마지막으로 보여드릴 것은, 클래스 자체에 `operator<` 를 두지 않더라도 셋을 사용하는 방법입니다. 예를 들어서 우리가 외부 라이브러리를 사용하는데, 만약에 그 라이브러리의 한 클래스의 객체를 셋에 저장하고 싶다고 해봅시다. 우리가 사용하는 외부 클래스에 `operator<` 가 정의되어 있지 않다는 점입니다. 이럴 경우, 셋을 사용하기 위해서는 따로 객체를 비교할 수 있는 방법을 알려주어야 합니다.


아래 예제를 보실까요.

```cpp-formatted
#include <iostream>
#include <set>
#include <string>
using namespace std;

template <typename T, typename C>
void print_set(set<T, C>& s) {
  // 셋의 모든 원소들을 출력하기
  for (auto itr = s.begin(); itr != s.end(); itr++) {
    cout << *itr << " " << endl;
  }
}
class Todo {
  int priority;
  string job_desc;

 public:
  Todo(int priority, string job_desc)
      : priority(priority), job_desc(job_desc) {}

  friend struct TodoCmp;

  friend ostream& operator<<(ostream& o, const Todo& td);
};
struct TodoCmp {
  bool operator()(const Todo& t1, const Todo& t2) const {
    if (t1.priority == t2.priority) {
      return t1.job_desc < t2.job_desc;
    }
    return t1.priority > t2.priority;
  }
};

ostream& operator<<(ostream& o, const Todo& td) {
  o << "[ 중요도: " << td.priority << "] " << td.job_desc;
  return o;
}
int main() {
  set<Todo, TodoCmp> todos;

  todos.insert(Todo(1, "농구 하기"));
  todos.insert(Todo(2, "수학 숙제 하기"));
  todos.insert(Todo(1, "프로그래밍 프로젝트"));
  todos.insert(Todo(3, "친구 만나기"));
  todos.insert(Todo(2, "영화 보기"));

  print_set(todos);

  cout << "-------------" << endl;
  cout << "숙제를 끝냈다면!" << endl;
  todos.erase(todos.find(Todo(2, "수학 숙제 하기")));
  print_set(todos);
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F217D3D41595C3A441DDAC9)



와 같이 나옵니다. 달라진 점은 일단 `Todo` 클래스에서 `operator<` 가 삭제되었습니다. 하지만 셋을 사용하기 위해 반드시 `Todo` 객체간의 비교를 수행해야 하기 때문에 다음과 같은 클래스를 만들었습니다.


```cpp-formatted
struct TodoCmp {
  bool operator()(const Todo& t1, const Todo& t2) const {
    if (t1.priority == t2.priority) {
      return t1.job_desc < t2.job_desc;
    }
    return t1.priority > t2.priority;
  }
};
```



앞서 템플릿 첫 강좌에서 함수 객체를 배운 것이 기억 나시나요? 위 클래스는 정확히 함수 객체를 나타내고 있습니다. 이 `TodoCmp` 타입을

```cpp-formatted
set<Todo, TodoCmp> todos;
```

위 처럼 `set` 에 두번째 인자로 넘겨주게 되면 셋은 이를 받아서 `TodoCmp` 클래스에 정의된 함수 객체를 바탕으로 모든 비교를 수행하게 됩니다. 실제로 `set` 클래스의 정의를 살펴보면;

```cpp-formatted
template <class Key, class Compare = std::less<Key>,
          class Allocator = std::allocator<Key>  // ← 후에 설명하겠습니다
          >
class set;
```



와 같이 생겼는데, 두 번째 인자로 `Compare` 를 받는 다는 것을 알 수 있습니다. (템플릿 디폴트 인자로 `std::less<Key>` 가 들어있는데 이는 `Key` 클래스의 `operator<` 를 사용한다는 의미와 같습니다. `Compare` 타입을 전달하지 않으면 그냥 `Key` 클래스의 `operator<` 로 비교를 수행합니다.)


결과적으로 셋은 원소의 삽입과 삭제를 `O(log N),` 원소의 탐색도 $$O(log N)$$ 에 수행하는 자료 구조 입니다.



###  맵 (map)


맵은 셋과 거의 똑같은 자료 구조 입니다. 다만 셋의 경우 키만 보관했지만, 맵의 경우 키에 대응되는 값(value) 까지도 같이 보관하게 됩니다.

```cpp-formatted
#include <iostream>

#include <map>
#include <string>

using namespace std;

template <typename K, typename V>
void print_map(map<K, V>& m) {
  // 맵의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << itr->first << " " << itr->second << endl;
  }
}

int main() {
  map<string, double> pitcher_list;

  // 참고로 2017년 7월 4일 현재 투수 방어율 순위입니다.

  // 맵의 insert 함수는 pair 객체를 인자로 받습니다.
  pitcher_list.insert(pair<string, double>("박세웅", 2.23));
  pitcher_list.insert(pair<string, double>("해커 ", 2.93));

  pitcher_list.insert(pair<string, double>("피어밴드 ", 2.95));

  // 타입을 지정하지 않아도 간단히 make_pair 함수로
  // pair 객체를 만들 수 도 있습니다.
  pitcher_list.insert(make_pair("차우찬", 3.04));
  pitcher_list.insert(make_pair("장원준 ", 3.05));
  pitcher_list.insert(make_pair("헥터 ", 3.09));

  // 혹은 insert 를 안쓰더라도 [] 로 바로
  // 원소를 추가할 수 있습니다.
  pitcher_list["니퍼트"] = 3.56;
  pitcher_list["박종훈"] = 3.76;
  pitcher_list["켈리"] = 3.90;

  print_map(pitcher_list);

  cout << "박세웅 방어율은? :: " << pitcher_list["박세웅"] << endl;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F276D7B4E595C7A1C0B0EC7)



와 같이 나옵니다.


```cpp-formatted
map<string, double> pitcher_list;
```

맵의 경우 템플릿 인자로 2 개를 가지는데, 첫번째는 키의 타입이고, 두 번째는 값의 타입입니다. 우리는 투수 이름을 키로 가지고 대응되는 값을 그 투수의 방어율로 하는 맵을 만들 예정입니다.

```cpp-formatted
pitcher_list.insert(pair<string, double>("박세웅", 2.23));
pitcher_list.insert(pair<string, double>("해커 ", 2.93));
pitcher_list.insert(pair<string, double>("피어밴드 ", 2.95));
```

맵에 원소를 넣기 위해서는 반드시 `pair` 객체를 전달해야 합니다. `pair` 객체는 별다른게 아니고,

```cpp-formatted
template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
};
```

로 생긴 단순히 2 개의 객체를 멤버로 가지는 객체 입니다. 문제는 `pair` 객체를 사용할 때 마다 위 처럼 템플릿 인자를 초기화 해야 하는데 꽤나 귀찮습니다. 그래서 `STL` 에서는 `make_pair` 함수를 제공해주는데,

```cpp-formatted
pitcher_list.insert(make_pair("차우찬", 3.04));
pitcher_list.insert(make_pair("장원준 ", 3.05));
pitcher_list.insert(make_pair("헥터 ", 3.09));
```

이 함수는 인자로 들어오는 객체를 보고 타입을 추측해서 알아서 `pair` 객체를 만들어서 리턴해줍니다. 따라서 굳이 귀찮게 타입을 명시해줄 필요가 없습니다.


한 가지 재미있는 점은

```cpp-formatted
// 혹은 insert 를 안쓰더라도 [] 로 바로
// 원소를 추가할 수 있습니다.
pitcher_list["니퍼트"] = 3.56;
pitcher_list["박종훈"] = 3.76;
pitcher_list["켈리"] = 3.90;
```

맵의 경우 `operator[]` 를 이용해서 새로운 원소를 추가할 수 도 있습니다 (만일 해당하는 키가 맵에 없다면). 만일 키가 이미 존재하고 있다면 값이 대체될 것입니다.

```cpp-formatted
template <typename K, typename V>
void print_map(map<K, V>& m) {
  // 맵의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << itr->first << " " << itr->second << endl;
  }
}
```

맵의 경우도 셋과 마찬가지로 반복자를 이용해서 순차적으로 맵에 저장되어 있는 원소들을 탐색할 수 있습니다. 참고로 셋의 경우 `*itr` 가 저장된 원소를 바로 가리켰는데, 맵의 경우 반복자가 맵에 저장되어 있는 `pair` 객체를 가리키게 됩니다. 따라서 `itr->first` 를 하면 해당 원소의 키를, `itr->second` 를 하면 해당 원소의 값을 알 수 있습니다.

```cpp-formatted
cout << "박세웅 방어율은? :: " << pitcher_list["박세웅"] << endl;
```

만약에 맵에 저장된 값을 찾고 싶다면 간단히 `[]` 연산자를 이용하면 됩니다. `[]` 연산자는 인자로 키를 받아서 이를 맵에서 찾아서 대응되는 값을 돌려줍니다.


하지만, `[]` 연산자를 사용할 때 주의해야 할 점이 있습니다.

```cpp-formatted
#include <iostream>
#include <map>
#include <string>

using namespace std;

template <typename K, typename V>
void print_map(map<K, V>& m) {
  // 맵의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << itr->first << " " << itr->second << endl;
  }
}

int main() {
  map<string, double> pitcher_list;

  pitcher_list["오승환"] = 3.58;
  cout << "류현진 방어율은? :: " << pitcher_list["류현진"] << endl;

  cout << "-----------------" << endl;
  print_map(pitcher_list);
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2266ED33595DE49812027A)


와 같이 나옵니다.

```cpp-formatted
pitcher_list["오승환"] = 3.58;
```



일단 위와 같이 `pitcher_list` 에 오승환의 방어율만 추가하였기 때문에 류현진의 방어율을 검색하면 아무것도 나오지 않는게 정상입니다. 그런데,

```cpp-formatted
cout << "류현진 방어율은? :: " << pitcher_list["류현진"] << endl;
```



위 처럼 류현진의 방어율을 맵에서 검색하였을 때, 0 이라는 값이 나왔습니다. 없는 값을 참조하였으니 오류가 발생해야 정상인데 오히려 값을 돌려주었네요.이는 `[]` 연산자가, 맵에 없는 키를 참조하게 되면, 자동으로 값의 디폴트 생성자를 호출해서 원소를 추가해버리기 때문입니다.


`double` 의 디폴트 생성자의 경우 그냥 변수를 0 으로 초기화 해버립니다. 따라서 되도록이면 `find` 함수로 원소가 키가 존재하는지 먼저 확인 후에, 값을 참조하는 것이 좋습니다. 아래는 `find` 함수를 이용해서 안전한게 키에 대응되는 값을 찾는 방법입니다.


```cpp-formatted
#include <iostream>
#include <map>
#include <string>

using namespace std;

template <typename K, typename V>
void print_map(map<K, V>& m) {
  // 맵의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << itr->first << " " << itr->second << endl;
  }
}

template <typename K, typename V>
void search_and_print(map<K, V>& m, K key) {
  auto itr = m.find(key);
  if (itr != m.end()) {
    cout << key << " --> " << itr->second << endl;
  } else {
    cout << key << "은(는) 목록에 없습니다" << endl;
  }
}

int main() {
  map<string, double> pitcher_list;

  pitcher_list["오승환"] = 3.58;

  print_map(pitcher_list);
  cout << "-----------------" << endl;

  search_and_print(pitcher_list, string("오승환"));
  search_and_print(pitcher_list, string("류현진"));
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F240B223E595DEA2625333E)



와 같이 나옵니다.


```cpp-formatted
template <typename K, typename V>
void search_and_print(map<K, V>& m, K key) {
  auto itr = m.find(key);
  if (itr != m.end()) {
    cout << key << " --> " << itr->second << endl;
  } else {
    cout << key << "은(는) 목록에 없습니다" << endl;
  }
}
```



위 처럼 `find` 함수는 맵에서 해당하는 키를 찾아서 이를 가리키는 반복자를 리턴합니다. 만약에, 키가 존재하지 않는다면 `end()` 를 리턴합니다.


마지막으로 짚고 넘어갈 점은 맵 역시 셋 처럼 중복된 원소를 허락하지 않는다는 점입니다. 이미, 같은 키가 원소로 들어 있다면 나중에 오는 `insert` 는 무시됩니다.


```cpp-formatted
#include <iostream>
#include <map>
#include <string>

using namespace std;

template <typename K, typename V>
void print_map(map<K, V>& m) {
  // 맵의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << itr->first << " " << itr->second << endl;
  }
}

int main() {
  map<string, double> pitcher_list;

  // 맵의 insert 함수는 pair 객체를 인자로 받습니다.
  pitcher_list.insert(pair<string, double>("박세웅", 2.23));
  pitcher_list.insert(pair<string, double>("박세웅", 2.93));

  print_map(pitcher_list);

  // 2.23 이 나올까 2.93 이 나올까?
  cout << "박세웅 방어율은? :: " << pitcher_list["박세웅"] << endl;
}
```



성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F276C924F595DFC5D184B3C)



와 같이 먼저 `insert` 된 원소가 나오게 됩니다. 즉, 이미 같은 키를 가지는 원소가 있다면 그 `insert` 작업은 무시됩니다. 만약에, 원소에 대응되는 값을 바꾸고 싶다면 `insert` 를 하지 말고, `[]` 연산자로 대응되는 값을 바꿔주면 됩니다.



###  멀티셋(multiset)과 멀티맵(multimap)

앞서 셋과 맵 모두 중복된 원소를 허락하지 않습니다. 만일, 이미 원소가 존재하고 있는데 `insert` 를 하였으면 무시가 되었지요. 하지만 멀티셋과 멀티맵은 중복된 원소를 허락합니다.

```cpp-formatted
#include <iostream>
#include <set>
#include <string>
using namespace std;

template <typename K>
void print_set(multiset<K>& s) {
  // 셋의의 모든 원소들을 출력하기
  for (auto itr = s.begin(); itr != s.end(); itr++) {
    cout << *itr << endl;
  }
}

int main() {
  multiset<string> s;

  s.insert("a");
  s.insert("b");
  s.insert("a");
  s.insert("c");
  s.insert("d");
  s.insert("c");

  print_set(s);
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2152BF42595DFC5D1478E8)



와 같이 나옵니다. 만약에 기존의 `set` 이였다면 그냥 `a,b,c,d` 이렇게 나왔어야 하지만, 멀티셋의 경우 중복된 원소를 허락하기 때문에 `insert` 한 모든 원소들이 쭈르륵 나오게 됩니다.


```cpp-formatted
#include <iostream>
#include <map>
#include <string>
using namespace std;

template <typename K, typename V>
void print_map(multimap<K, V>& m) {
  // 맵의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << itr->first << " " << itr->second << endl;
  }
}

int main() {
  multimap<int, string> m;
  m.insert(make_pair(1, "hello"));
  m.insert(make_pair(1, "hi"));
  m.insert(make_pair(1, "ahihi"));
  m.insert(make_pair(2, "bye"));
  m.insert(make_pair(2, "baba"));

  print_map(m);

  // 뭐가 나올까요?
  cout << "--------------------" << endl;
  cout << m.find(1)->second << endl;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F261D663E59605B062415DA)



와 같이 나옵니다.


일단 맵 과는 다르게, 한 개의 키에 여러개의 값이 대응될 수 있다는 것은 알 수 있습니다. 하지만 이 때문에 `[]` 연산자를 멀티맵의 경우 사용할 수 없습니다. 왜냐하면 예를 들어서


```cpp-formatted
m[1]
```



을 했을 때 "hello" 를 리턴해야할지, 아니면 "hi" 를 리턴해야 할 지 알 수 없기 때문이지요. 따라서 멀티맵의 경우 아예 `[]` 연산자를 제공하지 않습니다. 그렇다면

```cpp-formatted
cout << m.find(1)->second << endl;
```

위 처럼 `find` 함수를 사용했을 때 무엇을 리턴할까요? 일단 해당하는 키가 없으면 `m.end()` 를 리턴합니다. 그렇다면 위 경우 1 이라는 키에 3 개의 문자열이 대응되어 있는데 어떤거를 리턴해야 할까요? 제일 먼저 `insert` 한것? 아니면 문자열 중에서 사전 순으로 가장 먼저 오는 것?


사실 C++ 표준을 읽어보면 무엇을 리턴하라고 정해놓지 않았습니다. 즉, 해당되는 값들 중 아무 거나 리턴해도 상관 없다는 뜻입니다. 위 경우 `hello` 가 나왔지만, 다른 라이브러리를 쓰는 경우 `hi` 가 나올 수 도 있고, `ahihi` 가 나올 수 도 있습니다.

그렇다면 1 에 대응되는 값들이 뭐가 있는지 어떻게 알까요? 이를 위해 멀티맵은 다음과 같은 함수를 제공하고 있습니다.

```cpp-formatted
#include <iostream>
#include <map>
#include <string>
using namespace std;

template <typename K, typename V>
void print_map(multimap<K, V>& m) {
  // 맵의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << itr->first << " " << itr->second << endl;
  }
}

int main() {
  multimap<int, string> m;
  m.insert(make_pair(1, "hello"));
  m.insert(make_pair(1, "hi"));
  m.insert(make_pair(1, "ahihi"));
  m.insert(make_pair(2, "bye"));
  m.insert(make_pair(2, "baba"));

  print_map(m);

  cout << "--------------------" << endl;

  // 1 을 키로 가지는 반복자들의 시작과 끝을
  // pair 로 만들어서 리턴한다.
  auto range = m.equal_range(1);
  for (auto itr = range.first; itr != range.second; itr++) {
    cout << itr->first << " : " << itr->second << " " << endl;
  }
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F26246048596063613761EA)



와 같이 나옵니다.

```cpp-formatted
auto range = m.equal_range(1);
```

`equal_range` 함수의 경우 인자로 멀티맵의 키를 받은 뒤에, 이 키에 대응되는 원소들의 반복자들 중에서시작과 끝 바로 다음을 가리키는 반복자를 `pair` 객체로 만들어서 리턴합니다. 즉, `begin()` 과 `end()` 를 `pair` 로 만들어서 세트로 리턴한다고 볼 수 있겠지요. 다만, `first` 로 시작점을, `second` 로 끝점 바로 뒤를 알 수 있습니다. 왜 끝점 바로 뒤를 가리키는 반복자를 리턴하는지는 굳이 설명 안해도 알겠죠?

```cpp-formatted
for (auto itr = range.first; itr != range.second; itr++) {
  cout << itr->first << " : " << itr->second << " " << endl;
}
```



따라서 위 처럼 1 에 대응되는 모든 원소들을 볼 수 있게 됩니다.



###  정렬되지 않은 셋과 맵 (unordered_set, unordered_map)



`unordered_set` 과 `unordered_map` (한글로 하면 너무 길어서 그냥 영문으로 표기하겠습니다) 은 C++ 11 에 추가된 비교적 최근 나온 컨테이너들 입니다 (위에것들은 모두 C++ 98 에 추가되었었죠).
이 두 개의 컨테이너는 이름에서도 알 수 있듯이 원소들이 정렬되어 있지 않습니다.

이 말이 무슨 말이냐면, 셋이나 맵의 경우 원소들이 순서대로 정렬되어서 내부에 저장되지만, `unordered_set` 과 `unordered_map` 의 경우 원소들이 순서대로 정렬되서 들어가지 않는다는 뜻입니다. 따라서 반복자로 원소들을 하나씩 출력해보면 거의 랜덤한 순서로 나오는 것을 볼 수 있습니다.

```cpp-formatted
#include <iostream>
#include <string>
#include <unordered_set>
using namespace std;

template <typename K>
void print_unordered_set(unordered_set<K>& m) {
  // 셋의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << *itr << endl;
  }
}

int main() {
  unordered_set<string> s;

  s.insert("hi");
  s.insert("my");
  s.insert("name");
  s.insert("is");
  s.insert("psi");
  s.insert("welcome");
  s.insert("to");
  s.insert("c++");

  print_unordered_set(s);
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F2546B049596074021F4118)



와 같이 나옵니다.


실제로 `unordered_set` 의 모든 원소들을 반복자로 출력해보면 딱히 순서대로 나오는 것 같지는 않습니다. 원소를 넣은 순서도 아니고, `string` 문자열 순서도 아니고 그냥 랜덤한 순서 입니다.


그런데 이 `unordered _set` 에 한 가지 놀라운 점이 있습니다. 바로 `insert, erase, find` 모두가 $$O(1)$$ 으로 수행된다는 점입니다! 셋이나 맵의 경우 `O(log n)` 이었지만, `unordered_set` 과 `unordered_map` 의 경우 상수 시간에 원소를 삽입하고, 검색할 수 있습니다. 

이 놀라운 일이 어떻게 가능한건지 `unordered_set` 과 `unordered_map` 이 어떻게 구현되었는지 살펴보면 알 수 있습니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F265AE73859607D5303C92C)


`unordered_set` 과 `unordered_map` 은 원소를 삽입하거나 검색 하기 위해 먼저 해시 함수라는 것을 사용합니다 (사실 그래서 원래 `hashset` 이나 `hashmap` 이란 이름을 붙이려고 했지만 이미 이러한 이름을 너무 많이 사용하고 있어서 충돌을 피하기 위해 저런 이름을 골랐다고 합니다).

해시 함수란 임의의 크기의 데이터를 고정된 크기의 데이터로 대응시켜주는 함수라고 볼 수 있습니다. 이 때 보통 고정된 크기의 데이터라고 하면 일정 범위의 정수값을 의미합니다.


`unordered_set` 과 `unordered_map` 의 경우, 해시함수는 1 부터 `D (= 상자의 수)까지의` 값을 반환하고 그 해시값 (해시 함수로 계산한 값)을 원소를 저장할 상자의 번호로 삼게 됩니다. 해시 함수는 구조상 최대한 1 부터 `D` 까지 고른 값을 반환하도록 설계되었습니다. 따라서 모든 상자를 고루 고루 사용할 수 있게 되지요.

해시 함수의 가장 중요한 성질은, 만약에 같은 원소를 해시 함수에 넣었다면 같은 해시값을 리턴한다는 점입니다. 이 덕분에 원소의 탐색을 빠르게 수행할 수 있습니다.

예를 들어 사용자가 파란공이 이 `unordered_set` 에 들어있는지 아닌지 확인한다고 해봅시다. 파란공을 해시 함수에 대입하면 1 을 리턴합니다. 따라서 1 번 상자를 살펴보면 이미 파란공이 있는 것을 알 수 있지요. 따라서 파란 공이 이 `unordered_set` 에 이미 존재하고 있음을 알 수 있습니다.


그런데 재미있는 점은 해시 함수가 해시 값 계산을 상수 시간에 처리한다는 점입니다. 따라서 `unordered_set` 과 `unordered_map` 모두 탐색을 상수 시간에 처리할 수 있습니다.


물론 빨간색 공과 보라색 공 처럼 다른 원소임에도 불구하고 같은 해시값을 갖는 경우가 있을 것입니다. 이를해시 충돌(hash `collision)` 이라고 하는데, 이 경우 같은 상자에 다른 원소들이 들어있게 됩니다.

따라서 만약에 보라색 공이 이 셋에 포함되어 있는지 확인하고 싶다면 먼저 보라색 공의 해시값을 계산 한 뒤에, 해당하는 상자에 있는 모든 원소들을 탐색해보아야 할 것입니다.


해시 함수는 최대한 1 부터 N 까지 고른 값을 반환하도록 설계되었습니다. 뿐만 아니라 상자의 수도 충분히 많아야 상수 시간 탐색을 보장할 수 있습니다. 하지만 그럼에도 운이 매우 매우 나쁘다면 다른 색들의 공이 모두 1 번 상자에 들어갈 수 도 있습니다. 이 경우 탐색이 $$O(1)$$ 은 커녕 $$O(N)$$  (여기서 `n` 은 상자의 개수가 아니라 원소의 개수) 으로 실행될 것입니다.

따라서 `unordered_set` 과 `unordered_map` 의 경우 평균적으로 $$O(1)$$ 시간으로 원소의 삽입/탐색을 수행할 수 있지만 최악의 경우 $$O(N)$$ 으로 수행될 수 있습니다. (그냥 `set` 과 `map` 의 경우 평균도 $$O(log N)$$ 최악의 경우에도 $$O(log N)$$ 으로 실행됩니다)

이 때문에 보통의 경우에는 그냥 안전하게 맵이나 셋을 사용하고, 만약에 최적화가 매우 필요한 작업일 경우에만 해시 함수를 잘 설계해서 `unordered_set` 과 `unordered_map` 을 사용하는 것이 좋습니다. \sidenote{기본 타입들(int, double 등등) 과 string 의 경우 라이브러리 자체적으로 해시 함수가 내장되어 있으므로, 그냥 사용하셔도 됩니다}

또한 처음부터 많은 개수의 상자를 사용할 수 없기 때문에 (메모리를 낭비할 순 없으므로..) 상자의 개수는 삽입되는 원소가 많아짐에 따라 점진적으로 늘어나게 됩니다. 문제는 상자의 개수가 늘어나면 해시 함수를 바꿔야 하기 때문에 (더 많은 값들을 해시값으로 반환할 수 있도록) 모든 원소들을 처음부터 끝 까지 다시 `insert` 해야 합니다. 이를 `rehash` 라 하며 $$O(N)$$ 만큼의 시간이 걸립니다.

```cpp-formatted
#include <iostream>
#include <string>
#include <unordered_set>
using namespace std;

template <typename K>
void print_unordered_set(unordered_set<K>& m) {
  // 셋의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << *itr << endl;
  }
}

template <typename K>
void is_exist(unordered_set<K>& s, K key) {
  auto itr = s.find(key);
  if (itr != s.end()) {
    cout << key << " 가 존재!" << endl;
  } else {
    cout << key << " 가 없다" << endl;
  }
}
int main() {
  unordered_set<string> s;

  s.insert("hi");
  s.insert("my");
  s.insert("name");
  s.insert("is");
  s.insert("psi");
  s.insert("welcome");
  s.insert("to");
  s.insert("c++");

  print_unordered_set(s);
  cout << "----------------" << endl;
  is_exist(s, string("c++"));
  is_exist(s, string("c"));

  cout << "----------------" << endl;
  cout << "'hi' 를 삭제" << endl;
  s.erase(s.find("hi"));
  is_exist(s, string("hi"));
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F256E833D5960848D228BE9)



와 같이 나옵니다.

```cpp-formatted
template <typename K>
void is_exist(unordered_set<K>& s, K key) {
  auto itr = s.find(key);
  if (itr != s.end()) {
    cout << key << " 가 존재!" << endl;
  } else {
    cout << key << " 가 없다" << endl;
  }
}
```

일단 위에서 볼 수 있듯이, `unordered_set` 과 `unordered_map` 모두 `find` 함수를 지원하며, 사용법은 그냥 셋과 정확히 동일합니다. `find` 함수의 경우 만일 해당하는 원소가 존재한다면 이를 가리키는 반복자를, 없다면 `end` 를 리턴합니다.

```cpp-formatted
s.erase(s.find("hi"));
is_exist(s, string("hi"));
```

또한 원소를 제거하고 싶다면 간단히 `find` 함수로 원소를 가리키는 반복자를 찾은 뒤에, 이를 전달하면 됩니다.

###  내가 만든 클래스를 `unordered_set/unordered_map` 의 원소로 넣고 싶을 때


그렇다면 여러분이 만든 클래스를 직접 `unordered_set` 혹은 `unordered_map` 에 넣으려면 어떻게 해야 할까요? 안타깝게도 셋이나 맵에 넣는것 보다 훨씬 어렵습니다. 왜냐하면 먼저 내 클래스의 객체를 위한 '해시 함수'를 직접 만들어줘야 하기 때문입니다. (그렇기 때문에 셋과 맵을 사용하는 것을 권장하는 것입니다!)

물론 셋이나 맵 과는 다르게 순서대로 정렬하지 않기 때문에 `operator<` 는 필요하지 않습니다. 하지만 `operator==` 는 필요한데, 왜냐하면 해시 충돌 발생 시에 상자안에 있는 원소들과 비교를 해야하기 때문이지요.

한 가지 다행인 점은 C++ 에서 기본적인 타입들에 대한 해시 함수들을 제공하고 있습니다. 우리는 이들을 잘만 이용하기만 하면 됩니다.

```cpp-formatted
class Todo {
  int priority;  // 중요도. 높을 수록 급한것!
  string job_desc;

 public:
  Todo(int priority, string job_desc)
      : priority(priority), job_desc(job_desc) {}
};
```



그렇다면 위 `Todo` 클래스의 해시 함수를 만들어보겠습니다. 기본적으로 `unordered_set` 과 `unordered_map` 은 해시 함수 계산을 위해 hash 함수 객체를 사용합니다. `hash` 함수 객체는 아래와 같이 생겼습니다.


예를 들어 `string` 함수의 해시값을 계산하고 싶다면

```cpp-formatted
hash<string> hash_fn;
size_t hash_val = hash_fn(str);  // str 의 해시값 계산
```



위와 같이 수행하게 되는 것이지요. `string` 을 템플릿 인자로 받는 `hash_fn` 객체를 만든 뒤에, ( [Functor](http://itguru.tistory.com/219) [이죠](http://itguru.tistory.com/219)`!)` 마치 함수를 사용하는 것처럼 사용하면 됩니다.


따라서 `Todo` 함수의 해시 함수를 계산하는 함수 객체를 만들기 위해 다음과 같이 `hash` 클래스의 `Todo` 특수화 버전을 만들어줘야 합니다.

```cpp-formatted
// hash 클래스의 Todo 템플릿 특수화 버전!
template <>
struct hash<Todo> {
  size_t operator()(const Todo& t) const {
    // 해시 계산
  }
};
```

해시 함수는 객체의 `operator()` 를 오버로드하면 되고 `std::size_t` 타입을 리턴하면 됩니다. 보통 `size_t` 타입은 `int` 랑 동일한데, 이 말은 해시값으로 0 부터 4294967295 까지 가능하다는 뜻입니다. 물론 그렇다고 해서 이 만큼의 상자를 사용하는 것은 아니고, 현재 컨테이너가 사용하고 있는 상자 개수로 나눈 나머지를 상자 번호로 사용하겠지요.

```cpp-formatted
#include <functional>
#include <iostream>
#include <string>
#include <unordered_set>
using namespace std;

template <typename K>
void print_unordered_set(unordered_set<K>& m) {
  // 셋의 모든 원소들을 출력하기
  for (auto itr = m.begin(); itr != m.end(); itr++) {
    cout << *itr << endl;
  }
}

template <typename K>
void is_exist(unordered_set<K>& s, K key) {
  auto itr = s.find(key);
  if (itr != s.end()) {
    cout << key << " 가 존재!" << endl;
  } else {
    cout << key << " 가 없다" << endl;
  }
}
class Todo {
  int priority;  // 중요도. 높을 수록 급한것!
  string job_desc;

 public:
  Todo(int priority, string job_desc)
      : priority(priority), job_desc(job_desc) {}

  bool operator==(const Todo& t) const {
    if (priority == t.priority && job_desc == t.job_desc) return true;
    return false;
  }

  friend ostream& operator<<(ostream& o, const Todo& t);
  friend struct hash<Todo>;
};

// Todo 해시 함수를 위한 함수객체(Functor)
// 를 만들어줍니다!
namespace std {
template <>
struct hash<Todo> {
  size_t operator()(const Todo& t) const {
    hash<string> hash_func;

    return t.priority ^ (hash_func(t.job_desc));
  }
};
}  // namespace std
ostream& operator<<(ostream& o, const Todo& t) {
  o << "[중요도 : " << t.priority << " ] " << t.job_desc;
  return o;
}

int main() {
  unordered_set<Todo> todos;

  todos.insert(Todo(1, "농구 하기"));
  todos.insert(Todo(2, "수학 숙제 하기"));
  todos.insert(Todo(1, "프로그래밍 프로젝트"));
  todos.insert(Todo(3, "친구 만나기"));
  todos.insert(Todo(2, "영화 보기"));
  print_unordered_set(todos);
  cout << "----------------" << endl;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2366874C59609AB8266ABE)



와 같이 나옵니다.


먼저 `Todo` 를 위해 정의한 해시 함수를 살펴보도록 하겠습니다.



```cpp-formatted
// Todo 해시 함수를 위한 함수객체(Functor)
// 를 만들어줍니다!
namespace std {
template <>
struct hash<Todo> {
  size_t operator()(const Todo& t) const {
    hash<string> hash_func;

    return t.priority ^ (hash_func(t.job_desc));
  }
};
}  // namespace std
```

다행이도 `C++ STL` 에서는 기본적인 타입들 (`int, string` 등등) 에 대한 해시 함수를 제공하기 때문에 우리의 `Todo` 클래스의 해시 함수는 이들을 잘 사용해서 짬뽕만 시키면 됩니다. 일단 `priority` 는 `int` 값 이므로 그냥 해시값 자체로 쓰기로 하고, `string` 의 해시값은 `hash_func` 객체로 이용해서 계산하면 됩니다


결과적으로 두 해시값을 짬뽕 시키기 위해서 `XOR` 연산을 이용하였습니다.


참고로 왜 `hash` 클래스가 `namespace std` 안에 정의되어 있냐면 (이미 위에서 `using namespace std` 를 했음에도 불구하고), `std` 의 경우만 예외적으로 `std namespace` 안에 새로운 클래스/함수를 추가하기 위해서는 위처럼 명시적으로 `namespace std` 를 써줘야만 합니다. ( [여기를 참고](https://stackoverflow.com/questions/2282349/specialization-of-templateclass-tp-struct-stdless-in-different-namespace))


그리고 마지막으로 아래와 같이 간단히 `==` 연산자를 추가해주면 됩니다.


```cpp-formatted
bool operator==(const Todo& t) const {
  if (priority == t.priority && job_desc == t.job_desc) return true;
  return false;
}
```



그럼 위 처럼 `Todo` 객체를 마음껏 `unordered_set` 에서 사용할 수 있게 됩니다!



###  그렇다면 뭘 써야되?


아래와 같이 간단히 생각하시면 됩니다.

* 데이터의 존재 유무 만 궁금할 경우 → `set`
* 중복 데이터를 허락할 경우 → `multiset`

(`insert, erase, find` 모두 $$O(\log N)$$. 최악의 경우에도 $$O(\log N)$$)

* 데이터에 대응되는 데이터를 저장하고 싶은 경우 → `map`
* 중복 키를 허락할 경우 → `multimap`

(`insert, erase, find` 모두 $$O(\log N)$$. 최악의 경우에도 O(\log N)$$)

* 속도가 매우매우 중요해서 최적화를 해야하는 경우 → `unordered_set, unordered_map`

(insert, erase, find 모두 $$O(1)$$. 최악의 경우엔 $$O(N)$$ 그러므로 해시함수와 상자 개수를 잘 설정해야 한다!)

그렇다면 이번 강좌는 여기에서 마치도록 하겠습니다. 다음 강좌에서는 `STL` 알고리즘을 이용한 여러가지 작업들에 대해 알아보도록 하겠습니다!

##@ chewing-cpp-endw
Link :  223
2017-07-04 19:34
----------------
title : 씹어먹는 C++ - <10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)>
cat_title: 10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)
next_page : 224
publish_date : 2017-07-04 19:34
--------------


이번 강좌에서는

* C++ 표준 템플릿 라이브러리 개요
* 시퀀스 컨테이너(sequence container)
* 반복자 (iterator)

에 대해 배웁니다.

![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 지난번 템플릿 메타프로그래밍 강좌는 어떠셨나요? `TMP` 를 활용해서 프로그래밍을 하는 것은 엄청 머리아픈 일이지만 적당히 잘 쓰면 꽤 괜찮은 도구입니다.


하지만 이번 강좌는 조금 다룹니다. 이번 강좌에서 배우게 될 C++ 의 표준 템플릿 라이브러리 (STL) 은 사용하는 것도 엄청 간단한데, 여러분이 하는 프로그래밍 능률을 `100%` 향상 시킬 수 있는 엄청난 도구 입니다. 사실 이 STL 의 도입으로 C++ 이 한발 더 도약한 것도 과언이 아니라 볼 수 있습니다.



###  C++ 표준 템플릿 라이브러리 (Standard Template Library - STL)

사실 C++ 표준 라이브러리를 보면 꽤나 많은 종류의 라이브러리들이 있습니다. 예를 들어서, 대표적으로 입출력 라이브러리 (iostream 등등), 시간 관련 라이브러리 (chrono), 정규표현식 라이브러리 (regex) 등등 들이 있지요. 하지만 보통 C++ 템플릿 라이브러리(STL)를 일컫는다면 다음과 같은 세 개의 라이브러리들을 의미합니다.

* 임의 타입의 객체를 보관할 수 있는 컨테이너 (container)
* 컨테이너에 보관된 원소에 접근할 수 있는 반복자 (iterator)
* 반복자들을 가지고 일련의 작업을 수행하는 알고리즘 (algorithm)


각 라이브러리의 역할을 쉽게 생각하면 다음과 같이 볼 수 있습니다. 여러분이 우편 배달부가 되어서 편지들을 여러개의 편지함에 넣는다고 생각해봅시다. 편지를 보관하는 각각의 편지함들은 '컨테이너' 라고 생각하시면 됩니다. 그리고, 편지를 보고 원하는 편지함을 찾는 일은 '반복자' 들이 수행하지요. 마지막으로, 만일 편지들을 편지함에 날짜 순서로 정렬하여 넣는 일은 '알고리즘' 이 수행할 것입니다.


한 가지 주목할 만한 점은


* 임의 타입의 객체를 보관할 수 있는 컨테이너 (container)

에서 나타나 있듯이 우리가 다루려는 객체가 어떤 특성을 갖는지 무관하게 라이브러리를 자유롭게 사용할 수 있다는 것입니다 (바로 템플릿 덕분이죠!). 우리가 만일 사용하려는 자료형이 `int` 나 `string` 과 같은 평범한 애들이 아니라, 우리가 만든 임의이 클래스의 객체들이여도 자유롭게 위 라이브러리의 기능들을 모두 활용할 수 있습니다. 만일 C 였다면 불가능했을 일입니다.

또한 반복자의 도입으로 알고리즘 라이브러리에 필요한 최소한의 코드만을 작성할 수 있게 되었습니다. 다시 말하면, 기존의 경우 `M` 개 종류의 컨테이가 있고 `N` 종류의 알고리즘이 있다면 이 모든 것을 지원하려면 `MN` 개의 알고리즘 코드가 있어야만 했습니다.

하지만 반복자를 이용해서 컨테이너를 추상화 시켜서 접근할 수 있기 때문에 `N` 개의 알고리즘 코드 만으로 `M` 종류의 컨테이너들을 모두 지원할 수 있게됩니다. (후에 알고리즘 라이브러리에 대해서 설명할 때 더 와닿을 것입니다)

###  C++ `STL` 컨테이너 - 벡터 (vector)


`C++ STL` 에서 컨테이너는 크게 두 가지 종류가 있습니다. 먼저 배열 처럼 객체들을 순차적으로 보관하는 **시퀀스 컨테이너 (sequence container)** 와 키를 바탕으로 대응되는 값을 찾아주는 **연관 컨테이너 (associative container)** 가 있습니다.

먼저 시퀀스 컨테이너의 경우 `vector`, `list`, `deque` 이렇게 3 개가 정의되어 있습니다. 먼저 벡터(`vector`) 의 경우, 쉽게 생각하면 가변길이 배열이라 보시면 됩니다 (템플릿 강의에서 `Vector` 를 제작하신 것을 기억 하시나요?) 벡터에는 원소들이 메모리 상에서 실제로 순차적으로 저장되어 있고, 따라서 임의의 위치에 있는 원소를 접근하는 것을 매우 빠르게 수행할 수 있습니다.

### 정확히 얼마나 빠르다고?


사실 '매우 빠르다' 라는 말은 주관적일 수 밖에 없습니다. 따라서 어떠한 작업의 수행 속도를 나타내기 위해선 수학적으로 나타내야 합니다.

컴퓨터 공학에선 어떠한 작업의 처리 속도를 **복잡도(complexity)** 라고 부르고, 그 복잡도를 Big $$O$$ 표기법이라는 것으로 나타냅니다. 이 표기법은, $$N$$ 개의 데이터가 주어져 있을 때 그 작업을 수행하기 위해 몇 번의 작업을 필요로 하는지 $$N$$ 에 대한 식으로 표현하는 방식입니다. (즉 복잡도가 클 수록 작업이 수행되는데 걸리는 시간이 늘어나겠지요)

예를 들어 가장 기초적인 버블 정렬을 생각해봅시다. 버블 정렬의 코드는 간단히 보자면 아래와 같습니다.

```cpp-formatted
for (int i = 0; i < N; i++) {
  for (int j = i + 1; j < N; j++) {
    if (arr[i] > arr[j]) {
      swap(arr, i, j)
    }
  }
}
```

따라서 $$N$$ 개의 원소가 있는 `arr` 이라는 배열을 정렬하기 위해서는 일단 적어도

$$ \frac{N(N-1)}{2} $$

번의 반복이 필요하지요 ($$(N -1 + N- 2 + ... + 1)$$) 따라서 `Big O` 표현법으로 이 정렬이 얼마나 빠르게 수행될 수 있는지 나타내면

$$ O(\frac{N(N-1)}{2})$$

라고 볼 수 있습니다. 보통 **Big O** 표현법으로 나타낼 때, 최고차항만을 나타냅니다 (그리고 통상적으로 최고차항의 계수도 생략합니다). 왜냐하면 $$N$$ 이 엄청 커지게 되면 최고 차항 말고는 그닥 의미가 없게 되버리기 때문이지요 (최고 차항에 비해 크기가 너무 작기 때문에). 따라서 최종적으로, 버블 정렬 알고리즘의 복잡도는

$$O(N^2)$$

라고 볼 수 있습니다. 일반적으로 어떠한 알고리즘이 $$O(N^2)$$ 꼴이면 그닥 좋은 편은 아닙니다. 왜냐하면 $$N$$ 이 10000 만 되더라도, 10의 8 번의 작업을 처리해야 하기 때문이죠. 다행이도 정렬 알고리즘의 경우 퀵소트(Quicksort) 라는 알고리즘을 활용하면 아래와 같은 복잡도로 연산을 처리할 수 있습니다.

$$O(N\log N) $$

물론 퀵소트 알고리즘을 사용했을 때 항상 버블 정렬 방식 보다 빠르게 정렬할 수 있다는 의미는 아닙니다. 왜냐하면 저 항 앞에 어떠한 계수가 붙어있는지 알 수 없기 때문이지요. 만약에 버블 정렬이 $$O(N^2)$$ 이고 퀵소트가 $$O(100000 N \log N)$$ 이였다면 $$N$$ 이 1000 일 때 버블 정렬이 더 빠르게 수행됩니다.  (물론 이렇게 극단적이지 않습니다. 퀵소트가 거의 대부분 더 빠르게 됩니다!)


하지만, $$N$$ 이 정말 커진다면 언젠가는 퀵소트가 버블 정렬보다 더 빨리 수행되는 때가 발생합니다.


아래 그림을 보면 각각의 $$O$$ 에 대해 복잡도가 어떻게 증가하는지 볼 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F271D6B335959FB53166AF4)



가장 이상적인 복잡도는 $$O(1)$$ 이지만 이는 거의 불가능하고 (이는 마치 전체 데이터를 채 보지 않은 채 작업을 끝낼 수 있다는 의미 입니다), 보통 $$O(\log n)$$ 이 알고리즘이 낼 수 있는 가장 빠른 속도를 의미합니다. 그 다음으로 좋은 것이 당연히 $$O(n)$$ 이고, $$O(n \log n)$$ 순 입니다.


그렇다면 다시 벡터 자료형으로 돌아오겠습니다. `vector` 의 경우, 임의의 위치에 있는 원소에 접근을 $$O(1)$$ 로 수행할 수 있습니다. 게다가 맨 뒤에 새로운 원소를 추가하거나 제거하는 것 역시 $$O(1)$$ 에 수행합니다. `vector` 의 임의의 원소에 접근하는 것은 배열처럼 `[]` 를 이용하거나, `at` 함수를 이용하면 됩니다. 또한 맨 뒤에 원소를 추가하거나 제거하기 위해서는 `push_back` 혹은 `pop_back` 함수를 사용하면 됩니다. 아래 예를 보겠습니다.

```cpp-formatted
#include <iostream>
#include <vector>
using namespace std;

int main() {
  vector<int> vec;
  vec.push_back(10);  // 맨 뒤에 10 추가
  vec.push_back(20);  // 맨 뒤에 20 추가
  vec.push_back(30);  // 맨 뒤에 30 추가
  vec.push_back(40);  // 맨 뒤에 40 추가

  for (vector<int>::size_type i = 0; i < vec.size(); i++) {
    cout << "vec 의 " << i + 1 << " 번째 원소 :: " << vec[i] << endl;
  }
}
```



성공적으로 컴파일 하였으면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F246C303C595A08BC167DA0)



와 같이 우리가 넣은 순서대로 잘 나옴을 알 수 있습니다.



참고로 벡터의 크기를 리턴하는 함수인 `size` 의 경우, 그리턴하는 값의 타입은 `size_type` 멤버 타입으로 정의되어 있습니다.


참고로 맨 뒤에 원소를 추가하는 작업은 엄밀히 말하자면 **amortized** $$O(1)$$ 이라고 합니다. (amortized 의 뜻은 분할상환이란 뜻인데, 아마 아래 설명을 읽으시면 왜 그런 이름을 붙였는지 이해하실 수 있을 것입니다)


왜냐면 보통은 `vector` 의 경우 현재 가지고 있는 원소의 개수 보다 더 많은 공간을 할당해 놓고 있습니다. 예를 들어 현재 `vector` 에 있는 원소의 개수가 10 개라면 이미 20개를 저장할 수 있는 공간을 미리 할당해놓게됩니다. 따라서 만약에 뒤에 새로운 원소를 추가하게 된다면 새롭게 메모리를 할당할 필요가 없이, 그냥 이미 할당된 공간에 그 원소를 쓰기만 하면 됩니다. 따라서 대부분의 경우 $$O(1)$$ 으로 `vector` 맨 뒤에 새로운 원소를 추가하거나 지울 수 있습니다.


문제가 되는 상황은 할당된 공간을 다 채웠을 때 입니다. 이 때는 어쩔 수 없이, 새로운 큰 공간을 다시 할당하고, 기존의 원소들을 복사하는 수 밖에 없습니다. 따라서 이 경우 $$n$$ 개의 원소를 모두 복사해야 하기 때문에 $$O(n)$$ 으로 수행됩니다. 하지만 이 $$O(n)$$ 으로 수행되는 경우가 매우 드물기 때문에, 전체적으로 평균을 내보았을 때 $$O(1)$$ 으로 수행됨을 알 수 있습니다. 이렇기에 amortized $$O(1)$$ 이라고 부르게 됩니다. 아래 그림에서 자세히 설명하고 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2124A44B595A137D239739)

물론 `vector` 라고 만능은 아닙니다. 맨 뒤에 원소를 추가하거나 제거하는 것은 빠르지만,임의의 위치에 원소를 추가하거나 제거하는 것은 $$O(n)$$ 으로 느립니다. 왜냐하면 어떤 자리에 새로운 원소를 추가하거나 뺄 경우 그 뒤에 오는 원소들을 한 칸 씩 이동시켜 주어야만 하기 때문이지요. 따라서 이는 $$n$$ 번의 복사가 필요로 합니다.


따라서 만일 맨 뒤가 아닌 위치에 데이터를 추가하거나 제거하는 작업이 많은 일일 경우 `vector` 를 사용하면 안되겠지요. 결과적으로 `vector` 의 복잡도를 정리해보자면 아래와 같습니다.

* 임의의 위치 원소 접근 (`[], at`) : $$O(1)$$
* 맨 뒤에 원소 추가 및 제거 (`push_back`/`pop_back`) : amortized $$O(1)$$; (평균적으로 $$O(1)$$ 이지만 최악의 경우 $$O(n)$$ )
* 임의의 위치 원소 추가 및 제거 (`insert, erase`) : $$O(n)$$

위 처럼 어떠한 작업을 하냐에 따라서 속도차가 매우 크기 때문에, C++ 표준 라이브러리를 잘 사용하기 위해서는 내가 이 컨테이너를 어떠한 작업을 위해 사용하는지 정확히 인지하고, 적절한 컨테이너를 골라야 합니다. 후에 설명할 다른 자료 구조를 사용하면 `vector` 가 빠른 작업이 느릴 수 도 있고, `vector` 가 느린 작업을 빠르게 할 수 도 있습니다.



###  반복자 (iterator)



앞서 반복자는 컨테이너에 원소에 접근할 수 있는 포인터와 같은 객체라고 하였습니다. 물론 벡터의 경우 `[ ]` 를 이용해서 정수형 변수로 마치 배열 처럼 임의의 위치에 접근할 수 있지만, 반복자를 사용해서도 마찬가지 작업을 수행할 수 있습니다. 특히 후에 배울 알고리즘 라이브러리의 경우 대부분이 반복자를 인자로 받아서 알고리즘을 수행합니다.

반복자는 컨테이너에 `iterator` 멤버 타입으로 정의되어 있습니다. vector 의 경우 반복자를 얻기 위해서는 `begin()` 함수와 `end()` 함수를 사용할 수 있는데 이는 다음과 같은 위치를 리턴합니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F2165E44C595A970A1676B5)

`begin()` 함수는 예상했던 대로, `vector` 의 첫번째 원소를 가리키는 반복자를 리턴합니다. 그런데, 흥미롭게도 `end()` 의 경우 `vector` 의 마지막 원소 한 칸 뒤를 가리키는 반복자를 리턴하게 됩니다. 왜 `end` 의 경우 `vector` 의 마지막 원소를 가리것이 아니라, 마지막 원소의 뒤를 가리키는 반복자를 리턴할까요?

이에 여러가지 이유가 있겠지만, 가장 중요한 점이 이를 통해 빈 벡터를 표현할 수 있다는 점입니다. 만일 `begin() == end()` 라면 원소가 없는 벡터를 의미하겠지요. 만약에 `vec.end()` 가 마지막 원소를 가리킨다면 비어있는 벡터를 표현할 수 없게 됩니다.

```cpp-formatted
// 반복자 사용 예시
#include <iostream>
#include <vector>
using namespace std;

int main() {
  vector<int> vec;
  vec.push_back(10);
  vec.push_back(20);
  vec.push_back(30);
  vec.push_back(40);

  // 전체 벡터를 출력하기
  for (vector<int>::iterator itr = vec.begin(); itr != vec.end(); itr++) {
    cout << *itr << endl;
  }

  // int arr[4] = {10, 20, 30, 40}
  // *(arr + 2) == arr[2] == 30;
  // *(itr + 2) == vec[2] == 30;

  vector<int>::iterator itr = vec.begin() + 2;
  cout << "3 번째 원소 :: " << *itr << endl;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F26198938595A9B06322904)




와 같이 잘 수행됨을 알 수 있습니다.

```cpp-formatted
// 전체 벡터를 출력하기
for (vector<int>::iterator itr = vec.begin(); itr != vec.end(); itr++) {
  cout << *itr << endl;
}
```

`vector` 의 반복자의 타입은 위 처럼 `vector<>::iterator` 멤버 타입으로 정의되어 있고, `vec.begin()` 이나 `vec.end()` 함수가 이를 리턴합니다. `end()` 가 `vector` 의 마지막 원소 바로 뒤를 가리키기 때문에 `for` 문에서 `vector` 전체 원소를 보고 싶다면 `vec.end()` 가 아닐 때 까지 반복하면 됩니다.


앞서 반복자를 마치 포인터 처럼 사용한다고 하였는데, 실제로 현재 반복자가 가리키는 원소의 값을 보고 싶다면;

```cpp-formatted
cout << *itr << endl;
```

포인터로 `*` 를 해서 가리키는 주소값의 값을 보았던 것처럼, `*` 연산자를 이용해서 `itr` 이 가리키는 원소를 볼 수 있습니다. 물론 `itr` 은 실제 포인터가 아니고 `*` 연산자를 오버로딩해서 마치 포인터 처럼 동작하게 만든 것입니다. `*` 연산자는 `itr` 이 가리키는 원소의 레퍼런스를 리턴합니다.

```cpp-formatted
vector<int>::iterator itr = vec.begin() + 2;
cout << "3 번째 원소 :: " << *itr << endl;
```

또한 반복자 역시 `+` 연산자를 통해서 그 만큼 떨어져 있는 원소를 가리키게 할 수 도 있습니다. (그냥 배열을 가리키는 포인터와 정확히 똑같이 동작한다고 생각하시면 됩니다!)


반복자를 이용하면 아래와 같이 `insert` 와 `erase` 함수도 사용할 수 있습니다.

```cpp-formatted
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
void print_vector(vector<T>& vec) {
  // 전체 벡터를 출력하기
  for (typename vector<T>::iterator itr = vec.begin(); itr != vec.end();
       itr++) {
    cout << *itr << endl;
  }
}
int main() {
  vector<int> vec;
  vec.push_back(10);
  vec.push_back(20);
  vec.push_back(30);
  vec.push_back(40);

  cout << "처음 벡터 상태" << endl;
  print_vector(vec);
  cout << "----------------------------" << endl;

  // vec[2] 앞에 15 추가
  vec.insert(vec.begin() + 2, 15);
  print_vector(vec);

  cout << "----------------------------" << endl;
  // vec[3] 제거
  vec.erase(vec.begin() + 3);
  print_vector(vec);
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F277A2D4D595B000F1BBEBF)





와 같이 잘 나옵니다.


참고로 템플릿 버전의 경우,

```cpp-formatted
for (typename vector<T>::iterator itr = vec.begin(); itr != vec.end(); itr++) {
```

와 같이 앞에 `typename` 을 추가해줘야만 합니다. 그 이유는, `iterator` 가 `vector<T>` 의 의존 타입이기 때문입니다. [의존 타입이 무엇인지 기억 안나시는 분은 이 강좌를 참조하시기 바랍니다](http://itguru.tistory.com/222?category=361027)`. .

```cpp-formatted
// vec[2] 앞에 15 추가
vec.insert(vec.begin() + 2, 15);
```

앞서 `insert` 함수를 소개하였는데, 위 처럼 인자로 반복자를 받고, 그 반복자 앞에 원소를 추가해줍니다. 위 경우 `vec.begin() + 2` 앞에 15 를 추가하므로 `10, 20, 30, 40` 에서 `10, 20, 15, 30, 40` 이 됩니다.

```cpp-formatted
vec.erase(vec.begin() + 3);
print_vector(vec);
```

또 아까전에 언급하였던 `erase` 도 인자로 반복자를 받고, 그 반복자가 가리키는 원소를 제거합니다. 위 경우 4번째 원소인 30이 지워지겠지요. 물론 `insert` 과 `erase` 함수 모두 `O(n)` 으로 느린편입니다.

참고로 `vector` 에서 반복자로 `erase` 나 `insert` 함수를 사용할 때 주의해야할 점이 있습니다.

```cpp
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
void print_vector(vector<T>& vec) {
  // 전체 벡터를 출력하기
  cout << "[ ";
  for (typename vector<T>::iterator itr = vec.begin(); itr != vec.end(); itr++) {
    cout << *itr << " ";
  }
  cout << "]";
}
int main() {
  vector<int> vec;
  vec.push_back(10);
  vec.push_back(20);
  vec.push_back(30);
  vec.push_back(40);
  vec.push_back(20);

  cout << "처음 벡터 상태" << endl;
  print_vector(vec);

  vector<int>::iterator itr = vec.begin();
  vector<int>::iterator end_itr = vec.end();

  for (; itr != end_itr; itr++) {
    if (*itr == 20) {
      vec.erase(itr);
    }
  }

  cout << "값이 20 인 원소를 지운다!" << endl;
  print_vector(vec);
}
```



컴파일 후 실행하였다면 아래와 같은 오류가 발생합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2554D949595B4BB61B3489)





왜 이런 오류가 발생하는 것일까요?



```warning
for (; itr != end_itr; itr ++) {
if (*itr == 20) {
vec.erase(itr);
}
}
```

문제는 바로 위 코드에서 발생합니다.컨테이너에 원소를 추가하거나 제거하게 되면 기존에 사용하였던 모든 반복자들을 사용할 수 없게됩니다. 다시 말해 위 경우 `vec.erase(itr)` 을 수행하게 되면 더이상 `itr` 은 유효한 반복자가 아니게 되는 것이지요. 또한 `end_itr` 역시 무효화 됩니다.


따라서 `itr != end_itr` 이 영원히 성립되며 무한 루프에 빠지게되어 위와 같은 오류가 발생합니다.


그렇다면

```warning
vector<int>::iterator itr = vec.begin();
for (; itr != vec.end(); itr ++) {
  if (*itr == 20) {
    vec.erase(itr);
  }
}
```

와 같이 코드를 고치면 오류가 없어질까요? 실행해보시면 알겠지만 여전히 위와 같은 오류가 발생합니다. 왜냐하면 `itr` 이 유효한 반복자가 아니기 때문에 `vec.end()` 로 올바른 `end` 반복자 값을 매번 가지고 와도 `for` 문이 끝나지 않게 되는 것입니다. 결과적으로 코드를 제대로 고치려면 다음과 같이 해야 합니다.

```cpp-formatted
vector<int>::iterator itr = vec.begin();

for (; itr != vec.end(); itr++) {
  if (*itr == 20) {
    vec.erase(itr);
    itr = vec.begin();
  }
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F277A6C33595B4E5831E24D)



와 같이 제대로 값이 20 인 원소만 지워졌음을 알 수 있습니다.


사실 생각해보면 위 바뀐 코드는 꽤나 비효율적임을 알 수 있습니다. 왜냐하면 20 인 원소를 지우고, 다시 처음으로 돌아가서 원소들을 찾고 있기 때문이지요. 그냥 20 인 원소 바로 다음 위치 부터 찾아나가면 될 텐데 말입니다.

```cpp-formatted
for (vector<int>::size_type i = 0; i != vec.size(); i++) {
  if (vec[i] == 20) {
    vec.erase(vec.begin() + i);
    i--;
  }
}
```



그렇다면 아예 위 처럼 굳이 반복자를 쓰지 않고 `erase` 함수에만 반복자를 바로 만들어서 전달하면 됩니다.

```cpp-formatted
vec.erase(vec.begin() + i);
```



를 하게 되면 `vec[i]` 를 가리키는 반복자를 `erase` 에 전달할 수 있습니다. 하지만 사실 위 방법은 그리 권장하는 방법은 아닙니다. 기껏 원소에 접근하는 방식은 반복자를 사용하는 것으로 통일하였는데, 위 방법은 이를 모두 깨버리고 그냥 기존의 배열 처럼 정수형 변수 `i` 로 원소에 접근하는 것이기 때문입니다.


하지만 후에 C++ 알고리즘 라이브러리에 대해 배우면서 이 문제를 깔끔하게 해결 하는 방법에 대해 다루도록 할 것입니다. 일단 임시로는 위 방법 처럼 처리하도록 하세요 :)


`vector` 에서 지원하는 반복자로 `const_iterator` 가 있습니다. 이는 마치 `const` 포인터를 생각하시면 됩니다. 즉, `const_iterator` 의 경우 가리키고 있는 원소의 값을 바꿀 수 없습니다. 예를 들어서

```cpp
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
void print_vector(vector<T>& vec) {
  // 전체 벡터를 출력하기
  for (typename vector<T>::iterator itr = vec.begin(); itr != vec.end(); itr++) {
    cout << *itr << endl;
  }
}
int main() {
  vector<int> vec;
  vec.push_back(10);
  vec.push_back(20);
  vec.push_back(30);
  vec.push_back(40);

  cout << "초기 vec 상태" << endl;
  print_vector(vec);

  // itr 은 vec[2] 를 가리킨다.
  vector<int>::iterator itr = vec.begin() + 2;

  // vec[2] 의 값을 50으로 바꾼다.
  *itr = 50;

  cout << "---------------" << endl;
  print_vector(vec);

  vector<int>::const_iterator citr = vec.cbegin() + 2;

  // 상수 반복자가 가리키는 값은 바꿀수 없다. 불가능!
  *citr = 30;
}
```

컴파일 하였다면

```warning
'citr': you cannot assign to a variable that is const
```



와 같이, `const` 반복자가 가리키고 있는 값은 바꿀 수 없다고 오류가 발생합니다. 주의할 점은, `const` 반복자의 경우

```cpp-formatted
vector<int>::const_iterator citr = vec.cbegin() + 2;
```

와 같이 `cbegin()` 과 `cend()` 함수를 이용하여 얻을 수 있습니다. 많은 경우 반복자의 값을 바꾸지 않고 참조만 하는 경우가 많으므로, `const iterator` 를 적절히 이용하는 것이 좋습니다.


`vector` 에서 지원하는 반복자 중 마지막 종류로 역반복자 (reverse iterator) 가 있습니다. 이는 반복자와 똑같지만 벡터 뒤에서 부터 앞으로 거꾸로 간다는 특징이 있습니다. 아래 예제를 살펴볼까요.


```cpp

#include <iostream>
#include <vector>
using namespace std;

template <typename T>
void print_vector(vector<T>& vec) {
  // 전체 벡터를 출력하기
  for (typename vector<T>::iterator itr = vec.begin(); itr != vec.end(); itr++) {
    cout << *itr << endl;
  }
}
int main() {
  vector<int> vec;
  vec.push_back(10);
  vec.push_back(20);
  vec.push_back(30);
  vec.push_back(40);

  cout << "초기 vec 상태" << endl;
  print_vector(vec);

  cout << "역으로 vec 출력하기!" << endl;
  // itr 은 vec[2] 를 가리킨다.
  vector<int>::reverse_iterator r_iter = vec.rbegin();
  for (; r_iter != vec.rend(); r_iter++) {
    cout << *r_iter << endl;
  }
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F216F123F595B2E522A9968)



와 같이 역으로 벡터의 원소들을 출력할 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F275B1D3D595B2F4011531A)

이전에 반복자의 `end()` 가 맨 마지막 원소의 바로 뒤를 가리켰던 것처럼, 역반복자의 `rend()` 역시 맨 앞 원소의 바로 앞을 가리키게 됩니다. 또한 반복자의 경우 값이 증가하면 뒤쪽 원소로 가는 것처럼, 역반복자의 경우 값이 증가하면 앞쪽 원소로 가게 됩니다.


또 반복자가 상수 반복자가 있는 것 처럼 역반복자 역시 상수 역반복자가 있습니다. 그 타입은 `const_reverse_iterator` 타입이고, `crbegin(), crend()` 로 얻을 수 있습니다.

앞서 설명한 함수들 말고도 `vector` 에는 수 많은 함수들이 있고, 또 오버로드 되는 여러가지 버전들이 있습니다. 예를 들어 `insert` 함수만 해도 5 개의 오버로드 되는 버전들이 있습니다 (물론 하는 역할은 똑같지만 편의를 위해 여러가지 방식으로 사용할 수 있게 만들어 놓은것입니다). 이 모든 것들을 강좌에서 소개하는 것은 시간 낭비이고, [C++ 레퍼런스를 보면 잘 정리](http://en.cppreference.com/w/cpp/container/vector)되어 있으니 이를 참조하시기 바랍니다.



###  리스트 `- list`




리스트(`list`) 의 경우 양방향 연결 구조를 가진 자료형이라 볼 수 있습니다.
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F246A0A4B595B396939AF3D)

따라서 `vector` 와는 달리 임의의 위치에 있는 원소에 접근을 바로 할 수 없습니다. `list` 컨테이너 자체에서는 시작 원소와 마지막 원소의 위치만을 기억하기 때문에, 임의의 위치에 있는 원소에 접근하기 위해서는 하나씩 링크를 따라가야 합니다.

그래서 리스트에는 아예 `[]` 나 `at` 함수가 아예 정의되어 있지 않습니다.

물론 리스트의 장점이 없는 것은 아닙니다. `vector` 의 경우 맨 뒤를 제외하고는 임의의 위치에 원소를 추가하거나 제거하는 작업이 `O(n)` 이였지만 리스트의 경우 `O(1)` 으로 매우 빠르게 수행될 수 있습니다. 왜냐하면 원하는 위치 앞과 뒤에 있는 링크값만 바꿔주면 되기 때문입니다.

```cpp-formatted
#include <iostream>
#include <list>
using namespace std;

int main() {
  list<int> lst;

  lst.push_back(10);
  lst.push_back(20);
  lst.push_back(30);
  lst.push_back(40);

  for (list<int>::iterator itr = lst.begin(); itr != lst.end(); itr++) {
    cout << *itr << endl;
  }
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F26612B43595B40EF10724A)



와 같이 잘 나옵니다.


한 가지 재미있는점은 리스트의 반복자의 경우 다음과 같은 연산밖에 수행할 수 없습니다.

```cpp-formatted
itr++    // ++itr
  itr--  // --itr 도 됩니다.
```



다시말해

```warning

itr + 5 // 불가능!
```



와 같이임의의 위치에 있는 원소를 가리킬 수 없다는 것입니다. 반복자는 오직 한 칸 씩 밖에 움직일 수 없습니다. 이와 같은 이유는 `list` 의 구조를 생각해보면 알 수 있습니다. 앞서 말했듯이 리스트는 왼쪽 혹은 오른쪽을 가리키고 있는 원소들의 모임으로 이루어져 있기 때문에, 한 번에 한 칸 씩 밖에 이동할 수 없습니다. 즉, 메모리 상에서 원소들이 연속적으로 존재하지 않을 수 있다는 뜻입니다. 반면에 벡터의 경우 메모리 상에서 연속적으로 존재하기 때문에 쉽게 임의의 위치에 있는 원소를 참조할 수 있습니다.


이렇게 리스트 에서 정의되는 반복자의 타입을 보면 `BidirectionalIterator` 타입임을 알 수 있습니다. 이름에서도 알 수 있듯이 양방향으로 이동할 수 있되, 한 칸 씩 밖에 이동할 수 없습니다. 반면에 벡터에서 정의되는 반복자의 타입은 `RandomAccessIterator` 타입 입니다.

즉, 임의의 위치에 접근할 수 있는 반복자 입니다 (참고로 `RandomAccessIterator` 는 `BidirectionalIterator` 를 상속받고 있습니다)

```cpp-formatted
#include <iostream>
#include <list>
using namespace std;

template <typename T>
void print_list(list<T>& lst) {
  cout << "[";
  // 전체 리스트를 출력하기
  for (list<T>::iterator itr = lst.begin(); itr != lst.end(); itr++) {
    cout << *itr << " ";
  }
  cout << "]" << endl;
}
int main() {
  list<int> lst;

  lst.push_back(10);
  lst.push_back(20);
  lst.push_back(30);
  lst.push_back(40);

  cout << "처음 리스트의 상태 " << endl;
  print_list(lst);

  for (list<int>::iterator itr = lst.begin(); itr != lst.end(); itr++) {
    // 만일 현재 원소가 20 이라면
    // 그 앞에 50 을 집어넣는다.
    if (*itr == 20) {
      lst.insert(itr, 50);
    }
  }

  cout << "값이 20 인 원소 앞에 50을 추가 " << endl;
  print_list(lst);

  for (list<int>::iterator itr = lst.begin(); itr != lst.end(); itr++) {
    // 값이 30 인 원소를 삭제한다.
    if (*itr == 30) {
      lst.erase(itr);
      break;
    }
  }

  cout << "값이 30 인 원소를 제거한다" << endl;
  print_list(lst);
}
```



성공적으로 컴파일 하면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F27012E3A595B49D938EB89)



와 같이 잘 나옵니다.

```cpp-formatted
for (list<int>::iterator itr = lst.begin(); itr != lst.end(); itr++) {
  // 만일 현재 원소가 20 이라면
  // 그 앞에 50 을 집어넣는다.
  if (*itr == 20) {
    lst.insert(itr, 50);
  }
}
```



앞서 설명하였지만 리스트의 반복자는 `BidirectionalIterator` 이기 때문에 `++` 과 `--` 연산만 사용 가능합니다. 따라서 위 처럼 `for` 문으로 하나 하나 원소를 확인해보는것은 가능하지요. `vector` 와는 다르게 `insert` 작업은 `O(1)` 으로 매우 빠르게 실행됩니다.

```cpp-formatted
for (list<int>::iterator itr = lst.begin(); itr != lst.end(); itr++) {
  // 값이 30 인 원소를 삭제한다.
  if (*itr == 30) {
    lst.erase(itr);
    break;
  }
}
```

마찬가지로 `erase` 함수를 이용하여 원하는 위치에 있는 원소를 지울 수 도 있습니다. 물론 리스트의 경우도 벡터와 마찬가지로 한 번 원소를 지우거나 추가하면 기존의 모든 반복자들이 무효화 됨을 생각해야 합니다.



###  덱 (deque - double ended queue)




마지막으로 살펴볼 컨테이너는 덱(`deque`) 이라고 불리는 자료형 입니다. 덱은 벡터와 비슷하게 $$O(1)$$ 으로 임의의 위치의 원소에 접근할 수 있으며 맨 뒤에 원소를 추가/제거 하는 작업도 $$O(1)$$ 으로 수행할 수 있습니다. 뿐만아니라 벡터와는 다르게 맨 앞에 원소를 추가/제거 하는 작업 까지도 $$O(1)$$ 으로 수행 가능합니다.

임의의 위치에 있는 원소를 제거/추가 하는 작업은 벡터와 마찬가지로 $$O(n)$$ 으로 수행 가능합니다. 뿐만 아니라 그 속도도 벡터 보다 더 빠릅니다 (이 부분은 아래 덱이 어떻게 구현되어 있는지 설명하면서 살펴보겠습니다.)

그렇다면 덱이 벡터에 비해 모든 면에서 비교 우위에 있는 걸까요? 안타깝게도 벡터와는 다르게 덱의 경우 원소들이 실제로 메모리 상에서 연속적으로 존재하지는 않습니다. 이 때문에 원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리가 더 필요로 합니다. (실제 예로, 64 비트 `libc++` 라이브러리의 경우 1 개의 원소를 보관하는 덱은 그 원소 크기에 비해 8 배나 더 많은 메모리를 필요로 합니다).

즉 덱은 실행 속도를 위해 메모리를 (많이) 희생하는 컨테이너라 보면 됩니다.![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F245FC94C595B5F9B133E4E)

위 그림은 덱이 어떠한 구조를 가지는지 보여줍니다. 일단, 벡터와는 다르게 원소들이 메모리에 연속되어 존재하는 것이 아니라 일정 크기로 잘려서 각각의 블록 속에 존재합니다. 따라서 이 블록들이 메모리 상에 어느 곳에 위치하여 있는지 저장하기 위해서 각각의 블록들의 주소를 저장하는 벡터가 필요로 합니다.

참고로 이 벡터는 기존의 벡터와는 조금 다르게, 새로 할당 시에 앞쪽 및 뒤쪽 모두에 공간을 남겨놓게 됩니다. (벡터의 경우 뒤쪽에만 공간이 남았지요) 따라서 이를 통해 맨 앞과 맨 뒤에 `O(1)` 의 속도로 `insert` 및 `erase` 를 수행할 수 있는 것입니다. 그렇다면 왜 덱이 벡터 보다 원소를 삽입하는 작업이 더 빠른 것일까요?

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F236D8137595B617B02463F)

위와 같은 상황에서 `deq.push_back(10)` 을 수행하였다고 생각해봅시다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F244E834B595B642028B977)

그렇다면 단순히 새로운 블록을 만들어서 뒤에 추가되는 원소를 넣어주면 됩니다. 즉 기존의 원소들을 복사할 필요가 전혀 없다는 의미 입니다. 반면에 벡터의 경우

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F23015636595B647418F5CE)

위 그림에서도 잘 알 수 있듯이, 만약에 기존에 할당한 메모리가 꽉 차면 모든 원소들을 새로운 공간에 복사해야 합니다. 따라서 평균적으로 덱이 벡터보다 더 빠르게 작동합니다. (물론 덱의 경우 블록 주소를 보관하는 벡터가 꽉 차게 되면 새로운 공간에 모두 복사해야 합니다.

하지만 블록 주소의 개수는 전체 원소 개수 보다 적고 ( 위 경우 N / 5 가 되겠네요. 왜냐하면 각 블록에 원소가 5개 씩 있으므로), 대체로 벡터에 저장되는객체들의 크기가 주소값의 크기보다 크기 때문에 복사 속도가 훨씬 빠릅니다.)

```cpp-formatted
#include <deque>
#include <iostream>
using namespace std;

template <typename T>
void print_deque(deque<T>& dq) {
  // 전체 덱을 출력하기
  cout << "[ ";
  for (deque<T>::iterator itr = dq.begin(); itr != dq.end(); itr++) {
    cout << *itr << " ";
  }
  cout << " ] " << endl;
}
int main() {
  deque<int> dq;
  dq.push_back(10);
  dq.push_back(20);
  dq.push_front(30);
  dq.push_front(40);

  cout << "초기 dq 상태" << endl;
  print_deque(dq);

  cout << "맨 앞의 원소 제거" << endl;
  dq.pop_front();
  print_deque(dq);
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F22224A3B595B66C807172A)



와 같이 잘 수행됩니다.


```cpp-formatted
dq.push_back(10);
dq.push_back(20);
dq.push_front(30);
dq.push_front(40);
```



위와 같이 `push_back` 과 `push_front` 를 이용해서 맨 앞과 뒤에 원소들을 추가하였고,

```cpp-formatted
dq.pop_front();
```



`pop_front` 함수를 이용해서 맨 앞의 원소를 제거할 수 있습니다.


앞서 말했듯이 덱 역시 벡터 처럼 임의의 위치에 원소에 접근할 수 있으므로 `[]` 와 `at` 함수를 제공하고 있고, 반복자 역시 `RandomAccessIterator` 타입 이고 벡터랑 정확히 동일한 방식으로 작동합니다.



###  그래서 어떤 컨테이너를 사용해야돼?




어떠한 컨테이너를 사용할지는 전적으로 이 컨테이너를 가지고 어떠한 작업들을 많이 하냐에 달려있습니다.

* 일반적인 상황에서는 그냥 벡터를 사용한다 (거의 만능이다!)
* 만약에 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 일을 많이 하고,
원소들을 순차적으로만 접근
한다면 리스트를 사용한다.
* 만약에 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이하면 덱을 사용한다.



자 이번 강좌는 이것으로 마치도록 하겠습니다. 다음 강좌에서는 다른 종류의 컨테이너인 연관 컨테이너에 대해서 배웁니다.



###  생각 해보기

#### 문제 1

`deque` 를 구현해보세요. (난이도 : 중)

#### 문제 2

[여기에서 시퀀스 컨테이너들의 모든 함수들을 찾아볼 수 있습니다.](http://en.cppreference.com/w/cpp/container)한 번 읽어보세요!


##@ chewing-cpp-end
Link :  222
2017-07-02 18:57
----------------
title : 씹어먹는 C++ - <9 - 3. 템플릿 메타 프로그래밍 2>
cat_title: 9 - 3. 템플릿 메타 프로그래밍 2
next_page : 223
publish_date : 2017-07-02 18:57
--------------

이번 강좌에서는

* 의존 타입 (dependent type)

* `Unit` 라이브러리 만들기

* `auto` 키워드


에 대해서 배웁니다.


![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 지난 강좌에서 왜 `TMP` 를 활용하여 힘들게 힘들게 `Ratio` 클래스를 만들었는데, 아직 아마 이걸 왜 굳이 `TMP` 로 만들었는지는 설명하지 않았었습니다.


그에 앞서, 이번 강좌에서 왜 `Ratio` 클래스를 만들었는지 설명하기 전에 지난 강좌의 생각 해보기에 대해서 짚고 넘어가보자 합니다.



###  지난 강의 생각해보기 문제




지난번 생각해보기 문제는 아래와 같습니다.
```info
1. TMP 를 사용해서 어떤 수가 소수인지 아닌지를 판별하는 프로그램을 만들어보세요. (난이도 : 상)

int main()
{
  cout << boolalpha;
  cout << "Is prime ? :: " << is_prime<2>::result << endl; // true
  cout << "Is prime ? :: " << is_prime<10>::result << endl; // false
  cout << "Is prime ? :: " << is_prime<11>::result << endl; // true
  cout << "Is prime ? :: " << is_prime<61>::result << endl; // true
}
```



사실 처음에 딱 보았을 때 도대체 어떻게 `TMP` 로 구현할 것인지 감이 안잡혔을 것입니다. 하지만 만약에 소수 인지 아닌지 판별하라는 '함수' 를 작성하게 하였다면 잘 작성하였겠지요. 아마 여러분은 아래와 같은 코드를 쓰셨을 것입니다.

```cpp-formatted
bool is_prime(int N) {
  if (N == 2) return true;
  if (N == 3) return true;

  for (int i = 2; i <= N / 2; i++) {
    if (N % i == 0) return false;
  }

  return true;
}
```



왜 2 와 3 일 때 따로 처리하냐면 `N / 2` 까지 나누는 걸로 비교할 때 `2, 3` 일 경우 제대로 처리가 안되기 때문입니다. 이제 여러분이 해야할 일은 간단히 저 코드를 `TMP` 형식으로 옮기는 것입니다.

```cpp-formatted
template <>
struct is_prime<2> {
  static const bool result = true;
};

template <>
struct is_prime<3> {
  static const bool result = true;
};

template <int N>
struct is_prime {
  static const bool result = !check_div<N, 2>::result;
};

template <int N, int d>
struct check_div {
  static const bool result = (N % d == 0) || check_div<N, d + 1>::result;
};

template <int N>
struct check_div<N, N / 2> {
  static const bool result = (N % (N / 2) == 0);
};
```



무언가 잘 짜여진 코드 같습니다. 하지만 실제로 컴파일 해보면 다음과 같은 오류가 발생합니다.

```warning
check_div<N,N/>: non-type parameter of a partial specialization must be a simple identifier
```



바로

```cpp-formatted
template <int N>
struct check_div<N, N / 2> {
  static const bool result = (N % (N / 2) == 0);
};
```



이 부분에서 발생하는 문제 이지요. 위 오류가 발생한 문제는 템플릿 부분 특수화 시에 반드시 다른 연산자가 붙지 않고 단순한 식별자만 입력해주어야만 합니다. 따라서 C++ 컴파일러에 한계 상

```warning
struct check_div<N, N / 2>
```



와 같은 문법은 불가능 합니다. 그렇다면 이를 어떻게 해결할 수 있을까요? 생각을 잘 해보면, `N` 을 `int` 인자로 나타내는 대신에, 아예 `N` 을 나타내는 '타입' 으로 구현하면 어떨까요? 그렇다면 `N / 2` 역시, 직접 계산하는것이 아니라 `N / 2` 를 나타내는 타입으로 대체할 수 있고 따라서 템플릿 부분 특수화 문제를 해결할 수 있습니다.


따라서 아래와 같이 `int` 값을 표현하는 타입을 만들 수 있습니다.

```cpp-formatted
template <int N>
struct INT {
  static const int num = N;
};

template <typename a, typename b>
struct add {
  typedef INT<a::num + b::num> result;
};

template <typename a, typename b>
struct divide {
  typedef INT<a::num / b::num> result;
};

using one = INT<1>;
using two = INT<2>;
using three = INT<3>;
```



예를 들어 `one` 타입은 1을, `two` 타입은 2 를 나타내게 됩니다. 그렇다면 이를 바탕으로 `TMP` 코드를 수정해보도록 하겠습니다.

```cpp-formatted
using one = INT<1>;
using two = INT<2>;
using three = INT<3>;

template <typename N, typename d>
struct check_div {
  // result 중에서 한 개라도 true 면 전체가 true
  static const bool result =
    (N::num % d::num == 0) || check_div<N, add<d, one>::result>::result;
};

template <typename N>
struct is_prime {
  static const bool result = !check_div<N, two>::result;
};

template <>
struct is_prime<two> {
  static const bool result = true;
};

template <>
struct is_prime<three> {
  static const bool result = true;
};

template <typename N>
struct check_div<N, divide<N, two>::result> {
  static const bool result = (N::num % (N::num / 2) == 0);
};
```



그런데 컴파일 한다면 다음과 같은 오류를 보게 됩니다.


```warning
'check_div': 'divide<N,two>::result' is not a valid template type argument for parameter 'd'
```



왜 저런 오류가 발생하였을까요? 일단 오류가 발생하는 다음 두 부분의 코드를 살펴보겠습니다.

```cpp-formatted
(N::num % d::num == 0) || check_div<N, add<d, one>::result>::result;
```



와

```cpp-formatted
struct check_div<N, divide<N, two>::result> {
```



입니다. 먼저 컴파일러 입장에서 저 `::result` 를 어떻게 해석할지에 대해 생각해봅시다. 물론 우리는 `add<d, one>::result` 가 언제나 `INT<>` 타입 이라는 사실을 알고 있습니다. 왜냐하면 `typename` 인자로 들어오는 `N` 과 `d` 가 항상 `INT` 타입이기 때문에 저 `result` 를 항상 '타입'이네 라고 생각할 것입니다.


그런데, 컴파일러에 구조상 어떠한 식별자(변수 이름이든 함수 이름이든 코드 상의 이름들 `-` 위 코드의 경우 `add, check_div,, result, one` 등등 ...) 를 보았을 때 이 식별자가 '값' 인지 '타입' 인지 결정을 해야 합니다. 왜냐하면 예를들어서

```info
template <typename T>
int func() {
  T::t* p;
}

class A {
  const static int t;
};

class B {
  using t = int;
};
```



위와 같은 템플릿 함수에서 저 문장을 해석할 때 만약에 클래스 `A` 에 대해서, `func` 함수를 특수화 한다면, `t` 가 어떠한 `int` 값이 되어서

```info
T::t * p;
```



위 문장은 단순히 클래스 `A` 의 `t` 와 `p` 를 곱하는 식으로 해석이 됩니다.


반면에 `func` 함수가 클래스 `B` 에 대해서 특수화 된다면,

```info
T::t* p;
```



이 문장은 `int` 형 포인터 `p` 를 선언하는 꼴이 되겠지요. 따라서 컴파일러가 이 두 상황을 명확히 구분하기 위해 저 `T::t` 가 타입인지 아니면 값인지 명확하게 알려줘야만 합니다.


우리가 쓴 코드도 마찬가지로 컴파일러가 `result` 가 항상 '타입' 인지 아니면 '값' 인지 알 수 없습니다. 예컨대 만약에


```info
template <>
struct divide <int a, int b> {
  const static int result = a + b;
};
```



이런 템플릿이 정의가 되어있다면, 만약에 `N` 과 `two` 가 그냥 `int` 값이였다면 저 `result` 는 `static const int` 타입의 '값' 이 됩니다.이렇게 템플릿 인자에 따라서 어떠한 타입이 달라질 수 있는 것을 **의존 타입(dependent type)** 이라고 부릅니다. 위 경우 저 `result` 는 `N` 에 의존하기 때문에 의존 타입이 되겠지요.


따라서 컴파일러가 저 문장을 성공적으로 해석하기 위해서는 우리가 반드시 "야 저 `result` 는 무조건 타입이야" 라고 알려주어야만 합니다. 이를 위해서는 간단히 아래 코드 처럼

```cpp-formatted
struct check_div<N, typename divide<N, two>::result> {
```



'typename' 키워드를 붙여주면 됩니다.마찬가지로

```cpp-formatted
(N::num % d::num == 0) || check_div<N, add<d, one>::result>::result;
```



에서 `typename` 키워드를 붙인다면

```cpp-formatted
(N::num % d::num == 0) || check_div<N, typename add<d, one>::result>::result;
```



이 되겠지요. 참고로 의존 '값' 의 경우 `typename` 을 안 붙여줘도 됩니다. 컴파일러는 어떤 식별자를 보았을 때 기본으로 '값' 이라고 생각합니다. 따라서 `check_div` 앞에 아무것도 안올 수 있는 것입니다 (`check_div` 의 `result` 는 `static const bool` 이기 때문에!)


따라서 이를 고치면 다음과 같습니다.

```cpp-formatted
template <typename N, typename d>
struct check_div {
  // result 중에서 한 개라도 true 면 전체가 true
  static const bool result = (N::num % d::num == 0) ||
                             check_div<N, typename add<d, one>::result>::result;
};

// 생략

template <typename N>
struct check_div<N, typename divide<N, two>::result> {
  static const bool result = (N::num % (N::num / 2) == 0);
};
```



마지막으로, 위 `is_prime` 을 사용하기 위해서는

```cpp-formatted
is_prime<INT<11>>::result
```



이런 식으로 사용해야 합니다. 하지만 생각해보기에서 요구한 것은 `is_prime<11>::result` 로 사용하는 것이기 때문에 이를 위해서 `is_prime` 을 다음과 같이 정의하고, 기존의 `is_prime` 을 `_is_prime` 으로 바꾸도록 하겠습니다.

```cpp-formatted
template <int N>
struct is_prime {
  static const bool result = _is_prime<INT<N>>::result;
};
```



그렇다면 전체 코드를 살펴보겠습니다.

```cpp-formatted
#include <iostream>
#include <typeinfo>
using namespace std;

template <int N>
struct INT {
  static const int num = N;
};

template <typename a, typename b>
struct add {
  typedef INT<a::num + b::num> result;
};

template <typename a, typename b>
struct divide {
  typedef INT<a::num / b::num> result;
};

using one = INT<1>;
using two = INT<2>;
using three = INT<3>;

template <typename N, typename d>
struct check_div {
  // result 중에서 한 개라도 true 면 전체가 true
  static const bool result = (N::num % d::num == 0) ||
                             check_div<N, typename add<d, one>::result>::result;
};

template <typename N>
struct _is_prime {
  static const bool result = !check_div<N, two>::result;
};

template <>
struct _is_prime<two> {
  static const bool result = true;
};

template <>
struct _is_prime<three> {
  static const bool result = true;
};

template <typename N>
struct check_div<N, typename divide<N, two>::result> {
  static const bool result = (N::num % (N::num / 2) == 0);
};

template <int N>
struct is_prime {
  static const bool result = _is_prime<INT<N>>::result;
};

int main() {
  cout << boolalpha;
  cout << "Is 2 prime ? :: " << is_prime<2>::result << endl;
  cout << "Is 10 prime ? :: " << is_prime<10>::result << endl;

  cout << "Is 11 prime ? :: " << is_prime<11>::result << endl;
  cout << "Is 61 prime ? :: " << is_prime<61>::result << endl;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F246E4050595360293409F3)



와 같이 제대로 판별함을 알 수 있습니다.


참고로 컴파일러에 따라서 재귀적으로 몇 번까지 사용 가능한지 깊이가 정해져있기 때문에, 꽤 큰 수를 넣는다면 컴파일 오류가 발생할 수 도 있습니다.



자, 그렇다면 본격적으로 이번 강의를 시작해보도록 하겠습니다. 지난 강좌에서 `Ratio` 클래스를 만들면서 왜 굳이 이것을 `TMP` 로 만들었을까, 그냥 일반적인 클래스로 만들었다면 훨씬 직관적이고 편하지 않나라고 많이 생각하셨을 것입니다. 바로 지금부터 `TMP` 의 진짜 파워에 대해서 알아보도록 하겠습니다.




###  단위(Unit) 라이브러리


C++ 코드를 작성하는 이유는 여러가지가 있겠지만, 그 중 하나로 바로 여러 수치 계산을 사용하는데에도 많이 사용합니다. 예를 들어서 인공위성의 궤도를 계산한다던지, 입자의 운동을 계산한다던지 말이지요. 이러한 물리적 수치 계산 시에 꼭 필요한 것이 바로 '단위' 입니다.

단위라 하면 쉽게 말해 킬로그램 (kg), 미터 (m), 초 (s) 등을 생각하시면 됩니다. 이러한 것들을 계산하는 프로그램들의 경우, `double` 이나 `float` 변수에 들어가는 값에는 '단위' 가 붙어서 들어가겠지요.

예를 들어서 핸드폰의 가속도 센서에서 부터 데이터를 받는 프로그램은 아마도 m/s^2 단위로 데이터를 받겠지요. 혹은 시계로 부터 데이터를 받는 프로그램은 `s` 단위로 데이터를 받을 것 입니다.

아무튼 이렇게 단위가 붙은 데이터를 처리할 때 중요한 점은 바로 데이터를 연산할 때 항상 단위를 확인해야 된다는 점입니다. 예를 들어서, 다음과 같은 코드가 있다고 생각해봅시다.

```cpp-formatted
float v1, v2;  // v1, v2 는 속도

cout << v1 + v2;
```




당연히 `v1` 과 `v2` 는 속도 값을 나타내므로 같은 단위이기 때문에 더할 수 있습니다. (여기서 더할 수 있다는 말은 물리적으로 더한 값이 말이 된다는 의미 입니다). 반면에;


```cpp-formatted
float v;        // 속도; m/s
float a;        // 가속도; m/s^2
cout << v + a;  // ???
```



만약에 `v` 가 속도를 나타내는 값이고, `a` 가 가속도를 나타내는 값이라면, `v + a` 는 불가능한 연산입니다. 만약에 프로그래머가 저러한 코드를 썻다면 분명히 실수일 것입니다. 물론 C++ 컴파일러 입장에서는 그냥 두 개의 `float` 변수를 더한 것이기 때문에 문제 없이 컴파일 됩니다. 하지만 프로그램을 돌리게 된다면 골치아픈 문제가 발생하겠지요.


실제로, `NASA` 의 경우 단위를 잘못 처리해서 1조원 짜리 화성 탐사선을 날려먹은 경우가 있습니다. 이 경우 1조원 자리 버그 이겠네요.


여러분이라면 이러한 실수를 어떻게 막을 것인가요?일단 가장 먼저 드는 생각으로 단위 데이터를 일반적인 변수에 보관하지 말고 클래스를 만들어서 클래스 객체에서 보관하는 것입니다. 그리고 `operator+` 등으로 연산자들을 오버로딩 한 뒤에, 연산 시에 객체 끼리 단위를 체크해서 단위가 맞지 않으면 적절히 처리하면 됩니다.


물론 이 방법은 꽤나 괜찮아 보이지만 한 가지 문제가 있습니다. 만일 틀린 단위를 연산하는 코드가 '매우 드물게' 일어난다면 어떨까요? 즉 런타임에서 그 문제를 발견하지 못한 채 넘어갈 수 있다는 점입니다.


가장 이상적인 상황은 단위가 맞지 않는 연산을 수행하는 코드가 있다면아예 컴파일 시에 오류를 발생시켜버리는 것입니다. 그렇다면 적어도 틀린 단위를 연산하는 일은 막을 수 있게 되고, 프로그램을 실행 시키면서 기다리는 수고를 줄일 수 있게 되지요.

이를 위해서 다음과 같은 클래스를 생각해봅시다.

```cpp-formatted
template <typename U, typename V, typename W>
struct Dim {
  using M = U;  // kg
  using L = V;  // m
  using T = W;  // s

  using type = Dim<M, L, T>;
};
```


이 `Dim` 이라는 클래스는 어떠한 데이터의 단위를 나타내기 위해서 사용됩니다. 어떠한 물리량의 단위를 나타내기 위해서는 무게(kg), 길이(m), 시간(s) 이 3 개로 나타낼 수 있습니다. (실제로는 8개가 필요하지만 단순화를 위해 3개만 사용하도록 하겠습니다).


예를 들어서 속도의 경우 `m/s` 이므로, 저 `Dim` 클래스로 표현하자면 `Dim<0, 1, -1>` 로 나타낼 수 있습니다. 왜냐하면 `m/s =` kg^0 m^1 s^-1 이기 때문이지요.



마찬가지로 힘의 경우 단위가 kg m /s^2 이므로 `Dim` 클래스로 표현하자면 `Dim<1, 1, -2>` 가 됩니다.


물론 저 `Dim` 의 경우 템플릿 인자로 타입을 받기 때문에 단순히 `Dim<0, 1, -1>` 이렇게 사용할 수 있는 것이 아닙니다. 대신에 앞서 만들었던`Ratio` 클래스를 이용해서 저 숫자들을 '타입' 으로 표현해주어야 합니다. 따라서, 실제로는

```cpp-formatted
Dim<1, 1, -2>
```



가 아니라

```cpp-formatted
Dim<Ratio<1, 1>, Ratio<1, 1>, Ratio<-2, 1>>
```



이런 식으로 정의를 해야겠지요. 그렇다면 `Dim` 끼리 더하고 빼는 템플릿 클래스도 아래와 같이 만들 수 있게 됩니다.

```cpp-formatted
template <typename U, typename V>
struct add_dim_ {
  typedef Dim<typename Ratio_add<typename U::M, typename V::M>::type,
              typename Ratio_add<typename U::L, typename V::L>::type,
              typename Ratio_add<typename U::T, typename V::T>::type>
    type;
};

template <typename U, typename V>
struct subtract_dim_ {
  typedef Dim<typename Ratio_subtract<typename U::M, typename V::M>::type,
              typename Ratio_subtract<typename U::L, typename V::L>::type,
              typename Ratio_subtract<typename U::T, typename V::T>::type>
    type;
};
```



왜 `typename` 이 저렇게도 많이 붙어있는지는 아마 잘 이해하실 거라 생각합니다. 왜냐하면 예를 들어 `M` 의 경우 `U` 에 의존한 타입이고, `type` 의 경우도 마찬가지로 `U` 와 `V` 에 의존하는 타입이기 때문이지요.


자 이제, 실제 데이터를 담는 클래스를 만들어보도록 하겠습니다.

```cpp-formatted
template <typename T, typename D>
struct quantity {
  T q;
  using dim_type = D;
};
```



일단 위 처럼 `q` 라는 멤버 변수에 데이터를 담고, (데이터의 타입은 `T` 가 되겠지요), `dim_type` 에 차원 정보를 담게 됩니다. 차원 정보는 데이터와는 다르게 'Dim 타입' 그 자체로 표현됩니다.


자 이제, 실제로 `quantity` 객체를 가지고 연산을 수행하기 위해서는 우리가 연산자들을 오버로드 해줘야만 합니다. 일단 간단히 `+` 와 `-` 연산자를 어떻게 오버로드 할 지 생각해봅시다. 앞서 말했듯이, 두 개의 데이터를 더하거나 빼기 위해서는 반드시 단위가 일치해야 합니다. 이 말은, `dim_type` 이 같은 타입이어야만 하다는 것이지요.



따라서 `operator+` 와 `operator-` 는 다음과 같이 간단히 정의할 수 있습니다.

```cpp-formatted
quantity operator+(quantity<T, D> quant) { return quantity<T, D>(q + quant.q); }

quantity operator-(quantity<T, D> quant) { return quantity<T, D>(q - quant.q); }
```



위 `operator+` 는 인자로 받는 `quantity` 의 데이터 타입과 `Dim` 타입이 일치해야지만 인스턴스화 됩니다. 만약에, 데이터 타입이나 `Dim` 타입이 일치하지 않았더라면 저 `operator+` 는 인스턴스화 될 수 없고 따라서 컴파일러는 저 `operator+` 를 찾을 수 없다는 오류를 발생시키게 됩니다!


그렇다면 실제로 테스트를 해볼까요.

```cpp
#include <iostream>
using namespace std;

template <int X, int Y>
struct GCD {
  static const int value = GCD<Y, X % Y>::value;
};

template <int X>
struct GCD<X, 0> {
  static const int value = X;
};

template <int N, int D = 1>
struct Ratio {
 private:
  const static int _gcd = GCD<N, D>::value;

 public:
  typedef Ratio<N / _gcd, D / _gcd> type;
  static const int num = N / _gcd;
  static const int den = D / _gcd;
};
template <class R1, class R2>
struct _Ratio_add {
  using type = Ratio<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_add : _Ratio_add<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_subtract {
  using type = Ratio<R1::num * R2::den - R2::num * R1::den, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_subtract : _Ratio_subtract<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_multiply {
  using type = Ratio<R1::num * R2::num, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_multiply : _Ratio_multiply<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_divide {
  using type = Ratio<R1::num * R2::den, R1::den * R2::num>;
};

template <class R1, class R2>
struct Ratio_divide : _Ratio_divide<R1, R2>::type {};

template <typename U, typename V, typename W>
struct Dim {
  using M = U;
  using L = V;
  using T = W;

  using type = Dim<M, L, T>;
};

template <typename U, typename V>
struct add_dim_ {
  typedef Dim<typename Ratio_add<typename U::M, typename V::M>::type,
              typename Ratio_add<typename U::L, typename V::L>::type,
              typename Ratio_add<typename U::T, typename V::T>::type>
    type;
};

template <typename U, typename V>
struct subtract_dim_ {
  typedef Dim<typename Ratio_subtract<typename U::M, typename V::M>::type,
              typename Ratio_subtract<typename U::L, typename V::L>::type,
              typename Ratio_subtract<typename U::T, typename V::T>::type>
    type;
};

template <typename T, typename D>
struct quantity {
  T q;
  using dim_type = D;

  quantity operator+(quantity<T, D> quant) {
    return quantity<T, D>(q + quant.q);
  }

  quantity operator-(quantity<T, D> quant) {
    return quantity<T, D>(q - quant.q);
  }
};
int main() {
  using one = Ratio<1, 1>;
  using zero = Ratio<0, 1>;

  quantity<double, Dim<one, zero, zero>> kg(1);
  quantity<double, Dim<zero, one, zero>> meter(1);
  quantity<double, Dim<zero, zero, one>> second(1);

  // Good
  kg + kg;

  // Bad
  kg + meter;
}
```



컴파일 하였다면 다음과 같은 오류가 납니다.

```warning
no operator "+" matches these operands
binary '+': no operator found which takes a right-hand operand of type 'quantity<double,Dim<zero,one,zero>>' (or there is no acceptable conversion)
```



즉 위 `+` 에 해당하는 연산자 함수를 찾을 수 없다는 것이지요. 예상했던 대로,

```warning

// Bad
kg + meter;
```



위 부분에서 오류가 발생하는데, `kg` 와 `meter` 의 단위가 다르기 때문에 발생하게 됩니다. 반면에

```info

// Good
kg + kg;
```



는 잘 컴파일되지요.


그렇다면 이제 `*` 와 `/` 연산자만 만들어주면 되겠습니다. 하지만 `*` 와 `/` 의 경우 `+` 와 `-` 보다 좀 더 까다롭습니다. 왜냐하면 `*` 와 `/` 의 경우 굳이 `Dim` 이 일치하지 않아도 되거든요! 다만 이 연산을 수행하였을 때 새로운 차원의 데이터가 나올 뿐입니다.


예를 들어서 가속도를 나타내기 위해서는

```cpp-formatted
meter / (second * second)
```



이렇게 해주면 됩니다. 다만 새로운 차원의 데이터 (`Dim<zero, one, minus_two>`) 가 탄생할 뿐이지요. 따라서, `operator*` 와 `operator/` 의 경우 두 개의 다른 차원의 값을 받아도 처리할 수 있어야 합니다. 따라서 `opreator*` 와 `/` 를 정의해보자면 아래와 같습니다.

```cpp-formatted
template <typename D2>
quantity<T, typename add_dim_<D, D2>::type> operator*(quantity<T, D2> quant) {
  return quantity<T, typename add_dim_<D, D2>::type>(q * quant.q);
}

template <typename D2>
quantity<T, typename subtract_dim_<D, D2>::type> operator/(
  quantity<T, D2> quant) {
  return quantity<T, typename subtract_dim_<D, D2>::type>(q / quant.q);
}
```



새로 만들어지는 타입의 차원은 당연히도 `add_dim_<D, D2>::type` 이 되겠고 (`opreator*` 의 경우), 그 값은 그냥 실제 값을 곱해주면 됩니다. 이와 더불어서

```cpp-formatted
3 * kg
```



과 같은 곱도 처리해야 하기 때문에, 아래와 같은 함수들도 정의해줘야 합니다.

```cpp-formatted

quantity<T, D> operator*(T scalar) { return quantity<T, D>(q * scalar); }

quantity<T, D> operator/(T scalar) { return quantity<T, D>(q / scalar); }
```



이는 위 처럼 일반적인 차원이 없는 값 과의 곱도 지원해줍니다. 그렇다면 예를 들어서 아래와 같이 정의된 `F` 의 타입은 어떻게 될까요?


```cpp-formatted
// F 의 타입은?
F = kg * meter / (second * second);
```



일단 `F` 의 차원은 계산해보면 (1, 1, -2) 이렇게 나올 것 입니다. 따라서, `F` 의 `dim` 타입은 `<Ratio<1, 1>, Ratio<1, 1>, Ratio<-2, 1>>` 가 되겠지요. 다시 말해, `F` 를 다음과 같이 나타낼 수 있습니다.

```cpp-formatted
quantity<double, Dim<one, one, Ratio<-2, 1>>> F =
  kg * meter / (second * second);
```



그런데, 매번 변수를 정의할 때 마다 저렇게 길고 긴 타입을 써주는 것은 매우 귀찮은 일입니다. 저 `kg * meter / (second * second)` 를 계산해서 나오는 객체의 타입이 저렇게 된다는 사실은 저도 알고 컴파일러도 알고 있습니다. 컴파일러가 쉽게 알아낼 수 있는 타입을 굳이 우리가 써주어야 할까요? 똑똑한 컴파일러가 타입을 알아서 생각하도록 하면 안될까요?


물론 가능합니다.



###  타입을 알아서 추측해라! `- auto` 키워드


C++ 코드를 많이 짜면서 느꼈겠지만, 객체를 생성할 때, 많은 경우 굳이 타입을 쓰지 않아도 알아서 추측할 수 있는 경우들이 많이 있습니다.

예를 들어서,
```cpp-formatted
(??) a = 3;
```



와 같이 썼다면 저 (??) 는 아마 `int` 를 의도한 것이겠지요. 아니면

```cpp-formatted
some_class a;
(??) b = a;
```


의 경우 저 (??) 에는 아마 `some_class` 가 들어가겠지요? 즉 객체가 복사 생성 될 때, 그 복사 생성하는 대상의 타입을 확실히 알 수 있다면 굳이 그 객체의 타입을 명시하지 않아도 컴파일러가 알아낼 수 있습니다.


물론 때때로 컴파일러가 타입을 제대로 유추할 수 없는 경우도 있습니다. 예를 들어서, 우리의 위 예제 코드에서

```cpp-formatted
quantity<double, Dim<one, zero, zero>> kg(1);
```



의 경우 만약에 저 타입 부분을 가리고

```cpp-formatted
(??) kg(1);
```



와 같이 살펴본다면 어떨까요? 컴파일러에 입장에서는 단순히 생각해봤을 때 그냥 1 로 초기화 하는 변수 이므로 (??) 에는 `int` 가 들어가겠지요. 따라서 이 경우에는 우리가 원하는 타입으로 생성할 수 없습니다. 반면에,

```cpp-formatted
(??) F = kg * meter / (second * second);
```



`F` 의 경우 우리가 굳이 타입을 적지 않아도 컴파일러가 오른쪽의 연산을 통해서 `F` 의 타입을 정확하게 알아낼 수 있습니다.


이와 같이 컴파일러가 타입을 정확히 알아낼 수 있는 경우 굳이 그 길고 긴 타입을 적지 않고 간단히 `auto` 로 표현할 수 있습니다. 그리고 그 `auto` 에 해당하는 타입은 컴파일 시에 컴파일러에 의해 추론됩니다. 아래 간단한 예제를 살펴볼까요.

```cpp-formatted
#include <iostream>
#include <typeinfo>
using namespace std;

int sum(int a, int b) { return a + b; }

class SomeClass {
  int data;

 public:
  SomeClass(int d) : data(d) {}
  SomeClass(const SomeClass& s) : data(s.data) {}
};

int main() {
  auto c = sum(1, 2);  // 함수 리턴 타입으로 부터 int 라고 추측 가능
  auto num = 1.0 + 2.0;  // double 로 추측 가능!

  SomeClass some(10);
  auto some2 = some;

  auto some3(10);  // SomeClass 객체를 만들까요?

  cout << "c 의 타입은? :: " << typeid(c).name() << endl;
  cout << "num 의 타입은? :: " << typeid(num).name() << endl;
  cout << "some2 의 타입은? :: " << typeid(some2).name() << endl;
  cout << "some3 의 타입은? :: " << typeid(some3).name() << endl;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F212DD2445958AD6337F074)



와 같이 나옵니다.

```cpp-formatted
cout << "c 의 타입은? :: " << typeid(c).name() << endl;
cout << "num 의 타입은? :: " << typeid(num).name() << endl;
cout << "some2 의 타입은? :: " << typeid(some2).name() << endl;
```



일단 위 3줄은 우리의 예상대로 `auto` 키워드가 잘 타입을 추론해줍니다. `c` 의 경우 함수의 리턴 타입으로 부터 `int` 타입이라는 것을 알 수 있고, `num` 의 경우 `1.0 + 2.0` 의 결과가 `double` 이므로 `num` 역시 `double` 타입 변수로 초기화 됩니다. 마지막으로 `some2` 의 경우 `SomeClass` 타입인 `some` 으로 부터 복사 생성 되므로 `SomeClass` 타입이 되지요.


마지막으로 `some3` 를 살펴봅시다.

```cpp-formatted
auto some3(10);  // SomeClass 객체를 만들까요?
```



이전에 `some` 을 만들 때 `SomeClass some(10)` 으로 만들었기 때문에 저 `some3` 도 혹시 `SomeClass` 타입으로 추론하지 않을까 생각할 수 있습니다. 하지만 컴파일러는 최대한 단순하게 가능한 방법으로 추론하기 때문에 (실제로 `auto` 타입을 추론하는 방법은 템플릿에 들어갈 타입을 추론하는 것과 동일합니다), 그냥 `int` 변수로 만들어 버립니다.


하지만 아래의 `F` 의 경우 정확히 타입을 추론할 수 있기 때문에 그냥

```cpp-formatted
// F 의 타입은 굳이 알필요 없다!
auto F = kg * meter / (second * second);
```



위와 같이 `auto` 키워드를 이용하면 됩니다.


참고로 편의를 위해 `quantity` 를 `ostream` 으로 출력해주는 함수인
```cpp-formatted
template <typename T, typename D>
ostream& operator<<(ostream& out, const quantity<T, D>& q) {
  out << q.q << "kg^" << D::M::num / D::M::den << "m^" << D::L::num / D::L::den
      << "s^" << D::T::num / D::T::den;

  return out;
}
```



를 제작하였습니다. 따라서 전체 코드를 살펴보면 다음과 같습니다.

```cpp-formatted
#include <iostream>
#include <typeinfo>
using namespace std;

template <int X, int Y>
struct GCD {
  static const int value = GCD<Y, X % Y>::value;
};

template <int X>
struct GCD<X, 0> {
  static const int value = X;
};

template <int N, int D = 1>
struct Ratio {
 private:
  const static int _gcd = GCD<N, D>::value;

 public:
  typedef Ratio<N / _gcd, D / _gcd> type;
  static const int num = N / _gcd;
  static const int den = D / _gcd;
};
template <class R1, class R2>
struct _Ratio_add {
  using type = Ratio<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_add : _Ratio_add<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_subtract {
  using type = Ratio<R1::num * R2::den - R2::num * R1::den, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_subtract : _Ratio_subtract<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_multiply {
  using type = Ratio<R1::num * R2::num, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_multiply : _Ratio_multiply<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_divide {
  using type = Ratio<R1::num * R2::den, R1::den * R2::num>;
};

template <class R1, class R2>
struct Ratio_divide : _Ratio_divide<R1, R2>::type {};

template <typename U, typename V, typename W>
struct Dim {
  using M = U;
  using L = V;
  using T = W;

  using type = Dim<M, L, T>;
};

template <typename U, typename V>
struct add_dim_ {
  typedef Dim<typename Ratio_add<typename U::M, typename V::M>::type,
              typename Ratio_add<typename U::L, typename V::L>::type,
              typename Ratio_add<typename U::T, typename V::T>::type>
    type;
};

template <typename U, typename V>
struct subtract_dim_ {
  typedef Dim<typename Ratio_subtract<typename U::M, typename V::M>::type,
              typename Ratio_subtract<typename U::L, typename V::L>::type,
              typename Ratio_subtract<typename U::T, typename V::T>::type>
    type;
};

template <typename T, typename D>
struct quantity {
  T q;
  using dim_type = D;

  quantity operator+(quantity<T, D> quant) {
    return quantity<T, D>(q + quant.q);
  }

  quantity operator-(quantity<T, D> quant) {
    return quantity<T, D>(q - quant.q);
  }

  template <typename D2>
  quantity<T, typename add_dim_<D, D2>::type> operator*(quantity<T, D2> quant) {
    return quantity<T, typename add_dim_<D, D2>::type>(q * quant.q);
  }

  template <typename D2>
  quantity<T, typename subtract_dim_<D, D2>::type> operator/(
    quantity<T, D2> quant) {
    return quantity<T, typename subtract_dim_<D, D2>::type>(q / quant.q);
  }

  // Scalar multiplication and division
  quantity<T, D> operator*(T scalar) { return quantity<T, D>(q * scalar); }

  quantity<T, D> operator/(T scalar) { return quantity<T, D>(q / scalar); }

  quantity(T q) : q(q) {}
};

template <typename T, typename D>
ostream& operator<<(ostream& out, const quantity<T, D>& q) {
  out << q.q << "kg^" << D::M::num / D::M::den << "m^" << D::L::num / D::L::den
      << "s^" << D::T::num / D::T::den;

  return out;
}

int main() {
  using one = Ratio<1, 1>;
  using zero = Ratio<0, 1>;

  quantity<double, Dim<one, zero, zero>> kg(2);
  quantity<double, Dim<zero, one, zero>> meter(3);
  quantity<double, Dim<zero, zero, one>> second(1);

  // F 의 타입은 굳이 알필요 없다!
  auto F = kg * meter / (second * second);
  cout << "2 kg 물체를 3m/s^2 의 가속도로 밀기 위한 힘의 크기는? " << F << endl;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2104A74C5958A785159302)



와 같이 잘 나옵니다.


`auto` 키워드는 템플릿의 사용으로 복잡해진 타입 이름들을 간단하게 나타낼 수 있는 획기적인 방법입니다. 물론 짧은 이름의 타입일 경우 그냥 써주는 것이 좋지만 (왜냐면 그 코드를 읽는 사람에 입장에서 한눈에 타입을 알 수 있으면 좋기 때문에), 위 경우 처럼 복잡한 타입 이름의 경우, 그 타입을 쉽게 추측할 수 있다면 `auto` 키워드를 활용하는 것도 좋습니다.



이것으로 템플릿 메타프로그래밍에 대한 강좌를 마치도록 하겠습니다. 사실 실제 현업에서 템플릿 메타 프로그래밍을 활용하는 경우는 그다지 많지 않습니다. 왜냐하면 일단 `TMP` 의 특성상복잡하고, 머리를 매우 많이 써야되고, 무엇보다도 버그가 발생하였을 때 찾는 것이 매우 힘듧니다.


하지만 우리의 `Unit` 클래스 처럼 `TMP` 를 적절하게 활용하면 런타임에서 찾아야 하는 오류를 컴파일 타임에서 미리 다 잡아낼 수 도 있고, 런타임 시에 수행해야 하는 연산들도 일부 컴파일 타임으로 옮길 수 있습니다.


만약에 `TMP` 를 직접 작성할 일이 있다면 이미 `TMP` 를 그나마 편하게 수행하기 위해 만들어진 `boost::MPL` 라이브러리가 있습니다. 이 라이브러리를 활용하신다면 비교적 쉽게 `TMP` 코드를 짤 수 있을 것입니다!


다음 강좌에서는 C++ 의 또다른 막강한 무기인 표준 라이브러리 (STL) 에 대해 알아보도록 하겠습니다!



###  생각 해보기

#### 문제 1

컴파일러가 `auto` 키워드에 들어갈 타입을 추측하는 방법은 템플릿에서 들어갈 타입을 추측하는 방법과 같습니다. [여기를 클릭해서 읽어보세요!](http://en.cppreference.com/w/cpp/language/template_argument_deduction)

##@ chewing-cpp-end
Link :  221
2017-06-26 16:41
----------------
title : 씹어먹는 C++ - <9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)>
cat_title: 9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)
next_page : 222
publish_date : 2017-06-26 16:41
--------------

이번 강좌에서는

* 타입이 아닌 템플릿 인자
* 템플릿 메타 프로그래밍의 시작
* `using` 키워드 사용


![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 지난번 강좌에서 `template` 을 처음으로 소개하였는데 어떠하셨나요? 템플릿을 통해서 프로그래밍이 좀 더 편해진 것 같나요? 이렇게 템플릿을 통해서 타입이 마치 인자 인것 처럼 사용하는 것을 바로 **일반화 프로그래밍 (generic programming)** 혹은 그냥 제너릭 프로그래밍 이라고 부릅니다.


앞선 강좌에서는 템플릿 인자로 타입들만 전달하였지만, 실제로는 일반적인 값들도 인자로 전달할 수 있습니다. 아래의 예제를 살펴보겠습니다.

```cpp-formatted
/* 템플릿 인자로 값을 받기 */
#include <iostream>
using namespace std;

template <typename T, unsigned int N>
class Array {
  T data[N];

 public:
  // 배열을 받는 레퍼런스 arr
  Array(T (&arr)[N]) {
    for (int i = 0; i < N; i++) {
      data[i] = arr[i];
    }
  }

  T* get_array() { return data; }

  unsigned int size() { return N; }

  void print_all() {
    for (int i = 0; i < N; i++) {
      cout << data[i] << ", ";
    }
    cout << endl;
  }
};

int main() {
  int arr[3] = {1, 2, 3};

  // 배열 wrapper 클래스
  Array<int, 3> arr_w(arr);

  arr_w.print_all();
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27754F3B594C979F2AF4C4)



와 같이 나옵니다.

```cpp-formatted
template <typename T, int N>
```



템플릿 정의 부분을 살펴보면 바로 알겠지만, 템플릿 역시 마치 함수의 인자에 값을 받는 것 처럼 템플릿에도 값을 전달 할 수 있습니다. 다만 함수 처럼 임의의 객체를 인자로 받을 수 있는 것은 아니고, 위 처럼 정수 타입이나, 레퍼런스 혹은 포인터 만을 받을 수 있습니다.

그 이유는 잘 생각해보면 당연한데, 템플릿이 인스턴스화 되는 과정은 컴파일 시에 일어나는데, 만약에 객체를 직접 받는다면, 컴파일을 하기 전에 컴파일을 해야되는 모순적인 상황이 발생하게 되기 때문이지요.


아무튼, 템플릿 인자로는 단순한 정수타입이나, 레퍼런스, 포인터만 받을 수 있다고 생각하시면 됩니다.

```cpp-formatted
// 배열 wrapper 클래스
Array<int, 3> arr_w(arr);
```





위와 같이 템플릿 인스턴스화를 하게 되면, 템플릿에 `T` 자리에는 `int` 가, `N` 자리에는 3 이 들어가겠지요. 그렇다면 컴파일러는

```cpp-formatted
T data[N];
```



를


```cpp-formatted
int data[3];
```



으로 대체해서 코드를 생성하게 되고, 마찬가지로

```cpp-formatted
// 배열을 받는 레퍼런스 arr
Array(T (&arr)[N]) {
  for (int i = 0; i < N; i++) {
    data[i] = arr[i];
  }
}
```



생성자 역시

```cpp-formatted
// 배열을 받는 레퍼런스 arr
Array(int (&arr)[3]) {
  for (int i = 0; i < 3; i++) {
    data[i] = arr[i];
  }
}
```



로 아예 코드가 생성되어 실행됩니다. 참고로 이 처럼 배열을 감싸는 `wrapper` 클래스를 만들어서 마치 배열 처럼 사용한다면 (물론 그러기 위해서는 `[]` 연산자도 오버로드 해야겠죠?) 배열을 사용함으로써 발생하는 문제들을 많이 해결할 수 있게 됩니다.

예를 들어서, 일반 배열은 배열 범위가 넘어가도 알 수 없지만, 위 `Array` 클래스는 `index` 범위가 넘어가는 곳을 가리키면 뭔가 메세지를 띄우든 오류를 발생 시키든 해서 사용자에게 알려 줄 수 있습니다.


그런데, 과연 아래 두 개 클래스는 같은 클래스 일까요? 다른 클래스 일까요?

```cpp-formatted
Array<int, 5> Array<int, 3>
```



간단히 아래 코드로 확인해 볼 수 있습니다.

```cpp-formatted
cout << (typeid(Array<int, 3>) == typeid(Array<int, 5>)) << endl;
```



참고로 `typeid` 를 사용하려면 `<typeinfo>` 헤더파일을 추가해주시면 됩니다. 그 결과는 당연하게도


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2649724B594CB13D2F1774)



와 같이 다르다고 나옵니다. 왜 다르냐면 당연히, 다른 템플릿 인자로 인스턴스화 되었기 때문이지요. 컴파일러는 `Array<int, 5>` 와 `Array<int, 3>` 를 위해 각기 다른 코드를 생성하며 다른 클래스의 객체들을 만들게 됩니다.


그렇다면 아래와 같이 정의된 Int 클래스를 생각해봅시다.

```cpp-formatted
template <int N>
struct Int {
  static const int num = N;
};
```



이 클래스는 템플릿 인자로 `int` 값을 받습니다. 참고로, 왜 `static const` 에 값을 저장하냐면, 첫 번째로 C++ 클래스 멤버 중에서 클래스 자체에서 저런 식으로 초기화를 할 수 있는 멤버의 타입은 `static const` 밖에 없고, 두 번째로 `static const` 야 말로 '이 클래스는 이 것이다' 라는 의미를 가장 잘 나타내기 때문입니다.

왜냐하면 `static` 타입 멤버의 특성 상, 이 클래스가 생성한 객체들 사이에서 공유되는 값이기 때문에'이 타입이면 이 값을 나타낸다'라고 볼 수 있습니다. 또한 `const` 이므로, 그 나타내는 값이 변하지 않게 됩니다.


따라서 아래 처럼 마치 객체를 생성하듯 타입들을 생성할 수 있습니다.

```cpp-formatted
typedef Int<1> one;
typedef Int<2> two;
```





그렇다면 저 `one` 타입과 `two` 타입은 1 과 2 의 값을 나타내는 타입이 됩니다. (`one` 과 `two` 는 객체가 아닙니다!)


그럼 이제 `one` 과 `two` 를 가지고 무엇을 할 수 있을까요? 재미있게도 마치 `int` 변수를 다루는 것 처럼 연산자를 만들 수 있습니다. 아래 예제를 살펴볼까요.

```cpp-formatted
#include <iostream>
#include <typeinfo>
using namespace std;

template <int N>
struct Int {
  static const int num = N;
};

template <typename T, typename U>
struct add {
  typedef Int<T::num + U::num> result;
};

int main() {
  typedef Int<1> one;
  typedef Int<2> two;

  typedef add<one, two>::result three;

  cout << "Addtion result : " << three::num << endl;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F215FB037594F3E06197C17)



와 같이 실제 계산 결과가 잘 나오게 됩니다.


덧셈을 수행하는 템플릿 클래스를 살펴봅시다.

```cpp-formatted
template <typename T, typename U>
struct add {
  typedef Int<T::num + U::num> result;
};
```



위 `add` 클래스의 템플릿은 인자로 두 개의 타입을 받아서 그 타입의 `num` 멤버를 더해서 새로운 타입인 `result` 를 만들어 내게 됩니다.


```cpp-formatted
typedef add<one, two>::result three;
```



위 부분은 실제 덧셈을 수행하는 부분입니다. `add` 클래스를 함수라고 생각한다면 그 계산 결과를 내부 `result` 타입으로 반환한다고 보면 됩니다. 아무튼 `one` 과 `two` 를 더한 것을 나타내는 타입이 result 로 정의되고, 이를 `three` 라고 부르겠습니다.


실제로, 그 결과를 보면

```cpp-formatted
cout << "Addtion result : " << three::num << endl;
```



를 통해서 3 이 잘 출력됨을 알 수 있습니다.


한 가지 흥미로운 점은저 3 이라는 값이 프로그램이 실행되면서 계산되는 것이 아니라는 점입니다. 컴파일 시에, 컴파일러가 `three::num` 을 3 으로 치환 해버립니다.



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F23499834594F45E110436F)

실제로 마우스를 올려보면 저 값이 3 이란 사실을 알 수 있습니다.


다시 말해, 저 덧셈이 수행 되는 시기는 컴파일 타임이고, 런타임 시에는 단순히 그 결과를 보여주게 되는 것입니다.



###  템플릿 메타 프로그래밍 (Template Meta Programming - TMP)

여태까지 타입은 어떠한 객체에 무엇을 저장하느냐를 지정하는데 사용해 왔지, 타입 자체가 어떠한 값을 가지지는 않았습니다. 하지만, 바로 위 예제를 통해서 알 수 있듯이, 템플릿을 사용하면 객체를 생성하지 않더라도, 타입에 어떠한 '값' 을 부여할 수 있고, 또 그타입들을 가지고 '연산' 을 할 수 있다는 점 입니다.

또한 타입은 반드시 컴파일 타임에 확정되어야 하므로, 컴파일 타임에 모든 연산이 끝나게 됩니다.
이렇게 타입을 가지고컴파일 타임에 생성되는 '코드'로 프로그래밍을 하는 것을 **메타 프로그래밍(meta programming)** 이라고 합니다. C++ 의 경우 템플릿을 가지고 이러한 작업을 하기 때문에 **템플릿 메타 프로그래밍**, 줄여서  **TMP** 라고 부릅니다.

```cpp-formatted
/* 컴파일 타임 팩토리얼 계산 */
#include <iostream>
using namespace std;

template <int N>
struct Factorial {
  static const int result = N * Factorial<N - 1>::result;
};

template <>
struct Factorial<1> {
  static const int result = 1;
};

int main() { cout << "6! = 1*2*3*4*5*6 = " << Factorial<6>::result << endl; }
```



성공적으로 컴파일 하였다면
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F24481E4F595009FA13AE76)



와 같이 잘 나옵니다.


팩토리얼(factorial) 은 단순히 1 부터  n 까지 곱한 것이라 생각하면 됩니다. 예를 들어 3 팩토리얼 (3! 이라 씁니다) 은 `1 * 2 * 3` 이라 생각하면 됩니다. 이 팩토리얼을 어떻게 하면 이전 예제와 같은 템플릿을 사용한 구조로 나타낼 수 있을까요? 사실 아래와 같이 매우 단순합니다.

```cpp-formatted
template <int N>
struct Factorial {
  static const int result = N * Factorial<N - 1>::result;
};
```



만약에 저 `Factorial` 을 일반적인 함수로 구성하려고 했다면 아마 아래와 같은 재귀 함수 형태를 사용했겠지요.

```cpp-formatted
int factorial(int n) {
  if (n == 1) return 1;

  return n * factorial(n - 1);
}
```



따라서 우리는 위 처럼 재귀 함수 호출이 끝나게 하기 위해선, `n` 이 1 일 때 따로 처리를 해주어야 합니다. 템플릿 역시 마찬가지로 `n = 1` 일 때 따로 처리할 수 있는데 바로 아래 처럼 템플릿 특수화를 이용해주면 됩니다.

```cpp-formatted
template <>
struct Factorial<1> {
  static const int result = 1;
};
```



컴파일러는 `Factorial<1>` 타입의 경우만 따로 `result = 1` 로 만들어주게 되어서 재귀적 구조가 끝날 수 있게 해줍니다.


위 예제에서 볼 수 있듯이, 저기서 실질적으로 값을 가지는 객체는 아무 것도 없습니다. 즉, '720' 이라는 값을 가지고 있는 변수는 메모리 상에서 없다는 뜻입니다 (물론 `cout` 에서 출력 할 때 빼고). 저 화면에 나타나는 720 이라는 값은, 단순히 컴파일러가 만들어낸 `Factorial<6>` 이라는 타입을 나타내고 있을 뿐입니다.



사실 여러분 한테 `factorial` 을 계산하라는 함수를 만들라고 이야기 했다면 십중팔구 그냥 단순히 `for` 문으로 구현을 하였을 것입니다. 하지만 안타깝게도 템플릿으로는 `for` 문을 쓸 수 없기 때문에 위와 같은 재귀적 구조를 사용하였습니다. 한 가지 다행인 소식은 `for` 문으로 구현할 수 있는 모든 코드는 똑같이 템플릿 메타 프로그래밍을 이용해서 구현할 수 있습니다.


더군다나 위에서 보셨듯이 `if` 문 역시 템플릿 메타 프로그래밍으로 구현할 수 있습니다. 위 팩토리얼 예제에서도 알 수 있듯이, if 문 부분은 템플릿 특수화로 처리 가능합니다.



###  TMP 를 왜 쓰는가?


한 가지 재미있는 사실은어떠한 C++ 코드도 템플릿 메타 프로그래밍 코드로 변환할 수 있다는 점입니다(물론 엄청나게 코드가 길어지겠지만요). 게다가 템플릿 메타 프로그래밍으로 작성된 코드는 모두 컴파일 타임에 모든 연산이 끝나기 때문에 프로그램 실행 속도를 향상 시킬 수 있다는 장점이 있습니다 (당연히도 컴파일 시간은 엄청 늘어나게 됩니다).

하지만 그렇다고 해서 템플릿 메타 프로그래밍으로 프로그램 전체를 구현하는 일은 없습니다. 일단 템플릿 메타 프로그래밍은 매우 복잡합니다. 물론 위 `Factorial` 예제는 꽤 간단하였지만 아래 좀 더 복잡한 예제를 다루면서 왜 템플릿 메타 프로그래밍이 힘든 것인지 이야기 하겠습니다.

그 뿐만이 아니라, 템플릿 메타 프로그래밍으로 작성된 코드는 버그를 찾는 것이 매우 힘듭니다. 일단 기본적으로 '컴파일' 타임에 연산하는 것이기 때문에 디버깅이 불가능 하고, C++ 컴파일러에 특성 상 템플릿 오류 시에 엄청난 길이의 오류를 내뿜게 됩니다.

따라서 `TMP` 를 이용하는 경우는 꽤나 제한적이지만, 많은 C++ 라이브러리들이 `TMP` 를 이용해서 구현되었고 (Boost 라이브러리), `TMP` 를 통해서 컴파일 타임에 여러 오류들을 잡아낼 수 도 있고 (Ex. 단위나 통화 일치 여부등등) 속도가 매우 중요한 프로그램의 경우 `TMP` 를 통해서 런타임 속도도 향상 시킬 수 있습니다.

아래에서 좀 더 복잡한 예제를 가지고 그렇다면 `TMP` 를 어떻게 사용할 지에 대해서 자세히 알아보도록 하겠습니다.

컴퓨터 상에서 두 수의 최대공약수를 구하기 위해선 보통 유클리드 호제법을 이용합니다. 이는 매우 간단한데, 이 알고리즘을 일반적인 함수로 나타내자면 아래와 같습니다.

```cpp-formatted
int gcd(int a, int b) {
  if (b == 0) {
    return a;
  }

  return gcd(b, a % b);
}
```

따라서 이를 그대로 `TMP` 로 바꿔보면 아래와 같습니다. (여러분도 직접 해보세요!)

```cpp-formatted
#include <iostream>
using namespace std;

template <int X, int Y>
struct GCD {
  static const int value = GCD<Y, X % Y>::value;
};

template <int X>
struct GCD<X, 0> {
  static const int value = X;
};

int main() { cout << "gcd (36, 24) :: " << GCD<36, 24>::value << endl; }
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23373A49595058531B9B43)



와 같이 잘 계산됩니다.


이 최대 공약수 계산 클래스를 만든 이유는, 바로 `Ratio` 클래스를 만들기 위함입니다. `Ratio` 클래스는 유리수(p/q 꼴로 쓸 수 있는 수) 를 오차 없이 표현해 주는 클래스 입니다. 물론 `TMP` 를 사용하지 않고 간단하게 클래스를 사용해서도 만들 수 있습니다. 하지만 일단 연습 삼아서 한 번 `TMP` 를 사용해서 만들어 보겠습니다.

```cpp-formatted
template <int N, int D = 1>
struct Ratio {
  typedef Ratio<N, D> type;
  static const int num = N;
  static const int den = D;
};
```



먼저 `Ratio` 클래스는 위 처럼 정의할 수 있겠습니다. 위 처럼 분자와 분모를 템플릿 인자로 받고, 타입을 나타내게 됩니다. 참고로 편의상

```cpp-formatted
typedef Ratio<N, D> type;
```



`typedef` 로 '자기 자신을 가리키는 타입' 을 넣어 주었습니다. 이는 마치 클래스에서의 `this` 와 비슷한 역할입니다.


그렇다면 이 `Ratio` 로 덧셈을 수행하는 템플릿을 만들어보겠습니다. 상당히 직관적입니다.

```cpp-formatted
template <class R1, class R2>
struct _Ratio_add {
  typedef Ratio<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den> type;
};
```



두 분수의 더한 결과를 `Ratio` 에 분자 분모로 전달하면 알아서 기약분수로 만들어줍니다.

```cpp-formatted
typedef Ratio<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den> type;
```



그 후에, 그 덧셈 결과를 `type` 로 나타내게 됩니다. 따라서 덧셈을 수행하기 위해서는

```cpp-formatted
typedef _Ratio_add<rat, rat2>::type result;
```



이런 식으로 사용하면 되겠지요. 하지만 한 발 더 나아가서, 귀찮게 ::type 를 치고 싶지 않다고 해 봅시다. 다시 말해 `Ratio_add` 를 하면 그 자체로 두 `Ratio` 가 더해진 타입이 되는 것이지요. 이는 아래와 같이 구현할 수 있습니다.


```cpp-formatted
template <class R1, class R2>
struct Ratio_add : _Ratio_add<R1, R2>::type {};
```



바로 `_Ratio_add<R1, R2>::type` 를 상속 받는 `Ratio_add` 클래스를 만들어 버리는 것입니다! 상당히 재미있는 아이디어입니다. 따라서 `Ratio_add` 는 마치 `Ratio` 타입 처럼 사용할 수 있게 됩니다. 전체 코드를 살펴 보자면 아래와 같습니다.

```cpp-formatted
#include <iostream>
#include <typeinfo>
using namespace std;

template <int X, int Y>
struct GCD {
  static const int value = GCD<Y, X % Y>::value;
};

template <int X>
struct GCD<X, 0> {
  static const int value = X;
};

template <int N, int D = 1>
struct Ratio {
  typedef Ratio<N, D> type;
  static const int num = N;  // 분자
  static const int den = D;  // 분모
};
template <class R1, class R2>
struct _Ratio_add {
  typedef Ratio<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den> type;
};

template <class R1, class R2>
struct Ratio_add : _Ratio_add<R1, R2>::type {};

int main() {
  typedef Ratio<2, 3> rat;
  typedef Ratio<3, 2> rat2;
  typedef Ratio_add<rat, rat2> rat3;

  cout << rat3::num << " / " << rat3::den << endl;

  return 0;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2776165059506A812E3256)





와 같이 잘 계산되서 나옵니다.


참고로 `C++11` 부터 `typedef` 대신에 좀 더 직관적인 `using` 이라는 키워드를 사용할 수 있습니다.

```cpp-formatted
typedef Ratio_add<rat, rat2> rat3;
using rat3 = Ratio_add<rat, rat2>;
```



위 두 문장 모두 동일한 의미를 가집니다. 다만 `using` 을 사용하였을 경우 `typedef` 보다 좀 더 이해하기가 쉽습니다. 특히, 함수 포인터의 경우 만일 `void` 를 리턴하고 `int, int` 를 인자로 받는 함수의 포인터의 타입을 `func` 라고 정의하기 위해서는 `typedef` 로

```cpp-formatted
typedef void (*func)(int, int);
```



위와 같이 사용해야 했지만 (놀랍게도 `func` 이 새로 정의된 타입 이름이 됩니다) `using` 키워드를 사용하면

```cpp-formatted
using func = void (*)(int, int);
```



아래와 같이 매우 직관적으로 나타낼 수 있습니다. 따라서 위의 코드를 수정하자면;

```cpp-formatted
int main() {
  using rat = Ratio<2, 3>;
  using rat2 = Ratio<3, 2>;

  using rat3 = Ratio_add<rat, rat2>;
  cout << rat3::num << " / " << rat3::den << endl;

  return 0;
}
```



로 간단하고 좀 더 직관적으로 나타낼 수 있습니다. 다시 한 번 말하지만, 마치 `Ratio` 클래스의 객체를 생성한 것 같지만, 실제로 생성된 객체는 한 개도 없고, 단순히 타입들을 컴파일러가 만들어낸 것 뿐입니다.


마찬가지 방법으로 모든 사칙연산들을 구현하자면 아래와 같습니다.


```cpp-formatted
#include <iostream>
using namespace std;

template <int X, int Y>
struct GCD {
  static const int value = GCD<Y, X % Y>::value;
};

template <int X>
struct GCD<X, 0> {
  static const int value = X;
};

template <int N, int D = 1>
struct Ratio {
 private:
  const static int _gcd = GCD<N, D>::value;

 public:
  typedef Ratio<N / _gcd, D / _gcd> type;
  static const int num = N / _gcd;
  static const int den = D / _gcd;
};
template <class R1, class R2>
struct _Ratio_add {
  using type = Ratio<R1::num * R2::den + R2::num * R1::den, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_add : _Ratio_add<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_subtract {
  using type = Ratio<R1::num * R2::den - R2::num * R1::den, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_subtract : _Ratio_subtract<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_multiply {
  using type = Ratio<R1::num * R2::num, R1::den * R2::den>;
};

template <class R1, class R2>
struct Ratio_multiply : _Ratio_multiply<R1, R2>::type {};

template <class R1, class R2>
struct _Ratio_divide {
  using type = Ratio<R1::num * R2::den, R1::den * R2::num>;
};

template <class R1, class R2>
struct Ratio_divide : _Ratio_divide<R1, R2>::type {};

int main() {
  using r1 = Ratio<2, 3>;
  using r2 = Ratio<3, 2>;

  using r3 = Ratio_add<r1, r2>;
  cout << "2/3 + 3/2 = " << r3::num << " / " << r3::den << endl;

  using r4 = Ratio_multiply<r1, r3>;
  cout << "13 / 6 * 2 /3 = " << r4::num << " / " << r4::den << endl;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F237B10405950A66E12890D)



와 같이 나옵니다.


자 여기까지 따라 오셨다면 한 가지 궁금증이 들 것입니다.



"음 그래. `Ratio` 로 이용해서 재미있는 것을 할 수 있는거 같애. 컴파일 타임에 유리수 사칙 연산을 계산할 수 있다는 것도 좋아. 근데 도대체 저게 왜 필요하지?"


바로 다음 강좌에서 알아 보도록 하겠습니다!



###  생각 해보기

#### 문제 1

`N` 번째 피보나치 수를 나타내는 `TMP` 를 만들어보세요. 참고로 피보나치 수는, `N` 번째 항이 `N - 1` 번째 항과 `N - 2` 번째 항의 합으로 정의되는 수 입니다. 참고로 1, `1, 2, 3, 5, ...` 로 진행됩니다.(난이도 : 하)

```cpp-formatted
int main() {
  cout << "5 번째 피보나치 수 :: " << fib<5>::result << endl;  // 5
}
```

#### 문제 2

`TMP` 를 사용해서 어떤 수가 소수인지 아닌지를 판별하는 프로그램을 만들어보세요. (난이도 : 상)참고로 이 문제는 다음 강좌에서 다룰 예정입니다!


```cpp-formatted
int main() {
  cout << boolalpha;
  cout << "Is prime ? :: " << is_prime<2>::result << endl;   // true
  cout << "Is prime ? :: " << is_prime<10>::result << endl;  // false

  cout << "Is prime ? :: " << is_prime<11>::result << endl;  // true
  cout << "Is prime ? :: " << is_prime<61>::result << endl;  // true
}
```

##@ chewing-cpp-end
Link :  219
2017-04-07 07:59
----------------
title : 씹어먹는 C++ - <9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)>
cat_title: 9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)
next_page : 221
publish_date : 2017-04-07 07:59
--------------

이번 강좌에서는

* C++ 템플릿 (template) 도입
* 클래스 템플릿과 함수 템플릿
* 템플릿 인스턴스화와 템플릿 특수화
* 함수 객체 (Functor)

에 대해서 배웁니다.


![](/img/ChewingCpplogo.png)

안녕하세요 여러분! 지난번 강좌 생각해보기는 잘 해결 하셨나요? 뭐 해결 하지 못하고 넘어왔더라도 괜찮습니다. 이번 강좌에서는 여태까지 배워 왔던 것과 전혀 다른 새로운 세계를 탐험해 볼 것입니다.

지난번 강좌에서 벡터와 스택 자료형을 만드셨던 것을 기억 하시나요? **벡터(vector)** 는 쉽게 생각하면 가변 길이 배열로 사용자가 배열 처럼 사용하는데 크기를 마음대로 줄이고 늘일 수 있는 편리한 자료형입니다. **스택(stack)**의 경우 나중에 들어간 것이 먼저 나온다(*LIFO - last in first out*) 형태의 자료형으로 `pop` 과 `push` 를 통해서 여러가지 작업들을 처리할 수 있습니다.

하지만 한 가지 문제는 우리가 담으려고 하는 데이터 타입이 바뀔 때 마다 다른 벡터를 만들어주어야 한다는 점이 있습니다. 예를 들어서 아래의 `Vector` 클래스를 살펴봅시다.

```cpp-formatted
class Vector {
  string* data;
  int capacity;
  int length;

 public:
  // 생성자
  Vector(int n = 1) : data(new string[n]), capacity(n), length(0) {}

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(string s) {
    if (capacity <= length) {
      string* temp = new string[capacity * 2];
      for (int i = 0; i < length; i++) {
        temp[i] = data[i];
      }

      delete[] data;
      data = temp;
      capacity *= 2;
    }

    data[length] = s;
    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  string operator[](int i) { return data[i]; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      data[i - 1] = data[i];
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }

  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};
```

위 `Vector` 클래스의 경우 `string` 데이터 밖에 저장할 수 없습니다. 만일 사용자가 `int` 를 원한다면 어떨까요? 혹은 `char` 데이터를 담고 싶다면 어떻게 할까요? 물론, 각각의 경우에서 코드만 살짝 살짝 바꿔주면 될 것입니다. 예를 들어서 `char` 을 담는 `Vector` 의 경우

```cpp-formatted
class Vector {
  char* data;
  int capacity;
  int length;

 public:
  // 생성자
  Vector(int n = 1) : data(new char[n]), capacity(n), length(0) {}

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(char s) {
    if (capacity <= length) {
      char* temp = new char[capacity * 2];
      for (int i = 0; i < length; i++) {
        temp[i] = data[i];
      }
      delete[] data;
      data = temp;
      capacity *= 2;
    }

    data[length] = s;
    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  char operator[](int i) { return data[i]; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      data[i - 1] = data[i];
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }

  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};
```

위와 같이 `string` 부분만 살짝 `char` 로 바꿔주면 됩니다. 하지만 이는 큰 낭비가 아닐 수 없습니다. 위 `char` 을 보관하는 `vector` 와 `string` 을 보관하는 `vector` 의 코드는 단순히 `string` 부분이 `char` 로 바뀐 차이 밖에 없습니다. 나머지 부분은 정확히 일치합니다.

쉽게 말해서 우리가 `T` 라는 타입의 객체들을 보관하는 `vector` 를 만들고 싶을 경우

```cpp-formatted
class Vector {
  T* data;
  int capacity;
  int length;

 public:
  // 생성자
  Vector(int n = 1) : data(new T[n]), capacity(n), length(0) {}

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(T s) {
    if (capacity <= length) {
      T* temp = new T[capacity * 2];
      for (int i = 0; i < length; i++) {
        temp[i] = data[i];
      }
      delete[] data;
      data = temp;
      capacity *= 2;
    }

    data[length] = s;
    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  T operator[](int i) { return data[i]; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      data[i - 1] = data[i];
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }

  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};
```

만약에 우리가 `int` 를 담는 `vector` 가 필요할 경우 `T` 를 `int` 로 바뀌면 되고, `string` 을 담는 것이 필요하다면 `T` 가 `string` 으로 바뀌면 됩니다. 쉽게 말해 컴파일러가 `T` 부분에 우리가 원하는 타입으로 채워서 코드를 생성해주면 엄청 편할 것입니다.


마치 어떠한 틀에 타입을 집어넣으면 원하는 코드가 딱딱 튀어 나오는 틀 같이 말이죠.

###  C++ 템플릿(template)

놀랍게도, 우리가 원하는 작업을 C++ 에서는 `template` 이라는 이름으로 지원하고 있습니다. 영어 단어 `template` 의 뜻을 찾아보자면, 형판 이라고 나옵니다. 쉽게 말해 어떠한 물건을 찍어내는 틀 이라고 생각하면 됩니다.

C++ 에서도 정확히 같은 의미로 사용되고 있습니다. 사용자 (프로그래머)가 원하는 타입을 넣어주면 딱딱 알아서 코드를 찍어내는 틀 이라고 생각하면 됩니다 C++ 에서도 정확히 같은 의미로 사용되고 있습니다. 사용자 (프로그래머)가 원하는 타입을 넣어주면 딱딱 알아서 코드를 찍어내는 틀 이라고 생각하면 됩니다.

```cpp-formatted
// 템플릿 첫 활용
#include <iostream>
#include <string>
using namespace std;

template <typename T>
class Vector {
  T* data;
  int capacity;
  int length;

 public:
  // 생성자
  Vector(int n = 1) : data(new T[n]), capacity(n), length(0) {}

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(T s) {
    if (capacity <= length) {
      T* temp = new T[capacity * 2];
      for (int i = 0; i < length; i++) {
        temp[i] = data[i];
      }
      delete[] data;
      data = temp;
      capacity *= 2;
    }

    data[length] = s;
    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  T operator[](int i) { return data[i]; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      data[i - 1] = data[i];
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }

  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};

int main() {
  // int 를 보관하는 벡터를 만든다.
  Vector<int> int_vec;
  int_vec.push_back(3);
  int_vec.push_back(2);

  cout << "-------- int vector ----------" << endl;
  cout << "첫번째 원소 : " << int_vec[0] << endl;
  cout << "두번째 원소 : " << int_vec[1] << endl;

  Vector<string> str_vec;
  str_vec.push_back("hello");
  str_vec.push_back("world");
  cout << "-------- string vector -------" << endl;
  cout << "첫번째 원소 : " << str_vec[0] << endl;
  cout << "두번째 원소 : " << str_vec[1] << endl;
}
```

성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F256BAA3958E4332F1E0C9C)

와 같이 나옵니다.


일단 클래스 상단에 템플릿이 정의된 부분을 살펴봅시다.

```cpp-formatted
template <typename T>
class Vector {
  T* data;
  int capacity;
  // ...
```


맨 위에

```info
template <typename T>
```

는아래에 정의되는 클래스에 대해 템플릿을 정의하고, 템플릿 인자로 `T` 를 받게 되며, `T` 는 반드시 어떠한 타입의 이름임을 명시하고 있습니다.위 경우 템플릿 문장 아래 오는 것이 `class Vector` 이므로 이 `Vector` 클래스에 대한 템플릿을 명시하는데, 만약에 밑에 오는 것이 함수일 경우 함수에 대한 템플릿이 됩니다. (밑에 함수 템플릿에 대해서도 설명하겠습니다).


참고로, 간혹

```info
template <class T>
```



라고 쓰는 경우도 있는데, 이는 정확히 `typename T` 와 동일한 것 입니다. `class T` 라고 해서 `T` 자리에 꼭 클래스가 와야 하는 것이 아닙니다. 똑같이 `int, char` 등이 올 수 있습니다. 다시말해;

```info
template <typename T> 와 template <class T> 는 같습니다.
```



왜 똑같은 템플릿에 두 개의 키워드를 정의하였냐였는지는 C++ 의 역사와 관련이 있습니다. C++ 을 처음 만들었던 `Bjarne Stroustrup` 은 처음에 `template` 의 인자로 `class` 키워드를 사용하였는데, 굳이 새로운 키워드를 만들고 싶지 않아서 였기 때문입니다. 하지만, 시간이 흘러서 C++ 위원회는 이로 인한 혼동을 막기 위해 (왜냐하면 `class T` 라 하면 `T` 자리에 꼭 클래스만 와야 하는 것 처럼 느껴지니까) `typename` 이라는 이름을 사용하기로 하였습니다. 물론, 이전 코드와의 호환을 위해 `class` 는 그대로 남겨 놓았지요. (자세한 내막은 http://stackoverflow.com/questions/213121/use-class-or-typename-for-template-parameters 참조)


이렇게 정의한 템플릿의 인자에 값을 전달하기 위해서는

```cpp-formatted
Vector<int> int_vec;
```



와 같이, `<>` 안에 전달하려는 것을 명시해주면 됩니다.  우리의 `Vector` 템플릿은 템플릿 인자로 타입을 받게 되는데, 위 경우 T 에 `int` 가 전달되게 됩니다.


여태까지는 인자로 특정한 '값' 혹은 '객체' 를 전달해왔지만 '타입' 그 자체를 전달한 적은 없었습니다. 하지만 템플릿을 통해 타입을 전달할 수 있게 됩니다.

```cpp-formatted
Vector<int>  // 혹은

  Vector<string>
```



위와 같이 `Vector` 의 템플릿의 인자에 타입을 전달하게 되면, 컴파일러는 이것을 보고 실제 코드를 생성하게 됩니다. 예를 들어서, `Vector <int>` 의 경우

```cpp-formatted
class Vector {
  int* data;
  int capacity;
  int length;

 public:
  // 어떤 타입을 보관하는지
  typedef T value_type;

  // 생성자
  Vector(int n = 1) : data(new int[n]), capacity(n), length(0) {}

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(int s) {
    if (capacity <= length) {
      int* temp = new int[capacity * 2];
      for (int i = 0; i < length; i++) {
        temp[i] = data[i];
      }
      delete[] data;
      data = temp;
      capacity *= 2;
    }

    data[length] = s;
    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  int operator[](int i) { return data[i]; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      data[i - 1] = data[i];
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }

  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};
```
`T` 가 정확히 `int` 로 치환된 위와 같은 코드를 찍어내겠지요. `Vector<string>` 의 경우 마찬가지로 `T` 가 `string` 으로 치환된 코드를 생성하게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F231FA84A58E4D77C0594AF)

위 사진 처럼, `template` 에 인자로 어떠한 타입을 전달하냐에 따라 `int` 를 저장하는 `Vector` 를 만들거나, `string` 을 저장하는 `Vector` 를 만들어낼 수 있는 것입니다. 마치 틀에 쇳물을 넣으면 쇠로 된 물건이 나오고, 구리물을 넣으면 구리로 된 물건이 나오는 것 처럼 말입니다.

```cpp-formatted
Vector<int> int_vec;
```

따라서 위 코드는 `Vector` 의 `T` 가 `int` 로 치환된 클래스의 객체 `int_vec` 을 생성하게 되는 것이지요. 위와 같이 클래스 템플릿에 인자를 전달해서 실제 코드를 생성하는 것을 클래스 템플릿 인스턴스화 (class template instantiation) 라고 합니다.


템플릿이 인스턴스화 되지 않고 덩그러니 있다면 컴파일 시에 아무런 코드로 변환되지 않습니다. 템플릿은 반드시 인스턴스화 되어야지만 비로소 컴파일러가 실제 코드를 생성하게 되지요. 마치 틀 자체로는 아무런 의미가 없지만, 그 틀에 채워넣어 나오는 물건에 관심이 있는 것 처럼 말이지요.

위와 같이 템플릿에 사용자가 원하는 타입을 템플릿 인자로 전달하면, 컴파일러는 그 인자를 바탕으로 코드를 생성하여 이를 컴파일 하게 됩니다. 하지만, 간혹 일부 타입에 대해서는 다른 방식으로 처리해야 할 경우가 있습니다.

예를 들어서 `bool` 데이터를 보관하는 벡터를 생각해봅시다.

```cpp-formatted
Vector<bool> int_vec;
```



사실 쉽게 생각해보면 그냥 위 처럼 템플릿 인자에 `bool` 을 전달하여 `bool` 을 저장하는 벡터로 사용할 수 도 있을 것입니다. 하지만 문제가 하나 있는데, C++ 에서 기본으로 처리하는 단위가 `1 byte` 라는 점입니다.


다시 말해 사실 `bool` 데이터 형은 1개 비트 만으로도 충분히 저장할 수 있지만, 8 비트를 사용해서 1개 `bool` 값을 저장해야 된다는 뜻이지요. 이는 엄청난 메모리 낭비가 아닐 수 없습니다. 따라서 우리는 `Vector<bool>` 에 대해서는 특별히 따로 처리해줘야만 합니다. '



###  템플릿 특수화 (template specialization)




이와 같이 일부 경우에 대해서 따로 처리하는 것을 템플릿 특수화 라고 합니다. 템플릿 특수화는 다음과 같이 수행할 수 있습니다. 예를 들어서

```cpp-formatted
template <typename A, typename B, typename C>
class test {};
```

위와 같은 클래스 템플릿이 정의되어 있을 때, "아 나는 `A` 가 `int` 고 C 가 `double` 일 때 따로 처리하고 싶어!" 면,


```cpp-formatted
template <typename B>
class test<int, B, double> {};
```




와 같이 특수화 하고 싶은 부분에 원하는 타입을 전달하고 위에는 일반적인 템플릿을 쓰면 되겟지요. 만약에 `B` 조차도 특수화 하고 싶다면,

```cpp-formatted
template <>
class test<int, int, double> {};
```




와 같이 써주면 됩니다. 한 가지 중요한 점은, 전달하는 템플릿 인자가 없더라도 특수화 하고 싶다면 `template<>` 라도 남겨줘야 된다는 점입니다. 그렇다면 우리의 `bool` 벡터의 경우;

```cpp-formatted
template <>
class Vector<bool> {
  ...  // 원하는 코드
}
```

와 같이 따로 처리해주면 되겠지요.


`Vector<bool>` 을 구현하기 위해서는 저는 평범한 `int` 배열을 이용할 것입니다. 1 개의 `int` 는 4 바이트 이므로, 32 개의 `bool` 데이터들을 한데 묶어서 저장할 수 있겠지요. 이를 통해서 원래 방식대로라면 `bool` 이 1 바이트로 저장되지만, 이렇게 하면 `bool` 을 1 비트로 정확히 표현할 수 있게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F26389B3958E4E2BB16AC95)



이렇게 한데 묶어서 저장하면 메모리 관련 측면에서는 효율이 매우 높아지지만, 이를 구현하는데는 조금 더 복잡해집니다. 왜냐하면 `int` 데이터에서 정확히 한 비트의 정보만 뽑아서 보여주어야 하기 때문이지요. 예를 들어서 `N` 번째 `bool` 데이터는 `N / 32` 번째 `int` 에 들어가 있고, 그 안에서 정확히 `N % 32` 번째 비트가 됩니다.


이와 같은 내용으로 구현을 하면 다음과 같습니다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

template <typename T>
class Vector {
  T* data;
  int capacity;
  int length;

 public:
  // 어떤 타입을 보관하는지

  typedef T value_type;

  // 생성자
  Vector(int n = 1) : data(new T[n]), capacity(n), length(0) {}

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(T s) {
    if (capacity <= length) {
      T* temp = new T[capacity * 2];
      for (int i = 0; i < length; i++) {
        temp[i] = data[i];
      }
      delete[] data;
      data = temp;
      capacity *= 2;
    }

    data[length] = s;
    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  T operator[](int i) { return data[i]; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      data[i - 1] = data[i];
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }

  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};

template <>
class Vector<bool> {
  unsigned int* data;
  int capacity;
  int length;

 public:
  typedef bool value_type;

  // 생성자
  Vector(int n = 1)
      : data(new unsigned int[n / 32 + 1]), capacity(n / 32 + 1), length(0) {
    for (int i = 0; i < capacity; i++) {
      data[i] = 0;
    }
  }

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(bool s) {
    if (capacity * 32 <= length) {
      unsigned int* temp = new unsigned int[capacity * 2];
      for (int i = 0; i < capacity; i++) {
        temp[i] = data[i];
      }
      for (int i = capacity; i < 2 * capacity; i++) {
        temp[i] = 0;
      }

      delete[] data;
      data = temp;
      capacity *= 2;
    }

    if (s) {
      data[length / 32] |= (1 << (length % 32));
    }

    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  bool operator[](int i) { return (data[i / 32] & (1 << (i % 32))) != 0; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      int prev = i - 1;
      int curr = i;

      // 만일 curr 위치에 있는 비트가 1 이라면
      // prev 위치에 있는 비트를 1 로 만든다.
      if (data[curr / 32] & (1 << (curr % 32))) {
        data[prev / 32] |= (1 << (prev % 32));
      }
      // 아니면 prev 위치에 있는 비트를 0 으로 지운다.
      else {
        unsigned int all_ones_except_prev = 0xFFFFFFFF;
        all_ones_except_prev ^= (1 << (prev % 32));
        data[prev / 32] &= all_ones_except_prev;
      }
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }
  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};

int main() {
  // int 를 보관하는 벡터를 만든다.
  Vector<int> int_vec;
  int_vec.push_back(3);
  int_vec.push_back(2);

  cout << "-------- int vector ----------" << endl;
  cout << "첫번째 원소 : " << int_vec[0] << endl;
  cout << "두번째 원소 : " << int_vec[1] << endl;

  Vector<string> str_vec;
  str_vec.push_back("hello");
  str_vec.push_back("world");
  cout << "-------- string vector -------" << endl;
  cout << "첫번째 원소 : " << str_vec[0] << endl;
  cout << "두번째 원소 : " << str_vec[1] << endl;

  Vector<bool> bool_vec;
  bool_vec.push_back(true);
  bool_vec.push_back(true);
  bool_vec.push_back(false);
  bool_vec.push_back(false);
  bool_vec.push_back(false);
  bool_vec.push_back(true);
  bool_vec.push_back(false);
  bool_vec.push_back(true);
  bool_vec.push_back(false);
  bool_vec.push_back(true);
  bool_vec.push_back(false);
  bool_vec.push_back(true);
  bool_vec.push_back(false);
  bool_vec.push_back(true);
  bool_vec.push_back(false);
  bool_vec.push_back(true);
  bool_vec.push_back(false);

  cout << "-------- bool vector ---------" << endl;
  for (int i = 0; i < bool_vec.size(); i++) {
    cout << bool_vec[i];
  }
  cout << endl;
}
```

성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F232DED3658E4D77B3029B9)


와 같이 나옵니다.

```cpp-formatted
unsigned int* data;
int capacity;
int length;
```

먼저 `Vector<bool>` 의 멤버 변수들 부터 살펴봅시다. 일단, `int` 배열로 `unsigned int` 를 사용하기로 하였습니다. 굳이 `unsigned int` 를 사용한 이유는 그냥 `int` 를 사용했을 때 `shift` 연산 시에 귀찮은 문제가 발생할 수 도 있기 때문입니다.


`capacity` 는 생성된 `data` 배열의 크기를 의미하고 `length` 는 실제 `bool` 데이터의 길이를 의미합니다. 즉 1 `capacity` 에 32 개의 `bool` 이 들어갈 수 있게 되는 것이지요. (int 가 32 비트라 생각하면)

```cpp-formatted
// 맨 뒤에 새로운 원소를 추가한다.
void push_back(bool s) {
  if (capacity * 32 <= length) {
    unsigned int* temp = new unsigned int[capacity * 2];
    for (int i = 0; i < capacity; i++) {
      temp[i] = data[i];
    }

    for (int i = capacity; i < 2 * capacity; i++) {
      temp[i] = 0;
    }

    delete[] data;
    data = temp;
    capacity *= 2;
  }

  if (s) {
    data[length / 32] |= (1 << (length % 32));
  }
  length++;
}
```

다음으로 `push_back` 함수를 살펴보도록 합시다. 일단 윗 부분은 동일합니다. 만일 현재 길이가 `capacity` 를 초과하게 되면 현재 크기의 2 배로 새로 배열을 만들어서 복사하게 됩니다. 그리고 기본적으로 배열 전체를 0 으로 초기화 하기 때문에 기본적으로 `false` 로 설정되어 있다고 보시면 됩니다.

```cpp-formatted
if (s) {
  data[length / 32] |= (1 << (length % 32));
}
```



따라서 위 처럼 만일 `true` 를 추가하였을 때에만 해당 비트를 `true` 로 바꿔주면 됩니다. 어떤 비트에 1 을 `OR` 연산하게 되면 그 비트는 무조건 1 이 됩니다. 그리고 0 을 `OR` 연산하게 되면 그 비트의 값은 그대로 보존이 되지요. 따라서 `OR` 연산은 특정 비트에만 선택적으로 1로 바꾸는데 매우 좋은 연산입니다. 아래 그림을 보면 이해가 잘 되실 것입니다. 주변 나머지 비트들의 값은 보존하면서 특정 비트만 1 로 바꿔줍니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2240364758E4EA821BE62F)

위 경우에도 `1 << (length % 32)` 을 통해서 정확히 `length % 32` 번째 비트만 1 로 바꾼 뒤, `OR` 연산을 해서 해당 `int` 의 자리를 `true` 로 만들어 줄 수 있습니다.

```cpp-formatted
// 임의의 위치의 원소에 접근한다.
bool operator[](int i) { return (data[i / 32] & (1 << (i % 32))) != 0; }
```

그렇다면 임의의 위치에 접근하는 것은 어떨까요.

이번에는 거꾸로 `AND` 연산을 통해 해당 값을 가져올 수 있습니다. 어떤 비트에 0 을 `AND` 하게 되면 그 비트는 무조건 0 이 되고, 1 을 `AND` 연산 하게 되면 해당 비트가 1 이여야지만 1 이 됩니다. 즉, 1 을 `AND` 하게 되면 해당 비트의 값이 무엇인지 알아낼 수 있는 것입니다. 아래 그림을 보면 더 이해하기 쉽습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2407FE3C58E4F2C91ACF15)


```cpp-formatted
data[i / 32] & (1 << (i % 32))
```

따라서 위 작업을 수행하게 되면 해당 위치에 있는 비트가 1 일 때 에만 저 값이 0 이 아니게 되고 0 이면 저 값 전체가 0 이 됩니다.

```cpp-formatted
// x 번째 위치한 원소를 제거한다.
void remove(int x) {
  for (int i = x + 1; i < length; i++) {
    int prev = i - 1;
    int curr = i;

    // 만일 curr 위치에 있는 비트가 1 이라면
    // prev 위치에 있는 비트를 1 로 만든다.
    if (data[curr / 32] & (1 << (curr % 32))) {
      data[prev / 32] |= (1 << (prev % 32));
    }
    // 아니면 prev 위치에 있는 비트를 0 으로 지운다.
    else {
      unsigned int all_ones_except_prev = 0xFFFFFFFF;
      all_ones_except_prev ^= (1 << (prev % 32));
      data[prev / 32] &= all_ones_except_prev;
    }
  }
  length--;
}
```
마지막으로 `remove` 함수를 살펴봅시다.

사실 이전 버전에서는 그냥 오른쪽 원소를 왼쪽으로 쭈르륵 덮어 씌어나가는 방식으로 간단히 만들 수 있었지만 이 `bool` 버전의 경우 그 '왼쪽' 과 '오른쪽' 원소를 읽어내는거 자체가 꽤나 복잡하므로 간단하게는 구현하기 힘듧니다.

```cpp-formatted
// 만일 curr 위치에 있는 비트가 1 이라면
// prev 위치에 있는 비트를 1 로 만든다.
if (data[curr / 32] & (1 << (curr % 32))) {
  data[prev / 32] |= (1 << (prev % 32));
}
```
그래도 일단 특정 비트를 1 로 만드는 것은 간단합니다. 이전에도 하였듯이,  OR 을 수행해주면 됩니다.

```cpp-formatted
// 아니면 prev 위치에 있는 비트를 0 으로 지운다.
else {
  unsigned int all_ones_except_prev = 0xFFFFFFFF;
  all_ones_except_prev ^= (1 << (prev % 32));
  data[prev / 32] &= all_ones_except_prev;
}
```
그렇다면 오른쪽 비트가 0 일 때 왼쪽 비트를 0 으로 만드는 작업은 어떻게 할까요? 앞서 `AND` 연산의 경우 1 을 `AND` 하게 되면 원래 비트가 보존되고, 0 을 `AND` 하면 0 이 된다고 하였습니다. 따라서, 우리가 해야할 일은 원하는 자리의 비트만 0 이고 나머지는 1 인 것을 `AND` 해주면 됩니다. 그 과정을 수행하는 부분이 아래와 같습니다.

```cpp-formatted
unsigned int all_ones_except_prev = 0xFFFFFFFF;
all_ones_except_prev ^= (1 << (prev % 32));
```

`all_ones_except_prev` 는 0 으로 지우려고 하는 위치만 0 이고 나머지 부분은 1 인 값 입니다. 참고로 기억하는지는 모르겠지만, ^ 는 `XOR` 연산자로, 두 비트가 같으면 `0,` 다르면 1 이되는 연산 입니다 (덧셈을 생각하시면 됩니다). 따라서 `0xFFFFFFFF` 는 모든 비트가 1 인 `int` 인데, `XOR` 연산을 통해서 해당 비트만 0 으로 바꿔줍니다.

그 후에 `AND` 연산을 하게 되면 해당 비트만 0 으로 지워버릴 수 있게 되지요.

실제로, C++ 표준 라이브러리에서 `vector` 를 지원을 하는데, 그 구현을 살펴보면 위 처럼 `bool` 일 때만 따로 특수화 시켜서 처리하고 있습니다. C++ 표준 라이브러리의 `vector` 는 나중 강좌에서 다루도록 하겠습니다.

템플릿 특수화를 통해 템플릿 인자의 값이 특정 값일 때 따로 처리하는 방식에 대해 알아보았습니다.


###  함수 템플릿 (Function template)


이번에는 클래스 템플릿이 아닌 함수 템플릿에 대해 알아보도록 하겠습니다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

template <typename T>
T max(T& a, T& b) {
  return a > b ? a : b;
}

int main() {
  int a = 1, b = 2;
  cout << "Max (" << a << "," << b << ") ? : " << max(a, b) << endl;

  string s = "hello", t = "world";
  cout << "Max (" << s << "," << t << ") ? : " << max(s, t) << endl;
}
```

성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F26380B3E58E573D731A5E5)

와 같이 나옵니다.

```cpp-formatted
template <typename T>
T max(T& a, T& b) {
  return a > b ? a : b;
}
```

위 부분에서 템플릿 함수를 정의하고 있습니다. 클래스 템플릿과 마찬가지로, 위 함수도 인스턴스화 되기 전 까지는 컴파일 시에 아무런 코드로 변환되지 않습니다.

```cpp-formatted
cout << "Max (" << a << "," << b << ") ? : " << max(a, b) << endl;
```

실제로 위 템플릿 함수가 인스턴스화 되는 부분은 바로 위 코드에서 `max(a, b)` 가 호출되는 부분입니다. 신기하게도, 클래스를 인스턴스화 했을 때 와는 다르게 `<>` 하는 부분이 없습니다. 원래 대로라면

```cpp-formatted
max<int>(a, b)
```

이렇게 했었겠지요. 하지만 C++ 컴파일러는 생각보다 똑똑해서, `a` 와 `b` 의 타입을 보고 알아서 `max (a, b)` 를 `max<int>(a, b)` 로 인스턴스화 해줍니다.

```cpp-formatted
cout << "Max (" << s << "," << t << ") ? : " << max(s, t) << endl;
```

`string` 의 경우도 마찬가지 입니다. C++ 컴파일러가 알아서 `max<string>(s, t)` 로 생각해서 인스턴스화 해줍니다.

그렇다면 다음 함수를 살펴봅시다.

```cpp-formatted
template <typename Cont>
void bubble_sort(Cont& cont) {
  for (int i = 0; i < cont.size(); i++) {
    for (int j = i + 1; j < cont.size(); j++) {
      if (cont[i] > cont[j]) {
        cont.swap(i, j);
      }
    }
  }
}
```

위 함수는 임의의 컨테이너를 받아서 이를 정렬해 주는 함수 입니다 (사실 위 함수는 소위 말하는 거품 정렬 (버블소트) 방식을 사용하는데 매우 느립니다. 여러분들이 더 빠른 정렬 알고리즘(퀵소트, 등등)으로 구현해보세요!). 컨테이너란 쉽게 생각해서 데이터를 보관하는 것이라 생각하면 되는데, 앞서 소개하였던 `Vector` 도 하나의 예가 될 수 있습니다.

물론, 저 함수가 작동을 하려면 컨테이너에 `size` 함수와, `swap` 함수, 그리고 `[ ]` 연산자가 정의되어 있어야 겠지요.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;

template <typename T>
class Vector {
  T* data;
  int capacity;
  int length;

 public:
  // 어떤 타입을 보관하는지
  typedef T value_type;

  // 생성자
  Vector(int n = 1) : data(new T[n]), capacity(n), length(0) {}

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(int s) {
    if (capacity <= length) {
      int* temp = new T[capacity * 2];
      for (int i = 0; i < length; i++) {
        temp[i] = data[i];
      }
      delete[] data;
      data = temp;
      capacity *= 2;
    }

    data[length] = s;
    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  T operator[](int i) { return data[i]; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      data[i - 1] = data[i];
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }

  // i 번째 원소와 j 번째 원소 위치를 바꾼다.
  void swap(int i, int j) {
    T temp = data[i];
    data[i] = data[j];
    data[j] = temp;
  }

  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};

template <typename Cont>
void bubble_sort(Cont& cont) {
  for (int i = 0; i < cont.size(); i++) {
    for (int j = i + 1; j < cont.size(); j++) {
      if (cont[i] > cont[j]) {
        cont.swap(i, j);
      }
    }
  }
}

int main() {
  Vector<int> int_vec;
  int_vec.push_back(3);
  int_vec.push_back(1);
  int_vec.push_back(2);
  int_vec.push_back(8);
  int_vec.push_back(5);
  int_vec.push_back(3);

  cout << "정렬 이전 ---- " << endl;
  for (int i = 0; i < int_vec.size(); i++) {
    cout << int_vec[i] << " ";
  }

  cout << endl << "정렬 이후 ---- " << endl;
  bubble_sort(int_vec);
  for (int i = 0; i < int_vec.size(); i++) {
    cout << int_vec[i] << " ";
  }
  cout << endl;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F235F7B3358E5A6571B312A)

와 같이 나옵니다.

참고로 기존에 만들었던 `Vector` 에는 `swap` 함수가 없어서 새로 추가하였습니다.

```cpp-formatted
template <typename Cont>
void bubble_sort(Cont& cont) {
  for (int i = 0; i < cont.size(); i++) {
    for (int j = i + 1; j < cont.size(); j++) {
      if (cont[i] > cont[j]) {
        cont.swap(i, j);
      }
    }
  }
}
```
위 부분을 보면 정렬 함수를 템플릿으로 구현한 것을 볼 수 있습니다.

```cpp-formatted
bubble_sort(int_vec);
```

와 같이 위 함수를 호출한다면 컴파일러는 인자로 전달된 객체의 타입을 보고 알아서 인스턴스화 한 뒤에 컴파일 하게 되지요. 위 경우에 `int_vec` 이 `Vector<int>` 타입 이므로, `Cont` 에 Vector<int> 가 전달 될 것입니다.


다만 한 가지 중요한 사실은,

```cpp-formatted
for (int i = 0; i < cont.size(); i++) {
```
에서나,

```cpp-formatted
if (cont[i] > cont[j]) {
  cont.swap(i, j);
```

에서 `size(), operator[], swap()` 등이 사용되었다는 것입니다. 만약에 `Cont` 로 전달된 타입에 저러한 것들이 정의가 되어 있지 않다면 어떨까요? 예를 들어서

```info

struct dummy
{
};
dummy a;
bubble_sort(a);
```

를 하게 된다면

```warning
error C2039: 'size': is not a member of 'dummy'
// 생략 ...
```

컴파일 시에, 위와 같은 저 클래스에서 멤버 함수나 변수들을 찾을 수 없다는 오류들을 뿜어내게 됩니다. 당연한 이야기지만 이와 같이 템플릿으로 발생되는 오류는 프로그램이 실행되었을 때가 아니라 컴파일 할 때 발생한 다는 사실입니다. 왜냐하면 컴파일 시에 모든 템플릿을 실제 코드로 변환하여 실행하기 때문이지요.


재미있게도, 이와 같이 컴파일 시에 모든 템플릿들이 인스턴스화 되다는 사실을 가지고 또 여러가지 흥미로운 코드를 짤 수 있는데 이러한 방식을 템플릿 메타프로그래밍 (template metaprogramming) 이라고 합니다. 자세한 내용은 나중 강좌들에서 다루도록 하겠습니다.



그런데 위 `bubble_sort` 함수에서는 한 가지 부족한 점이 있습니다. 만약에, 정렬 순서를 역순으로 하고 싶다면 어떨까요? 위는 오름 차순으로 정렬하였지만, 간혹 내림 차순으로 정렬을 하고 싶을 수 도 있습니다. 아니면 아예 다른 기준으로 정렬을 할 수 도 있겠지요. 이를 위해서라면 크게 세 가지 방법이 있습니다.

1. `bubble_sort2` 를 만들어서 부등호 방향을 반대로 바꿔준다.
2. `operator>` 를 오버로딩해서 원하는 방식으로 만들어준다.
3. `cont[i]` 와 `cont[j]` 의 비교를 `>` 로 하지 말고 특정 함수에 넣어서 전달한다.



첫번째 방법은 C 를 배우는 단계에서나 적합한 방법입니다. 여러분은 C++ 를 배우고 있으니 더 나은 방법을 생각해야겠지요?
두번째 방법은 여러분들이 만든 객체를 사용할 때 적용할 수 있는 방법입니다. 예를 들어서,

```info

struct customClass {
// ..

bool operator< (const customClass & c) {
// Do something
}
};

Vector<customClass> a;
bubble_sort(a);
```



와 같이 여러분이 직접 정의한 클래스에 대해 `operator<` 를 오버로딩 할 수 있다면 원하는 방식으로 정렬을 수행할 수 있겠지요. 하지만 위 처럼 기본적으로 `operator<` 를 오버로딩 할 수 없는 상황이라면 어떨까요? 예를 들어서 `int` 나 `string` 은 이미 내부적으로 `operator<` 가 정의되어 있기 때문에 이를 따로 오버로딩을 할 수 없습니다.

그렇다면 3 번째 방법은 어떨까요?



###  함수 객체(Function `Object - Functor)` 의 도입


그럼 다음과 같은 함수를 생각해봅시다.
```cpp-formatted
template <typename Cont, typename Comp>

void bubble_sort(Cont& cont, Comp& comp) {
  for (int i = 0; i < cont.size(); i++) {
    for (int j = i + 1; j < cont.size(); j++) {
      if (!comp(cont[i], cont[j])) {
        cont.swap(i, j);
      }
    }
  }
}
```



위 함수는 기존의 `bubble_sort` 와는 달리 아예 `Comp` 라는 클래스를 템플릿 인자로 받고, 함수 자체도 `Comp` 객체를 따로 받습니다. 그렇다면 이 `comp` 객체가 무슨 일을 하냐면;

```cpp-formatted
if (!comp(cont[i], cont[j])) {
```



이 `if` 문에서 마치 함수를 호출하는 것 처럼 사용되는데, `cont[i]` 와 `cont[j]` 를 받아서 내부적으로 크기 비교를 수행한 뒤에 그 결과를 리턴하고 있습니다. 한 가지 중요한 사실은 `comp` 는 함수가 아니라 객체 이고, `Comp` 클래스에서 () 연산자를 오버로딩한 버전입니다. 자세한 내용은 아래 전체 코드를 보면서 설명하겠습니다.

```cpp-formatted
#include <iostream>
#include <string>
using namespace std;
template <typename T>
class Vector {
  T* data;
  int capacity;
  int length;

 public:
  // 어떤 타입을 보관하는지
  typedef T value_type;

  // 생성자
  Vector(int n = 1) : data(new T[n]), capacity(n), length(0) {}

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(int s) {
    if (capacity <= length) {
      int* temp = new T[capacity * 2];
      for (int i = 0; i < length; i++) {
        temp[i] = data[i];
      }
      delete[] data;
      data = temp;
      capacity *= 2;
    }

    data[length] = s;
    length++;
  }

  // 임의의 위치의 원소에 접근한다.
  T operator[](int i) { return data[i]; }

  // x 번째 위치한 원소를 제거한다.
  void remove(int x) {
    for (int i = x + 1; i < length; i++) {
      data[i - 1] = data[i];
    }
    length--;
  }

  // 현재 벡터의 크기를 구한다.
  int size() { return length; }

  // i 번째 원소와 j 번째 원소 위치를 바꾼다.
  void swap(int i, int j) {
    T temp = data[i];
    data[i] = data[j];
    data[j] = temp;
  }

  ~Vector() {
    if (data) {
      delete[] data;
    }
  }
};

template <typename Cont>
void bubble_sort(Cont& cont) {
  for (int i = 0; i < cont.size(); i++) {
    for (int j = i + 1; j < cont.size(); j++) {
      if (cont[i] > cont[j]) {
        cont.swap(i, j);
      }
    }
  }
}

template <typename Cont, typename Comp>
void bubble_sort(Cont& cont, Comp& comp) {
  for (int i = 0; i < cont.size(); i++) {
    for (int j = i + 1; j < cont.size(); j++) {
      if (!comp(cont[i], cont[j])) {
        cont.swap(i, j);
      }
    }
  }
}

struct Comp1 {
  bool operator()(int a, int b) { return a > b; }
};

struct Comp2 {
  bool operator()(int a, int b) { return a < b; }
};

int main() {
  Vector<int> int_vec;
  int_vec.push_back(3);
  int_vec.push_back(1);
  int_vec.push_back(2);
  int_vec.push_back(8);
  int_vec.push_back(5);
  int_vec.push_back(3);

  cout << "정렬 이전 ---- " << endl;
  for (int i = 0; i < int_vec.size(); i++) {
    cout << int_vec[i] << " ";
  }

  Comp1 comp1;
  bubble_sort(int_vec, comp1);

  cout << endl << endl << "내림차순 정렬 이후 ---- " << endl;
  for (int i = 0; i < int_vec.size(); i++) {
    cout << int_vec[i] << " ";
  }
  cout << endl;

  Comp2 comp2;
  bubble_sort(int_vec, comp2);

  cout << endl << "오름차순 정렬 이후 ---- " << endl;
  for (int i = 0; i < int_vec.size(); i++) {
    cout << int_vec[i] << " ";
  }
  cout << endl;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F27495C4458E6BF2C188F1C)



와 같이 나옵니다.

```cpp-formatted
struct Comp1 {
  bool operator()(int a, int b) { return a > b; }
};

struct Comp2 {
  bool operator()(int a, int b) { return a < b; }
};
```



일단 위 두 클래스를 살펴보도록 합시다. `Comp1` 과 `Comp2` 모두 아무 것도 하지 않고 단순히 `operator()` 만 정의하고 있습니다. 그리고 이 `Comp1` 과 `Comp2` 객체들은 `bubble_sort` 함수 안에서

```cpp-formatted
if (!comp(cont[i], cont[j])) {
```



마치 함수인양 사용되지요. 이렇게, 함수는 아니지만 함수 인 척을 하는 객체를 함수 객체 (Function Object), 혹은 줄여서 `Functor` 라고 부릅니다. 이 `Functor` 덕분에, `bubble_sort` 함수 내에서 두 객체간의 비교를 사용자가 원하는 대로 할 수 있게 되지요.


따라서 사용자들은 입맛에 맞게, 보통의 `<` 연산자로 비교를 수행하는

```cpp-formatted
template <typename Cont>
void bubble_sort(Cont& cont)
```



위 `bubble_sort` 함수를 사용하거나;

```cpp-formatted
template <typename Cont, typename Comp>
void bubble_sort(Cont& cont, Comp& comp)
```



특수한 경우에 따로 비교 하는 것을 직접 수행하고 싶은 경우에 `Comp` 객체를 받아서 비교를 수행하는 새로운 `bubble_sort` 함수를 사용할 수 있습니다.


물론

```cpp-formatted
bubble_sort(int_vec, comp1);
```



를 했다면 두 번째 버전으로 템플릿 인스턴스화 되서 함수가 호출되고,

```cpp-formatted
bubble_sort(int_vec);
```



그냥 위 처럼 한다면 첫 번째 버전으로 템플릿 인스턴스화 되서 함수가 호출되겠지요.

실제로, C++ 표준 라이브러리의 `sort` 함수를 살펴보아도 비교 클래스를 받지 않는

```info
template< class RandomIt >
void sort( RandomIt first, RandomIt last );
```

와

```info
template< class RandomIt,class Compare >
void sort( RandomIt first, RandomIt last,Compare comp );
```



비교 클래스를 받는 위 버전으로 구성되어 있습니다. (저 함수의 인자들에 대해서는 나중 강좌에서 자세히 다룰 테니 지금은 넘어가셔도 됩니다!)

이와 같이 비교 클래스를 받아서 원하는 비교 작업을 수행할 수 있게 됩니다. 만약에 C 였다면 위 `sort` 함수를 어떻게 만들었을 지 생각해봅시다. 일단 원하는 클래스를 받는 다는 생각 자체가 불가능하기 때문에 (template 이 없으니까) `functor` 는 꿈도 못 꾸었겠지요. 대신에, 비교 작업을 수행하는 함수의 포인터를 받아서 이를 처리하였을 것입니다.


그렇다면 뭐가 더 나은 방법일까요? `Functor?` 아니면 구닥다리 함수 포인터?


이미 예상하셨겠지만, `Functor` 를 사용하는것이 여러 모로 훨씬 편리한 점이 많습니다. 일단, 클래스 자체에 여러가지 내부 `state` 를 저장해서 비교 자체가 복잡한 경우에도 손쉽게 사용자가 원하는 방식으로 만들어낼 수 있습니다. 뿐만 아니라, 함수포인터로 함수를 받아서 처리한다면 컴파일러가 최적화를 할 수 없지만, `Functor` 를 넘기게 된다면 컴파일러가 `operator()` 자체를 인라인화 시켜서 매우 빠르게 작업을 수행할 수 있습니다. \sidenote{실제로 C 의 qsort 와 C++ 의 표준 sort 함수를 비교한다면 C++ 버전이 훨씬 빠릅니다. 왜냐하면 C 의 qsort 는 비교를 수행하기 위해 매번 함수를 호출시켜야 하지만, C++ 버전의 경우 그 함수를 인라인화 시켜버리면 되기 때문이지요. (함수 호출 필요 없음)}

이상으로 C++ 템플릿 첫 번째 강좌를 마치도록 하겠습니다. 다음 강좌에서는 템플릿이 C++ 에게 하사한 새로운 패러다임의 세계로 떠나볼 것입니다.

###  생각 해보기

#### 문제 1

`template` 을 사용해서 이전에 만들어 놓았던 `Excel` 프로젝트 코드를 깔끔하게 만들어보세요. 아마 10 배는 깔끔해질 것입니다 :) (난이도 : 下)

#### 문제 2

위 `Vector` 로 2차원, 3차원 배열 등을 똑같이 만들어낼 수 있을까요? (난이도 : 下)

#### 문제 3

위에서 컴파일러가 마법 처럼 템플릿 인자에 타입을 정해준다고 하지만 사실은 어떤 타입으로 추측할지 결정하는 일련의 규칙들이 있습니다. [자세한 내용은 여기](http://en.cppreference.com/w/cpp/language/template_argument_deduction) [를 참고해주세요](http://en.cppreference.com/w/cpp/language/template_argument_deduction)`!`

##@ chewing-cpp-end
Link :  220
2017-03-30 10:25
----------------
title : 비주얼 스튜디오 2017 커뮤니티에서 C/C++ 프로그래밍 하기
cat_title :  비주얼 스튜디오 2017 커뮤니티에서 C/C++ 프로그래밍 하기
path : /C
publish_date : 2017-03-30 10:25
--------------

```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```



안녕하세요 여러분. 2013년에 비주얼 스튜디오 2010 버전에서 `C/C++` 프로그래밍 하는 것을 업데이트 랍시고 올렸는데, 이제 시간이 많이 흘러서 이번에 새로 출시된 비주얼 스튜디오 2017 커뮤니티 버전에서 프로그래밍을 시작하는 방법에 대해 간단히 알아보도록 하겠습니다.


마이크로소프트에서 소프트웨어 개발 툴로 지원하는 프로그램은 크게 2 종류가 있는데요, 하나는 그냥 비주얼 스튜디오 이고, 다른 하나는 비주얼 스튜디오에서 몇 가지 기능을 뺀 비주얼 스튜디오 커뮤니티 버전입니다. 비주얼 스튜디오 커뮤니티 버전이 비주얼 스튜디오에서 몇 가지 기능이 빠졌다고 하지만, 여러분이 `C/C++` 프로그래밍 하는데 있어서 전혀 지장이 없습니다. (약간 회사에서 사용할 법 한 기능들이 빠졌지요).


비주얼 스튜디오 커뮤니티 버전은


 [https://www.visualstudio.com/vs/community/](https://www.visualstudio.com/vs/community/)


에서 받으실 수 있습니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2676893E58DC5A6402106D)

위와 같이 사이트에 들어가서 `Download VS Community 2017` 을 누르시면 됩니다. (제가 지금 미국에서 있어서 영어로 뜨지만 아마 한국에 계신 분들은 한국말로 뜰 것입니다 :)



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2763604A58DC5A642C5115)





다운로드 된 실행파일을 실행하면 위와 같이 뜹니다. `Continue` 를 눌러주세요


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2377554B58DC5A652B7F90)



이제 어떠한 것들을 설치할 지 선택할 수 있는데, 일단 여러분은 `C/C++` 을 배우는 것이 목적이므로 화면에 `Desktop development with C++` 만 선택해 주시면 됩니다. 혹시 내가 나중에 C# 이나 기타 등등으로 더 많은 코딩을 하고 싶다 그러시는 분들은 다른 것들을 선택해서 설치해주셔도 상관 없지만, 설치 용량이 엄청 커지게 됩니다. 저거 하나만 선택했는데에도 벌써 `5.61 GB` 네요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F27334D3C58DC5A6531172A)



그럼 이제 알아서 필요한 것들을 다운 받아서 설치하게 됩니다. 인터넷 상황에서 따라서 30분에서 1시간 정도 기다려야 합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F2758FB3858DC67FF0302F0)



설치가 다 되었으면 컴퓨터를 재시작 해야 합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27716B4C58DC67FE24EA96)



뭔가 가입하라고 나오는데 그냥 나중에 한다고 하고 무시하면 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2313A24658DC67FE212176)





그 다음으로 어떤 테마를 고를지 정하면 됩니다. 저의 경우 그냥 디폴트인 파란색 바탕을 사용하는데, 사람들에 따라서 어두운 테마를 좋아하는 경우도 있습니다 :)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F240BEE3958DC67FE073364)



이제 메인 화면에서 새로운 프로젝트를 만들어봅시다.


간단히 `Ctrl + Shift + N` 을 누르면 새 프로젝트를 만드는 창을 띄울 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2437B54058DC67FE25378A)



다음으로 프로젝트 선택 화면에서 `Win32 Console Application (Win32 콘솔 어플리케이션)` 을 선택합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2729344C58DCF43435069B)



'다음' 을 눌러줍니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2528FF3558DCF4342BD1FB)



빈 프로젝트에 체크해 주시면 프로젝트 생성이 완료됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F2325A94F58DCF4351586CA)



이제 프로젝트에 소스 파일을 추가해야 합니다.


기본적으로 왼쪽에 보시면 솔루션 탐색기에서 소스 파일을 쉽게 추가할 수 있는데, 솔루션 탐색기가 안보인다면, `Ctrl + Alt + L` 을 눌러서 띄울 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2445D24D58DCF435315473)



이제 C 프로그래밍을 하고 싶다면 이름에 `Hello.c` 처럼 확장자 명을 `.c` 로 명시해야 하고, C++ 로 프로그래밍 하고 싶다면 위 사진 처럼 그냥 확장자를 빼면 알아서 `cpp` 파일로 만들어줍니다.

C 프로그래밍 시에 `.c` 로 명시하지 않으면 C++ 컴파일러가 컴파일 하게 되므로 주의하셔야 합니다.


그럼 즐거운 프로그래밍 하세요!
Link :  218
2016-07-19 11:54
----------------
title : 씹어먹는 C++ - <8 - 2. Excel 만들기 프로젝트 2부>
cat_title: 8 - 2. Excel 만들기 프로젝트 2부
next_page : 219
publish_date : 2016-07-19 11:54
--------------

이번 강좌에서는

* Excel 만들기 프로젝트 완성.
* 중위 표기법(Infix notation), 후위 표기법(postfix notation) 간의 변환


![](/img/ChewingCpplogo.png)




안녕하세요 여러분. 지난 강좌에 이어서 Excel 만들기 프로젝트를 계속 진행해 보도록 하겠습니다. 지난 강좌에서는 셀에 문자열 데이터만 넣을 수 있지만, 테이블을 여러가지 형태 (텍스트, HTML, CSV)로 출력할 수 있는 엑셀을 제작하였습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2327BB39578FA96F053529)





하지만 시간에 만들었던 엑셀은 아직 엑셀이라 하기에는 기능이 조금 부족하였습니다. 실제 엑셀을 살펴보자면 셀에 문자열만 넣을 수 있는 것이 아니라 숫자 데이터도 넣을 수 있고 날짜도 넣을 수 있고, 심지어는 수식도 넣어서 연산 까지 할 수 있는 만능 셀입니다.



###  Cell 클래스 확장


앞서 말했듯이, `Cell` 클래스에는 `string` 데이터만 저장할 수 있기 때문에 이를 상속 받는 클래스들을 만들어서 셀에 다양한 데이터들을 보관할 수 있게 할 것입니다.
```cpp-formatted
class Cell

{
 protected:
  int x, y;
  Table* table;

 public:
  virtual string stringify() = 0;
  virtual int to_numeric() = 0;

  Cell(int x, int y, Table* table);
};
```



일단 기존의 `Cell` 클래스에서 문자열 데이터를 보관했던 것과는 달리 아예 그 항목을 빼버리고, 이를 상속 받는 클래스에서 데이터를 보관하도록 하였습니다. 또한, `stringify` 함수와 `to_numeric` 을 순수 가상 함수로 정의해서 이를 상속 받는 클래스에서 이 함수들을 반드시 구현 토록 하였습니다.

```cpp-formatted
class StringCell : public Cell {
  string data;

 public:
  string stringify();
  int to_numeric();

  StringCell(string data, int x, int y, Table* t);
};
class NumberCell : public Cell {
  int data;

 public:
  string stringify();
  int to_numeric();

  NumberCell(int data, int x, int y, Table* t);
};
class DateCell : public Cell {
  time_t data;

 public:
  string stringify();
  int to_numeric();

  DateCell(string s, int x, int y, Table* t);
};
```



일단 위 셋은 각각 문자열, 정수, 시간 정보를 보관하는 클래스들 입니다. 사실 이들을 구현하는 것은 그렇게 어렵지 않습니다. 단순히 데이터를 문자열이나 정수 형으로 바꾸기만 해주면 되기 때문이지요. 참고로 `DateCell` 의 경우에는 편의를 위해서 `yyyy-mm-dd` 형식으로만 입력을 받는 것으로 정하였습니다.그 결과 다음과 같습니다.

```cpp-formatted
Cell::Cell(int x, int y, Table* table) : x(x), y(y), table(table) {}

StringCell::StringCell(string data, int x, int y, Table* t)
    : data(data), Cell(x, y, t) {}
string StringCell::stringify() { return data; }
int StringCell::to_numeric() { return 0; }

/*


NumberCell


*/
NumberCell::NumberCell(int data, int x, int y, Table* t)
    : data(data), Cell(x, y, t) {}

string NumberCell::stringify() { return to_string(data); }
int NumberCell::to_numeric() { return data; }

/*


DateCell


*/
string DateCell::stringify() {
  char buf[50];
  tm temp;
  localtime_s(&temp, &data);

  strftime(buf, 50, "%F", &temp);

  return string(buf);
}
int DateCell::to_numeric() { return static_cast<int>(data); }

DateCell::DateCell(string s, int x, int y, Table* t) : Cell(x, y, t) {
  // 입력받는 Date 형식은 항상 yyyy-mm-dd 꼴이라 가정한다.
  int year = atoi(s.c_str());
  int month = atoi(s.c_str() + 5);
  int day = atoi(s.c_str() + 8);

  tm timeinfo;

  timeinfo.tm_year = year - 1900;
  timeinfo.tm_mon = month - 1;
  timeinfo.tm_mday = day;
  timeinfo.tm_hour = 0;
  timeinfo.tm_min = 0;
  timeinfo.tm_sec = 0;

  data = mktime(&timeinfo);
}
```



참고로 `DateCell` 의 경우 구현이 조금 복잡한데 자세히 살펴보도록 하겠습니다.


```cpp-formatted
// 입력받는 Date 형식은 항상 yyyy-mm-dd 꼴이라 가정한다.
int year = atoi(s.c_str());
int month = atoi(s.c_str() + 5);
int day = atoi(s.c_str() + 8);
```



일단 위 처럼 입력 받은 문자열을 연도, 월, 일로 구분하게 됩니다.

```cpp-formatted
tm timeinfo;

timeinfo.tm_year = year - 1900;
timeinfo.tm_mon = month - 1;
timeinfo.tm_mday = day;
timeinfo.tm_hour = 0;
timeinfo.tm_min = 0;
timeinfo.tm_sec = 0;

data = mktime(&timeinfo);
```



이를 바탕으로 `timeinfo` 객체를 초기화 합니다. `tm` 클래스는 일월년 시분초 단위로 데이터를 보관하는 클래스 입니다. 하지만 우리의 `DateCell` 은 `time_t` 형태로 데이터를 보관하고 있는데 그 변환을 위해 `mktime` 에 `timeinfo` 를 전달하면 변환할 수 있습니다. 참고로 `time_t` 타입은 1970년 부터 현재 시간 까지 몇 초가 흘렀는지 보관하는 정수형 변수라고 생각하시면 됩니다.

```cpp-formatted
class ExprCell : public Cell {
  string data;
  string* parsed_expr;

  Vector exp_vec;

  // 연산자 우선 순위를 반환합니다.
  int precedence(char c);

  // 수식을 분석합니다.
  void parse_expression();

 public:
  ExprCell(string data, int x, int y, Table* t);

  string stringify();
  int to_numeric();
};
```



그렇다면 이제 대망의 `ExprCell` 을 살펴볼 차례입니다. 일단 `to_numeric()` 에 다 넣을 수 없어서 두 개의 함수를 새로 만들었습니다. `precedence` 함수는 입력받은 연산자의 우선순위를 반환하고, `parse_expression` 함수는 수식을 분석해서 계산하기 편하게 해주는 함수 입니다. 계산하기 편하게 한다는게 무슨 말이냐고요? 아래를 봐주시기 바랍니다.




###  수식 계산하기 `-` 중위 표기법과 후위 표기법




우리는 흔히 수식을 나타내기 위해 다음과 같이 써 왔습니다.
```info

3 + 4 * 5 + 4 * (7 - 2)
```



이렇게 표기하는 방식을 중위 표기법이라고 합니다. 사실 우리는 위 방식에 익숙해서 어떠한 순서로 계산하는지 쉽게 알 수 있지만 컴퓨터에 경우 이를 계산하는데 조금 어려울 수 있습니다. 일단 고려해야할 점들이 먼저 괄호를 우선으로 계산하고, 그 다음에 `*` 와 `/ ,` 그리고 `+` 와 `-` 의 우선 순위로 나누어서 계산해야 합니다.


쉽게 말해 위 수식의 경우 비록 맨 앞에 `3 + 4` 이 있지만 사실은 4 `* 5` 를 먼저 계산해야 됩니다. 즉, 컴퓨터가 이 수식을 계산하기 위해서는계산하는 위치를 우선 순위에 맞게 이러 저리 옮겨다녀야 합니다.



위 처럼 피연산자와 피연산자 사이에 연산자를 넣는 형태로 수식을 표현하는 방법을 중위 표기법(infix notation) 이라고 부릅니다. 쉽게 말해 연산자가 '중간' 에 들어가서 중위 표기법이지요.


반면에 아래의 수식을 살펴보도록 합시다.


```info

3 4 5 * + 4 7 2 - * +
```



우리가 흔히 생각하는 수식의 모습이랑 사뭇 다릅니다. 사실 위 수식은 앞서 말한 수식과 정확히 동일한 수식인데, 그 표현 방식이 다를 뿐입니다.이러한 형태로 수식을 표현하는 방식을 후위 표기법(postfix notation)이라고 합니다. 자세히 보자면 이전 수식과 다른 점을 두 가지 찾을 수 있는데, 하나는 이전과는 달리 연산자들이 피연산자 뒤쪽에 위치해 있다는 점과, 또 하나는 괄호가 사라졌다는 점입니다.


괄호가 사라졌다는 것이 무슨 의미가 있을까요?


기존의 중위 표현법이 컴퓨터가 해석하기에 불편했었던 점이 바로 연산자의 우선 순위나 괄호에 따라 이리 저리 계산하는 부분을 찾아다녀야 했던 점이었습니다. 하지만 후위 표기법에서는 놀랍게도 이리 저리 계산할 위치를 찾으러 돌아다닐 필요 없이, 읽어들이는 순서 대로 계산을 쭉 할 수 있습니 . 하지만 후위 표기법에서는 놀랍게도 이리 저리 계산할 위치를 찾으러 돌아다닐 필요 없이, 읽어들이는 순서 대로 계산을 쭉 할 수 있습니다


물론 사람이 보기에는 조금 불편하지만 컴퓨터의 입장에서는, 즉 프로그래머의 입장에서는 코딩하기에 매우 편리한 표기 방법 입니다.


그렇다면 이 후위 표기법으로 표현된 식을 컴퓨터가 어떻게 해석하는지 살펴보겠습니다. 컴퓨터는 아래와 같은 과정으로 위 후위 표기법으로 변환된 식을 계산합니다.

1. 피연산자를 만나면 스택에 `push` 합니다.
2. 연산자를 만나면 스택에서 두 개를 `pop` 한 뒤에 그 둘에 해당 연산을 한 후, 그 결과를 다시 스택에 `push` 합니다.



이와 같은 방식으로 위 수식을 계산해보도록 하겠습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F24246334578EC0EE1DABA0)

실제로 `3 + 4 * 5 +` 4 * (7 - 2) 을 계산 했을 때와 그 결과가 같음을 알 수 있습니다.


이를 바탕으로 후위 표기법으로 된 수식을 계산하는 `is_numeric` 함수를 살펴보도록 하겠습니다.

```cpp-formatted
int ExprCell::to_numeric() {
  double result = 0;
  NumStack stack;

  for (int i = 0; i < exp_vec.size(); i++) {
    string s = exp_vec[i];

    // 셀 일 경우
    if (isalpha(s[0])) {
      stack.push(table->to_numeric(s));
    }
    // 숫자 일 경우 (한 자리라 가정)
    else if (isdigit(s[0])) {
      stack.push(atoi(s.c_str()));
    } else {
      double y = stack.pop();
      double x = stack.pop();
      switch (s[0]) {
        case '+':
          stack.push(x + y);
          break;
        case '-':
          stack.push(x - y);
          break;
        case '*':
          stack.push(x * y);
          break;
        case '/':
          stack.push(x / y);
          break;
      }
    }
  }
  return stack.pop();
}
```



일단 우리는 `parse_expression` 함수를 통해서 입력 받은 중위 표기법으로 되어 있는 수식이, 후위 표기법으로 변환되어 있고, 그 결과가 `exp_vec` 에 저장되어 있다고 생각해봅시다. `exp_vec` 은 벡터 클래스 객체로, 각각의 원소가 후위 표기법으로 변환된 수식의 각각의 토큰이 됩니다. 즉, 앞선 예제의 경우 `exp_vec` 은 `3, 4, 5, *, +, 4, 7, 2, -, *, +` 으로 이루어진 배열 이라 보시면 됩니다.

```cpp-formatted
string s = exp_vec[i];
```



따라서 위와 같이 `for` 문을 통해 각각의 토큰(exp_vec 의 각 원소들)에 접근할 수 있습니다.

```cpp-formatted
// 셀 일 경우
if (isalpha(s[0])) {
  stack.push(table->to_numeric(s));
}
// 숫자 일 경우 (한 자리라 가정)
else if (isdigit(s[0])) {
  stack.push(atoi(s.c_str()));
}
```





그리고 각각의 토큰에 대해서, 셀 이름 (A3, B2 이렇게) 이나 숫자일 경우 스택에 `push` 하게 됩니다.

```cpp-formatted
else {
  double y = stack.pop();
  double x = stack.pop();
  switch (s[0]) {
    case '+':
      stack.push(x + y);
      break;
    case '-':
      stack.push(x - y);
      break;
    case '*':
      stack.push(x * y);
      break;
    case '/':
      stack.push(x / y);
      break;
  }
}
```



아니면 연산자를 만날 경우 스택에서 두 번 `pop` 을 해서 해당하는 피연산자들에 해당 연산자를 적용해서 다시 스택에 `push` 하게 됩니다.

```cpp-formatted
return stack.pop();
```



그리고 모든 계산이 끝나면 스택에 최종 결과값을 `pop` 하며 이를 리턴하게 됩니다.


자 그럼 이제 우리가 해야할 일은 중위 표기법으로 표기된 수식을 후위 표기법으로 변환하는 작업만 수행하면 됩니다.



###  중위 표기법을 후위 표기법으로 변환하기 (parse_expression 함수)




중위 표기법을 후위 표기법으로 변환하는 것은 다음의 방식을 따릅니다.

1. 피연산자 (셀 이름이나 숫자) 일 경우 그냥 `exp_vec` 에 넣습니다.
1. 여는 괄호( (, [, { 와 같은 것들 ) 을 만날 경우 스택에 `push` 합니다.
1. 닫는 괄호( `), ], }` 와 같은 것들 `)` 을 만날 경우 여는 괄호가 `pop` 될 때 까지 `pop` 되는 연산자들을 `exp_vec` 에 넣습니다.
1. 연산자일 경우 자기 보다 우선순위가 낮은 연산자가 스택 최상단에 올 때 까지 (혹은 스택이 빌 때 까지) 스택을 `pop` 하고 (낮은 것은 `pop` 하지 않습니다), `pop` 된 연산자들을 `exp_vec` 에 넣습니다. 그리고 마지막에 자신을 스택에 `push` 합니다.

그리고 연산자들의 우선 순위는 아래의 함수에 의해 정의됩니다.
```cpp-formatted
int ExprCell::precedence(char c) {
  switch (c) {
    case '(':
    case '[':
    case '{':
      return 0;
    case '+':
    case '-':
      return 1;
    case '*':
    case '/':
      return 2;
  }
  return 0;
}
```



괄호들이 가장 낮고, 그 다음이 `+` 와 `-,` 그리고 최상위 우선순위가 `*` 와 `/` 입니다.


그렇다면 `3 + 4 * 5 +` 4 * (7 - 2) 가 어떻게 변환되는지 그림으로 살펴보도록 하겠습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2779ED44578F2D81123CD3)

이제 위 방식으로 그대로 코드로만 옮기면 됩니다. 여기서는  코딩의 편의를 위해서 사용자가 입력하는 숫자는 1 자리 정수이고, 셀 이름 역시 2자 로 제한하였습니다. 이를 확장하는 것은 크게 어렵지 않으니 여러분들이 직접 해보시기 바랍니다.


```cpp-formatted
void ExprCell::parse_expression() {
  Stack stack;

  // 수식 전체를 () 로 둘러 사서 exp_vec 에 남아있는 연산자들이 push 되게
  // 해줍니다.
  data.insert(0, "(");
  data.push_back(')');

  for (int i = 0; i < data.length(); i++) {
    if (isalpha(data[i])) {
      exp_vec.push_back(data.substr(i, 2));
      i++;
    } else if (isdigit(data[i])) {
      exp_vec.push_back(data.substr(i, 1));
    } else if (data[i] == '(' || data[i] == '[' ||
               data[i] == '{') {  // Parenthesis
      stack.push(data.substr(i, 1));
    } else if (data[i] == ')' || data[i] == ']' || data[i] == '}') {
      string t = stack.pop();
      while (t != "(" && t != "[" && t != "{") {
        exp_vec.push_back(t);
        t = stack.pop();
      }
    } else if (data[i] == '+' || data[i] == '-' || data[i] == '*' ||
               data[i] == '/') {
      while (!stack.is_empty() &&
             precedence(stack.peek()[0]) >= precedence(data[i])) {
        exp_vec.push_back(stack.pop());
      }
      stack.push(data.substr(i, 1));
    }
  }
}
```



위 코드를 보면 변환 알고리즘을 그대로 옮겨놓았다고 생각하면 됩니다.

```cpp-formatted
if (isalpha(data[i])) {  // 셀 이름의 경우 첫 번째 글자가 알파벳이다.
  exp_vec.push_back(data.substr(i, 2));
  i++;
} else if (isdigit(data[i])) {  // 첫번째 글자가 숫자라면 정수 데이터
  exp_vec.push_back(data.substr(i, 1));
}
```



일단 피연산자를 만날 경우 `exp_vec` 에 무조건 집어넣으면 됩니다.

```cpp-formatted
else if (data[i] == '(' || data[i] == '[' || data[i] == '{') {  // Parenthesis
  stack.push(data.substr(i, 1));
}
else if (data[i] == ')' || data[i] == ']' || data[i] == '}') {
  string t = stack.pop();
  while (t != "(" && t != "[" && t != "{") {
    exp_vec.push_back(t);
    t = stack.pop();
  }
}
```



반면에 괄호의 경우 여는 괄호를 만나면 스택에 `push` 하고, 닫는 괄호를 만나면 위 처럼 여는 괄호가 스택에서 나올 때 까지 `pop` 하고, 그 `pop` 한 연산자들을 벡터에 넣으면 됩니다. 주의할 점은 `pop` 한 연산자가 괄호일 경우 넣지 않는다는 점입니다.

```cpp-formatted
else if (data[i] == '+' || data[i] == '-' || data[i] == '*' || data[i] == '/') {
  while (!stack.is_empty() &&
         precedence(stack.peek()[0]) >= precedence(data[i])) {
    exp_vec.push_back(stack.pop());
  }
  stack.push(data.substr(i, 1));
}
```



마지막으로 연산자일 경우를 살펴봅시다. `peek` 의 경우 스택의 최상단 원소를 `pop` 하지는 않고 무엇인지만 살펴보는 것입니다. 만일 최상단 원소의 우선 순위가 현재 연산자의 우선순위 보다 높다면 이를 스택에서 `pop` 하고 이를 `exp_vec` 에 넣어야 겠지요. 위 `while` 문은 그 과정을 나타내고 있습니다.


그리고 맨 마지막에 스택에 현재 연산자를 넣습니다.


위 과정을 모두 마치면 후기 표기법으로 변환을 마칠 수 있을 것이라 생각되지만 사실 한 가지 빼먹은 사실이 있습니다. 마지막에 스택에 남아있는 연산자들을 모두 `pop` 해야 되기 때문이죠. 이를 `for` 문이 끝난 후에 `while` 문을 하나 더 넣어서 연산자를 `pop` 하는 과정을 넣을 수 도 있지만 아래 처럼 좀 더 간단하게 처리할 수 도 있습니다.

```cpp-formatted
// 수식 전체를 () 로 둘러 사서 exp_vec 에 남아있는 연산자들이 push 되게
// 해줍니다.
data.insert(0, "(");
data.push_back(')');
```



바로 수식 전체를 ( ) 로 한 번 감싸는 것입니다. 그렇게 된다면 맨 마지막 괄호를 처리하면서 스택에 남아 있던 모든 연산자들이 `pop` 되겠지요.


그렇다면 실제로 잘 작동하는지 살펴보도록 합시다.

```cpp-formatted
// 생략
int main() {
  TxtTable table(5, 5);
  table.reg_cell(new NumberCell(2, 1, 1, &table), 1, 1);
  table.reg_cell(new NumberCell(3, 1, 2, &table), 1, 2);

  table.reg_cell(new NumberCell(4, 2, 1, &table), 2, 1);
  table.reg_cell(new NumberCell(5, 2, 2, &table), 2, 2);
  table.reg_cell(new ExprCell("B2+B3*(C2+C3-2)", 3, 3, &table), 3, 2);
  table.reg_cell(new StringCell("B2 + B3 * ( C2 + C3 - 2 ) = ", 3, 2, &table),
                 3, 1);

  cout << table;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F274EDE3F578F605425EA74)



와 같이 잘 작동하고 있음을 알 수 있습니다.





###  엑셀 프로그램





그렇다면 이제 실제로 사용자의 입력을 받아서 비록 마우스는 쓸 수 없더라도 키보드로 명령을 처리하는 엑셀 프로그램을 만들어보도록 하겠습니다.

```cpp-formatted
class Excel

{
  Table* current_table;

 public:
  Excel(int max_row, int max_col, int choice);

  int parse_user_input(string s);
  void command_line();
};
```



위 클래스는 사용자의 입력을 받아서 실제 테이블을 생성하고 이를 관리해주는 클래스 입니다. 또한 `parse_user_input` 함수의 경우 사용자의 입력을 인자로 받아서, 이를 처리하는 역할을 수행합니다.

```cpp-formatted
Excel::Excel(int max_row, int max_col, int choice = 0) {
  switch (choice) {
    case 0:
      current_table = new TxtTable(max_row, max_col);
      break;
    case 1:
      current_table = new CSVTable(max_row, max_col);
      break;
    default:
      current_table = new HtmlTable(max_row, max_col);
  }
}
```



위는 Excel 객체의 생성자로 어떠한 형태의 테이블을 형성할 지 결정합니다.

```cpp-formatted
int Excel::parse_user_input(string s) {
  int next = 0;
  string command = "";
  for (int i = 0; i < s.length(); i++) {
    if (s[i] == ' ') {
      command = s.substr(0, i);
      next = i + 1;
      break;
    } else if (i == s.length() - 1) {
      command = s.substr(0, i + 1);
      next = i + 1;
      break;
    }
  }

  string to = "";
  for (int i = next; i < s.length(); i++) {
    if (s[i] == ' ' || i == s.length() - 1) {
      to = s.substr(next, i - next);
      next = i + 1;
      break;
    } else if (i == s.length() - 1) {
      to = s.substr(0, i + 1);
      next = i + 1;
      break;
    }
  }

  // Cell 이름으로 받는다.
  int col = to[0] - 'A';
  int row = atoi(to.c_str() + 1) - 1;

  string rest = s.substr(next);

  if (command == "sets") {
    current_table->reg_cell(new StringCell(rest, row, col, current_table), row,
                            col);
  } else if (command == "setn") {
    current_table->reg_cell(
      new NumberCell(atoi(rest.c_str()), row, col, current_table), row, col);
  } else if (command == "setd") {
    current_table->reg_cell(new DateCell(rest, row, col, current_table), row,
                            col);
  } else if (command == "sete") {
    current_table->reg_cell(new ExprCell(rest, row, col, current_table), row,
                            col);
  } else if (command == "out") {
    ofstream out(to);
    out << *current_table;
    cout << to << " 에 내용이 저장되었습니다" << endl;
  } else if (command == "exit") {
    return 0;
  }

  return 1;
}
```



그리고 `parse_user_input` 함수는 사용자의 입력을 받아서 적절한 명령을 처리하게 됩니다. 예를 들어서

```info

setn A1 10
```



이렇게 치면, `A1` 셀을 `NumberCell` 로 생성하며, 10 의 값으로 초기화 시켜줍니다.


혹은

```info

sets B2 hello world!
```



의 경우 `B2` 셀을 `StringCell` 로 생성하며 "hello world!" 로 초기화 시켜줍니다.


날짜와 수식의 경우도 마찬가지이며, 각각 `setd` 와 `sete` 의 명령어를 사용하고 있습니다. 그 외에도, `out` 을 통해서 원하는 파일에 출력할 수 도 있고, `exit` 를 하면 프로그램을 종료할 수 있습니다.

```cpp-formatted
void Excel::command_line() {
  string s;
  getline(cin, s);

  while (parse_user_input(s)) {
    cout << *current_table << endl << ">> ";
    getline(cin, s);
  }
}
int main() {
  cout << "테이블 (타입) (최대 행 크기) (최대 열 크기) 를 순서대로 입력해주세요"
       << endl;
  cout << "* 참고 * " << endl;
  cout << "1 : 텍스트 테이블, 2 : CSV 테이블, 3 : HTML 테이블" << endl;

  int type, max_row, max_col;
  cin >> type >> max_row >> max_col;
  Excel m(max_row, max_col, type - 1);
  m.command_line();
}
```



마지막으로 `command_line` 함수는 사용자의 입력을 계속 기다리면서 내용이 업데이트 될 때 마다 화면에 표를 출력해주게 됩니다. 실제로 사용하는 예시는 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F265A9C33578FA1FC0BD04C)



이상으로 위와 같이 나만의 미니 엑셀을 완성하였습니다!


사실 앞서 쭉 이야기 해 왔지만 제가 구현한 미니 엑셀은 코딩의 간소화를 위해서 몇 가지 제약들이 있습니다. 이러한 부분은 여러분들이 자유롭게 코딩하면서 더 확장 해 나가셨으면 좋겠습니다.



###  생각해보기

#### 문제 1

`ExprCell` 의 쉭에서 셀의 이름은 `A3` 과 같이 단 두 글자만 가능하다는 제약 조건이 있었습니다. 이를 임의의 크기의 이름도 가능하게 확장해보세요. (난이도 : 下)

#### 문제 2

마찬가지로 가능한 숫자도 임의의 길이가 상관없게 확장해보세요. (난이도 : 下)

#### 문제 3

사실 위와 같이 수식을 계산하는 경우 한 가지 문제가 있습니다. 바로 셀들이 서로를 참조할 수 있다는 것입니다. 예를 들어서 `A1 = B1` 이고 `B1 = A1` 으로 설정하였다면 `B1` 의 값을 알기 위해 `A1` 의 값을 알아야 하고, 그럼 `A1` 의 값을 알기 위해 `B1` 의 값을 알아야 하고... 와 같은 순환 참조 문제가 발생합니다.

따라서 사용자가 타의든 자의든 순환 참조가 있는 식을 입력하였을 때 이를 감지하고 입력을 방지하는 루틴을 제공해야 합니다. (실제 Excel 에서도 순환 참조되는 식을 입력하면 오류가 발생합니다) (난이도 : 上)

#### 문제 4

실제 Excel 의 경우 수식에서 여러가지 함수들을 지원합니다. 여기서도 수식에서 간단한 함수들을 지원하게 해보세요.. (난이도 : 上)

##@ chewing-cpp-end
Link :  217
2016-07-18 20:32
----------------
title : 씹어먹는 C++ - <8 - 1. Excel 만들기 프로젝트 1부>
cat_title: 8 - 1. Excel 만들기 프로젝트 1부
next_page : 218
publish_date : 2016-07-18 20:32
--------------

이번 강좌에서는

* Excel 만들기 프로젝트의 1번째 문제를 해결할 것입니다.

![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 이번 강좌에서는 여태 까지 배운 내용들을 바탕으로 하나의 작은 C++ 프로젝트를 진행해볼 예정입니다. 지난번 강좌의 생각해보기에서 공지하기는 했지만, 바로 콘솔로 Excel 을 만드는 것입니다. 물론 마이크로소프트의 그것 처럼 거대하게 만들 수 는 없지만, 그래도 기본적인 것들은 지원 할 수 있는 형태로 만들어 볼 예정입니다.


본격적으로 Excel 을 구현하기에 앞서서, 몇 가지 자료 구조를 만들 것입니다.자료구조라고 함은, 컴퓨터에서 데이터를 저장하는 방식이라 할 수 있는데, 그 구현에 따라서 장단점이 각각 있습니다. (장점만을 가진 자료 구조는 없습니다. 항상 무언가를 위해서 다른 무언가를 포기해야 되는 법이지요)


이 Excel 프로그램에서 사용할 자료구조는 크게 `Vector` 와 `Stack` 입니다.참고로 이들은 수식을 분석하기 위해, 즉 `ExprCell` 객체의 `to_numeric` 함수 내에서 사용될 예정입니다.


각 자료구조들은 다음과 같은 특징을 가지고 있습니다.

* 벡터 (Vector) : 수학의 그 벡터와는 살짝 다른 느낌인데, 그냥 배열의 크기를 맘대로 조절할 수 있는 가변길이 배열이라 보시면 됩니다. 즉, 배열 처럼 `[]` 연산자로 임의의 위치에 있는 원소에 마음대로 접근할 수 있고 또 임의의 위치에 원소를 추가하거나 뺄 수 있습니다. 벡터를 만드는 방법은 이전에 문자열 클래스를 만들 때와 거의 비슷합니다. 문자열 역시 `char` 데이터를 담는 가변 길이 배열과 마찬가지 이기 때문이지요.
* 스택 (Stack) : 벡터와는 다르게 임의의 위치에 있는 원소에 접근할 수 없고 항상 최 상단에 있는 데이터에만 접근할 수 있습니다. 그리고 새로운 데이터를 추가하면 최상단에 오게 됩니다. 쉽게 말해서 설거지 용으로 쌓아 놓는 접시들이라 보면 됩니다. 새로운 설거지 거리가 오면 쌓여 있는 접시 맨 위에 오게 되고(push). 설거지를 위해서 접시를 뺄 때 맨 위의 접시 부터 빼겠지요(pop).

물론 스택은 그냥 벡터를 활용해서 만들 수 있습니다. 하지만 이는 마치 소 잡는 칼을 닭 잡는 데 쓰는 것이라고나 할까요. 보통 스택의 경우 링크드 리스트(Linked List - [이 강좌](http://itguru.tistory.com/100)의 `Node` 부분을 살펴보세요) 를 이용해서 구현을 합니다. 스택은 임의의 위치에 데이터에 접근할 필요가 없습니다. 단순히 최상위에 뭐가 있을 지 궁금하고 또 거기에 새로운 것을 추가하던지 빼기만 하면 되겠지요. 아래 스택을 간단히 어떻게 구현 할 지 그림으로 보여드리겠습니다.



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2151894E5788A29118E8AB)

즉 스택의 경우 복잡하게 생각할 필요 없이 위와 같이 구성하면 됩니다.




###  벡터 클래스 (Vector)


먼저 문자열을 보관하기 위한 벡터 부터 만들겠습니다. 우리의 벡터 클래스는 다음과 같이 구성되어 있습니다.

```cpp-formatted
class Vector {
  string* data;
  int capacity;
  int length;

 public:
  // 생성자
  Vector(int n = 1);

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(string s);

  // 임의의 위치의 원소에 접근한다.
  string operator[](int i);

  // x 번째 위치한 원소를 제거한다.
  void remove(int x);

  // 현재 벡터의 크기를 구한다.
  int size();

  ~Vector();
};
```



먼저 클래스 소스를 살펴보도록 합시다.

```cpp-formatted
string* data;
int capacity;
int length;
```



`Vector` 클래스는 위와 같이 데이터를 보관하기 위한 `data` (문자열 배열로 만들 것입니다), 현재 할당되어 있는 크기를 알려주는 `capacity,` 그리고 현재 실제로 사용하는 양인 `length` 와 같은 변수로 구성되어 있습니다.

```cpp-formatted
// 생성자
Vector(int n = 1);
```



한 가지 특이한 점은 생성자에서 인자가 저렇게 `int n = 1` 과 같이 지정되어 있다는 것입니다. 이는 무엇이냐면, 만일 사용자가 인자를 지정하지 않으면, 알아서 `n = 1` 이 되게 지정한다는 것입니다. 다시 말해서

```cpp-formatted
Vector a() Vector a(1)
```



은 동일한 작업입니다. 물론 사용자가 인자를 지정하면 해당 인자가 들어가겠지요. 이렇게 해당 인자의 기본 값을 지정해 놓은 것을 **디폴트 인자 (Default argument)** 라고 합니다. 이렇게 하면 사용자가 인자를 지정하지 않아도 디폴트 값이 들어가기 때문에 문제 없이 사용할 수 있습니다.

```cpp-formatted
Vector::Vector(int n) : data(new string[n]), capacity(n), length(0) {}
```



`Vector` 의 생성자를 살펴보면 위와 같습니다. 한 가지 흥미로운 점은 여기서는 디폴트 인자가 명시되지 않은 점입니다. 이는 C++ 규칙이기도 한데, 클래스 내부 함수 선언에서 디폴드 인자를 명시하였다면 함수 본체에서 명시하면 안되고, 반대로 함수 본체에서 명시하였다면 클래스 내부 함수 선언에 명시하면 안됩니다. 즉, 둘 중 한 곳에서만 표시해야 합니다.

```cpp-formatted
void Vector::push_back(string s) {
  if (capacity <= length) {
    string* temp = new string[capacity * 2];
    for (int i = 0; i < length; i++) {
      temp[i] = data[i];
    }
    delete[] data;
    data = temp;
    capacity *= 2;
  }

  data[length] = s;
  length++;
}

string Vector::operator[](int i) { return data[i]; }

void Vector::remove(int x) {
  for (int i = x + 1; i < length; i++) {
    data[i - 1] = data[i];
  }
  length--;
}

int Vector::size() { return length; }

Vector::~Vector() {
  if (data) {
    delete[] data;
  }
}
```



간단히 위 처럼 `Vector` 클래스의 함수들을 만들어 보았습니다. 이 `Vector` 클래스는 일반적으로 다른 사람들이 사용할 것이 아니라 제가 이 프로젝트에서 간단히 사용하기 위해 만들어놓은 것이므로 몇 가지 문제점들이나 구현하지 않는 함수들 (보통 `Vector` 클래스에는 중간에 원소를 추가하는 `insert` 나 검색하는 `find` 함수들도 세트로 다닙니다) 이 있습니다. 물론 이렇게 한 이유는 이 정도로도 Excel 프로젝트에는 충분하기 때문에 문제 없습니다.

```cpp-formatted
void Vector::push_back(string s) {
  if (capacity <= length) {
    string* temp = new string[capacity * 2];
    for (int i = 0; i < length; i++) {
      temp[i] = data[i];
    }
    delete[] data;
    data = temp;
    capacity *= 2;
  }

  data[length] = s;
  length++;
}
```



우리 `Vector` 클래스의 `push_back` 함수는 배열 맨 끝에 원소를 집어넣는 클래스 입니다. 위 방법은 기존에 문자열 클래스에서 썼던 방법으로, 만일 배열이 다 차게 되면 1 칸을 더 늘리는 것이 아니라 현재 크기의 두 배 만큼을 새로 할당하고 새로 할당단 공간에 복사하는 것입니다. 이렇게 된다면 가장 효율적으로 공간과 시간을 활용할 수 있습니다.



###  스택 클래스


이번에는 스택 클래스 입니다.  스택의 경우 위에서 말한 것 처럼 링크드 리스트를 사용하기 때문에 데이터를 보관하기 위해서 배열을 사용하는 것이 아니라 하나의 노드를 만들어서 노드들을 체인 처럼 엮을 것입니다. 이를 위해 아래와 같이 `Stack` 클래스 안에 `Node` 라는 구조체를 정의하였습니다.

```cpp-formatted
struct Node {
  Node* prev;
  string s;

  Node(Node* prev, string s) : prev(prev), s(s) {}
};
```



`Node` 객체에는 자기 보다 하위 `Node` 를 가리키는 포인터(prev)와, 자신이 보관하는 데이터에 관한 값(s)을 보관하는 두 개의 변수로 구성되어 있습니다. 그냥 맨 위에 그려놓은 스택 구현 모습을 그대로 표현하였다고 생각하면 됩니다. 아래는 전체 `Stack` 클래스의 모습입니다.



```cpp-formatted
class Stack {
  struct Node {
    Node* prev;
    string s;

    Node(Node* prev, string s) : prev(prev), s(s) {}
  };

  Node* current;
  Node start;

 public:
  Stack();

  // 최상단에 새로운 원소를 추가한다.
  void push(string s);

  // 최상단의 원소를 제거하고 반환한다.
  string pop();

  // 최상단의 원소를 반환한다. (제거 안함)
  string peek();

  // 스택이 비어있는지의 유무를 반환한다.
  bool is_empty();

  ~Stack();
};
```



`Node` 들의 리스트를 정확하게 관리하기 위해서, `current` 와 `start` 를 만들어서 `current` 는 현재 최상위 노드를 가리키게 하고, `start` 는 맨 밑바닥을 이루는 노드, 즉 최하위 노드를 가리키게 하였습니다. `start` 노드를 둔 이유는, 마지막 노드에 도달하였을 때 그 여부를 알아야 하기 때문이지요.

```cpp-formatted
Stack::Stack() : start(NULL, "") { current = &start; }
void Stack::push(string s) {
  Node* n = new Node(current, s);
  current = n;
}
string Stack::pop() {
  if (current == &start) return "";

  string s = current->s;
  Node* prev = current;
  current = current->prev;

  // Delete popped node
  delete prev;
  return s;
}
string Stack::peek() { return current->s; }
bool Stack::is_empty() {
  if (current == &start) return true;
  return false;
}
Stack::~Stack() {
  while (current != &start) {
    Node* prev = current;
    current = current->prev;
    delete prev;
  }
}
```



위와 같이 간단하게 `Stack` 을 구성하였습니다. 주의해야 할 점은, 소멸자에서 최상위 원소 부터 줄줄이 바닥에 도달할 때 까지 메모리에서 해제시켜야 완전히 `Stack` 객체를 소멸시킬 수 있습니다.


스택의 경우 위와 같이 문자열을 받는 것 말고도, 숫자 데이터를 보관하는 스택인 `NumStack` 클래스 또한 `string` 만 `int` 로 바꿔서 동일하게 만들었습니다.



최종적으로 아래는 우리가 만든 벡터와 스택 클래스의 헤더 파일인 `utils.h` 의 전체 내용입니다.

```cpp-formatted
#pragma once
#include <string>
using namespace std;

class Vector {
  string* data;
  int capacity;
  int length;

 public:
  // 생성자
  Vector(int n = 1);

  // 맨 뒤에 새로운 원소를 추가한다.
  void push_back(string s);

  // 임의의 위치의 원소에 접근한다.
  string operator[](int i);

  // x 번째 위치한 원소를 제거한다.
  void remove(int x);

  // 현재 벡터의 크기를 구한다.
  int size();

  ~Vector();
};

class Stack {
  struct Node {
    Node* prev;
    string s;

    Node(Node* prev, string s) : prev(prev), s(s) {}
  };

  Node* current;
  Node start;

 public:
  Stack();

  // 최상단에 새로운 원소를 추가한다.
  void push(string s);

  // 최상단의 원소를 제거하고 반환한다.
  string pop();

  // 최상단의 원소를 반환한다. (제거 안함)
  string peek();

  // 스택이 비어있는지의 유무를 반환한다.
  bool is_empty();

  ~Stack();
};
class NumStack {
  struct Node {
    Node* prev;
    double s;

    Node(Node* prev, double s) : prev(prev), s(s) {}
  };

  Node* current;
  Node start;

 public:
  NumStack();
  void push(double s);
  double pop();
  double peek();
  bool is_empty();

  ~NumStack();
};
```




참고로 맨 위에 흥미로운 전처리기 하나가 있습니다.

```cpp-formatted
#pragma once
```



아직 C++ 표준에 정식으로 들어간 것은 아니지만, 그래도 대부분의 주요 컴파일러 `Visual Studio, gcc, clang` 등등에서 지원하고 있는 것으로 이 헤더파일이 중복되서 포함되지 않도록 합니다. 물론 기존에

```info

#ifndef A
#define A
// 헤더파일 내용
#endif
```



이런 형태로 사용하기도 하였지만 이를 위의 한 줄로 단순화 시킨 것입니다. #pragma `once` 를 명시하게 되면, 설사 다른 소스파일에서 이 헤더파일을 두 번 이상 `include` 해도 알아서 컴파일러 차원에서 한 번만 `include` 하게 해줍니다.


마찬가지로 아래는 해당 헤더파일 내용을 구현한 `utility.cpp` 입니다.

```cpp-formatted
#include <string>

#include "utils.h"
using namespace std;

// default argument must go only once
Vector::Vector(int n) : data(new string[n]), capacity(n), length(0) {}
void Vector::push_back(string s) {
  if (capacity <= length) {
    string* temp = new string[capacity * 2];
    for (int i = 0; i < length; i++) {
      temp[i] = data[i];
    }
    delete[] data;
    data = temp;
    capacity *= 2;
  }

  data[length] = s;
  length++;
}
string Vector::operator[](int i) { return data[i]; }
void Vector::remove(int x) {
  for (int i = x + 1; i < length; i++) {
    data[i - 1] = data[i];
  }
  length--;
}
int Vector::size() { return length; }
Vector::~Vector() {
  if (data) {
    delete[] data;
  }
}

Stack::Stack() : start(NULL, "") { current = &start; }
void Stack::push(string s) {
  Node* n = new Node(current, s);
  current = n;
}
string Stack::pop() {
  if (current == &start) return "";

  string s = current->s;
  Node* prev = current;
  current = current->prev;

  // Delete popped node
  delete prev;
  return s;
}
string Stack::peek() { return current->s; }
bool Stack::is_empty() {
  if (current == &start) return true;
  return false;
}
Stack::~Stack() {
  while (current != &start) {
    Node* prev = current;
    current = current->prev;
    delete prev;
  }
}
NumStack::NumStack() : start(NULL, 0) { current = &start; }
void NumStack::push(double s) {
  Node* n = new Node(current, s);
  current = n;
}
double NumStack::pop() {
  if (current == &start) return 0;

  double s = current->s;
  Node* prev = current;
  current = current->prev;

  // Delete popped node
  delete prev;
  return s;
}
double NumStack::peek() { return current->s; }
bool NumStack::is_empty() {
  if (current == &start) return true;
  return false;
}
NumStack::~NumStack() {
  while (current != &start) {
    Node* prev = current;
    current = current->prev;
    delete prev;
  }
}
```






###  본격적인 `Cell` 과 `Table` 클래스





```cpp-formatted
class Cell

{
 protected:
  int x, y;
  Table* table;

  string data;

 public:
  virtual string stringify();
  virtual int to_numeric();

  Cell(string data, int x, int y, Table* table);
};
```



`Cell` 클래스는 큰 테이블에서 한 칸을 의미하는 객체로, 해당 내용을 보관하는 문자열 `data` 와 어느 테이블에 위치해 있는지에 관련한 정보를 가지고 있는 `table` 과 그 위치 `x, y` 로 구성되어 있습니다.


또한, 가상 함수로 해당 셀 값을 문자열로 변환하는 `stringify` 함수와, 정수 데이터로 변환하는 `to_numeric` 함수도 선언되어 있습니다. 물론 문자열에 `to_numeric` 을 수행하게 되면 당연히 0 을 리턴하겠지만, 나중에 `Cell` 클래스를 `NumberCell` 과 같은 클래스들이 상속 받기 위한 큰 그림이라고 보시면 됩니다.


따라서 `Cell` 멤버 함수들의 정의는 아래와 같이 간단하게 나타낼 수 있습니다.

```cpp-formatted
Cell::Cell(string data, int x, int y, Table* table)
    : data(data), x(x), y(y), table(table) {}

string Cell::stringify() { return data; }
int Cell::to_numeric() { return 0; }
```



자 그럼 `Table` 클래스의 정의를 살펴보도록 하겠습니다.

```cpp-formatted
class Table {
 protected:
  // 행 및 열의 최대 크기
  int max_row_size, max_col_size;

  // 데이터를 보관하는 테이블
  // Cell* 을 보관하는 2차원 배열이라 생각하면 편하다
  Cell*** data_table;

 public:
  Table(int max_row_size, int max_col_size);

  ~Table();

  // 새로운 셀을 row 행 col 열에 등록한다.
  void reg_cell(Cell* c, int row, int col);

  // 해당 셀의 정수값을 반환한다.
  // s : 셀 이름 (Ex. A3, B6 과 같이)
  int to_numeric(const string& s);

  // 행 및 열 번호로 셀을 호출한다.
  int to_numeric(int row, int col);

  // 해당 셀의 문자열을 반환한다.
  string stringify(const string& s);
  string stringify(int row, int col);

  virtual string print_table() = 0;
};
```



일단 `Table` 클래스는 `Cell` 객체들을 2 차원 배열로 보관하게 됩니다. 이 때, 객체 자체를 보관하는 것이 아니라, 객체는 필요할 대 마다 동적으로 생성하고, 그 객체에 대한 포인터를 2차원 배열로 보관하고 있게 됩니다.

```cpp-formatted
Table::Table(int max_row_size, int max_col_size)
    : max_row_size(max_row_size), max_col_size(max_col_size) {
  data_table = new Cell**[max_row_size];
  for (int i = 0; i < max_row_size; i++) {
    data_table[i] = new Cell*[max_col_size];
    for (int j = 0; j < max_col_size; j++) {
      data_table[i][j] = NULL;
    }
  }
}
```



따라서 `Table` 클래스의 생성자는 위와 같이 정의될 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2409033B578C83591C4592)



위 그림을 보면 쉽게 이해할 수 있듯이, 동적 할당으로 Cell* 배열을 생성한 후에, `Cell` 객체가 필요 할 때 마다 생성해서 배열의 원소들이 이를 가리킬 수 있게 하였습니다.

```cpp-formatted
Table::~Table() {
  for (int i = 0; i < max_row_size; i++) {
    for (int j = 0; j < max_col_size; j++) {
      if (data_table[i][j]) delete data_table[i][j];
    }
  }
  for (int i = 0; i < max_row_size; i++) {
    delete[] data_table[i];
  }
  delete[] data_table;
}
```



`Table` 소멸자도 이와 비슷합니다. 일단, 동적으로 생성된 `Cell` 객체를 모두 지워야 하고 그 다음에 `Cell` 배열 (1차원) 을 지워야 하고 마지막으로 2차원 테이블 자체를 메모리에서 지워야 합니다. 3 단계에 걸쳐서 `Cell` 의 흔적으로 메모리에서 날려버릴 수 있습니다.

```cpp-formatted
void Table::reg_cell(Cell* c, int row, int col) {
  if (!(row < max_row_size && col < max_col_size)) return;

  if (data_table[row][col]) {
    delete data_table[row][col];
  }
  data_table[row][col] = c;
}
```



위는 `Table` 의 셀을 등록하는 함수 입니다. 등록하고자 하는 위치를 인자로 받는데, 만일 해당 위치에 이미 다른 셀 객체가 등록되어 있다면 해당 객체를 `delete` 한 후에 등록시켜주면 됩니다.

```cpp-formatted
int Table::to_numeric(const string& s) {
  // Cell 이름으로 받는다.
  int row = s[0] - 'A';
  int col = atoi(s.c_str() + 1) - 1;

  if (row < max_row_size && col < max_col_size) {
    if (data_table[row][col]) {
      return data_table[row][col]->to_numeric();
    }
  }
  return 0;
}
int Table::to_numeric(int row, int col) {
  if (row < max_row_size && col < max_col_size && data_table[row][col]) {
    return data_table[row][col]->to_numeric();
  }
  return 0;
}
string Table::stringify(const string& s) {
  // Cell 이름으로 받는다.
  int col = s[0] - 'A';
  int row = atoi(s.c_str() + 1) - 1;

  if (row < max_row_size && col < max_col_size) {
    if (data_table[row][col]) {
      return data_table[row][col]->stringify();
    }
  }
  return 0;
}
string Table::stringify(int row, int col) {
  if (row < max_row_size && col < max_col_size && data_table[row][col]) {
    return data_table[row][col]->stringify();
  }
  return "";
}
ostream& operator<<(ostream& o, Table& table) {
  o << table.print_table();
  return o;
}
```



마지막으로 해당하는 셀의 값을 반환하는 함수들로, 두 가지 형태로 구성되어 있는데 하나는 셀 이름(A1, `B2` 이렇게)을 받아서 해당하는 위치의 값을 리턴하는 함수와 행과 열 값을 받아서 해당 위치에 셀이 있으면 그 값을 리턴하는 함수들로 구성되어 있습니다.


또한 맨 마지막에 `ostream` 클래스의 `<<` 연산자를 오버로딩하는 함수를 하나 만들어서 파일이나 표준 스트림(cout) 입출력에 쉽게 사용할 수 있도록 하였습니다.



하지만 이 `Table` 클래스의 객체는 생성할 수 없습니다. 왜냐하면 아래와 같은 순수 가상 함수가 포함되어 있기 때문이지요.

```cpp-formatted
virtual string print_table() = 0;
```



우리는 이 `Table` 클래스를 상속 받는 다른 클래스를 만들어서 이 함수를 구현해주어야만 합니다.

```cpp-formatted
class TxtTable : public Table {
  string repeat_char(int n, char c);

  // 숫자로 된 열 번호를 A, B, .... Z, AA, AB, ...  이런 순으로 매겨준다.
  string col_num_to_str(int n);

 public:
  TxtTable(int row, int col);

  // 텍스트로 표를 깨끗하게 출력해준다.
  string print_table();
};
```



위는 `Table` 클래스를 상속 받는 `TxtTable` 클래스 입니다. 이 클래스는 `Table` 의 내용을 텍스트의 형태로 예쁘게 정리해서 출력해주는 역할을 하고 있습니다.

```cpp-formatted
TxtTable::TxtTable(int row, int col) : Table(row, col) {}

// 텍스트로 표를 깨끗하게 출력해준다.
string TxtTable::print_table() {
  string total_table;

  int* col_max_wide = new int[max_col_size];
  for (int i = 0; i < max_col_size; i++) {
    unsigned int max_wide = 2;
    for (int j = 0; j < max_row_size; j++) {
      if (data_table[j][i] &&
          data_table[j][i]->stringify().length() > max_wide) {
        max_wide = data_table[j][i]->stringify().length();
      }
    }
    col_max_wide[i] = max_wide;
  }
  // 맨 상단에 열 정보 표시
  total_table += "    ";
  int total_wide = 4;
  for (int i = 0; i < max_col_size; i++) {
    if (col_max_wide[i]) {
      int max_len = max(2, col_max_wide[i]);
      total_table += " | " + col_num_to_str(i);
      total_table += repeat_char(max_len - col_num_to_str(i).length(), ' ');

      total_wide += (max_len + 3);
    }
  }

  total_table += "\n";
  // 일단 기본적으로 최대 9999 번째 행 까지 지원한다고 생각한다.
  for (int i = 0; i < max_row_size; i++) {
    total_table += repeat_char(total_wide, '-');
    total_table += "\n" + to_string(i + 1);
    total_table += repeat_char(4 - to_string(i + 1).length(), ' ');

    for (int j = 0; j < max_col_size; j++) {
      if (col_max_wide[j]) {
        int max_len = max(2, col_max_wide[j]);

        string s = "";
        if (data_table[i][j]) {
          s = data_table[i][j]->stringify();
        }
        total_table += " | " + s;
        total_table += repeat_char(max_len - s.length(), ' ');
      }
    }
    total_table += "\n";
  }

  return total_table;
}

string TxtTable::repeat_char(int n, char c) {
  string s = "";
  for (int i = 0; i < n; i++) s.push_back(c);

  return s;
}
// 숫자로 된 열 번호를 A, B, .... Z, AA, AB, ...  이런 순으로 매겨준다.
string TxtTable::col_num_to_str(int n) {
  string s = "";
  if (n < 26) {
    s.push_back('A' + n);
  } else {
    char first = 'A' + n / 26 - 1;
    char second = 'A' + n % 26;

    s.push_back(first);
    s.push_back(second);
  }

  return s;
}
```



위는 그 구현 입니다. `repeat_char` 과 `col_num_to_str` 함수는 단순히 `print_table` 에서 사용할 부가적인 함수들 입니다. `print_table` 함수는 각 열의 최대 문자열 길이를 계산한 뒤에, 이를 바탕으로 각 열의 폭을 결정해서 표를 출력해줍니다.


참고로 이 구현 방식에서 한 가지 중요한 것이 빠졌는데, 셀의 문자열 데이터에서 개행 문자가 있는 경우(즉 특정 셀이 여러 줄이 될 때)를 고려하지 않았습니다. 즉, 모든 셀은 최대 1 줄로만 그려지게 됩니다.  따라서 실제로는 각 행의 최대 높이 역시 열과 마찬가지로 계산해서 그려야 합니다. (이는 여러분의 몫으로 남기겠습니다)

```cpp-formatted
// 생략
int main() {
  TxtTable table(5, 5);
  ofstream out("test.txt");

  table.reg_cell(new Cell("Hello~", 0, 0, &table), 0, 0);
  table.reg_cell(new Cell("C++", 0, 1, &table), 0, 1);

  table.reg_cell(new Cell("Programming", 1, 1, &table), 1, 1);
  cout << endl << table;
  out << table;
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2730FA3A578C93C81EB1DF)



와 같이 잘 나오게 됩니다.


또한 `test.txt` 파일에도 역시


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2506113B578C94130C2F95)



위와 같이 표가 잘 출력됩니다.


마찬가지로 저는 `CSV` 파일 형태와 `HTML` 형태로 데이터를 표현해주는 두 개의 클래스들을 더 만들었습니다.

```cpp-formatted
class HtmlTable : public Table {
 public:
  HtmlTable(int row, int col);

  string print_table();
};

class CSVTable : public Table {
 public:
  CSVTable(int row, int col);

  string print_table();
};
```



딱히 특별한 것은 없고, `HTML` 파일 형식이나 `CSV` 파일 형식을 잘 알고 있다면 만드는데 큰 문제가 없을 것입니다. (HTML 표 :http://aboooks.tistory.com/59 `, CSV` 파일 형식 : https://en.wikipedia.org/wiki/Comma-separated_values)

```cpp-formatted
// 생략
int main() {
  CSVTable table(5, 5);
  ofstream out("test.csv");

  table.reg_cell(new Cell("Hello~", 0, 0, &table), 0, 0);
  table.reg_cell(new Cell("C++", 0, 1, &table), 0, 1);

  table.reg_cell(new Cell("Programming", 1, 1, &table), 1, 1);
  out << table;

  HtmlTable table2(5, 5);
  ofstream out2("test.html");

  table2.reg_cell(new Cell("Hello~", 0, 0, &table), 0, 0);
  table2.reg_cell(new Cell("C++", 0, 1, &table), 0, 1);
  table2.reg_cell(new Cell("Programming", 1, 1, &table), 1, 1);
  out2 << table2;
}
```





그리고 그 구현 내용은 다음과 같습니다.

```cpp-formatted
HtmlTable::HtmlTable(int row, int col) : Table(row, col) {}

string HtmlTable::print_table() {
  string s = "<table border='1' cellpadding='10'>";
  for (int i = 0; i < max_row_size; i++) {
    s += "<tr>";
    for (int j = 0; j < max_col_size; j++) {
      s += "<td>";
      if (data_table[i][j]) s += data_table[i][j]->stringify();
      s += "</td>";
    }
    s += "</tr>";
  }
  s += "</table>";
  return s;
}

CSVTable::CSVTable(int row, int col) : Table(row, col) {}

string CSVTable::print_table() {
  string s = "";
  for (int i = 0; i < max_row_size; i++) {
    for (int j = 0; j < max_col_size; j++) {
      if (j >= 1) s += ",";
      // CSV 파일 규칙에 따라 문자열에 큰따옴표가 포함되어 있다면 "" 로
      // 치환하다.
      string temp;
      if (data_table[i][j]) temp = data_table[i][j]->stringify();

      for (int k = 0; k < temp.length(); k++) {
        if (temp[k] == '"') {
          // k 의 위치에 " 를 한 개 더 집어넣는다.
          temp.insert(k, 1, '"');

          // 이미 추가된 " 를 다시 확인하는 일이 없게 하기 위해
          // k 를 한 칸 더 이동시킨다.
          k++;
        }
      }
      temp = '"' + temp + '"';
      s += temp;
    }
    s += '\n';
  }
  return s;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F271F803B578C9B0A1CF30F)



`CSV` 파일의 경우 위와 같이 (실제) 엑셀에서 잘 열리고


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F212FFA3B578C9B0A0A770A)

`HTML` 파일로 변환한 경우 위와 같이 브라우저 상에서 잘 표현됨을 알 수 있습니다.



이상으로 간단히 엑셀 만들기 프로젝트 1 부를 마치도록 하겠습니다. 다음 강좌에서는 `Cell` 을 상속 받는 클래스들을 만들어서 마치 실제 엑셀 처럼 작동하는 엑셀을 만들어 보도록 하겠습니다.

##@ chewing-cpp-end
Link :  215
2016-07-14 00:46
----------------
title : 씹어먹는 C++ - <7 - 2. C++ 에서 파일 입출력 - ifstream. ofstream, stringstream>
cat_title: 7 - 2. C++ 에서 파일 입출력 - ifstream. ofstream, stringstream
next_page : 217
publish_date : 2016-07-14 00:46
--------------

이번 강좌에서는

* `ifstream` 을 이용한 파일 입력
* `ofstream` 을 이용한 파일 출력
* 문자열 스트림 (stringstream) 을 이용한 간편한 문자열 간의 변환

에 대해서 알아봅니다.


![](/img/ChewingCpplogo.png)


안녕하세요 여러분! 지난 강좌에서 C++ 에서 표준 스트림과의 입출력에 대해 간단히 다루어보았습니다. 이번에는 이를 이용해서 파일 스트림과의 입출력을 다루어 보도록 하겠습니다. 사실, 파일 입출력은 표준 스트림에서 입출력 하는 것과 크게 다른 점은 없습니다. 다만, 스트림이 화면 혹은 키보드에서 파일로 바뀌었을 뿐이지요.



###  fstream


파일 스트림은 기본적인 `istream` 이나 `ostream` 클래스 보다 더 지원하는 기능이 더 많기 때문에 이를 상속 받아서 작성되었으며, 각각을 상속 받은 것이 `ifstream` 과 `ofstream` 입니다. 이들 클래스를 모두 포함하는 라이브러리로 `fstream` 을 사용하면 됩니다.

```cpp-formatted
// 파일에서의 입출력
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

int main() {
  // 파일 읽기 준비
  ifstream in("test.txt");
  string s;

  if (in.is_open()) {
    in >> s;
    cout << "입력 받은 문자열 :: " << s << endl;
  } else {
    cout << "파일을 찾을 수 없습니다!" << endl;
  }
  return 0;
}
```



성공적으로 컴파일 하였다면
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2356764657838A5001A219)





와 같이 나옵니다. 참고로 `test.txt` 파일에는 다음과 같이 써 있었습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F23391F4557838A94388D50)



참고로 `test.txt` 를 읽어드리는 경로는, 비주얼 스튜디오 상에서 실행하였을 때 소스파일이 들어있는 위치와 동일합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2568EF4257838AF41801E1)





만일 `test.txt` 를 지워버려서 파일을 찾을 수 없다면 `is_open` 이 `false` 를 반환해서


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F2368264257838B44281523)



와 같이 파일을 찾을 수 없다고 표시 됩니다.


아마 소스가 매우 간단하므로 그냥 봐도 이해 하실 수 있으리라 생각합니다. 기존의 콘솔에서 사용자 입력을 받는 것과 별반 다를 게 없어 보입니다. 단 한가지 빼고요.

```cpp-formatted
// 파일 읽기 준비
ifstream in("test.txt");
```





기존에 `cout` 이나 `cin` 을 사용했을 때에는 이미 표준 입출력에 연동이 되어 있는 상황이었지만, 파일 입출력에 경우 어느 파일에 입출력을 해야 할 지 지정 해야 하는데, 이를 `ifstream` 객체에 생성자에 연동하고자 하는 파일의 경로 ("C:\\a\\b\\c.txt" 와 같이) 를 전달하면 됩니다. 위 경우 편의상 경로를 저렇게 썻지만 (이 경우 실행 파일과 같은 경로에 있는 파일을 찾게 됩니다. 다만 비주얼 스튜디오 상에서 실행할 경우에는 소스 파일과 같은 경로에 있는 것을 찾습니다)


위와 같이 생성자에 파일 경로를 지정하면, 해당하는 파일을 찾고 열게 됩니다. 만일 파일이 존재하지 않는다면 파일을 열 수 없습니다. 따라서 파일이 열렸는지의 유무는 다음과 같이 확인할 수 있습니다.

```cpp-formatted
if (in.is_open()) {
```



`is_open` 은 기존의 `istream` 에는 없고 `ifstream` 에서 상속 받으면서 추가된 함수 입니다. 파일이 열렸는지의 유무를 리턴합니다. 만일 해당 경로에 있는 파일이 존재하지 않는다면 `false` 를 리턴하겠지요.

```cpp-formatted
in >> s;
```



마지막으로 마치 `cin` 을 사용 하는 것 처럼 `in` 객체를 이용해서 파일로 부터 읽을 수 있습니다. (`cin` 에서 >> 로 읽을 때 공백 문자가 나올 까지 읽었던 것처럼 여기도 동일합니다)


여기서 한 가지 흥미로운 점이 있습니다. C 언어에서 기억을 되돌려 보자면 파일 입출력을 한 후에 꼭 `fclose` 를 해주어야 했었습니다. 그런데 여기서하는 신기하게도 그러한 작업을 하지 않습니다. 왜 그렇냐면, 이미 `ifstream` 객체의 소멸자에서 자동적으로 `close` 를 해주기 때문입니다.


다만 `close` 를 직접 해야 되는 경우도 있습니다.

```cpp-formatted
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

int main() {
  // 파일 읽기 준비
  ifstream in("test.txt");
  string s;

  if (in.is_open()) {
    in >> s;
    cout << "입력 받은 문자열 :: " << s << endl;
  } else {
    cout << "파일을 찾을 수 없습니다!" << endl;
  }

  in.close();
  in.open("other.txt");

  if (in.is_open()) {
    in >> s;
    cout << "입력 받은 문자열 :: " << s << endl;
  } else {
    cout << "파일을 찾을 수 없습니다!" << endl;
  }

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F243340355783AB3F274C61)



와 같이 나옵니다.



```cpp-formatted
in.close();
in.open("other.txt");
```



위 처럼 새로운 파일에서 같은 객체가 입력을 받기 위해서는 기존 파일 스트림과의 연결을 종료하고, 새로운 파일과 연결을 시켜주면 됩니다. 기존 파일과의 스트림 종료는 `close` 함수가, 새로운 파일과의 연결은 `open` 함수가 수행하고 있습니다. `open` 함수가 있기에 굳이 `ifstream` 객체 생성자에서 파일 경로를 바로 지정해줄 필요는 없고, 나중에 `open` 으로 원하는 파일을 열어도 상관 없습니다.

```cpp-formatted
// 이진수로 읽기
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

int main() {
  // 파일 읽기 준비
  ifstream in("test.txt", ios::binary);
  string s;

  int x;
  if (in.is_open()) {
    in.read((char*)(&x), 4);
    cout << hex << x << endl;
  } else {
    cout << "파일을 찾을 수 없습니다!" << endl;
  }

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2775BF425783D39F068ABA)





와 같이 나옵니다.


실제로 `Hex` 에디터로 `test.txt` 의 내용을 살펴보아도


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F275FEE3C5783D42D1F801C)



와 같이 첫 부분이 일치하는 것으로 나타납니다.


"어 다른데요?"


라고 생각하시는 분들은 엔디안을 간과한 것인데, 우리가 쓰는 `CPU` 의 경우 리틀 엔디안이라 해서, 높은 주소값에 높은 자리수가 온다고 생각하면 됩니다, 따라서 각각의 바이트가 `EF / BB / BF / EC` 가 거꾸로 `EC / BF / BB / EF` 이렇게 `int` 변수에 기록이 된 것입니다. (이에 대한 내용은 C 강좌에서도 다루었습니다)

```cpp-formatted
ifstream in("test.txt", ios::binary);
```



일단 위와 같이 `ifstream` 객체를 생성할 때 생성자에 옵션으로 `binary` 형태로 받겠다고 명시할 수 있습니다. 이 말은 문제열 데이터를 받는게 아니라 그냥 이진 그대로의 값을 받아내겠다는 의미 입니다. 만일 아무것도 명시 하지 않는다면 위에서 보았던 것 처럼 문자열 형태로 데이터를 받습니다.


이 `binary` 는 단순한 숫자로 `ios` 에 정의되어 있습니다. `binary` 말고도 설정할 수 있는 여러가지 옵션들이 있는데. 이들을 `OR` 해서 여러가지 옵션을 조합할 수 있습니다. ([여기](http://itguru.tistory.com/129) 에서의 비트연산 활용 부분을 생각하시면 됩니다)

```cpp-formatted
in.read((char*)(&x), 4);
```



`read` 함수는 말 그대로, 4 바이트의 내용을 읽으라는 의미로, 첫 번째 인자에 해당하는 버퍼를 전달해주어야 합니다. 우리의 경우 `int` 변수를 마치 4 바이트 짜리 `char` 배열이라 생각하게 해서이를 전달하였습니다. 두 번째 인자로 반드시 몇 바이트를 읽을 지 전달해야 합니다.

```cpp-formatted
char x[10];
in.read(x, 10);
```



실제로 예시 코드 처럼 `int` 공간에 저장하는 경우는 없고, 위 처럼 그냥 `char` 배열에 크기를 지정해서 읽어들이면 됩니다.



```cpp-formatted
cout << hex << x << endl;
```



참고로 `cout` 에서 사용한 `hex` 역시 지난 강좌에서 `cin` 에서 사용한 `hex` 와 비슷한 부류로 16 진수로 정수 데이터를 표시해줍니다.



###  파일 전체 읽기





```cpp-formatted
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

int main() {
  // 파일 읽기 준비
  ifstream in("test.txt");
  string s;

  if (in.is_open()) {
    // 위치 지정자를 파일 끝으로 옮긴다.
    in.seekg(0, ios::end);

    // 그리고 그 위치를 읽는다. (파일의 크기)
    int size = in.tellg();

    // 그 크기의 문자열을 할당한다.
    s.resize(size);

    // 위치 지정자를 다시 파일 맨 앞으로 옮긴다.
    in.seekg(0, ios::beg);

    // 파일 전체 내용을 읽어서 문자열에 저장한다.
    in.read(&s[0], size);
    cout << s << endl;
  } else {
    cout << "파일을 찾을 수 없습니다!" << endl;
  }

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F237564355784C70A050F4C)



와 같이 파일 전체의 내용이 잘 나오고 있습니다.



```cpp-formatted
// 위치 지정자를 파일 끝으로 옮긴다.
in.seekg(0, ios::end);
```



C 언어에서 `fseek` 과 같은 함수로, 파일 위치 지정자를 사용자의 입맛에 맞게 이리저리 움직일 수 있습니다. 두 번째 인자는, 파일 내 위치를 의미하고, 첫 번째 인자는 그 위치로 부터 얼마나 만큼 떨어져 있느냐를 의미합니다. 우리의 경우 위치 지정자를 파일의 끝에서 0 만큼 떨어진 것, 즉 파일의 끝으로 이동시켰습니다.

```cpp-formatted
// 그리고 그 위치를 읽는다. (파일의 크기)
int size = in.tellg();
```



`tellg` 함수는 위치 지정자의 위치 (시작 지점으로 부터의) 를 반환합니다. 현재 우리가 위치 지정자를 파일 끝으로 이동 시켜 놓았기 때문에 `tellg` 함수는 파일의 크기 (바이트 단위) 로 반환하겠지요. 그리고 문자열에 그 만큼의 크기를 할당해줍니다.



```cpp-formatted
// 위치 지정자를 다시 파일 맨 앞으로 옮긴다.
in.seekg(0, ios::beg);
```


이제 파일을 읽어야할 텐데, 파일 위치 지정자를 끝으로 옮겨 놓았기 때문에 읽기 위해서는 다시 처음으로 옮겨주어야 합니다. 옮기지 않을 경우 위치 지정자가 파일 끝에 있으므로 아무것도 읽지 못할 것입니다.

```cpp-formatted
// 파일 전체 내용을 읽어서 문자열에 저장한다.
in.read(&s[0], size);
```

마지막으로 파일 전체에 내용을 문자열에 저장하면 됩니다.

```cpp-formatted
// getline 으로 읽어들이기
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

int main() {
  // 파일 읽기 준비
  ifstream in("test.txt");
  char buf[100];

  if (in.is_open()) {
    while (!in.eof()) {
      // 한 줄 씩 최대 100 자 까지 읽어들인다.
      in.getline(buf, 100);
      cout << buf << endl;
    }
  } else {
    cout << "파일을 찾을 수 없습니다!" << endl;
  }

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F265016345784EBD7035F86)



와 같이 나옵니다.



`getline` 함수는 파일에서 개행문자 (\n) 이 나올 때 가지 최대 지정한 크기 만큼 읽게됩니다. 만일 파일 끝에 도달하게 된다면 `eofbit` 가 켜지면서

```cpp-formatted
in.getline(buf, 100);
```



위 경우 `buf` 에 최대 100 글자 까지 입력 받습니다. 물론 개행 문자가 나올 때 까지 입력 받는 다는 것은 디폴트 이고, 추가 인자로 지정해주면 해당 문자가 나올 때 가지 입력 받습니다. 예를 들어서

```cpp-formatted
in.getline(buf, 100, '.');
```



이런식으로 하면 마침표가 나올 때 까지 입력받게 됩니다.


한 가지 주의할 점은 `getline` 함수는 개행 문자 (혹은 지정한 문자) 가 나오기 전에 지정한 버퍼의 크기가 다 차게 된다면 `failbit` 를 키게 됩니다.

따라서 버퍼의 크기를 너무 작게 만든다면 정상적으로 데이터를 받을 수 없게 됩니다. `getline` 을 사용하기 전에 이와 같은 조건을 꼭 확인해야 합니다.



```cpp-formatted
// string 에 정의된 getline 사용
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

int main() {
  // 파일 읽기 준비
  ifstream in("test.txt");

  string s;
  if (in.is_open()) {
    while (!in.eof()) {
      getline(in, s);
      cout << s << endl;
    }
  } else {
    cout << "파일을 찾을 수 없습니다!" << endl;
  }

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F265016345784EBD7035F86)





와 같이 나옵니다.


이 `getline` 함수는 `ifstream` 에 정의되어 있는 것이 아니라, `string` 에 정의되어 있는 함수로, 첫 번째 인자로 `istream` 객체를 받고, 두 번째 인자로 입력 받은 문자열을 저장할 `string` 객체를 받게 됩니다.


기존에 `ifstream` 의 `getline` 을 활용할 때 보다 훨신 편리한 것이, 굳이 버퍼의 크기를 지정하지 않아도 알아서 `string` 의 크기를 조정해서 개행문자 혹은 파일에 끝이 나올 때 까지 입력받게 됩니다.



###  파일에 쓰기




```cpp-formatted
#include <iostream>

#include <fstream>
#include <string>
using namespace std;

int main() {
  // 파일 쓰기 준비
  ofstream out("test.txt");

  string s;
  if (out.is_open()) {
    out << "이걸 쓰자~~";
  }

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F21241F49578525D91300E8)



와 같이 `test.txt` 에 내용이 잘 써진 것을 알 수 있습니다.


만일 `test.txt` 가 존재하지 않을 경우, `test.txt` 를 생성한 뒤에, 생성이 성공하였다면 출력하게 됩니다. `ofstream` 은 열려는 파일이 존재하지 않으면 해당 파일을 생성하고 열게 됩니다. 만일, 해당 파일이 이미 존재한다면, 특별한 설정을 하지 않는다면 해당 파일 내용이 다 지워지고 새로운 내용으로 덮어 씌어지게 됩니다.

```cpp-formatted
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

int main() {
  // 파일 쓰기준비
  ofstream out("test.txt", ios::app);

  string s;
  if (out.is_open()) {
    out << "덧붙이기";
  }

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F2447743D5785BB37083826)





와 같이 나옵니다.


`out` 객체를 생성할 때 옵션으로 `app` 을 주게 되면, 파일에 스트림을 연결할 때 기존 파일의 내용을 지우고 새로 쓰는 것이 아니라 위 사진 처럼 그 뒤에 새로운 내용을 붙여 쓰게 됩니다.


앞서 나왔던 `ios::binary` 와 `ios::app` 말고도 4개가 더 있습니다. 이들을 나열해보자면

* `ios::ate` : 자동으로 파일 끝에서 부터 읽기와 쓰기를 실시합니다. (즉 파일을 열 때 위치 지정자가 파일 끝을 가리키고 있게 됩니다)
* `ios::trunc` : 파일 스트림을 열면 기존에 있던 내용들이 모두 지워집니다. 기본적으로 `ofstream` 객체를 생성할 때 이와 같은 설정으로 만들어집니다.
* `ios::in, ios::out` : 파일에 입력을 할 지 출력을 할 지 지정하며, `ifstream` 과 `ofstream` 객체를 생성할 때 각각은 이미 설정되어 있습니다.

참고로 `ios::ate` 와 `ios::app` 은 비슷해 보이지만 차이가 있다면 `ios::app` 의 경우 원본 파일의 내용을 무조건 적으로 보장하지만, `ate` 는 위치 지정자를 그 이전으로 옮길 수 있습니다.즉 `app` 의 경우 파일 위치 지정자가 기존 파일의 끝이 시작점이라 생각하여 움직이며 `ate` 의 경우 기존 파일을 포함해서 움직입니다 (사실 `ate` 의 경우 사용할 일이 거의 없을 것입니다).


그렇다고 해서 `ate` 를 이용해서 기존에 있는 파일 데이터 한 가운데에 무언가를 끼워 넣을 수 있는 것은 아닙니다.

```cpp-formatted
// ate 와 app
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

int main() {
  // 두 파일에는 모두 abc 라고 써 있었습니다.
  ofstream out("test.txt", ios::app);
  ofstream out2("test2.txt", ios::ate);

  out.seekp(3, ios::beg);
  out2.seekp(3, ios::beg);

  out << "추가";
  out2 << "추가";

  return 0;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F2206553D578624CF30D956)






`app` 을 사용한 경우 위와 같이 `abc` 바로 뒤에 '추가' 문자열에 붙어 있는 것으로 나타납니다. 비록 파일 위치 지정자를 앞에서 3 칸 떨어진 곳으로 이동하였음에도, `app` 모드로 읽었을 때 현재 파일은 빈 파일이라 생각되어 위치 지정자라 움직일 공간이 없기에, 실제로 위치 지정자는 움직이지 않고 출력되었습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F262BC340578624EC26E38B)



반면에 `ate` 를 사용한 경우 앞에서 3 칸 띄어진 곳에 '추가' 라고 문자열이 출력된 반면 기존의 `abc` 라는 데이터는 지워졌습니다. 즉 `ate` 모드로 파일을 열게 되면 비록 스트림 위치 지정자는 움직여서 3칸 뒤에 출력되기는 하였지만 기존에 써져 있던 내용은 모두 지워집니다. (ate 는 기존 파일의 내용을 보존하지 않습니다)



###  ofstream 연산자 오버로딩 하기





```cpp-formatted
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

class Human {
  string name;
  int age;

 public:
  Human(const string& name, int age) : name(name), age(age) {}
  string get_info() {
    return "Name :: " + name + " / Age :: " + to_string(age);
  }

  friend ofstream& operator<<(ofstream& o, Human& h);
};

ofstream& operator<<(ofstream& o, Human& h) {
  o << h.get_info();
  return o;
}
int main() {
  // 파일 쓰기 준비
  ofstream out("test.txt");

  Human h("이재범", 60);
  out << h << endl;

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2414734257863D4627B069)





와 같이 나옴을 알 수 있습니다. 이전 강좌에서 입출력 연산자 오버로딩을 한 번 해보았는데, `ofstream` 이라고 해서 달라지는 것은 없습니다. 단순히 `ofstream` 객체의 레퍼런스를 받고, 다시 이를 리턴하는 `operator<<` 함수를 정의해주면 됩니다.



###  문자열 스트림 (stringstream)



```cpp-formatted
#include <iostream>
#include <sstream>
using namespace std;
int main() {
  istringstream ss("123");
  int x;
  ss >> x;

  cout << "입력 받은 데이터 :: " << x << endl;

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2271F14B5786637E06C381)



와 같이 나옵니다.


`sstream` 에는 `stringstream` 이 정의되어 있는데 이는 마치 문자열을 하나의 스트림이라 생각하게 해주는 가상화 장치라고 보시면 됩니다.

```cpp-formatted
istringstream ss("123");
```



예를 들어서 우리는 위를 통해서 문자열 "123" 이 기록되어 있는 입력 스트림을 생성하였습니다. 마치 파일에 123 이라 기록해놓고 거기서 입력 받는 것과 동일하다고 생각하면 됩니다.

```cpp-formatted
int x;
ss >> x;
```



그래서 마치 파일에서 숫자를 읽어내는 것 처럼 `stringstream` 을 통해서 123 을 읽어낼 수 있습니다.


이를 활용하면 `atoi` 와 같은 함수를 사용할 필요 없이 간편하게 문자열에서 숫자로 변환하는 함수를 만들 수 있습니다.

```cpp-formatted
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

double to_number(string s) {
  istringstream ss(s);
  double x;

  ss >> x;
  return x;
}
int main() {
  cout << "변환:: 1 + 2 = " << to_number("1") + to_number("2") << endl;

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2633F437578664AD224FAD)



위와 같이 간편하게 문자열을 숫자로 변환할 수 있습니다.

```cpp-formatted
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

string to_str(int x) {
  ostringstream ss;
  ss << x;

  return ss.str();
}
int main() {
  cout << "문자열로 변환:: 1 + 2 = " << to_str(1 + 2) << endl;

  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F256F583B5786655F245518)



와 같이 나옵니다.


이번에는 거꾸로 데이터를 출력할 수 있는 `ostringstream` 이 있습니다. 위와 비슷한 방법으로 이번애는 거꾸로 숫자에서 ㅁ누자열로 바꾸는 함수를 제작할 수 있습니다.

```cpp-formatted
ostringstream ss;
ss << x;
```



위와 같이 `int` 변수 `x` 의 값을 문자열 스트림에 출력하였습니다. 이 과정에서 자동으로 숫자에서 문자열로의 변환이 있겠지요.

```cpp-formatted
return ss.str();
```



이제  str 함수로 현재 문자열 스트림에 쓰여 있는 값을 불러오기만 하면 끝납니다.


이상으로 이번 강좌를 마치도록 하겠습니다. 다음 강좌에서는 여태 까지 배운 내용들을 총 종합하여 큰 프로젝트 하나를 만들도록 하겠습니다. 다음 강좌에서 제작하기 전에, 아래 생각해보기를 통해서 먼저 여러분 스스로 구현해 보는 것도 좋을 것 같습니다.



###  생각 해보기


여러분은 콘솔 용 엑셀을 만들 것입니다. 물론 진짜 엑셀 처럼 엄청 거대한 프로그램을 만들 겠다는 것은 아니고, 기본적인 것들만 구현한 엑셀 프로그램이 될 것입니다.

#### 문제 1 (난이도 :中)

일단 엑셀의 셀들의 정보 (일단 단순한 `string` 이라고 생각합시다) 에 대한 `Cell` 클래스가 있고 이 `Cell` 객체들을 모아두는 `Table` 클래스가 있습니다. `Table` 클래스에는 2차원 배열로 `Cell` 객체들에 대한 정보 (참고로 `Cell` 객체가 생성 될 때 마다 동적으로 `Cell` 객체를 생성합니다.) 가 보관되어 있습니다. 또한 `Table` 클래스에 전체 데이터를 출력하는 `print_table` 함수가 가상으로 정의되어 있습니다.

여러분은 `Table` 클래스를 상속 받는 `TextTable, CSVTable, HTMLTable` 클래스를 만들어서 `print_table` 함수를 오버라이드 할 함수들을 제작할 것입니다. 예를 들어 `TextTable` 클래스의 `print_table` 함수는 텍스트 형식으로, `CSVTable` 은 `CSV` 파일 형식으로 등등 만들어야 겠지요?
제가 아래 대충 프로그램의 골격을 잡아 놓았으니 여러분들은 이를 채우기만 하면 됩니다.

```cpp-formatted
class Table;
class Cell어

{
  Table* table;  // 어느 테이블에 속해있는지
  string data;
  int x, y;  // 테이블 에서의 위치
 public:
  Cell(const string& data) : data(data){};
};
class Table {
  Cell*** data_base;  // 왜 3중 포인터 인지 잘 생각해보세요!
 public:
  Cell();
  virtual string print_table() = 0;
  void reg_cell(Cell* c, int row, int col);  // Cell 을 등록한다
  string get_cell_string(int row,
                         int col);  // 해당 위치의 Cell 데이터를 얻는다.
  ~Table();
};
ostream& operator<<(ostream& o, Table& t) {
  o << t.print_table();
  return o;
}
class TextTable : public Table {};
class CSVTable : public Table {};
class HTMLTable : public Table {};
```

#### 문제 2 (난이도 :最上 - 위의 문제와 이어집니다)


하지만 실제 엑셀의 경우 셀이 문자열 데이터만 들어가는 것이 아니라, 숫자나 날짜 심지어 수식 까지도 들어갈 수 있습니다. 따라서 우리는 `Cell` 을 상속 받는 4 개의 `StringCell. NumberCell, DateCell, ExprCell` 클래스들을 만들어야 합니다.


또한 `Cell` 클래스에 `to_numeric` (데이터를 숫자로 바꾼다)과 `stringify` (데이터를 문자열로 바꾼다) 함수들을 가상으로 정의하고, 4개의 클래스들이 이를 상속 받아서 구현할 수 있게 해야 합니다. (참고로 문자열을 숫자로 변환하면 그냥 0 이 되게 하면 됩니다)


또한 `ExprCell` 의 경우 간단한 수식에 대한 정보를 가지는 객체로, `Cell` 들 간의 연산을 사용할 수 있습니다. 에를 들어서 `A1+B2+C6-6` 와 같은 데이터가 들어 있는 `ExprCell` 에 `to_numeric` 함수를 호출하면`A1, B2, C6` 의 값을 더하고 (각 셀에 `to_numeric` 을 해서), 6 을 빼준 결과값이 나와야 합니다.


참고로 프로그래밍의 편의를 위해서 `ExprCell` 의 경우, 셀을 지칭하는 것은 딱 두 글자 (A1, Z9 처럼) 로 하고, 숫자는 오직 한 자리 수 정수, 그리고 가능한 연산자는 `+, -, *, /` 로 하겠습니다.


아마도 여태 까지 강좌에서 한 프로그래밍 중에 가장 도전적인 것이 아닌가 싶습니다. 참고로 위를 구현하기 위해서 여러가지 자료형이 필요할 텐데 (있으면 편리합니다!), 대표적으로 벡터와 스택이 있습니다. 벡터는 가변 길의 배열로, 배열 처럼 사용하면서 사용자가 임의의 위치에 자료를 넣다 뺏다 할 수 있는 구조고, 스택은 `pop` 과 `push` 밖에 없는 자료형으로, `push` 을 하면 새로운 데이터가 맨 위에 삽입되고, `pop` 을 하면 맨 위에 있는 것 부터 제거되어 나오게 됩니다. (즉 먼저 넣은것이 나중에 나오는 자료구조 입니다) 저는 이들 자료 구조를 새롭게 만들어서 사용하였습니다. 여러분들도 아마 필요하실 것입니다.


아마 여러분이 이 강좌에서 여태 까지 구현했던 프로그램 중에 가장 복잡할 것입니다. 많은 시간이 필요한 만큼 재미가 있을 테니 한 번 다음 강좌를 보기 전 까지 도전해보시기 바랍니다!

##@ chewing-cpp-end
Link :  216
2015-11-11 21:09
Link :  166
2011-10-23 09:25
----------------
title : C++ 레퍼런스 - ios::bad 함수
cat_title :  ios::bad
ref_title : bad
publish_date : 2011-10-23 09:25
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::bad

```info
bool bad ( ) const;
```


`badbit` 가 설정되어 있는지 확인한다.

만일 이전의 입출력 작업으로 인해 스트림의 오류 상태 플래그인 `badbit` 가 설정되어 있는지 확인한다. 이 플래그는 입력 작업 중 스트림의 완전성이 손상되었을 때 발생한다. 완전성이 손상되었다는 말은, 한 개의 스트림의 여러개의 입출력 작업이 동시에 일어날 때를 일컫는다.

한 가지 조심할 점은 이 함수는 [good](http://itguru.tistory.com/164)함수의 정 반대가 아니라는 점이다. [good](http://itguru.tistory.com/164)함수는 3 개의 오류 상태 플래그(`eofbit, failbit, badbit`) 모두가 설정되지 않았을 때 `true` 를 리턴한다.



###  인자




없다



###  리턴값




  `badbit` 이 설정되어 있을 때 `true` 를 리턴하고 아니면 `false`



###  템플릿 멤버 선언



```cpp-formatted
(basic_ios<charT, traits>)bool bad() const;
```



###  연관된 함수

*  [ios::fail](http://itguru.tistory.com/165)  :  `failbit` 이나 `badbit` 이 설정되어 있는지 확인한다.
*  [ios::good](http://itguru.tistory.com/164):  스트림에 어떠한 오류 플래그도 설정되지 않았는지 확인한다.
*  [ios::eof](http://itguru.tistory.com/167)  :  `eofbit` 이 설정되어 있는지 확인한다.
*  [ios::rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그를 얻는다.
*  [ios::clear](http://itguru.tistory.com/180)  :  오류 상태 플래그를 설정한다.
Link :  165
2011-10-23 09:15
----------------
title : C++ 레퍼런스 - ios::fail 함수
cat_title :  ios::fail
ref_title : fail
publish_date : 2011-10-23 09:15
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::fail

```info
bool fail ( ) const;
```


`failbit` 이나 `badbit` 이 설정되어 있는지 확인한다.
이 함수는 `failbit` 이나 `badbit` 중 어느 하나가 설정(set) 되어 있으면 `true` 를 리턴한다. 이 플래그들은 입력 작업 시 파일 끝(End `Of File)` 에 도달하기 전에 오류가 발생할 시 설정되는 플래그 들이다.

  `failbit` 은 보통 입력 작업 시 내부적인 논리 오류로 인해 발생되는 오류, 예컨대 입력 받기를 기대하였던 값이 오지 않을 때 (파일에 접근할 수 없다던지..) 설정되므로, `failbit` 이 설정되더라도 스트림의 다른 입출력 작업들은 가능하다. 반면에 `badbit` 의 경우 스트림의 완전성(integrity)이 깨질 때, 쉽게 말하면 하나의 스트림에 동시의 두 개의 다른 작업이 진행될 때 발생되는 것이므로 `badbit` 이 설정되면 다른 입출력 작업들은 할 수 없게 된다. `badbit` 은 `bad` 함수를 통해 상태를 독립적으로 확인할 수 있다.

이 함수는 `operator!` 와 동일하게 작동한다.



###  인자


없다



###  리턴값




`badbit` 나 `failbit` 가 설정되어 있다면 `true` 를 리턴한다. 아니면 `false`



###  템플릿 멤버 선언




```cpp-formatted
(basic_ios<charT, traits>)bool fail() const;
```




###  실행 예제




```cpp-formatted
/*

cin 으로 int 형 변수를 입력 받는데, 그 외의 타입의 값이 오면 failbit 가 설정되어
입력을 중지한다.

*/
#include <iostream>
using namespace std;

int main() {
  int i;
  while (!cin.fail()) {
    cin >> i;
    cout << "What you typed : " << i << endl;
  }

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F203CBC3E4EA35BD02BF7FF)




###  연관된 함수

* ios_base::iostate  :  스트림 상태 플래그들을 위한 타입
*  [ios::bad](http://itguru.tistory.com/166)  :  `badbit` 이 설정되어 있는지 확인한다.
*  [ios::good](http://itguru.tistory.com/164):  스트림에 어떠한 오류 플래그도 설정되지 않았는지 확인한다.
*  [ios::eof](http://itguru.tistory.com/167)  :  `eofbit` 이 설정되어 있는지 확인한다.
*  [ios::rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그를 얻는다.
*  [ios::setstate](http://itguru.tistory.com/179)  :  오류 상태 플래그를 설정한다.
*  [ios::clear](http://itguru.tistory.com/180)  :  오류 상태 플래그를 설정한다.
Link :  164
2011-10-23 08:54
----------------
title : C++ 레퍼런스 - ios::good 함수
cat_title :  ios::good
ref_title : good
publish_date : 2011-10-23 08:54
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::good

```info
bool good ( ) const;
```


스트림이 입출력 작업이 가능한 상태인지 확인한다.

이 함수는 스트림의 오류 상태 플래그(`eofbit, failbit, badbit`) 이 모두 설정되지 않을 때 `true` 를 리턴한다.

한 가지 주의할 점은 이 함수는 `bad` 함수와 정 반대가 아니라는 사실이다. `bad` 함수는 `badbit` 플래그가 설정되어 있는지의 여부만 확인하는 함수이다.

오류 상태 플래그들은 `eof, fail, bad` 함수들을  이용해서 독립적으로 체크할 수  있다.

이 함수가 리턴하는 값은 아래의 작업의 결과와 동일하다.

```cpp-formatted
(rdstate() == 0)
```




###  인자




없다.



###  리턴값


만일 스트림의 어떠한 오류 상태 플래그(`eofbit, failbit, badbit`) 이 설정되어 있지 않다면 `true` 를 리턴한다. 그렇지 않으면 `false` 를 리턴한다.


###  템플릿 멤버 선언


```cpp-formatted
(basic_ios<charT, traits>)bool good() const;
```

###  연관된 함수

*  [ios::fail](http://itguru.tistory.com/165)  :  `failbit` 이나 `badbit` 이 설정되어 있는지 확인한다.
*  [ios::bad](http://itguru.tistory.com/166)  :  `badbit` 이 설정되어 있는지 확인한다.
*  [ios::eof](http://itguru.tistory.com/167)  :  `eofbit` 이 설정되어 있는지 확인한다.
*  [ios::rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그를 얻는다.
*  [ios::setstate](http://itguru.tistory.com/179)  :  오류 상태 플래그를 설정한다.
Link :  163
2011-10-22 10:10
----------------
title : C++ 레퍼런스 - ios_base::pword 함수
cat_title :  ios_base::pword
publish_date : 2011-10-22 10:10
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::pword

```info
void* & pword (int idx);

```

내부 확장 가능 배열을 가리키는 포인터의 레퍼런스를 얻는다.
  내부 확장 가능 배열의 `idx` 번째의 원소를 가리키는 포인터의 레퍼런스를 리턴한다. 만일 `idx` 가 새로운 원소의 인덱스이고, 내부 확장 가능 배열의 크기가 충분하지 않을 경우, 이 함수는 자동으로 0 으로 초기화 된 원소들을 할당하게 된다.

`idx` 의 값은 이전의 [xalloc](http://itguru.tistory.com/162)함수의 호출을 통해 얻어진 값이여야만 한다.

 [xalloc](http://itguru.tistory.com/162)함수를 통해 얻어진 인덱스 값은 스트림에 다른 작업 (pword 를 호출하는 것을 포함한) 이 수행되기 전 까지 사용가능하다. 만일 다른 작업이 수행된다면, 인덱스 값은 무용지물이 된다. 물론, `pword` 를 연속으로 두 번 호출하는 것은 내부 확장 가능 배열의 동일한 포인터의 레퍼런스를 얻게 되는 것이겠지만 말이다.

  내부 확장 가능 배열은 범용의 `word` 크기의 원소들을 가진 배열로, 스트림 객체 마다 하나 씩 가지게 된다. 이 내부 확장 가능 배열은 임시적으로 데이터를 저장하는데 사용된다.



###  인자




`idx`

  내부 확장 가능 배열의 특정 원소의 인덱스 값이다. 이 값은 이전의 [xalloc](http://itguru.tistory.com/162)함수 호출을 통해 얻어져야 한다.



###  리턴값



  `idx` 번째의 원소를 가리키는 포인터의 레퍼런스를 얻는다. 이 때, 이 값은 `void*` 타입 객체의 레퍼런스가 된다. 실패시, 값이 0 인 `void*&` 가 리턴된다.



###  실행 예제


```cpp-formatted
/*

이 예제는
http://msdn.microsoft.com/en-us/library/77z9kz41.aspx
에서 가져왔습니다.

pword 로 cin 객체의 내부 확장 가능 배열의 i 번째 원소에 testing 의 주소를 넣고
이를 출력한다.
*/

#include <iostream>using namespace std;int main( ){    static const int i = ios_base::xalloc();    cin.pword( i ) = "testing";    cout << ( char * )cin.pword( i ) << endl;}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F133CFD414EA216FB40D60D)



###  연관된 함수

* ios_base:: [xalloc](http://itguru.tistory.com/162)  :  내부 확장 가능 배열의 새로운 인덱스를 리턴하게 된다. (정적 함수)
* ios_base:: [iword](http://itguru.tistory.com/161)  :  내부 확장 가능 배열의 정수 원소의 레퍼런스를 리턴한다.
Link :  161
2011-10-22 09:53
----------------
title : C++ 레퍼런스 - ios_base::iword
cat_title :  ios_base::iword
publish_date : 2011-10-22 09:53
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::iword

```info
long& iword (int idx);
```


내부 확장 가능한 배열의 정수 원소의 레퍼런스를 얻는다.
  내부 확장 가능 배열(internal `extensible array)` 에서 `long` 형의 `idx` 번째의 원소의 레퍼런스를 얻는다. 만일 `idx` 가 새로운 원소의 번호이고, 내부 확장 가능 배열의 크기 보다 더 큰 값을 가진다면 (즉, 아직 할당 되지 않았다면), 이 함수는 이에 해당하는 만큼 메모리를 확장하고, 새롭게 생성된 원소들의 값을 0 으로 초기화 한다.

`idx` 의 값은 이전에 [xalloc](http://itguru.tistory.com/162)에 의해 리턴된 값이여야만 한다.

  한 번 `iword` 가 리턴한 레퍼런스는 스트림에 다른 연산( `iword` 를 호출하는 것을 포함해서) 이 수행되기 전 까지 사용될 수 있다. 만일 스트림이 다른 작업을 수행한다면, 리턴된 레퍼런스를 사용하지 못할 수 있다.

  내부 확장 가능 배열은 스트림에서 여러 용도(general purpose)로 사용되는 `word` 크기의 원소들을 가진 배열로 데이터를 임시적으로 저장하는데 사용된다.



###  인자




`idx`

  내부 확장 가능 배열의 특정 원소의 인덱스값. 이 값은 이전의 `xalloc` 함수 호출을 통해 얻어진 값이여야 한다.



###  리턴값




  인덱스가 `idx` 인 내부 확장 가능 배열의 원소의 레퍼런스를 리턴한다. 이 때, 그 레퍼런스는 `long` 형의 원소의 레퍼런스 이다. 실패시, 값이 0 인, `long` 형 원소의 레퍼런스가 리턴된다.



###  실행 예제




```cpp-formatted
/*

이 예제는
http://msdn.microsoft.com/en-us/library/77z9kz41.aspx
에서 가져왔습니다.

i, j 가 각각 xalloc 을 통해 얻어낸 index 들이고, cout 과 cin 의 내부 확장 가능
배열의 i , j 번째 원소에 각각 11 과 13 을 넣는다.
*/
#include <iostream>
using namespace std;
int main() {
  static const int i = ios_base::xalloc();
  static const int j = ios_base::xalloc();

  cout.iword(i) = 11;
  cin.iword(j) = 13;

  cout << cout.iword(i) << endl;
  cout << cin.iword(j) << endl;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1701413C4EA213713E82A5)




###  연관된 함수

*  [ios_base::](http://itguru.tistory.com/162) [xalloc](http://itguru.tistory.com/162) :  내부 확장 가능 배열의 새로운 인덱스를 리턴한다.
*  [ios_base::pword](http://itguru.tistory.com/163)  :  내부 확장 가능 배열의 포인터의 레퍼런스를 얻는다.
Link :  162
2011-10-22 09:38
----------------
title : C++ 레퍼런스 - ios_base::xalloc 함수
cat_title :  ios_base::xalloc
publish_date : 2011-10-22 09:38
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::xalloc  (static member function)

```info
int xalloc ( );
```


내부 확장 가능 배열(internal extensible array) 의 새로운 인덱스를 리턴한다.
이 인덱스(index) 를 통해서 다른 멤버 함수들(pword, [iword](http://itguru.tistory.com/161)) 들의 작업에 사용될 수 있다. 이 인덱스는 매 호출 마다 1 씩 증가하게 된다.

내부 확장 가능 배열은 `word` 들을 원소를 가지는 배열이다.

이 함수는 정적 함수 이다.



###  리턴값


  새로운 인덱스를 리턴하며, 이 인덱스는 [iword](http://itguru.tistory.com/161)나 `pword` 멤버 함수들을 통해 참조될 수 있다.



###  연관된 함수

*  [ios_base::iword](http://itguru.tistory.com/161)  :  내부 확장 가능 배열의 정수 원소의 레퍼런스를 얻는다.
*  [ios_base::pword](http://itguru.tistory.com/163):  내부 확장 가능 배열을 가리키는 포인터의 레퍼런스를 얻는다.
Link :  160
2011-08-20 00:41
----------------
title : C++ 레퍼런스 - ios_base::getloc 함수
cat_title :  ios_base::getloc
publish_date : 2011-08-20 00:41
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::getloc

```cpp-formatted
locale getloc() const;
```


현재 로케일(locale) 을 알아낸다.
스트림 객체의 로케일을 리턴한다.




###  인자





없다.




###  리턴값





스트림의 로케일 객체를 리턴한다.




###  실행 예제




```cpp-formatted
// 로케일 이름을 출력한다.
#include <iostream>
#include <locale>
using namespace std;

int main() {
  locale current = cout.getloc();
  cout << current.name() << endl;  // 현재 로케일 이름을 출력한다.
  return 0;
}
```


실행 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F161A3C3B4E4E83B81B0A87)



###  연관된 함수

*  [ios_base::imbue](http://itguru.tistory.com/158)  :  로케일을 설정한다.
Link :  158
2011-08-20 00:28
----------------
title : C++ 레퍼런스 - ios_base::imbue
cat_title :  ios_base::imbue
publish_date : 2011-08-20 00:28
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::imbue

```cpp-formatted
locale imbue(const locale& loc);
```


로케일을 설정(imbue) 한다.
`loc` 를 스트림의 새로운 로케일(locale) 객체로 사용하여, 로케일과 관련있는 작업에 이를 사용한다.

`imbue` 함수 종료 직전에 `imbue_event` 가 발생되며 [register_callback](http://itguru.tistory.com/159)함수를 통해 등록되었던 함수들이 모두 호출되게 된다.





###  인자




`loc`

  스트림의 새롭게 설정될 로케일 객체이다.




###  리턴값




  함수 호출 이전 상태의 로케일 객체



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios_base/imbue/
에서 가져왔습니다.

*/
#include <iostream>
#include <locale>
using namespace std;

int main() {
  locale mylocale("french");  // 로케일 객체를 '프랑스' 로 설정한다.
  cout.imbue(mylocale);       // 이를 cout 로케일로 설정한다.
  cout << (double)3.14159
       << endl;  //프랑스에서는 . 대신 , 를 사용하므로 3,14159 로 표시된다.
  return 0;
}
```

실행 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F13095D574E4E10412DED75)



###  연관된 것들

*  [ios_base::getloc](http://itguru.tistory.com/160): 현재 로케일을 알아온다.
Link :  159
2011-08-20 00:24
----------------
title : C++ 레퍼런스 - ios_base::register_callback 함수
cat_title :  ios_base::register_callback
publish_date : 2011-08-20 00:24
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::register_callback

```cpp-formatted
void register_callback(event_callback fn, int index);
```


이벤트 콜백 함수를 등록한다.

인자 `fn` 으로 전달된 함수를 등록(register)하고 특정 이벤트가 발생시 이 함수가 자동으로 호출되게 된다. `index` 는 함수 호출 시 전달되는 인자이다. 만일 한 개 이상의 콜백 함수가 등록 되어 있다면 이들은 등록된 순서 반대로 호출되게 된다. (즉 나중에 등록된 것이 먼저 호출됨)

이 때 콜백 함수는 `event_callback` 타입이여야만 하는데 이는

```cpp-formatted
(*fn)(ev, *this, index)
```


위와 같다. 이 때 `index` 는 이 함수를 등록시 사용되는 인자이고, `*this` 는 호출한 객체를 가리키는 포인터, 그리고 `ev` 는 객체의 `enum` 형의 멤버로, 어떠한 이벤트가 발생되었는지 알려주게 된다. 이 값은 아래의 값들 중 하나일 수 있다.

|값|발생한 이벤트|
|---|--------|
|`copyfmt_event`|`ios::copyfmt` 를 호출하였을 때 (정확히 말하면, 서식 플래그가 복사가 되었지만 예외 마스크는 복사가 되기 직전일 때)|
|`erase_event`|소멸자 호출시(또한 `ios::copyfmt` 시작시에도 호출된다)|
|`imbue_event`|[imbue](http://itguru.tistory.com/158) 함수 종료 바로 직전에|

모든 등록된 함수들은 위의 상황 발생 시 호출된다. 이 때 함수 자체에서 어떠한 이벤트가 발생하였는지는 `ev` 인자를 통해 알아낼 수 있다


###  인자

`fn`

호출하고 싶은 함수를 가리키는 포인터. 이 때 `event_callback` 타입은 아래와 같다.

```cpp-formatted
typedef void (*event_callback)(event ev, ios_base& ios, int index);
```


`index`

  콜백 함수 호출시 인자로 전달되는 정수값이다. 이는 콜백 함수에서 사용될 인자들의 값들을 지정하는데 사용할 수 있다.



###  리턴값




없다.



###  실행 예제




```cpp-formatted
/*

testfn 이 imbue 함수 호출시와 ostream 객체 소멸시 두 번 호출된다
이 예제는
http://www.cplusplus.com/reference/iostream/ios_base/register_callback/
에서 가져왔습니다.

*/
#include <fstream>
#include <iostream>
using namespace std;

void testfn(ios_base::event ev, ios_base& iosobj, int index) {
  switch (ev) {
    case ios_base::copyfmt_event:
      cout << "copyfmt_event\n";
      break;
    case ios_base::imbue_event:
      cout << "imbue_event\n";
      break;
    case ios_base::erase_event:
      cout << "erase_event\n";
      break;
  }
  cout << "인자로 전달된 인덱스" << index << endl;
}

int main() {
  ofstream filestr;
  filestr.register_callback(testfn, 0);
  filestr.imbue(cout.getloc());
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F150F314E4E4E7FA61FBD71)





###  연관된 것들

*  [ios_base::imbue](http://itguru.tistory.com/158) :  로케일(locale) 을 설정한다.
* ios::copyfmt  :  서식 정보를 복사한다.
* ios_base::event  :  이벤트를 나타내기 위한 타입
Link :  157
2011-08-19 16:01
----------------
title : C++ 레퍼런스 - ios_base::precision 함수
cat_title :  ios_base::precision
publish_date : 2011-08-19 16:01
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::precision

```cpp-formatted
streamsize precision() const;
streamsize precision(streamsize prec);
```


부동 소수점 정밀도를 설정하거나, 알아온다.

첫 번째 형태의 함수는 현재 스트림의 **부동 소수점 정밀도(floating point precision)** 값을 리턴한다.

두 번째 형태의 함수는 정밀도를 새로운 값으로 설정한다.

  부동 소수점 정밀도는 부동 소수점 데이터(실수 데이터)를 출력시 최대 얼마의 정밀도로 나타낼 것인지를 의미한다. 어떠한 방식으로 해석될지는 [floatfield 서식 플래그](http://itguru.tistory.com/154)에 의해 결정되는데 이는 과학적 표기법(scientific) 과 고정 소수점 표기(fixed) 그리고 기본 표기(default notation) 이 있다. 기본 표기는 `scientific` 과 `fixed` 모두 설정 되어 있지 않은 경우를 의미한다.

기본 표기(default)시, 정밀도는 소수점 앞 뒤에 나타나는 숫자의 최대 개수를 의미한다. 표시되는 숫자가 정밀도 보다 적다면 0 을 붙여서 정밀도 개수로 맞추어 주게 된다.

`fixed` 나 `scientific` 이 설정되어 있다면 정밀도의 의미가 달라진다. 여기서 정밀도는 소수점 '뒤' 에 존재하는 숫자의 개수를 의미한다. 또한 정밀도가 설정되어 있는 `precision` 보다 적다면 뒤에 0 을 붙여서 그 수를 맞추어 주게 된다. 이 때 소수점 앞에 있는 숫자의 개수는 무시한다.

정밀도는 인자를 가지는 조작자인 `setprecision` 을 통해서도 변경할 수 있다.



###  인자



`prec`

  새로운 부동 소수점 정밀도 값. 이는 `streamsize` 타입의 정수형이다.



###  리턴값




함수 호출 이전의 `precision` 값이다.



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios_base/precision/
에서 가져왔습니다.

*/
#include <iostream>
using namespace std;

int main() {
  double f = 3.14159;
  cout.setf(0, ios::floatfield);  // floatfield 설정 안됨
  cout.precision(5);
  cout << f << endl;
  cout.precision(10);
  cout << f << endl;
  cout.setf(ios::fixed, ios::floatfield);  // floatfield 를 fixed 로 설정
  cout << f << endl;
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1318CA544E4E091A309789)





###  연관된 것들




* setprecision  :  정밀도를 설정한다.
*  [ios_base::width](http://itguru.tistory.com/152):  필드 너비(field width) 를 설정한다.
*  [ios_base::setf](http://itguru.tistory.com/155):  특정 서식 플래그를 설정한다.
Link :  156
2011-08-19 13:33
----------------
title : C++ 레퍼런스 - ios_base::unsetf 함수
cat_title :  ios_base::unsetf
ref_title : unsetf
publish_date : 2011-08-19 13:33
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::unsetf

```cpp-formatted
void unsetf(fmtflags mask);
```


특정 서식 플래그를 끈다(clear)
인자로 전달되는 `mask` 에 켜져 있는 서식 플래그가 꺼지게 된다.

인자를 가지는 조작자인 `resetiosflags` 역시 동일한 작업을 수행한다.



###  인자





`mask`

  어떤 서식 플래그를 끌지 나타내는 비트마스크. 이 비트마스크는 `fmtflags` 타입의 상수들의 조합(OR 연산) 으로 나타낼 수 있다. 아래 실행 예제를 참고하여라.



###  리턴값




없다



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios_base/unsetf/
에서 가져왔습니다.

*/
#include <iostream>
using namespace std;

int main() {
  cout.setf(ios::hex, ios::basefield);  // hex 를 설정한다.
  cout.setf(ios::showbase);             // showbase 를 설정
  cout << 100 << endl;
  cout.unsetf(ios::showbase);  // showbase 를 끝다.
  cout << 100 << endl;
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F12714A584E4DE70D317643)




###  연관된 것들

*  [ios_base::flags](http://itguru.tistory.com/153)  :  서식 플래그를 설정하거나 얻는다.
*  [ios_base::setf](http://itguru.tistory.com/155)  :  특정 서식 플래그를 설정한다.
*  [ios_base::fmtflags](http://itguru.tistory.com/154)  :  스트림 서식 플래그의 타입
* `resetiosflags` :  서식 플래그를 끈다.
Link :  155
2011-08-19 03:06
----------------
title : C++ 레퍼런스 - ios_base::setf 함수
cat_title :  ios_base::setf
ref_title : setf
publish_date : 2011-08-19 03:06
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::setf




```cpp-formatted
fmtflags setf(fmtflags fmtfl);
fmtflags setf(fmtflags fmtfl, fmtflags mask);
```


특정 서식 플래그를 설정한다.

첫번째 형태의 함수의 경우 스트림의 서식 플래그(format flag) 의 비트들 중, `fmtfl` 에 해당하는 것만 설정(set)하고 나머지는 그대로 놔둔다. 이는 마치 `fmtfl | flags()` 를 한 것과 동일하다. ( [flags](http://itguru.tistory.com/153) 함수는 현재 자신의 서식 플래그를 리턴하므로, 이와 `OR` 연산하는 것과 동일하다)

두번째 형태의 함수의 경우 서식 플래그 중 `fmtfl` 과 `mask` 둘 다 설정되니 비트들을 설정하고, 마스크 에는 설정되어 있지만 `fmftl` 에 설정되어 있지 않은 비트는 초기화(clear) 해버린다. 참고로 마스크에 대한 설명은 아래를 참조.두 형태의 함수 모두 함수 호출 이전 상태의 서식 플래그를 리턴한다.

서식 플래그는 스트림에서 데이터를 어떻게 해석하고, 또 어떻게 출력하는지 결정하는데 중요한 역할을 한다. [ios_base::fmtflags](http://itguru.tistory.com/154)를 보면 함수의 인자로 어떠한 값들이 가능한지 알 수 잇다.

보통 첫번째 형태의 `setf` 함수의 경우, 단항 서식 플래그(독립적으로 기능을 수행하는 것)들, `boolalpha, showbase, showpoint, showpos, skipws, unitbuf, uppercase` 를 설정하기 위해 사용되고, 이들 역시 `unsetf` 에서도 사용된다. 반면에 선택적인 플래그들(반드시 하나만 켜져 있어야 한다) 을 조작하기 위해서는 아래와 같은 비트 마스크와 플래그 값들을 이용한다.

|`fmtfl` 서식 플래그 값|`mask` 필드 비트마스크|
|:-----------------:|:-----------------:|
|`left, right, internal`|`adjustfield`|
|`dec, oct, hex`|`basefield`|
|`scientific, fixed`|`floatfield`|

각각이 무엇인지 자세한 설명은 [ios_base::fmtflags](http://itguru.tistory.com/154) 를 참조하면 된다.

또한 인자를 가지는 조작자인 `setiosflags` 역시 비슷한 작업을 한다.



###  인자


`fmtfl`

설정될 서식 플래그. 만일 두번재 형태의 함수가 사용된다면 스트림 서식 플래그에서 `fmtfl` 과 `mask` 에서 모두 설정된 비트만 켜지게 된다. 또한 `mask` 에서 켜졌지만 `fmtfl` 에서 설정 안된 비트는 꺼진다.

`mask`

수정할 플래그를 포함하고 있는 비트마스크


###  리턴값




  함수 호출 이전 상태의 서식 플래그



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios_base/setf/
에서 가져왔습니다

*/
#include <iostream>
using namespace std;

int main() {
  cout.setf(ios::hex, ios::basefield);  // hex 를 설정한다.
  cout.setf(ios::showbase);             // showbase 를 설정
  cout << 100 << endl;
  cout.setf(0, ios::showbase);  // showbase 를 끈다.
  cout << 100 << endl;
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1743DC364E4D51B505E4D8)



###  연관된 것들

*  [ios_base::flags](http://itguru.tistory.com/153)  :  서식 플래그를 설정하거나 얻는다.
*  [ios_base::unsetf](http://itguru.tistory.com/156)  :  서식 플래그를 초기화한다.
*  [ios_base::fmtflags](http://itguru.tistory.com/154)  :  스트림 서식 플래그 타입
* `setiosflags` :  서식 플래그를 설정한다.
* resetiosflags  :  서식  플래그를 재설정 한다.
Link :  154
2011-08-19 02:32
----------------
title : C++ 레퍼런스 - ios_base::fmtflags 타입
cat_title :  ios_base::fmtflags 타입
ref_title : ios_base::fmtflags, fmtflags
publish_date : 2011-08-19 02:32
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::fmtflags

**스트림 서식 플래그(format flag) 를 위한 타입**

스트림 서식 플래그를 나타내기 위한 비트 마스크(bit mask) 형태의 타입이다.  이 타입은 [flags](http://itguru.tistory.com/153), [setf](http://itguru.tistory.com/155), [unsetf](http://itguru.tistory.com/156)와 같은 함수들의 인자 혹은 리턴 타입에 사용된다. 이들 함수에 전달되는 값들은 아래와 같은 멤버 상수들의 조합(OR 연산) 으로 이루어진다.


|필드|멤버 상수|하는 일|
|---|-------|------|
|독립적인 플래그들|`boolalpha`|`bool`데이터를 문자열로 나타내고, 그렇게 입력 받는다. (`true, false`)|
||`showbase`|정수 표기시,진법을 명시한다. (`0x`같은 것)|
||`showpoint`|부동 소수점 표기시, 소수점을 명시한다|
||`showpos`|양수를 표기시 `+` 부호를 붙인다.|
||`skipws`|입력 작업시 앞에 나오는 공백 문자(whitespace)를 무시한다|
||`unitbuf`|매 출력 작업 마다 `flush` 한다|
||`uppercase`|출력 작업시 소문자를 대문자로 출력한다|
|진법 관련 (basefield)| `dec` | 정수를 10진수 형태로 입출력 한다|
||`hex`|정수를 16진수 형태로 입출력 한다.|
||`oct`|정수를 8 진수 형태로 입출력 한다|
|부동소수점 관련 (floatfield)|`fixed`|부동 소수점 데이터를 고정 소수점(fixed-point) 형태로 표기한다|
||`scientific`|부동 소수점 데이터를 과학적 표기(scientific notation)로 출력한다|
|너비 맞추기 (adjustfield)|`internal`| 필드 너비(field  width)에 맞게 채우기 문자(fill character)을 덧붙이되, 내부의 특정 지점에 덧붙여 진다.|
||`left`|필드 너비에 맞게 채우기 문자를 덧붙이되, 왼쪽에 덧붙인다.|
||`right`|필드 너비에 맞게 채우기 문자를 덧붙이되, 오른쪽에 덧붙인다.|

이 때 아래와 같은 비트마스크 상수들은 위 플래그들의 몇 개의 조합을 의미한다. 이들은 `setf` 나 `unsetf` 에서 사용된다.


|플래그 값|오른쪽과 동일하다|
|-------|--------------|
|`adjustfield`|`left | right | internal`|
|`basefield`|`dec | oct | hex`|
|`floatfield`|`scientific | fixed`|

플래그들은 `OR` 연산자를 통해 하나의 `fmtflags` 로 조합될 수 있다.

이 상수들은 `ios_base` 클래스의 `public` 멤버로 정의되므로, `ios_base::hex` 와 같이 [ios_base](http://itguru.tistory.com/144) 의 멤버라는 것을 직접적으로 명시하여 접근하거나, 이를 상속한 클래스나, 이들의 객체에서 `ios::hex` 나 `cout.hex` 와 같이도 접근 가능하다.

참고로 `ios_base::fmtflags` 타입의 이 값들은 같은 이름을 가진 전역 함수인 조작자들과 혼동되서는 안된다. 이 조작자들은 `ios_base::fmtflags` 타입으로 사용될 수 없으며 (사실 그들은 함수이다!), 이들 상수를 조작자로도 사용할 수 없다. 예컨대 아래와 같은 차이가 있다.

```cpp-formatted
ios_base::skipws  // ios_base::fmtflags 타입의 상수
  skipws          // 조작자 (전역 함수)
```


꽤 많은 수의 조작자들이 위 플래그들과 이름이 동일하다. 이들에 대한 설명은 조작자를 참고하면 된다. 이러한 조작자들의 기능은 위 플래그들이 하는 일들과 꽤 유사하다.

예를 들어서 `showbase` 를 조작자로 사용한다면, 역시 정수 데이터를 표기시 진법을 명시하게 되는데, [ios_base::setf](http://itguru.tistory.com/155) 에서 인자로 `ios_base::showbase` 를 전달했다면 이 경우 역시 정수 데이터 표기시 진법을 명시해 달라는 의미이다. 하는 일을 비슷하지만 절대로 혼동해서 사용해서는 안된다.



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios_base/fmtflags/
에서 가져왔습니다.

*/
#include <iostream>
using namespace std;

int main() {
  // fmtflags 타입 상수들을 직접 이용하기
  cout.setf(ios_base::hex, ios_base::basefield);
  cout.setf(ios_base::showbase);
  cout << 100 << endl;

  // ios_base 를 상속 받은 ios 에서도 이 멤버들에 접근할 수 있다.
  cout.setf(ios::hex, ios::basefield);
  cout.setf(ios::showbase);
  cout << 100 << endl;

  // 역시 이들을 객체의 멤버 상수들로도 접근할 수 있다.
  cout.setf(cout.hex, cout.basefield);
  cout.setf(cout.showbase);
  cout << 100 << endl;

  // fmtflags 를 타입 자체로도 사용할 수 있다.
  ios_base::fmtflags ff;
  ff = cout.flags();
  ff &= ~cout.basefield;  // basefield 비트들을 초기화 시켜버린다.
  ff |= cout.hex;         // hex 를 설정
  ff |= cout.showbase;    // showbase 를 설정
  cout.flags(ff);
  cout << 100 << endl;

  // 아래는 fmtflags 타입 멤버들을 이용한 것은 아니고
  // 이름이 동일한 조작자 showbase 를 이용한 것이다
  cout << hex << showbase << 100 << endl;

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F12059E574E4D4B4D011E0C)




###  연관된 것들





*  [ios_base::flags](http://itguru.tistory.com/153):  서식 플래그를 설정하거나 얻는다.

*  [ios_base::setf](http://itguru.tistory.com/155)  :  특정 서식 플래그를 설정한다.

*  [ios_base::unsetf](http://itguru.tistory.com/156)  :  특정 서식 플래그를 초기화 한다.

* setiosflags  :  서식 플래그들을 설정한다 (조작자)
Link :  153
2011-08-19 01:55
----------------
title : C++ 레퍼런스 - ios_base::flags 함수
cat_title :  ios_base::flags
ref_title : flags
publish_date : 2011-08-19 01:55
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::flags

```cpp-formatted
fmtflags flags() const;
fmtflags flags(fmtflags fmtfl);
```


서식 플래그를 얻어오거나 설정한다.
첫번째 형태의 경우, 현재 스트림의 서식 플래그가 어떻게 설정되어 있는지 불러온다.
두번째 형태의 경우 스트림의 서식 플래그를 새롭게 설정하고, 원래 설정되어있던 것을 리턴한다.

서식 플래그는 입출력시 데이터가 어떻게 해석되고, 또 어떻게 출력되는지 결정해준다. `fmtfl` 로 무슨 값이 올 수 있는지 알려면 [ios_base::fmtflags](http://itguru.tistory.com/154)를 참조하여라

`fmtfl` 에 서식 플래그를 전달할 때, 기존의 스트림의 서식 플래그의 내용은 모두 지워지고, 전달된 `fmtfl` 의 내용으로 덮어 씌워지게 된다. 다른 서식 플래그를 바꾸지 않고, 한 개의 서식 플래그 만 바꾸기 위해서는 [setf](http://itguru.tistory.com/155)함수나 [unsetf](http://itguru.tistory.com/156)함수를 이용하면 된다.



###  인자





`fmtfl`

  스트림에서 사용되는 서식 플래그. 이 값은 [ios_base::fmtflags](http://itguru.tistory.com/154)형이다.




###  리턴값



함수 호출 직전의 서식 플래그






###  실행 예제



```cpp-formatted
/*

cout 의 서식 플래그로 right, hex, showbase 를 전달한다.
이를 통해 100 은 오른쪽에 10 크기로 맞추어서, 16 진수로, 무슨 진법으로(0x)
표시하였는지 명시되어 출력된다. 이 예제는
http://www.cplusplus.com/reference/iostream/ios_base/flags/
에서 가져왔습니다

*/
#include <iostream>
using namespace std;

int main() {
  cout.flags(ios::right | ios::hex | ios::showbase);
  cout.width(10);
  cout << 100;
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F110B09414E4D3E30316DF2)





###  연관된 것들

*  [ios_base::setf](http://itguru.tistory.com/155)  :  특정 서식 플래그를 설정한다.
*  [ios_base::unsetf](http://itguru.tistory.com/156)  :  특정 서식 플래그를 초기화 한다.
*  [ios_base::fmtflags](http://itguru.tistory.com/154)  :  스트림 서식 플래그의 타입
* setiosflags  :  서식 플래그를 설정한다.
Link :  152
2011-08-18 02:08
----------------
title : C++ 레퍼런스 - ios_base::width
cat_title :  ios_base::width
publish_date : 2011-08-18 02:08
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios_base::width

```cpp-formatted
streamsize width() const;
streamsize width(streamsize wide);
```


너비를 설정하거나 얻어온다.
위 소스에서 첫번째 형태의 함수는 현재 필드 너비를 구한다.
두번째 형태의함수는 필드의 너비를 수정한다.

필드 너비는 출력될 문자의 최소 개수를 의미한다. 만일 출력할 문자의 개수가 필드 너비보다 작다면, 채우기 문자(fill character) 을 넣어서 필드 너비를 맞추게 된다. 이 때 어디에 채우기 문자가 들어갈지는 서식 플래그인 `adjustfield` (`left, right, internal` 이 있다) 가 결정한다.

또한 채우기 문자는 [ios::fill](http://itguru.tistory.com/181)을 통해 수정하거나, 얻어질 수 있다.

서식 플래그 `adjustfield` 는 `setf` 나 [flags](http://itguru.tistory.com/153) 함수를 통해서, 혹은 `left, right, internal` 과 같은 조작자(manipulator) 을 넣음으로써, 혹은 인자가 있는 조작자인 `setiosflags` 를 통해서 수정될 수 있다.

또한 필드 너비는 인자가 있는 조작자인 `setw` 를 통해서도 수정될 수 있다.


###  인자


`wide`

스트림의 필드 너비의 새로운 값으로, `streamsize` 타입으로 정수 형태 이다.



###  리턴값


  함수 호출 직전의 필드 너비 값



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios_base/width/
에서 가져왔습니다

*/
#include <iostream>
using namespace std;

int main() {
  cout << 100 << endl;
  cout.width(10);
  cout << 100 << endl;
  cout.fill('x');
  cout.width(15);
  cout << left << 100 << endl;
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F205F6A374E4BF4E1335046)




###  연관된 함수


* setw  :  필드 너비를 조절한다.
*  [ios_base::flags](http://itguru.tistory.com/153):  서식 플래그를 수정하거나 얻는다.
*  [ios_base::setf](http://itguru.tistory.com/155)  :  특정 서식 플래그를 수정한다.
*  [ios::fill](http://itguru.tistory.com/181):  채우기 문자를 얻거나 수정한다.
Link :  151
2011-08-18 01:40
----------------
title : C++ 레퍼런스 - ifstream 클래스
cat_title :  ifstream 클래스
publish_date : 2011-08-18 01:40
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ifstream

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F11562C3C509A4623156640)

파일 입력 스트림 클래스 이다.

`ifstream` 은 입력 스트림으로 부터 데이터를 읽을 수 있게 해준다. 이 함수의 객체는 내부적으로 `filebuf` 객체를 가리키는 포인터로, 이는 [rdbuf](http://itguru.tistory.com/182)함수를 통해 얻어질 수 있다. 이 스트림과 파일을 연관(associate)시키기 위해서 생성자에 인자로 파일 이름을 지정하거나, `open` 함수를 통해서 할 수 있다.

만일 모든 파일 작업이 끝나게 되면 `close` 함수를 통해 스트림과 파일 관계를 끊을 수 있다. 한 번 끊어진다면 같은 다른 파일과 스트림을 연관시켜서 사용할 수 있게 된다.

  `is_open` 함수를 통해 현재 스트림 객체가 파일과 연관이 되어 있는지 확인할 수 있다.



###  Public 멤버





* 생성자 - 객체를 생성하며 부가적으로 파일과 연관시킬 수 있다.

* rdbuf  :  `filebuf` 객체를 얻는다.

* `is_open` :  파일이 열려있는지 확인한다.

* open  :  파일을 연다.

* close  :  파일을 닫는다.


 [istream](http://itguru.tistory.com/146)으로 부터 상속 받은 멤버들


*  [operator>>](http://itguru.tistory.com/147):  서식화된 데이터를 추출(입력)한다.

*  [gcount](http://itguru.tistory.com/192)  :  마지막 서식화 되지 않은 입력에서 받아들였었던 문자의 개수를 구한다.

*  [get](http://itguru.tistory.com/191)  :  스트림으로 부터 서식화 되지 않은 데이터를 얻는다.

*  [getline](http://itguru.tistory.com/149):  스트림으로 부터 한 줄을 입력받는다.

*  [ignore](http://itguru.tistory.com/193):  문자들을 입력 받고 지운다.

*  [peek](http://itguru.tistory.com/194):  그 다음으로 추출될 문자를 얻어온다.

* read  :  데이터 블록을 읽는다.

* readsome  :  버퍼에서 읽기 가능한 데이터 블록을 읽어온다.

* putback  :  문자를 다시 집어넣는다.



* `unget` :  `get pointer` 을 감소 시킨다.

* tellg  :  `get pointer` 의 위치를 얻는다.

* seekg  :  `get pointer` 의 위치를 설정한다.

* sync  :  입력 버퍼를 문자들의 소스에 동기화 시킨다.

* sentry  :  예외로 부터 안전한 접두/접미 작업을 수행한다. (클래스)



 [ios](http://itguru.tistory.com/145)로 부터 상속 받은 함수들


*  [good](http://itguru.tistory.com/164)  :  스트림의 상태가 입출력 작업을 할 수 있는지 확인한다.

*  [eof](http://itguru.tistory.com/167)  :  `eof` 비트가 설정되었는지 확인한다.

*  [fail](http://itguru.tistory.com/165)  :  `fail` 비트나 `bad` 비트가 설정되었는지 확인한다.

*  [bad](http://itguru.tistory.com/166):  `bad` 비트가 설정되었는지 확인한다.

*  [operator!](http://itguru.tistory.com/168):  스트림 객체에 오류 플래그(fail 비트나 `bad` 비트)가 설정되었는지 확인한다.

*  [operator void*](http://itguru.tistory.com/170):  포인터로 변환한다.

*  [rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그(error `state` flag)를 얻어온다.

*  [setstate](http://itguru.tistory.com/179)  :  오류 상태 플래그를 설정한다.

*  [clear](http://itguru.tistory.com/180)  :   오류 상태 플래그들을 설정한다

* copyfmt  :  서식 정보를 복사한다.

*  [fill](http://itguru.tistory.com/181):  채우기 문자(fill `character)` 을 얻거나 설정한다.

*  [exceptions](http://itguru.tistory.com/150):  예외 마스크를 얻거나 설정한다.

* `imbue` :  로케일을 설정한다.



*  [tie](http://itguru.tistory.com/190)  :  엮어진 스트림(tied stream)을 얻거나 설정한다.



*  [rdbuf](http://itguru.tistory.com/182)  :  연관된 스트림 버퍼를 얻거나 설정한다.

* narrow  : 표준 `char` 형으로 문자를 변환한다.

* `widen` :  표준 `wchar_t` 형으로 문자를 변환한다.


 [ios_base](http://itguru.tistory.com/144)로 부터 상속된 함수들


*  [flags](http://itguru.tistory.com/153):  서식 플래그를 수정하거나 얻어온다.

*  [setf](http://itguru.tistory.com/155)  :  특정 서식 플래그를 설정한다.



*  [unsetf](http://itguru.tistory.com/156)  :  특정 서식 플래그를 초기화 한다.



*  [precision](http://itguru.tistory.com/157)  :  부동 소수점 정밀도를 수정하거나 얻어온다.



*  [width](http://itguru.tistory.com/152)  :  필드의 너비를 수정하거나 얻어온다

*  [imbue](http://itguru.tistory.com/158)  :  로케일을 채운다.

*  [getloc](http://itguru.tistory.com/160)  :  현재 로케일을 얻어온다

*  [xalloc](http://itguru.tistory.com/162)  :  내부 확장 가능 배열의 새로운 인덱스를 리턴한다. (정적 함수)

*  [iword](http://itguru.tistory.com/161)  :  내부 확장 가능 배열의 특정 정수 원소의 레퍼런스를 얻는다.

*  [pword](http://itguru.tistory.com/163)  :  내부 확장 가능 배열의 포인터의 레퍼런스를 얻는다.

*  [register_callback](http://itguru.tistory.com/159)  :  이벤트 콜백 함수를 등록한다.

* `sync_with_stdio` :  `iostream` 과 `cstdio` 스트림과의 동기화를 활성화 하거나 비활성화 한다.
Link :  150
2011-08-18 01:25
----------------
title : C++ 레퍼런스 - ios::exceptions
cat_title :  ios::exceptions
publish_date : 2011-08-18 01:25
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 [저의 모토인 '지식전파'](http://itguru.tistory.com/notice/107) 를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::exceptions

```cpp-formatted
iostate exceptions() const;
void exceptions(iostate except);
```


**예외 마스크(exception mask)** 를 얻거나 설정한다.

첫번째 형태의 함수는 현재 스트림의 예외 마스크를 리턴한다.

두번째 형태의 함수는 새로운 예외 마스크를 설정하고 `clear(rdstate())` 를 호출한다.

예외 마스크는 모든 스트림 객체가 각각 가지고 있는 데이터로,예외마스크에 해당하는 상태 플래그가 설정 되었을 시 반드시 예외를 `throw` 해야만 한다. 이 마스크는 `ios_base::iostate` 타입의 객체로, 아래와 같은 멤버 상수들의 조합으로 값이 결정된다.


플래그 값
의미
`eofbit`
스트림으로부터 추출 작업(extracting operation)을 수행 중 `End–Of–File`에 도달하는 경우
`failbit`
마지막 입력 작업이 자체의 내부 오류 때문에 실패하였을 경우
`badbit`
스트림 버퍼의 입출력 작업이 실패하여 발생한 오류
`goodbit`
오류가 없다`. .

  한 개 이상의 상태 플래그를 `OR` 연산자로 조합하여 하나의 비트 마스크(bit mask)를 만들 수 있게 된다. 기본값로 스트림 객체는 `goodbit` 예외 마스크를 가지고 있는데, 이 말은 어떠한 상태 플래그가 설정 되어도 예외를 던지지 않는다는 의미 이다.



###  인자




`except`

`ios_base::iostate` 형의 비트 마스크 값으로 오류 상태 플래그 비트들(`badbit, eofbit, failbit)` 의 조합에 의해 설정된다.


###  리턴값

`ios_base::iostate` 타입의 비트 마스크로 이 함수를 호출하기 직전의 예외 마스크를 리턴한다.

###  실행 예제


```cpp-formatted
/*사용자가 file 의 exception 에 failbit 와 badbit 를 등록하였으므로 이들 비트가
 * 설정될 때 예외를 throw 하게 된다. 나의 경우 test.txt 파일에 내용이 존재하지
 * 않았으므로 failbit 가 설정되어서 예외가 throw 된 것이다.*/
#include <fstream>
#include <iostream>
using namespace std;
int main() {
  ifstream file;
  file.exceptions(ifstream::failbit | ifstream::badbit);
  try {
    file.open("test.txt");
    file.get();
  } catch (ifstream::failure e) {
    cout << "Exception opening/reading file";
  }
  file.close();
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F145ED6344E4BEA8A334FD9)




###  템플릿 멤버 정의




```cpp-formatted
// ( basic_ios<charT,traits> )
iostate exceptions() const;
iostate exceptions(iostate except);
```





###  연관된 함수

*  [ios::rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그를 얻는다.
Link :  149
2011-08-18 00:40
----------------
title : C++ 레퍼런스 - istream::getline 함수
cat_title :  istream::getline
ref_title : getline
publish_date : 2011-08-18 00:40
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 [저의 모토인 '지식전파'](http://itguru.tistory.com/notice/107) 를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ istream::getline

```info
istream& getline (char* s, streamsize n );
istream& getline (char* s, streamsize n, char delim );
```

스트림으로 부터 한 줄을 읽는다.
  입력 시퀀스(sequence) 로 부터 문자를 읽어들여 C 형식의 문자열로 `s` 에 저장한다.
이 함수는 최대 (n - 1) 개의 문자들을 읽어들일 때 까지나 (n 번째는 NULL 문자로 채워진다), 제한자(delimiter) 가 나타날 때 까지 읽게 된다. 제한자는 함수의 인자 `delim` 으로 전달되며, 명시하지 않았다면 '\n' 으로 간주한다. 또한 입력은 파일의 끝에 도달하거나, 입력 작업시 오류가 발생시 자동으로 종료된다.

  제한자를 찾았다면, 시퀀스에서 추출되지만 버려지게 된다. 즉, `s` 에 저장이 되지 않으며, 그 입력 연산은 제한자 다음 부터 진행되게 된다. 따라서 여러분이 이 제한자를 추출하고 싶지 않다면 `get` 함수를 사용하면 된다.

종료 널 문자는 데이터 추출이 완료되었을 때 자동으로 뒤에 붙게 된다.

이 함수를 통해 읽어진 문자의 개수를 알고 싶다면 [gcount](http://itguru.tistory.com/192)함수를 호출하면 된다.

  동일한 이름을 가진 전역 함수가 `<string>` 에 존재한다. 이 전역 함수는 비슷한 작업을 하지만 C 형식 문자열 대신에 표준 C++ 문자열 객체를 사용한다. `getline (string)` 함수를 참조



###  인자




`s`

  C 형식 문자열을 저장할 배열을 가리키는 포인터

`n`

  저장할 문자의 최대 개수 (끝의 종료 널 문자를 포함한 값)로, 이는 `streamsize` 타입의 정수값이다. 만일 이 `streamsize` 최대 크기에 도달하여 입력이 중단되었으면 `failbit` 플래그가 설정된다.

`delim`

  제한자(delimiter) 로 이 문자에 도달시 추출이 중단된다. 이 때, 이 문자는 `s` 에 기록되지는 않지만 스트림에서 사라지게 된다. 이 인자는 꼭 사용하지 않아도 되고, 명시하지 않았을 경우 '\n' 으로 제한자를 주었다고 생각한다.



###  리턴값




이 함수는 `*this` 를 리턴한다.

만일 입력시 발생된 오류들은 내부 상태 플래그를 통해 알아낼 수 있다.

|플래그|오류|
|-----|----|
|`eofbit`|작업 중 문자들의 끝에 도달하였을 때|
|`failbit`|끝에 바로 도달해버려서 어떠한 문자도 추출해 낼 수 없을 경우. 혹은 `n - 1` 개의 문자들을 모두 추출하여서 입력 작업이 중단되었을 경우에도 설정된다. 또한 일부 `eofbit` 를 설정하는 오류들이 `failbit` 도 설정할 수 있다.|
|`badbit`|위 같은 일들 외의 다른 오류가 발생시|

`ios::exceptions` 를 통해 적절한 플래그가 설정되어 있을 경우 위와 같은 상황이 발생시 `ios_base::failure` 이 `throw` 된다.


###  실행 예제


```cpp-formatted
/*

getline 함수를 통해 사용자로 부터 문자열을 입력 받는다.
이 예제는
http://www.cplusplus.com/reference/iostream/istream/getline
에서 가져왔습니다.

*/
#include <iostream>
using namespace std;

int main() {
  char name[256], title[256];

  cout << "Enter your name: ";
  cin.getline(name, 256);

  cout << "Enter your favourite movie: ";
  cin.getline(title, 256);

  cout << name << "'s favourite movie is " << title;

  return 0;
}
```


실행 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F171C67424E4BDFE4051BA6)





###  템플릿 멤버 선언




```cpp-formatted
// ( basic_istream<charT,traits> )
typedef charT char_type;
basic_istream& getline(char_type* s, streamsize n);
basic_istream& getline(char_type* s, streamsize n, char_type delim);
```




###  연관된 함수


*  [istream::get](http://itguru.tistory.com/191)  :  서식화 되지 않은 데이터를 스트림에서 가져온다.
*  [istream::ignore](http://itguru.tistory.com/193)  :  문자를 추출하고 버린다.
*  [istream::gcount](http://itguru.tistory.com/192): 이전의 서식화 되지 않았던 입력 작업서 추출하였던 문자의 개수를 얻어온다.
Link :  147
2011-08-17 16:55
----------------
title : C++ 레퍼런스 - istream::operator>> (추출 연산자)
cat_title :  istream::operator>> (추출 연산자)
ref_title : istream::operator>>
publish_date : 2011-08-17 16:55
--------------


```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 [저의 모토인 '지식전파'](http://itguru.tistory.com/notice/107) 를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ istream::operator>>

```info
istream& operator>> (bool& val );
istream& operator>> (short& val );
istream& operator>> (unsigned short& val );
istream& operator>> (int& val );
istream& operator>> (unsigned int& val );
istream& operator>> (long& val );
istream& operator>> (unsigned long& val );
istream& operator>> (float& val );
istream& operator>> (double& val );
istream& operator>> (long double& val );
istream& operator>> (void*& val );

istream& operator>> (streambuf* sb );

istream& operator>> (istream& ( *pf )(istream&));
istream& operator>> (ios& ( *pf )(ios&));
istream& operator>> (ios_base& ( *pf )(ios_base&));

// 아래 함수들은 멤버들이 아니라, 전역 함수들이다.

istream& operator>> (istream& is, char& ch );
istream& operator>> (istream& is, signed char& ch );
istream& operator>> (istream& is, unsigned char& ch );

istream& operator>> (istream& is, char* str );
istream& operator>> (istream& is, signed char* str );
istream& operator>> (istream& is, unsigned char* str );
```

서식화 된 데이터를 추출(extract)한다.

  이 연산자(>>) 은 입력 스트림에서 사용되는데, '추출 연산자(extraction operator)' 이라 불리기도 한다. 이는 오른쪽 쉬프트 연산자와 다른 것이다. 이 연산자는 스트림에서 데이터의 해석을 필요로 하는 입력 작업을 수행하게 된다. 예를 들어, 입력 받은 숫자 데이터 (문자 형태로 입력될 것이다) 를 사용자가 지정한 수치 형태로 변환한다든지 등 말이다.

  참고적으로 3 가지 종류의 멤버 함수들과, 한 가지 종류의 전역 함수들이 [istream](http://itguru.tistory.com/146)객체에 적용되는 추출 연산자에서 오버로드 된다.


* 첫번재 종류의 멤버 함수는 산술 추출자(arithmetic extractor) 이다. 이들은 입력 데이터로 부터 문자들을 받아서 이 추출자의 인자의 특정 타입의 형태로 값을 해석하게 된다. 그 결과값은 인자로 전달된 변수에 저장되게 된다. (위 소스에서 상단 부분)



* `streambuf` 형태의 복사는 연산자 우변에 전달된 스트림 버퍼 객체로 부터 더 이상 복사 할 수 없을 때 까지 최대한 많은 문자들을 복사한다.



* 마지막 종류의 멤버 함수는 인자로 함수 포인터를 가지고 있다. 이들은 조작자(manipulator) 함수로 사용되게 만들어졌다. 조작자 함수는 이 연산자와 함께 사용되도록 특이적으로 만들어진 함수들이다. (위 소스에서 세번째 부분)



* 전역 함수가 오버로드 하는 경우는 인자가 문자거나 C 형식 문자열일 때 연산자를 오버로드 하는데, 이들은 입력스트림으로 부터 한 개의 문자 혹은 문자들의 나열을 입력 받는다. (위 소스에서 마지막 부분)




  이 함수들이 연산자 오버로딩 함수들이기 때문에 이 연산자를 사용하기 위해서는

```cpp-formatted
strm >> variable;
```

 와 같이 사용하면 된다. 이 때 `strm` 은 [istream](http://itguru.tistory.com/146) 객체의 이름이고, `variable` 은 우변으로 전달되는 인자이다. 물론 이 연산자를 아래처럼 쭉 이어나가서 사용해도 된다.

```cpp-formatted
strm >> variable1 >> variable2 >> variable3;  //...
```

이는 `strm` 객체에 추출 연산을 계속 진행하는 것과 다름 없다.

  표준 [istream](http://itguru.tistory.com/146)객체에 사용시 효과가 있는 조작자들은


* boolalpha  :  `bool` 값을 문자열로(true, `false)`

* dec  :  십진수를 사용

* hex  :  16 진수를 사용한다.



* noboolalpha  :  `bool` 값에 문자열을 사용하지 않는다 (0,1)



* `noskipws` :  공백문자(whitespace) 를 생략하지 않는다.

* oct  :  8 진수를 사용한다.



* skipws  :  공백 문자(whitespace)를 생략한다


* ws  :  공백문자를 추출한다.


  다른 조작자들도 [istream](http://itguru.tistory.com/146)객체에 사용 가능하지만 효과는 없다.

  아래의 인자를 가지는 조작자들은 `istream` 객체에 영향이 있다. 이들은 `<iomanip>` 헤더파일에 정의되어 있으며 명시적으로 `include` 를 시켜 주어야만 한다.


* setiosflags  :  서식 플래그를 설정한다.

* setbase  :  진법 플래그를 설정한다.



* `resetiosflags` : 서식 플래그를 재설정 한다.




###  인자들





`val`

  입력 시퀀스(sequence)에서 문자들을 추출하여 주어진 인자의 타입에 맞게 수치값으로 해석하려 한다. 만일 성공적으로 해석하였다면 그 값은 `val` 에 저장된다. 데이터가 정확히 어떠한 방식으로 해석될지는 이전에 스트림에 적용된 조작자와, 로케일(locale) 에 의해 결정된다.

`sb`

  입력 시퀀스로 부터 문자들을 추출하여 `End Of File` 이 나타나기 전이나, 버퍼가 성공적으로 문자를 삽입(insert)할 때 까지 `sb` 에 저장한다.

`pf`

  `pf(*this)` 를 호출하는데, 보통 조작자 함수이다.

`ch`

  단일 문자를 추출하여 `ch` 에 저장한다.

`str`

  문자를 추출하여 C 형식 문자열로 저장한다. (즉 `str` 이 문자열의 시작 부분을 가리키고, `null` 문자로 문자열이 끝난다) 추출은 다음 문자가 공백 문자(whitespace) 이거나 널 문자 혹은 `End of file` 에 도달하였을 때 종료된다. 입력 받은 문자열 끝에는 자동적으로 널 문자가 붙게 된다.

  이 때 만일 필드의 너비가 0 보다 크게 설정되었다면 (이는 [ios_base::width](http://itguru.tistory.com/152)혹은 `setw` 로 설정할 수 있다)  입력 받을 문자의 수를 제한할 수 도 있다(버퍼 오버플로우 문제를 막기 위해). 이 경우 입력 받은 문자의 수가 필드 너비 값에 도달하기 하나 전에, 입력을 중단하고 나머지 한 문자를 널 종료 문자(null terminating character) 로 채운다. 그리고 자동으로 필드 너비 값이 0 으로 재설정 되버린다.

`is`

  작업이 수행될 스트림 객체. 이는 전역 함수의 첫 번째 인자로 연산자의 왼쪽에 위치한다.




###  리턴값




객체 자기 자신을 리턴한다 (*this)

발생된 오류는 내부 플래그를 변화시키게 된다.

플래그오류`eofbit`작업 중 문자들의 끝에 도달하였을 때`failbit`입력받은 데이터가 올바른 타입으로 해석이 되지 않을 경우
(참고로` eofbit`시` failbit`도 참이 된다) `badbit`위 같은 일들 외의 다른 오류가 발생시(`ios_base::iostate` 를 참조)

  추가적으로 [ios::exceptions](http://itguru.tistory.com/150) 의 멤버 함수를 통해 적절하게 플래그가 설정되어있다면, 위와 같은 상황 발생 시 `ios_base::failure` 예외가 `throw` 된다.




###  실행 예제


```cpp-formatted
/*

cin 으로 여러 작업을 수행한다.
이 예제는
http://www.cplusplus.com/reference/iostream/istream/operator%3E%3E/
에서 가져왔습니다.

*/
#include <iostream>
using namespace std;

int main() {
  int n;
  char str[10];

  cout << "Enter a number: ";
  cin >> n;
  cout << "You have entered: " << n << endl;

  cout << "Enter a hexadecimal number: ";
  cin >> hex >> n;  // manipulator
  cout << "Its decimal equivalent is: " << n << endl;

  cout << "Enter a word: ";
  cin.width(10);  // limit width
  cin >> str;
  cout << "The first 9 chars of your word are: " << str << endl;

  return 0;
}
```

  실행 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F144DE2524E4B71D4023599)


###  템플릿 전역 함수들




```cpp-formatted
template <class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is,
                                         charT& ch);

template <class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is,
                                         signed char& ch);

template <class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is,
                                         unsigned char& ch);

template <class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is,
                                         charT* str);

template <class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is,
                                         signed char* str);

template <class charT, class traits>
basic_istream<charT, traits>& operator>>(basic_istream<charT, traits>& is,
                                         unsigned char* str);
```


###  연관된 함수


* 
 [istream::get](http://itguru.tistory.com/191) :  서식화 되지 않는 데이터를 스트림에서 가져온다.

*  [istream::getline](http://itguru.tistory.com/149)  :  스트림에서 한 줄을 입력 받는다.

* ostream::operator<<  :  서식에 맞게 데이터를 삽입한다.

* istream::sentry  :  예외에 안전한 접두/접미 작업을 수행한다.
Link :  146
2011-08-17 15:53
----------------
title : C++ 레퍼런스 - istream 클래스
cat_title :  istream 클래스
ref_title : istream
publish_date : 2011-08-17 15:53
--------------


```warning
  이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 [저의 모토인 '지식전파'](http://itguru.tistory.com/notice/107) 를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ istream

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F195A313C509A45B20CA82E)

`istream` 객체는 스트림 객체들로 문자들의 나열을 읽고 해석하는데 사용된다. `istream` 의 특정 멤버들은 이러한 입력 연산을 수행하는데 사용되는데, 이들은 크게 두 가지로 분류될 수 있다.

#### 서식화된 입력 (Formatted input)

이 함수들은 문자들의 나열에서 데이터를 추출하고, 특정 타입에 맞게 데이터를 해석하고 서식화 한다. 이러한 형식의 작업은 추출 연산자 (extraction operator) 인 
 [istream::operator>>](http://itguru.tistory.com/147) 을 오버로드 하는 멤버 및 전역 함수들에 의해 처리된다.

#### 서식화 되지 않은 입력 (Unformatted input)


`istream` 클래스의 대부분의 다른 멤버 함수들은 서식화된 입력을 사용하지 않는다. 즉, 입력 받은 문자들로 부터 어떠한 해석도 이루어지지 않는다는 뜻이다. 이 멤버 함수들은 입력되는 문자들의 나열에서 부터 정해진 개수의 문자만을 입력 받는다 (
 [get](http://itguru.tistory.com/191), 
 [getline](http://itguru.tistory.com/149), 
 [peek](http://itguru.tistory.com/194), `read, readsome)`. 또한 `get pointer` 을 조절하거나 (
 [ignore](http://itguru.tistory.com/193), `seekg, tellg, unget)` 마지막 서식화 되지 않았던 입력 작업의 정보를 얻어오는 함수(
 [gcount](http://itguru.tistory.com/192))들도 있다.


  표준 객체인 `cin` 은 이 클래스로 부터 만들어진 인스턴스 이다.

  이 클래스는 [ios_base](http://itguru.tistory.com/144)와 [ios](http://itguru.tistory.com/145)로 부터 모든 것들을 상속 받았다.

#### 서식 정보(Formatting information)


* 서식 플래그(format flag) :  입출력 작업들이 어떠한 형식으로 해석되어야 할지를 지시하는 내부 지시자들의 집합이다. 이 지시자들의 상태는
 [flags](http://itguru.tistory.com/153),
 [setf](http://itguru.tistory.com/155)나
 [unsetf](http://itguru.tistory.com/156)함수들을 호출하거나 조작자(manipulator) 들을 사용함으로써 바뀔 수 있다.



* 필드 너비(field width) : 출력될 다음 원소의 너비에 대한 정보이다. 이 값은 멤버 함수인
 [width](http://itguru.tistory.com/152)를 호출하거나, 인자 있는 조작자인 `setw` 를 사용함으로써 얻어지거나 수정될 수 있다.



* 채우기 문자(fill character)
:  필드의 너비를 맞추기 위해 부가적으로 채워지는 문자. 이는
 [fill](http://itguru.tistory.com/181)함수를 호출하거나, 인자가 있는 조작자인 `setfill` 을 사용하므로써 얻어지거나 수정될 수 있다.

* 출력 정밀도(display precision) :  부동 소수점 데이터를 출력시 어떠한 정밀도로 표시할 것인지를 나타낸다. 이 값은
 [precision](http://itguru.tistory.com/157)함수나 인자 있는 조작자인 `setprecision` 을 통해 얻어지거나 수정될 수 있다.

* 로케일 객체(locale object) : 입출력 작업을 서식화 할 때 고려해야 할 로케일 정보(언어 문화권의 차이에 따라 달라지는 특성) 들을 담고 있다. 로케일 객체는
 [getloc](http://itguru.tistory.com/160)함수를 호출함으로써 얻어지고
 [imbue](http://itguru.tistory.com/158)함수를 통해 조작할 수 있다.




#### 상태 정보


* 오류 상태(error state) : 내부 지시자가 현재 스트림의 오류 상태를 나타내고 있다. 객체는
 [rdstate](http://itguru.tistory.com/171) 함수를 호출함으로써 얻어지고,
 [clear](http://itguru.tistory.com/180) 와
 [setstate](http://itguru.tistory.com/179) 함수를 호출함을 통해 수정될 수 있다. 각각의 값은
 [good](http://itguru.tistory.com/164), 
 [eof](http://itguru.tistory.com/167), 
 [fail](http://itguru.tistory.com/165), 
 [bad](http://itguru.tistory.com/166) 를 호출함으로써 얻어진다.



* 예외 마스크(exception mask) : 내부 예외 상태 지시자. `exceptions` 를 통해 이 값을 얻어낼거나 수정할 수 있다.




#### 그 외


* 이벤트 함수 스택(event function stack) : 특정 이벤트가 일어낼 때 호출되었던 콜백 함수들을 가리키는 포인터들의 스택. 추가적인 콜백 함수들은
 [register_callback](http://itguru.tistory.com/159) 함수를 호출함으로써 스택에 등록할 수 있다.

* 내부 확장 가능 배열(internal extensible arrays) : 두 개의 배열로 `long` 객체와 `void` 포인터들을 저장하기 위한 것이다. 이 배열은 [xalloc](http://itguru.tistory.com/162) 함수를 호출함으로써 확장될 수 있고, 각각의 객체들의 레퍼런스는 [iword](http://itguru.tistory.com/161) 나 [pword](http://itguru.tistory.com/163) 함수를 호출함으로써 얻어진다.



* 엮여진 스트림(tied stream)을 가리키는 포인터 :  이 스트림 객체와 엮여진 스트림을 가리키는 포인터를 의미하며, `tie` 함수를 호출함으로써 얻어지거나 설정된다.  (엮여진 스트림에 대한 설명은 `tie` 함수 참조)



* 스트림 버퍼(stream buffer) 을 가리키는 포인터 :  `streambuf` 객체와 연관된 포인터로, [rdbuf](http://itguru.tistory.com/182)함수를 호출함으로써 수정되거나 얻어진다.






###  Public 멤버들


* 생성자

* 소멸자


서식화된 입력


*  [operator>>](http://itguru.tistory.com/147) :  서식화된 데이터를 추출(입력)한다.




서식화 되지 않은 입력


*  [gcount](http://itguru.tistory.com/192)  :  마지막 서식화 되지 않은 입력에서 받아들였었던 문자의 개수를 구한다.

*  [get](http://itguru.tistory.com/191)  :  스트림으로 부터 서식화 되지 않은 데이터를 얻는다.

*  [getline](http://itguru.tistory.com/149):  스트림으로 부터 한 줄을 입력받는다.

*  [ignore](http://itguru.tistory.com/193):  문자들을 입력 받고 지운다.

*  [peek](http://itguru.tistory.com/194):  그 다음으로 추출될 문자를 얻어온다.

* read  :  데이터 블록을 읽는다.

* readsome  :  버퍼에서 읽기 가능한 데이터 블록을 읽어온다.

* putback  :  문자를 다시 집어넣는다.


* `unget` :  `get pointer` 을 감소 시킨다.


위치 관련


* tellg  :  `get pointer` 의 위치를 얻는다.

* seekg  :  `get pointer` 의 위치를 설정한다.


동기화

* sync  :  입력 버퍼를 문자들의 소스에 동기화 시킨다.




접두/접미 (prefix/suffix)

* sentry  :  예외로 부터 안전한 접두/접미 작업을 수행한다. (클래스)


 [ios](http://itguru.tistory.com/145)로 부터 상속 받은 함수들


*  [good](http://itguru.tistory.com/164)  :  스트림의 상태가 입출력 작업을 할 수 있는지 확인한다.

*  [eof](http://itguru.tistory.com/167)  :  `eof` 비트가 설정되었는지 확인한다.

*  [fail](http://itguru.tistory.com/165)  :  `fail` 비트나 `bad` 비트가 설정되었는지 확인한다.

*  [bad](http://itguru.tistory.com/166) :  `bad` 비트가 설정되었는지 확인한다.

*  [operator!](http://itguru.tistory.com/168) :  스트림 객체에 오류 플래그(fail 비트나 `bad` 비트)가 설정되었는지 확인한다.

*  [operator void*](http://itguru.tistory.com/170) :  포인터로 변환한다.

*  [rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그(error state flag)를 얻어온다.

*  [setstate](http://itguru.tistory.com/179)  :  오류 상태 플래그를 설정한다.

*  [clear](http://itguru.tistory.com/180)  :   오류 상태 플래그들을 설정한다

* copyfmt  :  서식 정보를 복사한다.

*  [fill](http://itguru.tistory.com/181) :  채우기 문자(fill character) 을 얻거나 설정한다.

*  [exceptions](http://itguru.tistory.com/150) :  예외 마스크를 얻거나 설정한다.

* `imbue` :  로케일을 설정한다.



*  [tie](http://itguru.tistory.com/190)  :  엮어진 스트림(tied stream)을 얻거나 설정한다.



*  [rdbuf](http://itguru.tistory.com/182)  :  연관된 스트림 버퍼를 얻거나 설정한다.

* narrow  : 표준 `char` 형으로 문자를 변환한다.

* `widen` :  표준 `wchar_t` 형으로 문자를 변환한다.


 [ios_base](http://itguru.tistory.com/144) 로 부터 상속된 함수들


*  [flags](http://itguru.tistory.com/153) :  서식 플래그를 수정하거나 얻어온다.

*  [setf](http://itguru.tistory.com/155) :  특정 서식 플래그를 설정한다.



*  [unsetf](http://itguru.tistory.com/156):  특정 서식 플래그를 초기화 한다.



*  [precision](http://itguru.tistory.com/157)  :  부동 소수점 정밀도를 수정하거나 얻어온다.



*  [width](http://itguru.tistory.com/152)  :  필드의 너비를 수정하거나 얻어온다

*  [imbue](http://itguru.tistory.com/158)  :  로케일을 채운다.

*  [getloc](http://itguru.tistory.com/160)  :  현재 로케일을 얻어온다

*  [xalloc](http://itguru.tistory.com/162)  :  내부 확장 가능 배열의 새로운 인덱스를 리턴한다. (정적 함수)

*  [iword](http://itguru.tistory.com/161)  :  내부 확장 가능 배열의 특정 정수 원소의 레퍼런스를 얻는다.

*  [pword](http://itguru.tistory.com/163)  :  내부 확장 가능 배열의 포인터의 레퍼런스를 얻는다.

*  [register_callback](http://itguru.tistory.com/159)  :  이벤트 콜백 함수를 등록한다.

* `sync_with_stdio` :  `iostream` 과 `cstdio` 스트림과의 동기화를 활성화 하거나 비활성화 한다.
Link :  145
2011-08-17 13:21
----------------
title : C++ 레퍼런스 - ios 클래스
cat_title :  ios 클래스
ref_title : ios
publish_date : 2011-08-17 13:21
--------------


```warning
  이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 [저의 모토인 '지식전파'](http://itguru.tistory.com/notice/107) 를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios

표준 스트림 클래스의 타입 의존적인 멤버(type-dependent) 들을 포함하는 기초 클래스



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F016CA136509A4531255174)



이 클래스는 스트림 클래스의 [ios_base](http://itguru.tistory.com/144)를 제외한 모든 클래스의 기초 클래스가 되도록 만들어졌다.

`ios` 는 부모 클래스인 [ios_base](http://itguru.tistory.com/144)와 함께 표준 스트림의 객체가 입력이냐, 출력이냐에 무관하게, 공통적으로 필요한 멤버들을 정의하고 있다. `ios_base` 의 경우 그들 중 템플릿 인자와 무관한 것들, `ios` 는 템플릿 인자에 의존적인 멤버들을 정의하게 된다.

`ios` 는 `ios_base` 로 부터 파생된 것이기 때문에 [ios_base](http://itguru.tistory.com/144)의 정보를 포함하고 있으며 다음과 같은 것들이 추가되었다.


* 채우기 문자(fill character) :  필드 너비를 맞추기 위해 채워지는 문자를 의미한다. 이는 `fill` 함수를 호출함으로써 설정되거나 얻어질 수 있다.
* 엮여진 스트림(tied stream)을 가리키는 포인터 :  이 스트림 객체와 엮여진 스트림을 가리키는 포인터를 의미하며, `tie` 함수를 호출함으로써 얻어지거나 설정된다.  (엮여진 스트림에 대한 설명은 `tie` 함수 참조)
* 스트림 버퍼(stream buffer) 을 가리키는 포인터 :  `streambuf` 객체와
연관된 포인터로,
 [rdbuf](http://itguru.tistory.com/182)함수를 호출함으로써 수정되거나 얻어진다.




###  멤버 함수



* 생성자

* 소멸자


상태 플래그 함수


*  [good](http://itguru.tistory.com/164)  :  스트림의 상태가 입출력 작업을 할 수 있는지 확인한다.

*  [eof](http://itguru.tistory.com/167)  :  `eof` 비트가 설정되었는지 확인한다.

*  [fail](http://itguru.tistory.com/165)  :  `fail` 비트나 `bad` 비트가 설정되었는지 확인한다.

*  [bad](http://itguru.tistory.com/166):  `bad` 비트가 설정되었는지 확인한다.

*  [operator!](http://itguru.tistory.com/168):  스트림 객체에 오류 플래그(fail 비트나 `bad` 비트)가 설정되었는지 확인한다.

*  [operator void*](http://itguru.tistory.com/170):  포인터로 변환한다.

*  [rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그(error `state` flag)를 얻어온다.

*  [setstate](http://itguru.tistory.com/179)  :  오류 상태 플래그를 설정한다.

*  [clear](http://itguru.tistory.com/180)  :   오류 상태 플래그들을 설정한다.





서식


* copyfmt  :  서식 정보를 복사한다.

*  [fill](http://itguru.tistory.com/181):  채우기 문자(fill `character)` 을 얻거나 설정한다.




그 외


*  [exceptions](http://itguru.tistory.com/150):  예외 마스크를 얻거나 설정한다.

* `imbue` :  로케일을 설정한다.



*  [tie](http://itguru.tistory.com/190)  :  엮어진 스트림(tied stream)을 얻거나 설정한다.



*  [rdbuf](http://itguru.tistory.com/182)  :  연관된 스트림 버퍼를 얻거나 설정한다.

* narrow  : 표준 `char` 형으로 문자를 변환한다.

* `widen` :  표준 `wchar_t` 형으로 문자를 변환한다.




`ios_base` 로 부터 상속된 함수들


*  [flags](http://itguru.tistory.com/153):  서식 플래그를 수정하거나 얻어온다.

*  [setf](http://itguru.tistory.com/155)  :  특정 서식 플래그를 설정한다.



*  [unsetf](http://itguru.tistory.com/156)  :  특정 서식 플래그를 초기화 한다.
*  [precision](http://itguru.tistory.com/157)  :  부동 소수점 정밀도를 수정하거나 얻어온다.
*  [width](http://itguru.tistory.com/152)  :  필드의 너비를 수정하거나 얻어온다

*  [imbue](http://itguru.tistory.com/158)  :  로케일을 채운다.

*  [getloc](http://itguru.tistory.com/160)  :  현재 로케일을 얻어온다

*  [xalloc](http://itguru.tistory.com/162)  :  내부 확장 가능 배열의 새로운 인덱스를 리턴한다. (정적 함수)

*  [iword](http://itguru.tistory.com/161)  :  내부 확장 가능 배열의 특정 정수 원소의 레퍼런스를 얻는다.

*  [pword](http://itguru.tistory.com/163)  :  내부 확장 가능 배열의 포인터의 레퍼런스를 얻는다.

*  [register_callback](http://itguru.tistory.com/159)  :  이벤트 콜백 함수를 등록한다.

* `sync_with_stdio` :  `iostream` 과 `cstdio` 스트림과의 동기화를 활성화 하거나 비활성화 한다.
Link :  144
2011-08-17 12:45
----------------
title : C++ 레퍼런스 - ios_base 클래스
cat_title :  ios_base 클래스
ref_title : ios_base
publish_date : 2011-08-17 12:45
--------------


```warning
  이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 [저의 모토인 '지식전파'](http://itguru.tistory.com/notice/107) 를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?

```

#@ ios_base


표준 스트림 클래스의 타입과 무관한 멤버들을 포함하고 있는 기초 클래스(base `class)` 이다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F18728641509A44B6183588)


`ios_base` 클래스는 모든 `stream` 클래스의 기초 클래스가 되도록 만들어졌다. 이 클래스에서는 스트림의 가장 기초적인 부분을 담당하게 되는데, 이는 모든 스트램 객체의 공통적인 부분을 의미한다. 따라서 이 클래스에서 객체를 직접적으로 만들어내는 경우는 없다.

`ios_base` 클래스와 파생 클래스 모두 스트림 객체가 입력이냐, 출력이냐에 무관한, 다시 말해 모든 스트림 객체들이 포함해야 하는 멤버들을 포함하고 있다.  이들 중에서 `ios_base` 는 템플릿 인자 ( [앞서 말한 두 인자들, http://itguru.tistory.com/143 참조](http://itguru.tistory.com/143)) 들에 무관한 멤버들을 포함하고 있게 된다. 반면에 `ios` 는 타입에 무관하지 않은 경우를 담당하고 있다.

구체적으로 말하자면 `ios_base` 클래스는 스트림의 아래와 같은 정보들을 관리한다고 보면 된다.

#### 서식 정보(Formatting information)

* 서식 플래그(format flag) :  입출력 작업들이 어떠한 형식으로 해석되어야 할지를 지시하는 내부 지시자들의 집합이다. 이 지시자들의 상태는
 [flags](http://itguru.tistory.com/153), 
 [setf](http://itguru.tistory.com/155) 나
 [unsetf](http://itguru.tistory.com/156) 함수들을 호출함으로써 알아내거나 수정될 수 있다.

* 필드 너비(field width) : 출력될 다음 원소의 너비에 대한 정보이다. 이 값은
 [width](http://itguru.tistory.com/152) 함수 호출을 통해 수정되거나 얻어질 수 있다.

* 출력 정밀도(display precision) :  부동 소수점 데이터를 출력시 어떠한 정밀도로 표시할 것인지를 나타낸다. 이 값은
 [precision](http://itguru.tistory.com/157)함수를 통해 얻어질 수 있다.

* 로케일 객체(locale object) : 입출력 작업을 서식화 할 때 고려해야 할 로케일 정보(언어 문화권의 차이에 따라 달라지는 특성) 들을 담고 있다. 로케일 객체는
 [getloc](http://itguru.tistory.com/160)함수를 호출함으로써 얻어진다.




#### 상태 정보


* 오류 상태(error state) : 내부 지시자가 현재 스트림의 오류 상태를 나타내고 있다. 객체는
 [ios::rdstat](http://itguru.tistory.com/171) 함수를 호출함으로써 얻어지고, `ios::clear` 와
 [ios::setstate](http://itguru.tistory.com/179) 함수를 호출함을 통해 수정될 수 있다. 각각의 값은
 [ios::good](http://itguru.tistory.com/164), 
 [ios::eof](http://itguru.tistory.com/167), 
 [ios::fail](http://itguru.tistory.com/165), 
 [ios::bad](http://itguru.tistory.com/166) 를 호출함으로써 얻어진다.

* 예외 마스크(exception mask) : 내부 예외 상태 지시자.
 [ios::exceptions](http://itguru.tistory.com/150) 를 통해 이 값을 얻어낼거나 수정할 수 있다.

#### 그 외

* 이벤트 함수 스택(event function stack) : 특정 이벤트가 일어낼 때 호출되었던 콜백 함수들을 가리키는 포인터들의 스택. 추가적인 콜백 함수들은
 [register_callback](http://itguru.tistory.com/159)함수를 호출함으로써 스택에 등록할 수 있다.

* 내부 확장 가능 배열(internal extensible arrays) : 두 개의 배열로 `long` 객체와 `void` 포인터들을 저장하기 위한 것이다. 이 배열은
 [xalloc](http://itguru.tistory.com/162)함수를 호출함으로써 확장될 수 있고, 각각의 객체들의 레퍼런스는
 [iword](http://itguru.tistory.com/161)나
 [pword](http://itguru.tistory.com/163)함수를 호출함으로써 얻어진다.



###  멤버 함수들


* 생성자

* 소멸자


서식


*  [flags](http://itguru.tistory.com/153):  서식 플래그를 수정하거나 얻어온다.

*  [setf](http://itguru.tistory.com/155)  :  특정 서식 플래그를 설정한다.



*  [unsetf](http://itguru.tistory.com/156):  특정 서식 플래그를 초기화 한다.



*  [precision](http://itguru.tistory.com/157)  :  부동 소수점 정밀도를 수정하거나 얻어온다.



*  [width](http://itguru.tistory.com/152)  :  필드의 너비를 수정하거나 얻어온다.




로케일


*  [imbue](http://itguru.tistory.com/158)  :  로케일을 채운다.

*  [getloc](http://itguru.tistory.com/160)  :  현재 로케일을 얻어온다.




내부 확장 가능 배열(internal `extensible array)`


*  [xalloc](http://itguru.tistory.com/162)  :  내부 확장 가능 배열의 새로운 인덱스를 리턴한다. (정적 함수)



*  [iword](http://itguru.tistory.com/161)  :  내부 확장 가능 배열의 특정 정수 원소의 레퍼런스를 얻는다.

*  [pword](http://itguru.tistory.com/163)  :  내부 확장 가능 배열의 포인터의 레퍼런스를 얻는다.

그 외


*  [register_callback](http://itguru.tistory.com/159)  :  이벤트 콜백 함수를 등록한다.

* `sync_with_stdio` :  `iostream` 과 `cstdio` 스트림과의 동기화를 활성화 하거나 비활성화 한다.






###  멤버 타입들





* event  :  이벤트를 표시하기 위한 타입

* `event_callback`  :  이벤트 콜백 함수 타입

*  [fmtflags](http://itguru.tistory.com/154)  :  스트림 서식 플래그를 위한 타입

* iostate  :  스트림 상태 플래그를 위한 타입

* openmode  :  스트림 열기 모드 플래그(opening mode flag)를 위한 타입

* seekdir  :  방향 찾기 플래그를 위한 타입




멤버 클래스


* failure  :  스트림 예외를 위한 기초 클래스

* `Init` :  표준 스트림 객체를 초기화 한다.
Link :  143
2011-08-17 01:59
----------------
title : C++ IOstream (입출력) 라이브러리
ref_title : iostream
publish_date : 2011-08-17 01:59
--------------


```warning
  이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 [저의 모토인 '지식전파'](http://itguru.tistory.com/notice/107) 를 위해 모든 이들에게 공개하도록 하겠습니다.
```



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F180EB4384E4A8EC128AFA3)

`iostream` 라이브러리의 전체 개요도. 참고로 모두 `char` 형으로 특수화 된 것들이다. 사실은 모두 템플릿으로, 예컨대 `basic_ios<>, basic_iostream<>, basic_streambuf<>` 등이다.

`iostream` 라이브러리는 객체지향 라이브러리로, 스트림을 이용하여 입출력 기능을 제공한다.

스트림이란, 여러 장치에 입출력 작업이 실행되는 것을 '추상화' 하여 나타낸 것이다. 보통 스트림은 디스크나 키보드, 혹은 콘솔과 같이 문자들을 이러한 장치들로 부터 주고받을 때 사용된다. 따라서 사용자는 어떤 장치들에 입출력 연산을 하냐에 무관하게, 스트림을 통해 편리하게 입출력을 사용할 수 있게 된다.

예컨대, 파일 스트림은 C++ 객체로 파일들을 수정하고, 여러가지 상호작용할 수 있도록 만들어진 것이다. 또한, 파일 스트림을 디스크의 특정 파일과 연관시켰다면, 파일 스트림에 단순히 작업하므로써 사용자는 실제 디스크의 파일에 물리적 작업(쓰거나 읽거나 등등) 을 할 수 있게 된다.

스트림과 작업하기 위해서는 C++ 은 아래와 같은 표준 입출력 라이브러리 (standard iostream library) 를 지원하여, 아래와 같은 것들을 가지고 있다. (참고적으로 C 의 경우 C 표준 입출력 라이브러리 (stdio) 를 지원하며 C++ 에서 역시 사용 가능한데, 이 경우 `cstdio.h` 를 참조하면 된다)



### `iostream` 라이브러리는 무엇으로 구성되어 있나?


#### 기초적인 클래스 템플릿들 (Basic class templates)

입출력 라이브러리는 클래스 템플릿들의 상속 관계로 이루어져 있다. 이러한 클래스 템플릿들은 라이브러리를 타입에 영향을 받지 않게 독립적(type-independent)으로 만들어주게 된다. 이들은 클래스 템플릿의 집합으로, 각각은 2 개의 템플릿 인자를 가지고 있다. 하나는 `char` 로(charT) 입출력될 데이터들을 어떠한 문자로 조작(manipulate) 할 지 결정하고 (예컨대 `char, wchar_t` 등등), 다른 하나는 `trait` 인자로, 입출력될 데이터 처리시 부가적인 성질을 부여하게 된다.

이 클래스 템플릿들로 부터 `char` 형으로 특수화 된 클래스들 (즉 `char_traits` 에 `char` 이 전달된 경우) 은 템플릿 이름 앞에 붙은 `basic_` 을 뺀 이름을 가지고 있다. 예컨대 `istream` 은 `basic_istream` 으로 부터 `char` 형으로 특수화 된 클래스 이다. 또한 `fstream` 은 `basic_fstream` 으로 부터 특수화 된 것이다. 유일한 예외는 [ios_base](http://itguru.tistory.com/144)인데, 이는 그 자체로 타입에 무관하기 대문에 템플릿을 기반으로 하지 않지만 어쨋든 클래스 이다.

#### 클래스 템플릿 특수화

이 라이브러리에는 기본적으로 `iostream` 클래스 템플릿에서 두 가지 형태로 특수화 된 클래스 들이 존재한다. 하나는 위에서도 말했지만 `char` 형태로 데이터들을 조작하는 것이고 다른 하나는 `wchar_t` 형태로 데이터를 조작하는 클래스들이다.

이 `char` 형으로 특수화 된 클래스들이 위 사진에서도 잘 나와있듯이 `iostream` 라이브러리에서는 더 잘 알려진 형태이다. 이들을 보통 `narrow-oriented` 되었다고 부르는데, [ios](http://itguru.tistory.com/145), [ istream](http://itguru.tistory.com/146)`, ofstream` 과 같은 경우이다. 반대로 `wchar_t` 형태로 특수화 된 경우(wide-oriented 되었다고 부른다), 클래스 이름 앞에 `w` 가 붙게 되는데, 예컨대 `wios, wistream, wofstream` 등이 있다.

#### 표준 객체(standard object)

`iostream` 라이브러리의 일부로, 해더파일 `<iostream>` 에서는 표준 입력과 출력에 입출력 작업을 실행할 객체들이 정의되어 있다. `narrow-oriented` 객체들의 경우 우리에게 친숙한 `cin, cout, cerr, clog` 가 정의되어 있고, `wide-oriented` 객체들의 경우 `wcin, wcout, wcerr, wclog` 들이 있다.

#### 타입

`iostream` 클래스들은 `trait` 를 기반으로 한 타입과 이들을 특수화 한 타입들을 주로 사용한다.

#### 조작자(Manipulator)

조작자들은 전역 함수들로, `iostream` 스트림 객체에 삽입(insertion, <<) 과 추출(extraction, [>>](http://itguru.tistory.com/147)) 작업과 함께 사용되는 것들이다. 이들은 스트림의 성질이나, 설정된 서식등을 바꾼다. 예를 들어 `endl, hex, scientific` 등을 들 수 있다.


### 전체의 대략적 구성

라이브러리와 이들와 관계로 분류하였다.

* [ios](http://itguru.tistory.com/145),
 [istream](http://itguru.tistory.com/146), `<ostream>, <streambuf>, <iosfwd>` 들은 C++ 프로그램들에서 직접적으로 사용되지 않는다. 이들은 단순히 기초 클래스(base class) 로 파생 클래스들을 사용시 자동으로 헤더에 포함된다.
* `<iostream>` 은 표준 입력과 출력에 소통할 수 있도록 하는 객체들을 정의하게 된다 (`cin, cout` 등)
* `<fstream>` 은 파일 스트림 클래스 및 템플릿 (예컨대 템플릿 `basic_ifstream` 이나 `ofstream` 클래스 등) 들과 `basic_filebuf` 와 사용되는 버퍼 객체들을 정의하고 있다. 이 클래스들은 스트림을 이용하여 파일을 조작하는데 사용된다.
* `<sstream>` 에 들어있는 클래스들은 스트림에 들어있는 문자열 객체들을 조작하는데 사용된다.
* `<iomanip>` 은 추출/삽입 연산자들과 사용되어 플래그들과 서식 옵션들을 수정하는데 쓰이는 표준 조작자와 그것의 인자들을 정의한다.


#### 참고사항

이 레퍼런스에 수록된 이름들과 원형들, 그리고 예시들은 모두 클래스 템플릿 그 자체 보다는 `char` 형으로 특수화 된 경우이다. 물론 클래스 템플릿들이 다른 타입으로 특수화 될 수 있지만 이렇게 `char` 형으로 특수화 된 경우를 수록한 것이 보기에 더 편하고, 원래 템플릿 이름을 알아내는데 훨씬 용이하므로 이 형태로 나타내었다.



### 표준 입출력 라이브러리(iostream) 의 구성 요소들


#### 클래스


*  [ios_base](http://itguru.tistory.com/144)  :  기초 클래스(base)로 표준 입출력 라이브러리와 타입과 무관한(type-independent) 멤버들만 가지고 있다.

*  [ios](http://itguru.tistory.com/145):  기초 클래스로 표준 입출력 라이브러리의 타입 의존적 멤버들을 가지고 있다.

*  [istream](http://itguru.tistory.com/146)  :  입력(Input) 클래스

* ostream  :  출력(Output) 클래스

* iostream  :  입출력 스트림 클래스

*  [ifstream](http://itguru.tistory.com/151)  :  파일 입력 스트림 클래스



* `ofstream` :  파일 출력 스트림 클래스

* fstream  :  파일 입출력 스트림 클래스

* istringstream  :  입력 문자열 스트림 클래스



* ostringstream  :  출력 문자열 스트림 클래스



* stringstream  :  입출력 문자열 스트림 클래스

* streambuf  :  스트림들의 기초 버퍼 클래스

* filebuf  : 파일 스트림 머퍼 클래스



* stringbuf  :  문자열 스트림 버퍼 클래스




#### 객체


* cin  :  표준 입력 스트림

* cout  :  표준 출력 스트림



* cerr  :  표준 오류 출력 스트림

* `clog` :  표준 로그(log) 출력 스트림




#### 타입


* fpos  :  스트림 위치 클래스 템플릿



* streamoff  :  스트림 오프셋 타입

* streampos  :  스트림 위치 타입



* `streamsize` :  스트림 크기 타입




####  조작자(Manipulator) - 모두 함수이다.


* boolalpha  :  `bool` 값을 문자열로(true, `false)`

* dec  :  십진수를 사용

* `endl` :  새로운 줄을 추가하고 `flush` 한다.



* `ends` :  `null` 문자를 추가한다.



* fixed  :  고정점 표기를 사용한다.



* `flush` :  스트림 버퍼를 `flush` 한다.



* hex  :  16 진수를 사용한다.



* `internal`  :  특정 지점에 문자들을 추가하여 폭을 조절한다.



* `left` :  출력을 왼쪽으로 조정한다.



* `noboolalpha`  :  `bool` 값에 문자열을 사용하지 않는다 (0,1)



* `noshowbase` :  몇 진법으로 나타냈는지 표시하지 않는다.



* `noshowpoint` :  소수점을 표시하지 않는다.



* noshowpos  :  `+` 부호를 표시하지 않는다.



* `noskipws` :  공백문자(whitespace) 를 생략하지 않는다.



* nounitbuf  :  입력(insertion) 뒤 강제로 `flush` 하지 않는다.



* nouppercase  :  대문자를 사용하지 않는다.



* oct  :  8 진수를 사용한다.



* resetiosflags  :  서식 플래그를 초기화 한다.



* right  :  출력을 오른쪽으로 조절한다.



* scientific  :  과학적 표기법을 사용한다.



* setbase  :  진법 플래그를 설정한다.



* setfill  :  어떤 문자로 채울지 설정한다.

* setiosflags  :  서식 플래그를 설정한다.

* setprecision  :  소수점 몇 째 자리 까지 표시할지 설정한다.



* setw  :  출력할 너비를 조절한다.



* showbase  :  몇 진법으로 표시됬는지 표시한다.



* showpoint  :  소수점을 표시한다.



* showpos  :  `+` 부호를 표시한다.



* skipws  :  공백 문자(whitespace)를 생략한다.



* unitbuf  :  입력(insertion) 뒤 버퍼를 `flush` 한다.

* uppercase  :  대문자로만 표시한다.



* ws  :  공백문자를 추출한다.
Link :  142
2011-08-16 11:06
----------------
title : 비주얼 스튜디오에서 소스 한꺼번에 정렬하기
publish_date : 2011-08-16 11:06
--------------


  여러분이 인터넷에서 소스를 긁어오게나 소스 중간 중간에 수정할 때, 소스 전체의 모양이 흐트러지는 경우가 많습니다. 이 때 보기 별로 좋지 않으므로 들여쓰기 (Indent) 를 통해서 소스를 정렬해주는 경우가 많은데요, 이를 한꺼번에 해주는 단축키를 모른다면 일일히 탭을 눌러가면서 고생하는 경우가 많습니다.

  하지만 대부분의 에디터를 이를 지원하는데, 비주얼 스튜디오에서는


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F145A5F424E49CF570CE829)

  위와 같이 소스가 있을 때, 일단` Ctrl + A`를 눌러서 전체선택을 해주시고,


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F136F663D4E49CF8A0A8AFA)

위와 같이 된 상태에서` Ctrl` 을 누른 채로 `K, F`를 눌러주시면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F182D92414E49D02E28F450)
위와 같이 정렬이 됩니다.

정리하자면 `Ctrl + A` 후, `Ctrl + K,F` 를 눌러주셔면 됩니다. 물론, 원하는 부분만 정렬하려면 마우스로 드래그 한 뒤 `Ctrl + K,F` 하시면 됩니다.
Link :  138
2011-05-15 11:44
----------------
title : 씹어먹는 C++ - <2 - 1. C++ 은 C 친구 - C 와 공통점>
cat_title: 2 - 1. C++ 은 C 친구 - C 와 공통점
next_page : 141
publish_date : 2011-05-15 11:44
--------------


이번 강좌에서는

* C++ 과 C 언어와의 동일한 문법 구조들에 대해 살펴본다 C++ 과 C 언어와의 동일한 문법 구조들에 대해 살펴본다.

* 예를 들어 `if - else, while, for, switch` 문 등이다.

* 변수 정의에 대해 알아본다.

![](/img/ChewingCpplogo.png)

안녕하세요 여러분~ Psi 입니다. 저의 C++ 세번째 강좌 이네요. 이번 강좌에는 여러분과 많이 친숙할 듯 한데요, 왜냐하면 C++ 이 C 언어의 여러가지 문법들을 어떻게 사용하는지 살펴볼 것입니다. 사실 C 언어에서 작성된 코드를 그대로 C++ 에 붙여 넣기 해도 큰 문제가 없다고 말해도 과언이 아닌 만큼 C++ 은 C 언어의 문법을 거의 완전하게 포함하고 있습니다 C++ 은 C 언어의 문법을 거의 완전하게 포함하고 있습니다.

```cpp-formatted
// 변수의 정의
#include <iostream>
using namespace std;

int main() {
  int i;
  char c;
  double d;
  float f;

  return 0;
}
```

일단 가장 기초적인 부분으로 변수를 정의하는 것 부터 봅시다. 사실 위 코드를 볼 때 의위 `#include` 와 `using ...` 만 빼면은 C 언어에서 작성한 코드라고 말해도 똑같이 생각할 것입니다. 변수를 정의하는 부분에서 만큼은 C 언어때와 달라진 것이 없습니다. 물론 변수 명 이름 작성 규칙도 바뀐 것이 없지요. 변수명도 C 언어 때와 마찬가지로 알파벳과 `_` 기호, 숫자들를 사용할 수 있고 그 외의 것들은 사용할 수 없습니다. (Visual C++ 2010 에서는 한글 변수명도 사용 가능하지만 바람직한 일이 절대로 아닙니다) 또한 변수 이름의 맨 앞부분에는 숫자가 오면 안되지요.

`Google` 의 C++ 변수 이름 짓기 가이드에 따르면 [여기](http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#General_Naming_Rules)에서 보실 수 있습니다. 다음과 같이 하기를 권장합니다.

먼저 변수의 이름은 변수의 이름만을 딱 보았을 때 무엇을 하는지 확실히 알 수 있어야 합니다.

```cpp-formatted
int number_of_people;  // OK
double interest_rate;  // OK
```

```warning
    int num_of_ppl; // BAD
    double intrst_rt; // BAD
```


맨 위의 두 변수 이름들은 딱 보았을 때 '아, 사람의 인원수이고 아래는 이자율 이구나' 라는 느낌이 확 들지만 아래의 두 변수 이름을 보았을 때에는 그러한 느낌을 받기 힘듭니다. 따라서 변수 이름이 조금 길더라도 확실히 이해할 수 있는 변수 이름을 짓는 것이 매우 중요합니다.

둘째로 변수 이름의 띄어쓰기에 관한 규칙인데, 보통 변수 이름을 지을 때

```cpp-formatted
int number_of_people;  // OK
int NumberOfPeople;    // Ok
```


위 처럼 두 가지 방법을 사용하는데 하나는 이름의 띄어쓰기 부분에 `_` 를 넣는 것이고 다른 하나는 띄어쓰기 부분에 대문자로 구분하는 것인데, 저의 경우 전자의 방법을 선호합니다. 물론 이는 사람 마다 개인차가 있겠지만, 가장 중요한 것은 소스 상에서 위 둘을 같이 사용하는 것을 막는 것인데, 예를 들어서

```warning
    int NumberOf_People; // BAD
```


는 전혀 권장할 것이 못됩니다. 저는 앞으로 제 소스에서 전자의 방법을 취할 것입니다 :)

아무튼 제 C++ 강좌를 보고 계실 여러분들의 실력은 이미 상당한 수준(아마도 C 언어 정도는 다룰 줄 아실 분들) 이실 테니 이러한 내용들도 중간에 짬짬히 이야기 하고 지나갈 것입니다 ㅎㅎ

이렇게 해서 변수의 정의는 C 나 C++ 이 차이가 없다는 것을 보실 수 있으셨을 것입니다. 마찬가지로 배열이나 포인터를 정의하는 방법도 C 나 C++ 이 동일합니다. 물론 포인터의 경우 C 에서 `*` 와 `&` 가 하였던 역할을 C++ 에서도 그대로 물려 받았습니다.

예를 들어 C 에서

```cpp-formatted
int arr[10];
int *parr = arr;

int i;
int *pi = &i;
```


  게 했던 것들을 C++ 에서는 어떻게 할까요? 답은 간단합니다. 똑같이

```cpp-formatted
int arr[10];
int *parr = arr;

int i;
int *pi = &i;
```


 쓰면 됩니다. 쉽지요? 어떠한 것들을 선언하는 방법은 정말로 C++ 이나 C 가 차이가 하나도 없음을 알 수 있습니다.

그렇다면 다른 문법 구조들은 어떻까요. 반복문(`for, while`)이라던지 조건문(`if, else, switch`) 이라던지.. 일단 `for` 부터 살펴보도록 합시다.

```cpp-formatted
// C++ 의 for 문
#include <iostream>
using namespace std;

int main() {
  int i;

  for (i = 0; i < 10; i++) {
    cout << i << endl;
  }
  return 0;
}
```


  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F1342C9454D857C7D29DDCF)

와우! 정말로 똑같습니다. C 언어 때와 `for` 문은 달라진 것이 없군요. 그렇다면 C++ 에서 `for` 문을 이용해 1 부터 10 까지 더하는 문장은 어떻게 만들까요.

```cpp-formatted
/* 1 부터 10 까지 합*/
#include <iostream>
using namespace std;

int main() {
  int i, sum = 0;

  for (i = 1; i <= 10; i++) {
    sum += i;
  }

  cout << "합은 : " << sum << endl;
  return 0;
}
```


  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1744AB3E4D8581790CB209)

역시 기존의 C 언어 때와 동일합니다.

사실 `for` 문은 C++ 에서도 그 문법이 바뀌지 않았습니다. 그냥 여러분이 기억하시는대로 사용하시면 됩니다. 한 가지 달라진 점이 있다면 변수의 선언이 반드시 최상단에 있어야 되는 것은 아닙니다. 기존의 C 에서는 변수를 정의할 때 언제나 소스 맨 위부분에 선언을 하였습니다. 예를 들어

```cpp-formatted
int i, sum = 0;

for (i = 1; i <= 10; i++) {
  sum += i;
}
```

와 같이 말이지요. 하지만 C++ 에서는 변수를 사용하기 직전 어느 위치에서 든지 변수를 선언할 수 있게 됩니다. 예를 들어서 다음과 같이 해도 상관이 없습니다.

```cpp-formatted
/* 변수는 변수 사용 직전에 선언해도 된다.*/
#include <iostream>
using namespace std;

int main() {
  int sum = 0;

  for (int i = 1; i <= 10; i++) {
    sum += i;
  }

  cout << "합은 : " << sum << endl;
  return 0;
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1744AB3E4D8581790CB209)

로 동일한 결과를 보입니다.
그렇다면 `while` 문은 어떨까요. 역시 동일합니다

```cpp-formatted
/* while 문 이용하기 */
#include <iostream>
using namespace std;

int main() {
  int i = 1, sum = 0;

  while (i <= 10) {
    sum += i;
    i++;
  }

  cout << "합은 : " << sum << endl;
  return 0;
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1744AB3E4D8581790CB209)

와 같이 우리가 기존에 알고 있었던 `while` 문과 동일한 결과를 나타냅니다.

C++ 에서 `if - else` 문 역시 C 와 동일한 문법 구조로 되어 있습니다. 아래의 예제를 볼까요 C++ 에서 `if - else` 문 역시 C 와 동일한 문법 구조로 되어 있습니다. 아래의 예제를 볼까요.

```cpp-formatted
/* 행운의 숫자 맞추기*/
#include <iostream>
using namespace std;

int main() {
  int lucky_number = 3;
  cout << "내 비밀 수를 맞추어 보세요~" << endl;

  int user_input;  // 사용자 입력

  while (1) {
    cout << "입력 : ";
    cin >> user_input;
    if (lucky_number == user_input) {
      cout << "맞추셨습니다~~" << endl;
      break;
    } else {
      cout << "다시 생각해보세요~" << endl;
    }
  }
  return 0;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F1636CA3F4DCD5438225045)

와 같이 역시 우리가 C 에서 생각했던 대로 동일하게 나옵니다. 위 코드에서 살펴볼 부분은 바로

```cpp-formatted
cout << "입력 : ";
cin >> user_input;
```

입니다. 일단 `cout` 은 앞에서 배웠지만 `<<` 를 이용하여 출력을 시키지요.  그리고, 이미 예상했다 싶이 `cin` 은 사용자로 부터 입력을 받아서 `>>` 를 통해 `user_input` 에 넣습니다. `scanf` 에서는 `&` 를 붙였는데 C++ 에서는 편리하게도 앞에 `&` 연산자를 붙일 필요가 없네요. 심지어, `scanf` 에서는 `int` 형태로 입력받을 지 아니면 `char` 인지에 따라서 `%d` 냐 `%c` 냐로 구분하였는데 여기서는 그냥 변수를 보고 `cin` 이 알아서 처리해 줍니다. 매우 편리하지요

아직까지 여러분은 `cin` 이 뭔지, `cout` 이 뭔지 이게 도대체 함수인건지 변수인건지 구조체 인건지, 기본의 쉬프트 연산자로 사용되었던 `<<` 나 `>>` 는 뭔지 도저히 감이 잡히지 않을 것입니다. 그래도 상관은 없습니다. 일단 사용하세요! 사용하시고 편리하게 될 쯤에는 제 강좌에서 뭔지 배우실 것입니다.


```cpp-formatted
if (lucky_number == user_input) {
  cout << "맞추셨습니다~~" << endl;
  break;
} else {
  cout << "다시 생각해보세요~" << endl;
}
```


C 에서와 마찬가지로 C++ 에서도 `if` 문은 동일하게 사용함을 알 수 있습니다. 그렇다면 `switch` 문은 어떨까요?

```cpp-formatted
// switch 문 이용하기
#include <iostream>

using namespace std;
int main() {
  int user_input;
  cout << "저의 정보를 표시해줍니다" << endl;
  cout << "1. 이름 " << endl;
  cout << "2. 나이 " << endl;
  cout << "3. 성별 " << endl;
  cin >> user_input;

  switch (user_input) {
    case 1:
      cout << "Psi ! " << endl;
      break;

    case 2:
      cout << "99 살" << endl;
      break;

    case 3:
      cout << "남자" << endl;
      break;

    default:
      cout << "궁금한게 없군요~" << endl;
      break;
  }
  return 0;
}
```


  성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F181E9D454DCF3D540FB6F4)


 으로 `switch` 문이 잘 작동하는 것을 보실 수 있습니다.

```cpp-formatted
switch (user_input) {
  case 1:
    cout << "Psi ! " << endl;
    break;

  case 2:
    cout << "99 살" << endl;
    break;

  case 3:
    cout << "남자" << endl;
    break;

  default:
    cout << "궁금한게 없군요~" << endl;
    break;
}
```


위를 보면 기존의 C 에서 사용하였던 `switch` 문과 다를 바 없다는 것을 아실 수 있습니다.그렇습니다. 늘 말해왔듯이 C와 C++ 은 기본적인 문법 구조(조건문; `if, else, switch`, 제어문; `for, whlie, break, continue` ...)는 똑같습니다.

자 그럼 이번 강좌에서는 이것으로 마치도록 하겠습니다:) C 에서 기본적으로 다뤘던 예제들을 C++ 로 바꿔 보는 것도 재밌는 작업 일 것 같습니다.

##@ chewing-cpp-end
Link :  140
2011-05-05 23:32
----------------
title : C 언어 레퍼런스 - srand 함수
path : /C Reference/stdlib.h
cat_title :  srand
publish_date : 2011-05-05 23:32
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ srand

```info
#include <stdlib.h> // C++ 에서는 <cstdlib>

void srand ( unsigned int seed );

```

난수 생성기를 초기화 한다.

**의사 난수(psudo-random) 생성기**의 초기값을 인자로 전달된 값으로 초기화 한다. 이때 의사 난수란 실제 난수는 아니지만 일련의 알고리즘에 의해 생성된 수들로 전혀 규칙성이 없어보이는 수들이다.

`srand` 에 다른 `seed` 값을 전달하게 된다면 `rand` 함수로 부터 생성되는 난순열은 전혀 다를 것이라 생각해보도 무방하다. 하지만 동일한 `seed` 값을 이용한 두 `rand` 함수는 동일한 난순열을 만들어내게 된다.

만일 `seed` 를 1 로 설정한다면 `rand` 함수가 호출되기 전의 맨 처음 초기값으로 설정이 된다.

진짜 난수 같은 수열을 생성해 내고 싶다면 `srand` 는 보통 시간에 관련된 함수로 초기화 하는 것이 좋다. 예를 들어 `<time.h>` (C++ 에서는 `<ctime>`) 에 정의되어 있는 `time` 함수의 경우 매 초당 다른 값을 주기 때문에 매우 좋은 예가 될 수 있다. 실제로 대부분의 경우 `srand` 는 `time(NULL)` 값으로 초기화 하는 것이 대다수 이다.


###  인자

`seed`

난순열을 생성 알고리즘을 위한 초기 정수 값이다.이 `seed` 값을 바탕으로 난순열이 생성된다.



###  리턴값




없음



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/cstdlib/srand/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  printf("First number: %d\n", rand() % 100);
  srand(time(NULL));
  printf("Random number: %d\n", rand() % 100);
  srand(1);
  printf("Again the first number: %d\n", rand() % 100);

  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F13223D3B4DC8A03528E793)



###  연관된 함수

*  [rand](http://itguru.tistory.com/139)  :  난수를 생성한다.
Link :  139
2011-05-05 23:23
----------------
title : C 언어 레퍼런스 - rand 함수
path : /C Reference/stdlib.h
cat_title :  rand
publish_date : 2011-05-05 23:23
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ rand

```info
#include <stdlib.h> // C++ 에서는 <cstdlib>

int rand ( void );

```

난수를 생성한다.

`0` 부터 `RAND_MAX` 범위의 정수들로 **의사 난수(pseudo-random)** 를 생성한다. 의사 난수란 실질적인 난수가 아니라 컴퓨터 상에서 일련의 복잡한 연산에 의해 만들어지는 난수 같아 보이는 수들을 말한다.

`rand` 함수를 실행할 때 마다 특정한 알고리즘에 의해 연관성이 없어 보이는 수들이 생성된다. 이 알고리즘은 난순열을 생성하기 위해 초기값이 필요한데, `srand` 함수를 통해 이 초기값을 설정할 수 있다.



###  인자


없음



###  리턴값




`0` 과 `RAND_MAX` 사이의 정 0 과 `RAND_MAX` 사이의 정수



###  실행 예제


```cpp-formatted
/*

숫자 맞추기
이 예제는
http://www.cplusplus.com/reference/clibrary/cstdlib/rand/
에서 가져왔습니다

 */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  int iSecret, iGuess;

  /* initialize random seed: */
  srand(time(NULL));

  /* generate secret number: */
  iSecret = rand() % 10 + 1;

  do {
    printf("Guess the number (1 to 10): ");
    scanf("%d", &iGuess);
    if (iSecret < iGuess)
      puts("The secret number is lower");
    else if (iSecret > iGuess)
      puts("The secret number is higher");
  } while (iSecret != iGuess);

  puts("Congratulations!");
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F206A0F394DC2B23C3487C4)


위 예제에서 난수의 초기값으로 `time()` 함수의 리턴값 (1970 년 부터 현재 까지 지난 초 수) 를 사용하였다. 대부분의 경우 이 방법을 사용한다.



###  연관된 함수

*  [srand](http://itguru.tistory.com/140)  :  난순열의 초기값을 설정한다.
Link :  136
2011-03-06 20:33
----------------
title : 씹어먹는 C++ - <1 - 2. 첫 C++ 프로그램 분석하기>
cat_title: 1 - 2. 첫 C++ 프로그램 분석하기
next_page : 138
publish_date : 2011-03-06 20:33
--------------


이번 강좌에서는

* 첫번째 C++ 프로그램 분석

* 이름공간(namespace) 에 대한 이해


![](/img/ChewingCpplogo.png)


안녕하세요 여러분~ 씹어먹는 C++ 두번째 강좌 입니다. 지난번에는 아마도 여러분 인생 최초의 C++ 프로그램을 만들어 보았을 텐데요, 이번 강좌에서는 소스 코드를 따라가면서 분석을 하는 시간을 갖도록 하겠습니다.

사실, 지금 제 강좌를 보고 계시는 분들 중에서는 막 C 언어 공부를 끝내고 오신 분들도 많으실 텐데요, 무언가 초심자의 마음으로 돌아간 것 같지 않으세요? C 언어에서 막 어려운 프로그래밍 하다가 C++ 오니 다시 맨 밑바닥 부터 화면에 출력하는 것을 하니 답답한 마음이 들 것도 같네요.. 하지만 이것도 잠시라고 생각하세요. 곧 놀라운 C++ 의 세계가 펼쳐질 것입니다.

```cpp-formatted
#include <iostream>
using namespace std;

int main() {
  cout << "Hello, World!!" << endl;
  return 0;
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1526FF484D7B572829CC38)

와 같이 나옵니다.

  위 코드가 바로 지난 강좌에서 사용하였던 코드 입니다. 일단 C 언어와 비슷한 점들 부터 찾아보도록 합시다. 일단 맨 위에

```cpp-formatted
#include <iostream>
```


 을 보면 '아하! `iostream` 이라는 헤더파일을 `include` 하고 있구나!' 라는 생각이 머리속에 번뜩이셔야 합니다. 그렇지 않다면 C 언어를 다시 공부하도록 하세요 ㅎ ([이 강좌를 보시면 됩니다](http://itguru.tistory.com/87))

`iostream` 헤더 파일은 C++ 에서 표준 입출력에 필요한 것들을 포함하고 있습니다. 예를 들면 아래에서 사용되는 `cout` 이나 `endl` 과 같은 것들을 말이지요. C 언어에서의 `stdio.h` 와 비슷하다고 보시면 됩니다. (그리고 C 와 하나 다른 점은 헤더 파일 이름 뒤에 `.h` 가 붙지 않습니다!)

그 다음 줄의 `using ...` 을 보면 잘 모르겠네요.일단 패스~그 아래를 보게 되면 다시 어디서 많이 보던 것이 나왔죠?

```cpp-formatted
int main()
```


네. `main` 함수를 정의하는 부분 입니다. 그리고 그 함수의 몸체를 보면

```cpp-formatted
cout << "Hello, World!!" << endl;
return 0;
```


와 같은 내용이 있네요. 화면에 대충 출력된 것을 보아 `cout` 은 화면에 무언가 출력시켜주는 것 같은데, `printf` 와 다르게 사용된 것을 보니 함수 같지는 않네요. 그리고 화면에 출력된 것을 대충 보면 "계속하려면 아무 키나 누르세요" 가 한 줄 개행되어서 나온 것을 보니 `endl` 은 한 줄 엔터를 쳐서 나타내라는 표시 같습니다.

그리고 마찬가지로 `main` 함수에서도 `return` 을 해주고요. 이렇게 대략 살펴보면 기존의 C 언어와 크게 다른 점은 없는 것 같습니다.

하지만 미스테리로 남아있던 부분부터 살펴보도록 합시다.

```cpp-formatted
using namespace std;
```


위 문장을 직역해보면 '`std` 라는 이름 공간(namespace) 를 사용하겠다' 라는 의미가 됩니다. 그렇다면 이름 공간이란 것이 정확히 무엇일까요? 이름 공간은 말그대로 특정한 공간에 이름을 붙여준 것입니다. 예를 들어서

```cpp-formatted
#include "header1.h"
#include "header2.h"

int main() { function(); }
```


와 같은 표현을 사용했다고 합시다. 그런데 문제는 `header1.h` 에도 `function` 이 정의되어 있고, `header2.h` 에도 이름만 똑같이 다른 일을 하는 `function` 이 정의되어 있는 것입니다. 보통 C 언어에서는 이러한 문제를 해결하기 위해 우리에게 주어진 선택권은 오직 하나, 함수의 이름을 바꾸는 것 밖에 없었지만 C++ 에서는 이름 공간을 도입한 덕분에 이 문제를 유연하게 해결할 수 있었습니다. 바로 `namespace` 를 사용하는 것이지요.

```cpp-formatted
// header1.h 의 내용
namespace header1 {
int function();
}
```


```cpp-formatted
// header2.h 의 내용
namespace header2 {
int function();
}
```


위 둘은 각각 다른 `header` 들의 내용 입니다. 각각의 함수들은 다른 `namespace` 에 존재합니다. 즉, `header1` 에 있는 `function` 의 경우 'header1.h 에 `header1` 라는 이름 공간에 살고 있는 function' 이 되고, `header2` 에 있는 `function` 의 경우 'header2.h 에 `header2` 라는 이름 공간에 살고 있는 function' 이 되는 것이지요. 즉 기존의 C 에서는 'header1.h 에 살고 있는 function' 과 'header2.h 에 살고있는 function' 으로 밖에 나눌 수 없었지만 C++ 에서는 좀더 세부적으로 분류할 수 있게 됩니다. 따라서 실제로 `main` 함수에서 사용할 때는


```cpp-formatted
#include "header1.h"
#include "header2.h"

int main() {
  header1::function();  // header1 이란 이름 공간에 있는 function 을 호출
}
```


과 같이 사용하게 됩니다. 하지만 만일 위 같은 `function` 을 여러번 반복적으로 호출하게 되는 경우 어떨까요. 앞에 `header1::` 을 붙이기가 상당히 귀찮게 됩니다. 그래서 아래와 같이 '나는 앞으로 `header1` 이란 이름 공간에 들어있는 것들만 쓸거다!' 라고 선언할 수 있습니다.

```cpp-formatted
#include "header1.h"
#include "header2.h"
using namespace header1;
int main() {
  function();  // header1 에 있는 함수를 호출
}
```

물론 그렇다고 해서 `header2` 에 있는 함수를 못 사용하는 것은 아니고 다음과 같이 지정해서 써주면 됩니다.

```cpp-formatted
#include "header1.h"
#include "header2.h"
using namespace header1;
int main() {
  header2::function();  // header2 에 있는 함수를 호출
  function();           // header1 에 있는 함수를 호출
}
```


그렇다면 다시 원래 예제를 살펴보도록 합시다.

```cpp-formatted
using namespace std;

int main() {
  cout << "Hello, World!!" << endl;
  return 0;
}
```


여기서 `cout` 과 `endl` 은 모두 `iostream` 헤더파일의 `std` 라는 이름 공간에 정의되어 있는 것들입니다. 따라서 만일 `using namespace std;` 를 붙여주지 않았더라면

```cpp-formatted
int main() {
  std::cout << "Hello, World!!" << std::endl;
  return 0;
}
```


로 꽤 귀찮게 써주야 했었을 것입니다.



그렇다면 `cout` 은 무엇일까요? 정확히 무엇인지 말하자면 `ostream` 클래스의 객체로 표준 출력(C 언어에서의 `stdout` 에 대응됩니다) 을 담당하고 있습니다. 무슨 말인지 모르겠다고요? 괜찮습니다. 이 것이 정확히 무슨 의미인지는 나중 강좌에서 알아보도록 하겠고, 그냥 다음과 같이 쓴다는 것만 알아두시면 됩니다.

```info
cout << 출력할 것 << 출력할 것 << ... << 출력할 것;
```


그리고 `endl` 은 화면에 출력해주는 '함수' 입니다. 놀라셨지요? 하지만 그냥

```cpp-formatted
cout << endl;
```



이라 쓰면 화면에 엔터를 하나 출력해주는 것으로 기억하시면 됩니다. 물론 `endl` 에 대해서도 나중에 다루어 보도록 하겠습니다 :)

### 생각 해보기

#### 문제 1

화면에 출력되는 것들을 바꾸어보자.

#### 문제 2

아래 문장은 화면에 어떻게 출력될까요?

```cpp-formatted
cout << "hi" << endl
     << "my name is "
     << "Psi" << endl;
```

##@ chewing-cpp-end
Link :  135
2011-03-06 19:51
----------------
title : 씹어먹는 C++ 강좌 계획
next_page: 134
publish_date : 2011-03-06 19:51
--------------

![](/img/ChewingCpplogo.png)

안녕하세요 여러분~ 이제 C 언어에 이어서 C++ 강좌를 연재하게 된 Psi 입니다. 저의 C++ 강좌는 여러분이 C 언어를 충분히 이해하고 사용하고 있다는 것을 가정으로 진도를 나갈 것입니다.


물론 C 언어를 굳이 배우지 않은 상태에서 C++ 을 첫 언어로 배워도 상관 없습니다. C 언어와 C++ 이 매우 다르기 때문에 **무엇을 먼저 배워야 하냐 라는 의미는 크게 중요하지 않습니다.** 하지만 C++ 이 C 의 기초적인 문법을 그대로 사용하고 있고, 제가 강좌를 C 언어를 먼저 완성하였기 때문에 독자 타겟을 **C 언어 문법을 어느 정도 아는 사람** 으로 잡았을 뿐입니다.


다시 말해 구질 구질하게 기초적인 `for` 문 사용법, 포인터와 같은 것들은 C++ 강좌에서 다루지 않겠다는 의미 입니다.

간혹 C++ 이 C 언어 확장팩(?) 개념이라고 생각하시는 분들이 있는데 이건 역시 사실이 아닙니다. 물론 초기에는 C++ 이름이 `C with classes` 였을 정도로 그냥 C 언어에 몇 가지 정도를 더 얹은 정도였습니다. 하지만 이제는 C++ 과 C 언어가 '둘이 같은 언어야?' 라고 말할 수 있을 정도로 매우 달라졌습니다.


###  강좌 수칙


제 강좌를 들으시면서 지켜야 할 수칙들은 다음과 같습니다.

1. 강좌는 적어도 한 번 꼭 정독해보기
1. 모르는 것은 꼭 답글 달기
1. 답글로 질문하기 꺼린 내용은 kev0960@gmail.com 으로 메일 보내기!
1. '생각 해보기' 에 적어도 30 분 이상은 투자하기
1. 이전 강좌를 완벽히 이해했다 싶지 않으면 다음 강좌로 넘어가지 말기

입니다. 위 수칙 중에서 무엇보다도 중요한 것은 바로 모르는 내용은 꼭 답글을 다는 것입니다 :)
세상에서 어리석은 질문은 없습니다. 여러분들이 궁금하거나 이상한 내용, 마음에 와닿지 않는 내용들을 질문하지 않고 다음강좌로 넘어가는 한 여러분의 실력은 결코 향상될 수 없을 것입니다.
꼭 궁금한 것들은 댓글로 남겨주시고, 공개적으로 남기기 꺼리면 비밀글로 남기거나 정 그렇다면 `mail` 로 보내주시면 감사하겠습니다. 그러면 제가 확인하는대로 최대한 빨리 답글로 보내드릴께요 ㅎ

```warning
 [참고로 이 강좌는 Visual Studio 2017 커뮤니티 버전을 사용하고 있습니다. 여기를 클릭해서 사용법을 미리 숙지하는게 좋겠습니다.](http://itguru.tistory.com/220)
```


그렇다면 이제 강좌를 보러갈 시간이 되었네요~


###  C++ 강좌 총 목록

###@ [1 - 1. 자~ C++ 의 세계로](http://itguru.tistory.com/134)

이번 강좌에는 `Visual Studio 2010` 을 설치하고 첫번째 C++ 프로그램을 만들어본다.

###@ [1 - 2. 첫 C++ 프로그램 분석하기](http://itguru.tistory.com/136)

이번 강좌에서는 첫번째 C++ 에 관한 상세한 분석 및 `namespace` (이름 공간) 에 대해 알아본다

###@ [2 - 1. C++ 은 C 친구 - C 와 공통점](http://itguru.tistory.com/138)

기초적인 변수의 정의, `if, else, switch for, while,` 배열 등등

###@ [2 - 2. C++ 은 C 친구일까?](http://itguru.tistory.com/141)

함수의 정의, 레퍼런스 등등

###@ [3. C++ 의 세계로 오신 것을 환영합니다(new, delete)](http://itguru.tistory.com/169)

`new, delete,` 그리고 왜 객체 지향 프로그래밍을 해야 하는가?

###@ [4 - 1. 이 세상은 객체로 이루어져 있다](http://itguru.tistory.com/172)

객체 지향 프로그래밍은 무엇인가?, 객체와 클래스, 접근 제어자

###@  [4 - 2. 클래스의 세계로 오신 것을 환영합니다 (함수의 오버로딩, 생성자)](http://itguru.tistory.com/173)

함수의 오버로딩(function overloading), 생성자(constructor), 디폴트 생성자(default constructor)

###@ [4 - 3. 스타크래프트를 만들자 ① (복사 생성자, 소멸자)](http://itguru.tistory.com/188)

복사 생성자(copy constructor), 얕은 복사, 깊은 복사, 소멸자(destructor)

###@ [4 - 4. 스타크래프트를 만들자 ② (const, static)](http://itguru.tistory.com/197)

생성자 초기화 리스트(initializer list), `const, static` 멤버 변수, 레퍼런스를 리턴하는 함수, `this` 포인터, `const` 멤버함수

###@ [4 - 5. 내가 만드는 String 클래스](http://itguru.tistory.com/198)

직접 `String` 클래스를 제작해서 여태까지 클래스에 대해 배웠던 내용을 복습하며 정리한다.

###@ [5 - 1. 내가 만든 연산자 - 연산자 오버로딩](http://itguru.tistory.com/202)

연산자 오버로딩의 기초적인 개념 정리와 함께, 산술, 비교, 대입 연산자의 오버로딩을 수행한다.

###@ [5 - 2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩](http://itguru.tistory.com/203)

멤버함수가 아닌 표현의 연산자 오버로딩과 함께, 입출력 연산자, 첨자 연산자([]), 타입 변환 연산자, 증감 연산자(++, --)들의 오버로딩에 대해 알아본다.
 
###@ [5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열](http://itguru.tistory.com/204)

C++ 스타일의 캐스팅, 디폴트 인자(default argument), 반복자(iterator), 그리고 `N` 차원 배열 제작에 대해 알아본다 C++ 스타일의 캐스팅, 디폴트 인자(default argument), 반복자(iterator), 그리고 `N` 차원 배열 제작에 대해 알아본다.

###@ [6 - 1. C++ 표준 문자열 & 부모의 것을 물려쓰자 - 상속](http://itguru.tistory.com/209)

C++ 표준 문자열, 상속 (inheritance), `protected` 키워드에 대해 알아본다.

###@ [6 - 2. 가상(virtual) 함수와 다형성](http://itguru.tistory.com/210)

*is-a* 와 *has-a* 관계. 오버라이딩, `virtual` 키워드, 가상(virtual) 함수, 다형성(polymorphism)

###@ [6 - 3. 가상함수와 상속에 관련한 잡다한 내용들](http://itguru.tistory.com/211)

`virtual` 소멸자, 가상 함수 테이블, 다중 상속, 가상 상속

###@ [7 - 1. C++ 에서의 입출력 (istream, ostream)](http://itguru.tistory.com/213)

C++ 입출력 라이브러리, `istream, ostream, streambuf` 에 대해 알아본다 C++ 입출력 라이브러리, `istream, ostream, streambuf` 에 대해 알아본다.

###@ [7 - 2. C++ 파일 입출력 (ifstream, ofstream, stringstream)](http://itguru.tistory.com/215)

C++ 에서의 파일 입출력, `stringstream` 과 그 활용에 대해 알아본다 C++ 에서의 파일 입출력, `stringstream` 과 그 활용에 대해 알아본다.

###@ [8 - 1. Excel 만들기 프로젝트 1부](http://itguru.tistory.com/217)

여태까지 배운 내용을 총 동원 하여 조그만 엑셀을 만드는 프로젝트이다.

###@ [8 - 2. Excel 만들기 프로젝트 2부](http://itguru.tistory.com/218)

이전 강좌에서 이어서 엑셀 만들기를 진행한다. 중위 표기법과 후위 표기법에 대해 다룬다.

###@ [9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(Template)](http://itguru.tistory.com/219)

템플릿이란 무엇인가?, 함수 템플릿, 클래스 템플릿. 템플릿 인스턴스화, 템플릿 특수화. 함수 객체 (Functor)

###@  [9 - 2. 템플릿 메타 프로그래밍 (Template Meta Programming)](http://itguru.tistory.com/221)

타입이 아닌 인자를 받는 템플릿, 템플릿 메타 프로그래밍

###@ [9 - 3. 템플릿 메타 프로그래밍 2 (Template Meta Programming)](http://itguru.tistory.com/222)

`TMP` 마무리, 의존 타입(dependent type), `auto` 키워드

###@ [10 - 1. C++ 의 표준 템플릿 라이브러리 (STL) - 시퀀스 컨테이너](http://itguru.tistory.com/223)

시퀀스 컨테이너 (vector, list, deque) 와반복자(iterator)

###@ [10 - 2. C++ 의 표준 템플릿 라이브러리 (STL) - 연관 컨테이너](http://itguru.tistory.com/224)

`set, multiset, map, multimap, unordered_set, unordered_map` 등에 대해 배웁니다.

###@ [10 - 3. C++ STL - 알고리즘(algorithm)](http://itguru.tistory.com/225)

STL 알고리즘 라이브러리, 람다 함수, `sort, partial_sort, stable_sort, find, erase, erase_if, any_of, all_of`

###@ [11 - 1. 우측값 레퍼런스와 이동 생성자](http://itguru.tistory.com/227)

복사 생략 (copy elision), C++ 11 에 추가된 우측값 레퍼런스 (rvalue reference)와 이동 생성자 (move constructor)

###@ [11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)](http://itguru.tistory.com/228)

move semantics, 완벽한 전달 (perfect forwarding), 레퍼런스 접힘 규칙 (reference collapsing rule)

###@ [12. C++ 에서의 예외 처리](/230)

`try .. catch` 와 `throw` 를 사용한 C++ 스타일의 예외 처리 방식에 대해 배운다.

###@ [13 - 1. 객체의 유일한 소유권 (unique_ptr)](/229)

C++ 에서의 RAII 패턴과 `unique_ptr` 의 사용법에 대해 배웁니다.

###@ [13 - 2. 자원을 공유할 때 - shared_ptr 와 weak_ptr](/252)

`shared_ptr`, `weak_ptr` 의 사용법에 대해 배웁니다.

###@ 14 - 1. 동시에 실행을 시킨다고? - C++ 쓰레드(thread)

C++ thread, mutex 그리고 atomic variable.

###@ 14 - 2. 세마포어와 condition_variable

###@ 14 - 3. C++ future 와 promise


아래 강좌들에서는 C++ 11 에 새로 추가된 짜잘짜잘한 기능들을 다룹니다.

###@ 15 - 1. C++ 11 - 초기화자 리스트 (initializer_list)

###@ 15 - 2. C++ 11 - Range 기반 for 문 (Range based for loop)

###@ 15 - 3. C++ 11 - 가변 길이 템플릿 (Variadic template)
Link :  134
2011-03-06 16:18
----------------
title : 씹어먹는 C++ - <1. 자~ C++ 의 세계로>
cat_title: 1. 자~ C++ 의 세계로
next_page : 136
publish_date : 2011-03-06 16:18
--------------



이번 강좌에서는

* `Visual Studio 2010` 을 설치한다.

* 첫 번째 C++ 프로그램을 만든다.


![](/img/ChewingCpplogo.png)



안녕하세요~ 여러분. 흥미롭고도 신기한 C++ 의 세계에 오신 것을 진심으로 환영합니다. 사실 C 언어를 접해본 여러분들이 생각하기에 C++ 은 C 의 확장판 정도라 생각하는 분들이 있는데 이는 결코 사실이 아닙니다.

스타크래프트로 따지면 오리지날과 브로드워 개념이 아니라 스타 1 과 스타 2 정도의 차이 일까요. C++ 은 말 그대로 C 언어의 문법만을 차용한 새로운 언어라고 보시면 됩니다. 왜냐하면 언어를 만들어낸 기본 개념이 다르기 때문이지요. 이 기본 개념이 어떻게 다른 지에 대해서는 나중에설명하도록 하겠습니다.

자 그렇다면, 신나는 C++ 의 세계로 gogogo~



###  준비물




이전 처럼 C++ 을 배우기 위해서는 다음과 같은 준비물들이 필요합니다.


1. 인터넷이 되는 컴퓨터. 특히 http://itguru.tistory.com 이 수월하게 들어가져야 함

1. 뇌

1. 개념

1. 씹어먹는 C 언어를 다 배움으로써 얻을 수 있는 지식

1. 컴파일러

여기서 가장 중요한 것은 4 번 씹어먹는 C 언어를 다 배움으로써 얻을 수 있는 지식인데,왜냐하면 이 강좌는 오직 전적으로 여러분이 C 를 충분히 알고 있다는 전제 하에서 진행될 것이기 때문입니다. 물론 C++ 을 배우기 위해서 반드시 C 언어를 먼저 배워야 하는 것은 아니지만, C++ 이 C 의 문법을 그대로 따르고 있고 제가 이미 C 강좌를 작성한 관계로 문법에 대한 설명(for 문, `if` 문 등등)은 대부분 생략할 것이기 때문입니다.
만일 프로그래밍이 처음이시거나 C 언어 문법을 잘 모르시는 분들의 경우 [어서 여기를 누르셔서](http://itguru.tistory.com/notice/15) C 언어 부터 정복 하고 오시기 바랍니다. 그럼 이제 필요한 것은 5 번, 컴파일러가 되겠네요.

```warning
 [참고로 아래 설치하는 비주얼 스튜디오는 2010 년 버전이고 현재 마이크로소프트에서 2017 년 버전을 제공하고 있습니다. 여기를 눌러서 따라 설치하시면 됩니다.](http://itguru.tistory.com/220)
```


사실 여러분들은 C++ 컴파일러를 이미 다 컴퓨터에 설치하고 계실 것입니다. 왜냐구요? 이전에 C 언어를 배울 때 설치하였던 `Visual Studio 2008` 에 C 및 C++ 컴파일러가 모두 다 들어있기 때문이지요. 하지만 제가 씹어먹는 C 언어 강좌를 썼을 때가 바야흐로 2 년 전인 2009 년으로 최신 버전이 2008 이였지만 이제는 2011 년으로 최신 버전이 2010 으로 올라갔지요. 2008 하고 2010 의 버전 차이는 하늘과 땅 차인데, 무엇보다도 코딩 하기가 매우 편리해 져서 여러분들이게 설치하기를 강력 추천 합니다. (왠지 이 강좌를 끝낼 즘에 2012 버전이 곧 나올 듯한 안좋은 느낌이 드네요ㅎ)

일단

 [ http://www.microsoft.com/visualstudio/en-us/products/2010-editions/visual-cpp-express](http://www.microsoft.com/visualstudio/en-us/products/2010-editions/visual-cpp-express)

로 들어갑니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1157F0514D731DC51F6D47)

그리고 왼쪽에 `DOWNLOAD` 를 누르신 뒤 오른쪽에 언어를 `Korean` 으로 선택하시고 `INSTALL NOW` 를 누르시면 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F157C1E524D731E9B1A62B3)

다음을 누르시고,


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F130354524D731E9B117976)

동의를 누른 뒤, 다시 다음을 누르고


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F177E5A524D731E9C168775)

이것은 우리가 앞으로 배울 수준의 프로그래밍에서는 결코 필요한 것이 아니기 때문에 체크를 해제하고 다음을 누르고


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F197909524D731E9D1F292D)
역시 다음..


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1376FF524D731E9D23D09F)

자 이제, 위와 같이 온라인 상으로 전체 프로그램을 다운받게 됩니다. 그리고 조금만 기다리다 보면 완료되었다는 표시가 납니다. 그렇다면 이제 실행해봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F126BBC354D7320DB1C20A5)

아주 멋있네요~


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F186396374D732157248B16)
이제 새 프로젝트를 누른 후, 이전에 2008 때 처럼 `Win32` 콘솔 응용 프로그램을 눌러줍니다. 만일 다른 것을 눌렀을 경우 예상치 못한 오류들이 나오게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F172172414D7321BA09E0CF)

그리고 아래쪽에 이름을 아무거나 씁니다. 저의 경우 `My first program` 이라고 적어주었습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F124476424D7322071D8E04)

다음을 누르시고


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F14446A424D7322081EF8AA)

빈 프로젝트에 체크를 한 뒤, 마침을 누르면 마침내 새로운 프로젝트가 만들어지게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F18152C464D73226008DB1C)

소스파일을 누른 후 마우스 오른쪽 클릭을 한 후, 추가로 들어가서 새 항목을 누르시면 아래와 같이 나옵니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1777E83E4D73320B13AF46)

여기서 C++ 파일을 선택 한 후, 아래에 원하는 이름.cpp 로 적으면 됩니다. 저의 경우 `hello.cpp` 라 적었습니다. 이전에 C 언어에서는 원하는 이름.c 로 적었던 것이 기억이 나지요? 파일의 확장자를 `c` 로 하면 C 컴파일러가, `cpp` 로 하면 C++ 컴파일러가 프로그램을 컴파일 해줍니다.

자 그럼 왼쪽에 생긴 `hello.cpp` 를 클릭 한 뒤, 나타나는 창에 아래와 같이 코드를 씁니다.


```cpp-formatted
#include <iostream>
using namespace std;

int main() {
  cout << "Hello, World!!!" << endl;
  return 0;
}
```


성공적으로 컴파일 하였다면 (이전과 똑같이 `Ctrl + F5` 를 누르면 컴파일 후 빌드까지 하여 프로그램을 출력해줍니다)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F185243334D73330C3AE117)
우와!!

여러분은 드디어 첫번째 C++ 프로그램을 작성하였습니다. 위 소스가 어떠한 의미를 가지고 있는지는 다음 강좌에서 다루어 보도록 하겠습니다.

##@ chewing-cpp-end
Link :  182
2012-03-25 12:07
----------------
title : C++ 레퍼런스 - ios::rdbuf 함수
cat_title :  ios::rdbuf
publish_date : 2012-03-25 12:07
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::rdbuf

```info
streambuf* rdbuf ( ) const;
streambuf* rdbuf ( streambuf* sb );

```

연관된 스트림 버퍼를 설정하거나 얻는다.
첫번째 형태의 함수는 연관된 스트림 버퍼를 리턴한다.
두 번째 형태의 경우 현재 스트림을 `sb` 와 연관 시키고 이전에 연관되어 있었던 스트림 버퍼를 리턴한다. 이 때 상태 플래그는 `goodbit` 로 설정된다.



###  인자





`sb`

연관시킬 스트림 버퍼를 가리키는 포인터



###  리턴값




이전에 연관되어 있었던 스트림 버퍼



###  실행 결과




```cpp-formatted
/*이 예제는http://www.cplusplus.com/reference/iostream/ios/rdbuf/에서
 * 가져왔습니다.*/
#include <iostream> #include <fstream> using namespace std;
int main() {
  streambuf *psbuf, *backup;
  ofstream filestr;
  filestr.open("test.txt");
  backup = cout.rdbuf();  // 현재 cout 의 스트림 버퍼를 백업한다.    psbuf =
                          // filestr.rdbuf();   // 파일 스트림 버퍼를 얻는다
                          // cout.rdbuf(psbuf);         // 파일 스트림 버퍼를
                          // cout 에 연관시킨다    cout << "This is written to
                          // the file"; // 따라서 이것은 파일에 쓰여진다.
                          // cout.rdbuf(backup);        // 원래 cout 의 스트림
                          // 버퍼로 돌아간다.    filestr.close();    return 0;}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F19116F414F6E86F8080AC6)

파일에 잘 출력된 것을 알 수 있다.



###  템플릿 멤버 정의




```cpp-formatted
(basic_ios<charT, traits>)

  basic_streambuf<charT, traits>* rdbuf() const;
basic_streambuf<charT, traits>* rdbuf(basic_streambuf<charT, traits> sb);
```





###  연관된 자료

* `streambuf` :  스트림의 부모(base) 버퍼 클래스
Link :  181
2012-03-25 10:47
----------------
title : C++ 레퍼런스 - ios::fill 함수
cat_title :  ios::fill
publish_date : 2012-03-25 10:47
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::fill

```info
char fill ( ) const;
char fill ( char fillch );
```


현재 채우기 문자(fill character)를 얻거나 설정한다.

첫번째 형태의 함수의 경우 채우기 문자를 리턴한다.
두번째 형태의 함수의 경우 `fillch` 로 현재의 채우기 문자를 설정하고, 이전의 채우기 문자를 리턴한다.

인자를 가지는 조작자 (manipulator) `setfill` 역시 채우기 문자를 설정하는데 사용할 수 있다.




###  인자





`fillch`

새롭게 사용할 채우기 문자



###  리턴값



함수 호출 이전에 설정되어 있던 채우기 문자.





###  실행 예제




```cpp-formatted
/*

채우기 문자를 'x' 로 설정하고 이를 사용한다.

이 예제는
http://www.cplusplus.com/reference/iostream/ios/fill/
에서 가져왔습니다

*/
#include <iostream>
using namespace std;

int main() {
  char prev;

  cout.width(10);
  cout << 40 << endl;

  prev = cout.fill('x');
  cout.width(10);
  cout << 40 << endl;

  cout.fill(prev);

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1609C6464F6E78A9187FE3)





###  템플릿 멤버 정의





```cpp-formatted
(basic_ios<charT, traits>)

  typedef charT char_type;
char_type fill() const;
char_type fill(char_type fillch);
```




###  연관된 함수


* `setfill` : 채우기 문자를 설정한다. (조작자)
* `ios_base::width` : 필드 폭을 설정하거나 그 값을 얻어온다.
Link :  180
2012-03-25 10:35
----------------
title : C++ 레퍼런스 - ios::clear
cat_title :  ios::clear
publish_date : 2012-03-25 10:35
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::clear

```info
void clear ( iostate state = goodbit );
```


오류 상태 플래그를 설정한다.
오류 상태 플래그를 새로운 값으로 설정한다. 참고로 이와 유사한 동작을 하는 [ios::setstate](http://itguru.tistory.com/179)의 경우, 이전의 오류 상태 플래그를 보존하면서 설정하지만, ios::clear 의 경우 이전의 오류 상태 플래그 값을 보존하지 않는다.

만일 인자를 넣어주지 않는다면 (혹은 인자로 `goodbit` 을 전달하면) 모든 오류 상태 플래그는 초기화된다.

현재의 오류 상태 플래그는 [ios::rdstate](http://itguru.tistory.com/171)함수로 얻을 수 있다.



###  인자

`state`

새롭게 바꿀 `ios_base::iostate` 타입의 객체로 아래의 오류 상태 멤버 상수들의 조합 (비트 OR 연산) 으로 구성된다.

|플래그 값|의미|
|-------|----|
|`eofbit`|스트림으로부터 추출 작업(extracting operation)을 수행 중 End Of File 에 도달하는 경우|
|`failbit`|마지막 입력 작업이 자체의 내부 오류 때문에 실패하였을 경우|
|`badbit`|스트림 버퍼의 입출력 작업이 실패하여 발생한 오류|
|`goodbit`|오류가 없다|

만일 인자로 아무 것도 전달하지 않는다면 디폴트 인자로 `goodbit` 가 전달된다.




###  리턴값



없음



###  실행 예제




```cpp-formatted
/*

test.txt 를 in 형식으로 open 하였으므로 읽기만 가능한다. 따라서 쓰기를 하면
오류가 발생하므로 myfile.fail() 이 true 가 되고 입출력 작업은 중지되지만 오류
상태 플래그를 초기화함으로써 나중에 getline 을 수행할 수 있게 된다.

이 예제는
http://www.cplusplus.com/reference/iostream/ios/clear/
에서 가져왔습니다.

*/
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  char buffer[80];
  fstream myfile;

  myfile.open("test.txt", fstream::in);

  myfile << "test";
  if (myfile.fail()) {
    cout << "Error writing to test.txt\n";
    myfile.clear();
  }

  myfile.getline(buffer, 80);
  cout << buffer << " successfully read from file.\n";

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F182B374B4F6E75AF1F5F53)




###  템플릿 멤버 정의





```cpp-formatted
(basic_ios<charT, traits>)

  void clear(iostate state = goodbit);
```




###  연관된 함수

*  [ios::fail](http://itguru.tistory.com/165)  :  `failbit` 이나 `badbit` 이 설정되어 있는지 확인한다.
*  [ios::bad](http://itguru.tistory.com/166)  :  `badbit` 이 설정되어 있는지 확인한다.
*  [ios::good](http://itguru.tistory.com/164) :  스트림에 어떠한 오류 플래그도 설정되지 않았는지 확인한다.
*  [ios::eof](http://itguru.tistory.com/167)  :  `eofbit` 이 설정되어 있는지 확인한다.
*  [ios::rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그를 얻는다.
Link :  179
2012-03-25 10:18
----------------
title : C++ 레퍼런스 - ios::setstate 함수
cat_title :  ios::setstate
ref_title : setstate
publish_date : 2012-03-25 10:18
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::setstate

```info
void setstate (iostate state);
```


오류 상태 플래그를 설정한다.
인자로 전달된 오류 상태 플래그와 현재의 오류 상태 플래그를 합친다. (비트 OR 연산을 수행한다) 따라서 `setstate` 함수는 현재 이미 켜져 있는 오류 비트는 끌 수 없다. 만일, 켜져 있는 오류 비트를 끄고 싶다면 `clear` 함수를 이용하여 현재 설정된 오류 상태 플래그 값을 모두 지우고 사용자가 새롭게 설정할 수 있다.

이 함수는

```cpp-formatted
clear(rdstate() | state);
```


를 하는 것과 동일하다고 볼 수 있다.



###  인자





`state`

`ios_base::iostate` 타입의 객체로 다음과 같은 멤버 상수들의 조합(비트 `OR` 연산) 으로 구성되어 있다.

|플래그 값|의미|
|-------|----|
|`eofbit`|스트림으로부터 추출 작업(extracting operation)을 수행 중 End Of File 에 도달하는 경우|
|`failbit`|마지막 입력 작업이 자체의 내부 오류 때문에 실패하였을 경우|
|`badbit`|스트림 버퍼의 입출력 작업이 실패하여 발생한 오류|
|`goodbit`|오류가 없다|


###  리턴값



없다



###  템플릿 멤버 정의





```cpp-formatted

(basic_ios<charT, traits>)void setstate(iostate state);
```




###  연관된 함수

*  [ios::fail](http://itguru.tistory.com/165)  :  `failbit` 이나 `badbit` 이 설정되어 있는지 확인한다.
*  [ios::bad](http://itguru.tistory.com/166)  :  `badbit` 이 설정되어 있는지 확인한다.
*  [ios::good](http://itguru.tistory.com/164):  스트림에 어떠한 오류 플래그도 설정되지 않았는지 확인한다.
*  [ios::eof](http://itguru.tistory.com/167)  :  `eofbit` 이 설정되어 있는지 확인한다.
*  [ios::rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그를 얻는다.
*  [ios::clear](http://itguru.tistory.com/180)  :  오류 상태 플래그를 설정한다.
Link :  171
2012-03-25 09:49
----------------
title : C++ 레퍼런스 - ios::rdstate 함수
cat_title :  ios::rdstate
ref_title : rdstate
publish_date : 2012-03-25 09:49
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::rdstate

```info
iostate rdstate ( ) const;

```

**오류 상태 플래그(error state flag)**를 얻어온다.

현재 스트림의 오류 상태 플래그를 리턴한다.

오류 상태 플래그는 입출력 함수를 호출할 때 발생하는 오류에 따라 자동으로 설정되는 플래그이다.



###  인자

없다



###  리턴값


`ios_base::iostate` 타입의 객체로, 아래 상태 플래그 상수들의 조합(OR 연산) 으로 구성된다.

|플래그 값|의미|
|-------|----|
|`eofbit`|스트림으로부터 추출 작업(extracting operation)을 수행 중 End Of File 에 도달하는 경우|
|`failbit`|마지막 입력 작업이 자체의 내부 오류 때문에 실패하였을 경우|
|`badbit`|스트림 버퍼의 입출력 작업이 실패하여 발생한 오류|
|`goodbit`|오류가 없다|

`goodbit` 을 제외한 다른 오류 플래그가 설정되어 있는지 확인하려면, 그 오류 플래그와 `AND` 연산을 취해보면 된다. 즉, `failbit` 가 설정되어 있는지 확인하려면 `rdstate` 가 리턴한 객체와 비트 `AND` 연산을 취해서 값이 1 이면 설정된 것이고 0 이면 `failbit` 가 설정되지 않은 것이다.

위 방법이 귀찮다면 그냥 [eof](http://itguru.tistory.com/167), [fail](http://itguru.tistory.com/165), [bad](http://itguru.tistory.com/166), [good](http://itguru.tistory.com/164)함수들을 이용해서 각각의 비트가 설정되었는지 아닌지 확인할 수 도 있다.



###  실행 예제





```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios/rdstate/
에서 가져왔습니다.

*/
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  ifstream is;
  is.open("test.txt");
  if ((is.rdstate() & ifstream::failbit) != 0)
    cerr << "Error opening 'test.txt'\n";
  return 0;
}
```


실행 결과

같은 디렉토리 내에 `test.txt` 가 없다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F193DD94F4F6E6A952D5EB7)




###  템플릿 멤버 정의





```cpp-formatted
(basic_ios<charT, traits>)iostate rdstate() const;
```




###  연관된 함수

*  [ios::fail](http://itguru.tistory.com/165)  :  `failbit` 이나 `badbit` 이 설정되어 있는지 확인한다.
*  [ios::bad](http://itguru.tistory.com/166)  :  `badbit` 이 설정되어 있는지 확인한다.
*  [ios::good](http://itguru.tistory.com/164):  스트림에 어떠한 오류 플래그도 설정되지 않았는지 확인한다.
*  [ios::eof](http://itguru.tistory.com/167)  :  `eofbit` 이 설정되어 있는지 확인한다.
*  [ios::clear](http://itguru.tistory.com/180)  :  오류 상태 플래그를 설정한다.
Link :  177
2012-03-24 23:04
----------------
title : C++ 레퍼런스 - STL 컨테이너 - list
cat_title :  list
path : /C++ Reference/Containers/list
publish_date : 2012-03-24 23:04
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ `list`

**리스트(list)** 는 헤더파일 `<list>` 에 정의된 순차 컨테이너의 한 종류로 원소들은 메모리 상에 선형으로 배열된다.

리스트 컨테이너는 보통 **이중 연결 리스트 (doubly linked list)**로 구현된다. 이중 연결 리스트를 이용하면 메모리 상의 임의의 위치에 원소를 저장하더라도 참조할 수 있게 된다. 왜냐하면 어떤 원소의 위치는 이전 원소와 다음 원소의 링크를 통해 따라서 추적해나갈 수 있기 때문이다.

덕분에 리스트는 아래와 같은 장점을 가진다.


*  컨테이너 임의의 위치에 원소의 삽입과 삭제가 가능하다 (상수 시간)

*  서로 다른 컨테이너 사이 나 컨테이너 내부에서 원소들 간의 이동이 매우 효율적이다. (상수 시간)

*  원소들을 앞에서 뒤로, 혹은 뒤에서 앞으로 참조해나갈 수 있다 (선형 시간)



다른 표준 순차 컨테이너 (`vector`, `deque`) 와 비교했을 때, 리스트는 원소의 삽입, 삭제, 그리고 컨테이너 내부에서의 원소들 간의 이동이 매우 효율적이다. 따라서 정렬 알고리즘 처럼 원소의 이동이 빈번하게 일어나는 곳에 적용하면 효율적이다. 특히 `list::sort` 함수와, 원소 이동 관련한 함수가 `list::splice` 가 기본적으로 제공되어서 편리하다.

하지만 리스트의 가장 큰 문제점은 원소들을 인덱스로 직접 참조하는 것이 비효율적이라는 것이다. 예를 들어서 리스트의 6 번째 원소를 참조하기 위해서는 리스트의 시작 부분으로 부터 링크를 하나씩 돌면서 찾아 나가야 한다.

뿐만 아니라, 링크 되는 다른 원소의 주소값을 보관해야 하기 때문에 추가적인 메모리가 사용된다는 것인데, 보관하는 원소에 크기가 작을 수 록 배보다 배꼽이 더 커지는 현상이 발생하게 된다. (원소의 주소값은 4 바이트인데, 보관하는 것은 1 바이트 원소라면 전체 메모리 사용의 `80%` 가 단순히 다음 원소의 주소값을 보관하는데 낭비된다)

다른 순차 컨테이너들 처럼 메모리 할당과 해제는 내부적으로 스스로 수행한다.

리스트는 C++ 표준 템플릿 라이브러리에서 아래와 같이 구현된다.

```cpp-formatted
template <class T, class Allocator = allocator<T> >
class list;
```


* `T` : (보관하려는) 원소의 타입

* `Allocator` : 어떠한 방식으로 메모리를 할당할지에 관련한 할당자(allocator) 타입을 나타낸다. 기본값으로 `T` 의 할당자 클래스 템플릿을 사용하며, `Heap` 에 할당하게 된다. 많은 경우 인자를 생략한다.


###  멤버 함수

* 생성자 : 리스트를 생성한다.

* 소멸자 : 리스트를 소멸한다.

* `operator=` : 리스트의 내용을 복사한다.


반복자

* `begin` : 시작 부분 (첫번째 원소) 을 가리키는 반복자를 리턴한다.



* `end` : 끝 부분 (마지막 원소 바로 다음) 을 가리키는 반복자를 리턴한다.

* `rbegin` : 역순으로 첫번째 (즉, 마지막 원소) 를 가리키는 반복자를 리턴한다.

* `rend` : 역순으로 끝 부분 (즉, 첫번째 원소 바로 이전) 을 가리키는 반복자를 리턴한다.



할당 관련 ([벡터](http://itguru.tistory.com/175)와는 다르게 `capacity` 와 `reserve` 가 없다!)

* `size` : 리스트의 `size` 를 리턴한다 (현재 원소의 개수)

* `max_size` : 리스트 최대 크기를 리턴한다.

* `resize` : 리스트가 `size` 개의 원소를 포함하도록 변경한다.

* `empty` : 리스트가 비었는지 체크한다.





임의 접근

* `front` : 첫번째 원소에 접근한다.

* `back` : 마지막 원소에 접근한다.





수정자 (Modifier)

* `assign` :
리스트
에 원소를 집어넣는다.

* `push_back` :
리스트
끝에 원소를 집어 넣는다.

* `push_front` :
리스트
맨 앞에 원소를 집어 넣는다.



* `pop_back` : 마지막 원소를 제거한다.



* `pop_front` : 첫번째 원소를 제거한다.



* `insert` :
리스트
중간에 원소를 추가한다.

* `erase` : 원소를 제거한다.

* `swap` : 다른
리스트
와 원소를 바꿔치기 한다.



* `clear` : 원소를 모두 제거한다.


특별한 작업들 (Operations)


* `splice` : 리스트와 리스트 사이에서 원소를 이동한다.

* `remove` : 특정 값을 지닌 원소를 삭제한다.


* `remove_if` : 특정 조건을 만족시 원소를 삭제한다.

* `unique` : 중복된 값을 삭제한다.


* `merge` : 정렬된 리스트를 합친다.

* `sort` : 컨테이너의 원소를 정렬한다.

* `reverse` : 원소들의 순서를 거꾸로 뒤집는다.



할당자


* `get_allocator` : 할당자(allocator) 을 얻는다.



###  멤버 변수들





* `reference` : `Allocator::reference`


* `const_reference` :  `Allocator::const_reference`


* `iterator` :  임의 접근 반복자(random access iterator)



* `const_iterator` : 상수 임의 접근 반복자 (즉, 접근하는 원소의 내용을 수정 못함)



* `size_type` : 리스트 `size` 를 나타내는 타입 (많은 경우 `size_t` 와 타입이 같으며 부호없는 정수이다)



* `difference_type` :
리스트
내의 두 원소 사이의 거리를 나타내는 타입 (많은 경우 `ptfdiff_t` 와 타입이 같으며 부호있는 정수)





* `value_type` : 원소 타입 (T)

* `allocator_type` : 할당자

* `pointer` : 포인터 (`Allocator::pointer`)

* `const_pointer` : 상수 포인터 (`Allocator::const_pointer`)

* `reverse_iterator` :  역 반복자 (끝에서 부터 참조해나간다) `reverse_iterator<iterator>`

* `const_reverse_iterator` :  상수 역 반복자 (`reverse_iterator<const_iterator>`)
Link :  176
2012-03-24 22:44
----------------
title : C++ 레퍼런스 - STL 컨테이너 - deque
ref_title : <deque>
cat_title :  deque
path : /C++ Reference/Containers/deque
publish_date : 2012-03-24 22:44
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ `deque`


양쪽에서 끝나는 큐 (Double ended queue) 로 `<deque>` 에 정의되어 있다.

흔히 줄여서 데크 ("deck") 로 발음된다. 보통의 스택(stack) 의 경우 최상단(top) 에서 삭제(pop) 과 삽입(push) 가 일어나고 반대쪽 (end) 에서는 아무것도 할 수 없다. 또한 큐(queue) 의 경우 한쪽에서는 삭제, 반대쪽에서는 삽입이 일어나지만, 삭제하는 쪽에서는 삽입을, 반대쪽에서는 삭제를 할 수 없다.

즉 스택의 경우 나중에 들어간 것이 먼저 나가는 `LIFO (Last In First Out)` 구조를, 큐의 경우 먼저 들어간 것이 먼저 나가는 `FIFO (First In First Out)` 구조를 취하가 된다. 데크의 경우 스택과 큐를 합친 것이라 볼 수 있으며, 즉, 양쪽 끝에서 삭제와 입력 모두 수행할 수 있게 된다.

다른 순차 컨테이너 처럼 데크에서도 데이터는 선형으로 메모리 상에 위치하게 된다.데크는 라이브러리 마다 다른 방식으로 구현되겠지만, 어떤 경우라도 각각의 원소는 임의 접근 반복자를 통해 접근할 수 있고, 크기 할당 역시 자동으로 수행되게 된다.

  데크는 아래과 같은 장점이 있다.


* 개개의 원소들은 각자의 인덱스 값을 통해 접근할 수 있다.

* 원소를 어떠한 방향으로도 참조해 나갈 수 (iterate) 있다.

* 데크 끝과 시작 부분에 효율적으로 원소를 추가하거나 삭제할 수 있다.


데크는 벡터( [vector](http://itguru.tistory.com/175)) 에서 제공하는 많은 기능을 제공해준다. 하지만, 데크의 경우 [벡터](http://itguru.tistory.com/175)와는 다르게 양쪽 끝 모두에서 원소의 효율적인 추가와 삭제가 가능하다. 하지만, [벡터](http://itguru.tistory.com/175)와는 달리 데크는 모든 원소가 메모리 상에 연속적으로 존재한다고 보장할 수 없다. 즉, 포인터 연산을 통해서 데크의 원소들을 안전하게 접근할 수 없다는 의미이다.


[벡터](http://itguru.tistory.com/175)와 데크 모두 비슷한 인터페이스를 제공하고 있지만, 내부적으로는 다르게 처리된다. [벡터](http://itguru.tistory.com/175)의 경우 `capacity` 가 꽉 찼을 경우 새롭게 크게 한 덩어리의 메모리를 할당하게 되지만, 데크의 경우메모리 상에서 잘게 쪼개어서 보관하게 된다. 물론, 데크 객체 자체에서 메모리에 쪼개져서 보관되는 덩어리들의 위치를 기억하고, 각각의 원소에 대해 접근할 수 있는 인터페이스를 제공해준다. 따라서 데크는 내부적으로 [벡터](http://itguru.tistory.com/175)의 비해 조금 더 복잡하게 구현되어 있지만 그 덕분에 [벡터](http://itguru.tistory.com/175)와는 달리 메모리 공간을 효율적으로 사용할 수 있게 된다. 뿐만 아니라 엄청나게 큰 데이터의 경우, 데크는 [벡터](http://itguru.tistory.com/175)와는 다르게 많은 양의 메모리 재할당을 하지 않기 때문에 좀더 빠르다고 볼 수 있다.

  처음과 끝 말고 중간에 원소의 삽입과 삭제를 빈번하게 사용한다면 데크 보다는 [리스트(list)](http://itguru.tistory.com/177)를 사용하는 것을 추천한다.

  C++ 표준 템플릿 라이브러리에서는 데크는 다음과 같은 두 개의 템플릿 인자를 받는다.

```cpp-formatted
template <class T, class Allocator = allocator<T> >
class deque;
```


* `T` : (보관하려는) 원소의 타입

* `Allocator` : 어떠한 방식으로 메모리를 할당할지에 관련한 할당자(allocator) 타입을 나타낸다. 기본값으로 `T` 의 할당자 클래스 템플릿을 사용하며, `Heap` 에 할당하게 된다. 많은 경우 인자를 생략한다.







###  멤버 함수






* 생성자 : 데크를 생성한다.

* 소멸자 : 데크를 소멸한다.

* `operator=` : 데크의 내용을 복사한다.


#### 반복자


* `begin` : 시작 부분 (첫번째 원소) 을 가리키는 반복자를 리턴한다.



* `end` : 끝 부분 (마지막 원소 바로 다음) 을 가리키는 반복자를 리턴한다.

* `rbegin` : 역순으로 첫번째 (즉, 마지막 원소) 를 가리키는 반복자를 리턴한다.

* `rend` : 역순으로 끝 부분 (즉, 첫번째 원소 바로 이전) 을 가리키는 반복자를 리턴한다.



#### 할당 관련 

참고로 [벡터](http://itguru.tistory.com/175)와는 다르게 `capacity` 와 `reserve` 가 없다!


* `size` : 데크의 `size` 를 리턴한다 (현재 원소의 개수)

* `max_size` : 데크 최대 크기를 리턴한다.

* `resize` : 데크가 `size` 개의 원소를 포함하도록 변경한다.

* `empty` : 데크가 비었는지 체크한다.


#### 임의 접근


* `operator[]` : 원소에 접근한다.

* `at` : 원소에 접근한다.

* `front` : 첫번째 원소에 접근한다.

* `back` : 마지막 원소에 접근한다.


#### 수정자 (Modifier)


* `assign` : 데크에 원소를 집어넣는다.

* `push_back` : 데크 끝에 원소를 집어 넣는다.

* `push_front` : 데크 맨 앞에 원소를 집어 넣는다.



* `pop_back` : 마지막 원소를 제거한다.
* `pop_front` : 첫번째 원소를 제거한다.
* `insert` : 데크 중간에 원소를 추가한다.

* `erase` : 원소를 제거한다.

* `swap` : 다른 데크와 원소를 바꿔치기 한다.



* `clear` : 원소를 모두 제거한다.


#### 할당자


* `get_allocator` : 할당자(allocator) 을 얻는다.





###  멤버 변수들


* `reference` : `Allocator::reference`


* `const_reference` :  `Allocator::const_reference`


* `iterator` :  임의 접근 반복자(random access iterator)



* `const_iterator` : 상수 임의 접근 반복자 (즉, 접근하는 원소의 내용을 수정 못함)



* `size_type` : 데크 `size` 를 나타내는 타입 (많은 경우 `size_t` 와 타입이 같으며 부호없는 정수이다)



* `difference_type` : 데크 내의 두 원소 사이의 거리를 나타내는 타입 (많은 경우 `ptfdiff_t` 와 타입이 같으며 부호있는 정수)





* `value_type` : 원소 타입 (T)

* `allocator_type` : 할당자

* `pointer` : 포인터 (`Allocator::pointer`)

* `const_pointer` : 상수 포인터 (`Allocator::const_pointer`)

* `reverse_iterator` :  역 반복자 (끝에서 부터 참조해나간다) `reverse_iterator<iterator>`

* `const_reverse_iterator` :  상수 역 반복자 (`reverse_iterator<const_iterator>`)
Link :  175
2012-03-24 22:07
----------------
title : C++ 레퍼런스 - STL 컨테이너 - vector
cat_title :  vector
path : /C++ Reference/Containers/vector
publish_date : 2012-03-24 22:07
--------------

```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ vector

**벡터(vector)** 는 헤더파일 `<vector>` 에 정의되어 있는 는 순차 컨테이너의 한 종류로, 각각의 원소들이 선형으로 배열되어 있다.

벡터 컨테이너는 동적 배열로 구현되는데, 보통의 배열 처럼 벡터 컨테이너들도 각각의 원소들이 메모리 상에서 연속적으로 존재하게 된다. 이 때문에 벡터 컨테이너의 원소를 참조할 때 반복자(iterator) 을 이용해서 순차적으로 참조할 수 있고, 처음 원소의 부터의 상대적인 거리를 이용하여 접근할 수 도 있다.

하지만, 보통의 배열과는 달리 벡터 컨테이너는 스스로 공간을 할당하고, 크기를 확장할 수 있고, 또 줄일 수 도 있다.

벡터 컨테이너는 아래와 같은 장점을 가지고 있다.

*  각각의 원소를 원소의 인덱스(index) 값으로 바로 참조 가능하다 (상수 시간이 소요)

*  원소들을 임의의 순서로 접근할 수 있다. (선형 시간 소요)

*  벡터 끝에 새로운 원소를 추가하거나 제거하기 (상수 시간 소요 - constant amortized time) \sidenote{동적 배열 끝에 새로운 원소를 추가하는 경우를 생각해보자. 만일 이미 공간 자체가 할당되어 있으면 새로운 원소를 추가하는 일은 O(1) 일 것이다. 하지만, 공간이 할당되어 있지 않다면, 보통 2 배의 공간으로 다시 할당하게 되는데 이 때 시간이 O(n) 정도 들어가게 된다. 따라서 전체 평균적으로 볼 때 O(1) 정도의 상수 시간이 걸린다고 볼 수 있고 이러한 형태의 소요 시간을 constant amortized time 이라고 부른다.}


벡터는 배열이 제공하는 거의 모든 기능을 다 가지고 있다. 게다가, 벡터 컨테이너의 크기는 쉽게 조정될 수 있기 때문에 매우 용이하다. 하지만 이러한 장점들 때문에 보통의 배열보다 더 많은 메모리 공간을 필요로 한다는 단점이 있다.

다른 표준 순차 컨테이너 ([deque](http://itguru.tistory.com/176), [list](http://itguru.tistory.com/177)) 와 비교해 볼 때, 벡터는 원소에 접근하는 시간이나, 컨테이너의 끝에 새로운 원소를 삽입/삭제 하는것이 매우 효율적이다. 반면에 끝이 아닌 중간에 새로운 원소를 삽입하는 작업은 [deque](http://itguru.tistory.com/176)나 [list](http://itguru.tistory.com/177)에 비해 느리다.

벡터 컨테이너는 내부적으로 공간을 관리하기 위해 두 개의 변수를 사용한다. 하나는 `size` 로 `vector::size` 함수를 통해서 그 값을 얻을 수 있는데, 이는 현재 벡터에 보관되어 있는 원소의 개수를 의미한다. 다른 하나는 `capacity` 로 `vector::capacity` 함수를 통해서 그 값을 얻을 수 있는데, 이는 벡터에 할당된 공간의 크기를 의미한다.

따라서 당연하게도, `capacity` 의 크기는 항상 `size` 보다 크게 조정되며, 만일 원소를 추가해서 `size` 의 크기가 `capacity` 를 넘어가 버리면 벡터 내부적으로 추가적인 공간을 할당하게 된다. 이 때 추가적으로 할당되는 공간은 많은 경우 현재 벡터 `capacity` 만큼 할당되어서 (즉, 전체 할당 크기가 이전의 두 배가 됨) 메모리 할당을 빈번하게 하는 경우를 최대한 줄이고, 사용하는 메모리 양도 줄이도록 최적화되어 있다.

벡터의 `capacity` 를 확장하는 작업은 꽤 많은 시간을 필요로 하는 작업이기 때문에 (왜냐하면 일단 메모리를 새로 할당해야 하고, 벡터의 내용을 새로운 장소에 복사해야 하기 때문) 많은 원소를 추가해야되는 경우 `vector::reserve` 함수를 이용해서 `capacity` 를 미리 크게 할당해 놓을 수 있다.

C++ 표준 템플릿 라이브러리 (STL) 에서는 벡터를 다음과 같이 두 개의 템플릿 인자를 가지도록 구현하였다.

```cpp-formatted
template <class T, class Allocator = allocator<T> >
class vector;
```


  이 때 각각의 템플릿 인자는 다음을 의미한다.

* `T` : (보관하려는) 원소의 타입

* `Allocator` : 어떠한 방식으로 메모리를 할당할지에 관련한 할당자(allocator) 타입을 나타낸다. 기본값으로 `T` 의 할당자 클래스 템플릿을 사용하며, `Heap` 에 할당하게 된다. 많은 경우 인자를 생략한다.





###  벡터의 멤버 함수



*  [생성자](http://itguru.tistory.com/178): 벡터를 생성한다.

* 소멸자 : 벡터를 소멸한다.

* `operator=` : 벡터의 내용을 복사한다.




반복자 (Iterators)


* `begin` : 시작 부분 (벡터의 첫번째 원소) 을 가리키는 반복자를 리턴한다.



* `end` : 끝 부분 (벡터의 마지막 원소 바로 다음) 을 가리키는 반복자를 리턴한다.

* `rbegin` : 역순으로 첫번째 (즉, 벡터의 마지막 원소) 를 가리키는 반복자를 리턴한다.

* `rend` : 역순으로 끝 부분 (즉, 벡터의 첫번째 원소 바로 이전) 을 가리키는 반복자를 리턴한다.




할당 관련


* `size` : 벡터의 `size` 를 리턴한다 (현재 원소의 개수)

* `max_size` : 벡터 최대 크기를 리턴한다.

* `resize` : 벡터가 `size` 개의 원소를 포함하도록 변경한다.

* `capacity` : 벡터에 할당된 전체 크기를 리턴한다.

* `empty` : 벡터가 비었는지 체크한다.

* `reserve` : 벡터에 할당된 크기를 변경한다.




원소 접근 관련


* `operator[]` : 원소에 접근한다.

* `at` : 원소에 접근한다.

* `front` : 첫번째 원소에 접근한다.

* `back` : 마지막 원소에 접근한다.




수정자 (Modifier)


* `assign` : 벡터의 원소를 집어넣는다.

* `push_back`: 벡터 끝에 원소를 집어 넣는다.

* `pop_back` : 마지막 원소를 제거한다.

* `insert$vector` : 벡터 중간에 원소를 추가한다.

* `erase` : 원소를 제거한다.

* `swap` : 다른 벡터와 원소를 바꿔치기 한다.



* `clear` : 원소를 모두 제거한다.




할당자


* `get_allocator` : 할당자(allocator) 을 얻는다.





###  멤버 변수들





* `reference` : `Allocator::reference`


* `const_reference` :  `Allocator::const_reference`


* `iterator` :  임의 접근 반복자(random `access iterator)`



* `const_iterator` : 상수 임의 접근 반복자 (즉, 접근하는 원소의 내용을 수정 못함)



* `size_type` : 벡터 `size` 를 나타내는 타입 (많은 경우 `size_t` 와 타입이 같으며 부호없는 정수이다)



* `difference_type` : 벡터 내의 두 원소 사이의 거리를 나타내는 타입 (많은 경우 `ptfdiff_t` 와 타입이 같으며 부호있는 정수)





* `value_type` : 원소 타입 (T)

* `allocator_type` : 할당자

* `pointer` : 포인터 (`Allocator::pointer`)

* `const_pointer` : 상수 포인터 (`Allocator::const_pointer`)

* `reverse_iterator` :  역 반복자 (끝에서 부터 참조해나간다) `reverse_iterator<iterator>`

* `const_reverse_iterator` :  상수 역 반복자 (`reverse_iterator<const_iterator>`)


###  템플릿 특수화 (template specialization)

벡터 템플릿 클래스는 특별히 `bool` 타입에 대한 템플릿 특수화(specialization)를 가지고 있다.

`bool` 만 특별하게 특수화 시킨 이유는 메모리 공간을 최적화 하기 위해 `bool` 원소가 한 개의 비트만 사용하도록 설계하였기 때문이다. (C++ 에서 최소 자료형의 크기는 8 비트 이다 - 즉 실제 bool 객체는 8 비트를 차지한다. )

따라서 `bool` 원소의 레퍼런스는 `bool&` 가 아니라, 아래와 같이 `vector<bool>` 에 특별히 정의되어 있는 멤버 변수를 통해 `vector<bool>` 의 단일 비트에 대한 조작을 수행할 수 있게 된다.


```cpp-formatted
class vector<bool>::reference {
  friend class vector;
  reference();  // public 생성자가 아니다
 public:
  ~reference();
  operator bool() const;                     // bool 로 캐스팅 한다.
  reference& operator=(const bool x);        // bool 을 대입
  reference& operator=(const reference& x);  // 비트로 대입
  void flip();  // 비트값 반전 (0 -> 1, 1 -> 0)
}
```

이와 비슷한 컨테이너로 `bitset` 이 있다.
Link :  174
2012-03-24 01:04
----------------
title : C++ 레퍼런스 - STL 컨테이너 (STL Container)
cat_title :  STL 컨테이너 (STL Container)
path : /C++ Reference/Containers
publish_date : 2012-03-24 01:04
--------------

```info
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 '[저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

### STL 컨테이너 (STL Container)

**컨테이너(Container)**는 다른 객체들을(원소) 보관하는 하나의 커다란 **보관소**라고 볼 수 있다. 특히, STL 컨테이너는 클래스 템플릿(class template) 의 형태로 구현되어 있기 때문에 임의의 타입의 원소들을 위한 컨테이너를 만들 수 있다. **물론 한 컨테이너에는 한 가지 종류의 객체들만 보관할 수 있다**

![컨테이너](/img/container.jpg)

컨테이너는 자신이 보관하는 원소(element)들의 메모리를 관리하며, 각각의 원소에 접근할 수 있도록 멤버 함수를 제공해준다. 컨테이서 상에서 원소에 접근하는 방법으로 크게 두 가지가 있는데, 하나는 직접 함수를 호출해서 접근하는 것이고, 다른 하나는 반복자(iterator) 을 이용해서 접근하는 것이다. 이에 관해서는 나중에 설명하도록 하겠다.

[시퀀스 컨테이너(vector, list, deque)에 대한 자세한 설명을 보려면 여기를 클릭](http://itguru.tistory.com/223)!


또한 표준 라이브러리에서는, 여러가지 형태의 컨테이너를 제공하고 있기에, 프로그래머가 자신의 상황에 적합한 컨테이너를 고를 수 있다. 예컨대 동적 배열(`vector`), 큐(`queue`), 스택(`stack`), 힙(`priority_queue`), 링크드 리스트 (`list`) 트리 (`set`), 연관 컨테이너 (`map`) 등등이 지원되고 있다.

[연관 컨테이너(set, map, multiset, multimap,](http://itguru.tistory.com/224)[unordered_set, unordered_map) 에 대한 자세한 설명을 보려면 여기를 클릭](http://itguru.tistory.com/223)!

한 가지 유의할 사항은 스택(`stack`), 큐(`queue`), 우선순위 큐(`priority_queue`) 들로 이들은 **컨테이너 어댑터(container adaptor)** 이다. 이들은 다른 컨테이너 클래스들을 상속 받아서 다른 컨테이터 클래스의 객체에 특정한 인터페이스를 제공해준다. 

이를 통해 원래 컨테이너의 기능을 제한하고, 어댑터가 제공하는 인터페이스를 사용할 수 있게 된다. 예컨대 `stack` 이 [deque](http://itguru.tistory.com/176)  에 작용한다면, [deque](http://itguru.tistory.com/176)에 `stack` 이 제공하는 `top, pop, push` 등의 인터페이스를 사용할 수 있게 되는 것이다.



### 컨테이너 클래스 템플릿


#### 순차 컨테이너 (Sequence Container)


*  [vector](http://itguru.tistory.com/175):  벡터 (Vector)


*  [deque](http://itguru.tistory.com/176):  데크 (double ended queue)


*  [list](http://itguru.tistory.com/177): 리스트 (List)


#### 컨테이너 어댑터 (Container Adaptor)


* `stack` : `LIFO (Last in First out)` 스택


* `queue` : `FIFO (First in First out)` 큐


* `priority_queue` : 우선순위 큐 (Priority queue)


#### 연관 컨테이너


* `set` : `Set`


* `multiset` : 여러 키를 가지는 `set`


* `map` : `Map`


* `multimap` : 여러 키를 가지는 `map`


* `bitset` :  `Bitset`
Link :  172
2012-02-29 13:56
----------------
title : 씹어먹는 C++ - <4 - 1. 이 세상은 객체로 이루어져 있다>
cat_title: 4 - 1. 이 세상은 객체로 이루어져 있다
next_page : 173
publish_date : 2012-02-29 13:56
--------------


이번 강좌에서는
* 객체 지향 프로그래밍의 도래


* 객체란 무엇인가, 클래스란 무엇인가



* 접근 지시자 (public, private)

![](/img/ChewingCpplogo.png)


안녕하세요 여러분~ 그간 침묵을 깨고 오래간만에 C++ 강좌를 이어 나가고자 합니다. 앞선 3 강을 읽으셨던 분들은 다 느껴셨겠지만 기존의 C 언어를 통해서 대형 프로젝트를 개발하기 위해서는 많은 어려움들이 있기 마련입니다. (그래도 아직도 많은 수의 프로그램이 C 로 쓰여지고 있습니다)

사실 컴퓨터 프로그래밍 언어는 이러한 난관을 뚫고서 발전해 나갔습니다. 초기의 컴퓨터는 이름만 들어도 유명한 에니악(ENIAC) 과 같이 거대한 크기를 자랑하였습니다. 이러한 컴퓨터를 어떻게 프로그래밍 했냐고요?  아래 사진 오른쪽에 보이는 수 많은 진공관들 사이의 전선 연결을 바꾸어 가며 전기 신호를 전달했다고 합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F204144494F4CB9F1063F09)

즉, 우리가 컴퓨터 상에서 소스 코드를 치는 것을 직접 손으로 조작했다고 보시면 됩니다. 정말로 끔찍한 일이 아닐 수 없지요. 이것을 '컴퓨터 언어 '라고 보기에는 조금 무리가 있을 것 같습니다. 아무튼 진공관 상에서 단순한 전선 연결 배치로 명령을 했던 언어가 1 세대 컴퓨터 언어 입니다. 참고로 위 그림 아래에 써있는 말이 무슨 말이냐면, 이와 같이 '컴퓨터 프로그래밍' 을 수행하였는데 어딘 가에서 오류가 났을 때 어떠한 진공관이 고장났다는 의미인데 (아니면 전선 배치를 잘못했거나), 이를 수정하기 위해서 19000 여개의 달하는 진공관들을 확인해야 했다고 하네요.

1950 년대 이후 컴퓨터 내장 메모리가 만들어지고, 실질적으로 '컴퓨터 프로그래밍' 을 할 수 있게 되자, 2 세대 컴퓨터 언어가 등장하였는데요, 가장 첫번째로 나온 것이 어셈블리어 (Assembly language) 입니다. 언어라고 하기에 보다는 컴퓨터에 직접 명령을 내리는 기계어 (0 과 1 로 이루어짐) 에 사람들이 보기 쉽게 문자열을 대응 시킨 것에 가까운 형태였습니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2051944F4F4CBBEB1E6EF9)

위 그림은 `IBM PC` 어셈블리어로 쓰여진 것을 캡쳐한 것입니다. 어셈블리어는 말그대로 기계어와 1 : 1 대응 되어 있기 때문에, 할 수 있는 동작이 매우 단순합니다. 즉, 우리가 "`1 + 1` 을 계산해봐!" 라고 C 언어에서 쉽게 말하는 것을 어셈블리어에서는 "음, 1 을 어디에 저장하고, 또 1 을 어디에 저장하고, 이제 `CPU` 에 메모리 어디에서 1 을 불러오고, 또 `CPU` 에 메모리 어디에서 1 을 불러오고, 이들에 덧셈을 수행해!" 라고 말하는 것과 동일한 것입니다.

참으로 노가다가 아닐 수 없지요. 위  캡쳐한 사진도 사실 보면, 어떠한 값이 97 과 122 사이에 있다면 32 를 빼라는 의미 인데, 이를 일일히 지정하고 있는 것을 볼 수 있습니다. 여기까지의 컴퓨터 언어는 저급 언어 (Low level) 이라 부르며, 수준이 낮다는 것이 아니라, 조금더 기계어에 근접해 있다는 것을 의미합니다. 그리고, 이 때부터 초보적인 수준의 고급 언어(High level) 가 등장하게 되었는데, 은행과 같은 금융 쪽에서 많이 쓰였던 `COBOL` 이나, 수치 계산용으로 쓰이는 `FORTRAN` 이 등장하게 됩니다. 그리고 꽤나 쉬운 언어였던 `BASIC` 도 한 몫 하게 되지요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1553D8494F4CC0640CD2EA)

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F17758B4E4F4CC0A1277867)

위의 `FORTRAN` 코드를 살작 보면 알겠지만 어셈블리어를 통해서는 매우 복잡한 명령 (예를 들어서 화면에 출력한다던지) 을 단순하게 처리하고 있음을 알 수 있습니다. 이런 2 세대 초기의 언어들은 어셈블리어에 비해서는 획기적인 발전이 있을 수 있었습니다. 하지만 문제는 데이터 타입이나, 프로그램 문법 구조가 완전하지가 않아서 복잡한 데이터 타입을 단순히 모두 배열로 처리한다던지, 논리 구조를 모두 `goto` 문으로 처리한다던지의 문제가 있었습니다.

이렇게 하게 되면 오류가 발생하여도 찾기가 굉장히 힘든, 소위 말하는 스파게티 코드가 만들어지지요. 스파게티코드란, 스파게티 처럼 프로그램의 논리 구조가 뒤엉킨 상태를 의미합니다. 그래서 유명한 컴퓨터 과학자 다익스트라 (Dijkstra) 가 "Go to statement considered harmful" 이라는 유명한 글을 남기게 됩니다. 아무튼 이 때문에 조금 더 체계적인 프로그래밍 언어가 크게 필요로 해졌습니다.

그래서 짠하고 나타난 것이 3 세대 프로그래밍 언어, 절차 지향 언어 (Procedural programming language) 라고 불리는 파스칼(Pascal) 언어와 그 뒤를 이어서 C 언어가 등장하게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F14209E394F4CC276266FCE)

위 그림은 파스칼 언어로, 우리가 지금 아는 C 언어와 상당히 유사합니다. 함수라는 개념이 완성되었고, (이전에도 있었지만 불완전한 면이 있었다), 변수의 타입 (위 그림의 `var` 부분을 보면 알 수 있지만 정수형, 문자열 등등) 이 정립되어서 기존의 배열을 남발하던 것에서 벗어날 수 있게 됩니다.

절차(?) 를 지향한다라는 말이 이해가 잘 안가실 텐데, 영어로 보면, `Procedure` 를 지향하는 언어, 즉 프로시져 (함수) 를 지향한다는 것입니다. 다시 말해 프로그램을 설계할 때 중요한 부분을 하나의 프로시져로 만들어서 쪼개어 처리한다는 것입니다. 물론 기존의 언어들에서도 프로시져라는 것은 존재하였지만, 함수의 인자와 같은 개념이 없었고, 비로소 이 때야 완전한 함수 라는 것이 만들어지게 되는 것입니다.

그렇게 해서 절차 지향 언어로 몇십년을 버텨왔습니다. 그러나, 프로그램의 크기가 예전보다 상상도 할 수 없을 만큼 거대해 지자 새로운 패러다임이 필요하게 되었는데요, 그것이 바로 **객체 지향 언어(Object oriented language)** 입니다. 이를 사용하는 언어는 C++ 을 비롯한 Java, Python, C# 등등 아마 90년대 이후에 생긴 언어들은 대부분 객체 지향 언어 일 것입니다.



###  객체란?

그럼, 절차 지향적 언어의 뭐가 부족해서 였는지 객체 지향 언어를 필요로 하게 된 것일까요? 먼저 지난 강좌의 `Animal` 구조체를 가져와서 살펴 봅시다. 우리는

```cpp-formatted
typedef struct Animal {
  char name[30];  // 이름
  int age;        // 나이

  int health;  // 체력
  int food;    // 배부른 정도
  int clean;   // 깨끗한 정도
} Animal;
```

위와 같이 `Animal` 구조체를 정의한 후, `animal` 변수를 만들어서 이를 필요로 하는 함수들에게

```cpp-formatted
play(list[play_with]);
```


이와 같이 전달해 주었습니다. 그런데, 곰곰히 생각해 보면 `Play` 함수에 인자로 전달하는 것이 매우 불필해보입니다. 이 상황을 그림을 생각하면, 마치 [러시아식 유머](http://uncyclopedia.kr/wiki/%EB%9F%AC%EC%8B%9C%EC%95%84%EC%8B%9D_%EC%9C%A0%EB%A8%B8) 처럼 "`Play` 가 `Animal` 을 합니다!" 라고 볼 수 있는데, 사실은 "`Animal` 이 `Play` 를 한다" 가 더 맞기 때문이지요.

다시 말해서 `Animal` 자체가 `Play` 를 하는 것이지, `Play` 가 `Animal` 을 해주는 것이 아닙니다. 만일 `Animal` 자체가 `Play` 를 한다 라는 개념을 생각하게 된다면, 다음과 같이 생각할 수 있을 것입니다.

```cpp-formatted
Animal animal;

// 여러가지 초기화 (생략)

animal.play();   // 즉 내가 (animal 이) Play 를 한다!
animal.sleep();  // 내가 sleep 을 한다!
```

이렇게 하면 `play` 함수에 `animal` 을 인자로 주지 않아도 됩니다. 왜냐하면 내가 `play` 하는 것이기 때문에 내 정보는 이미 `play` 함수가 다 알고 있기 때문입니다. `play` 함수는 나의 상태들, 예를 들어서 체력이나, 배고픔 정도나 피곤한 정도 등을 모두 알 수 있기 때문에 나에 대한 적절한 처리를 할 수 있게 되는 것입니다. 즉, `animal` 은 자신의 상태를 알려주는 변수(variable) 과, 자신이 하는 행동들 (play, sleep 등등) 을 수행하는 함수(method) 들로 이루어졌다고 볼 수 있습니다.

결과적으로 객체는 다음과 같이 정의됩니다.

객체란, 변수들과 연관된 함수들로 이루어진 소프트웨어 덩어리 이다.

이 때 객체가 현실 세계에서의 존재하는 것들을 나타내기 위해서는 **추상화(abstraction)** 라는 과정이 필요합니다. 컴퓨터 상에서 현실 세계를 100% 나타낼 수 없는 것이기 때문에, 적절하게 컴퓨터에서 처리할 수 있도록 바꾸는 것인데, 예를 들어서 핸드폰의 경우 '전화를 한다', '문자를 보낸다' 와 같은 것들은 '핸드폰이 하는 것' 이므로 함수로 추상화시킬 수 있고,핸드폰의 상태를 나타내는 것들, 예를 들어서 자기 자신의 전화 번호나 배터리 잔량 같은 것은변수로 추상화시킬 수 있습니다.

아래 그림은 흔히 객체를 나타내기 위한 그림 입니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2012E33F4F4CCAF12C29D8)
http://journals.ecs.soton.ac.uk/java/tutorial/java/objects/object.html에서 인용하였습니다.

이와 같이 어떠한 객체는 자기 만의 정보를 나타내는 변수들과, 이를 가지고 어떠한 작업을 하는 함수들로 둘러싸고 있다고 보시면 됩니다. 참고로, 이러한 객체의 변수나 함수들을 보통 **인스턴스 변수(instance variable)** 와 **인스턴스 메소드(instance method)** 라고 부르게 되는데, 그냥 알고 계시는 변수와 함수와 동일한 것으로 생각하시면 됩니다. 누군가 인스턴스 메소드라고 하면 "아 그냥 객체에 정의되어 있는 함수구나" 라고 생각하시면 됩니다.

그림을 메소드가 변수들을 감싸고 있는 것 처럼 그리는 이유는 진짜로 변수들이 외부로 부터 '보호' 되고 있기 때문입니다. 다시 말해, 외부에서 어떠한 객체의 인스턴스 변수의 값을 바꾸지 못하고오직 객체의 인스턴스 함수를 통해서만 가능하다는 것이지요 (물론 항상 이렇게 극단적으로 불가능 한 것은 아니고 사실 사용자가 조절할 수 있습니다) 이를 단순히 코드로 표현한다면, 예컨대 `Animal` 의 `food` 를 바꾼다고 할 때

```cpp-formatted
Animal animal;
// 초기화 과정 생략

animal.food += 100;         // --> 불가능
animal.increase_food(100);  // --> 가능
```


이렇게 된다는 것입니다. 일단 `animal.food +=` 100; 자체는 외부에서 `animal` 이라는 '객체' 의 '인스턴스 변수' 에 '직접' 접근하는 것이기 때문에 불가능한 것이고, 아래의 `animal.increase_food(100);` 의 경우 `animal` 객체의 '인스턴스 함수' 를 통해서 값을 수정하는 것이기 때문에가능한 것이지요. 이와 같이 외부에서 직접 인스턴스 변수의 값을 바꿀 수 없고 항상 인스턴스 메소드를 통해서 간접적으로 조절하는 것을 **캡슐화(Encapsulation)** 라고 부릅니다.

이 개념을 처음 들었을 때 이게 왜 필요하냐고 생각하시는 분들이 많습니다. 저도 캡슐화를 굳이 해야될 이유를 못찼었거든요. 그냥, `animal.food += 100;` 하나 `animal.increase_food(100);` 하나 거기서 거기이지 라는 생각을 말이죠.

일단 여기서는 캡슐화의 장점에 대해서는 나중에 설명하겠지만 간단하게 말하자면, "객체가 내부적으로 어떻게 작동하는지 몰라도 사용할 줄 알게 된다" 라고 볼 수 있습니다. 예컨대 `animal.increase_food(100);` 을 하면 내부적으로 `food` 변수 값이 100 증가하는것 뿐만이 아니라 몸무게도 바뀔 수 있고, 행복도도 올라갈 수 있고 등등 여러가지 작업들이 일어나겠지요. 만일 `increase_food` 함수를 사용하지 않았다면

```cpp-formatted
animal.food += 100;
animal.weight += 10;
//... 여러가지 처리
```


여러가지 처리를 프로그래머가 직접 해주어야 합니다. 하지만 이것은 프로그래머가 `food` 를 100 늘리는 과정에서 정확히 어떠한 일들이 일어나는지 알아야지만 가능하다는 것입니다. 이는 상당히 피곤한 작업이겠지요. 더군다나, 대형 프로젝트에서는 객체들을 한 사람이 설계하는 것이 아니기 때문에 다른 사람이 작성한 것을 읽고 완벽히 이해해야만 합니다. 짜증나는 일이 겠지요. 하지만 인스턴스 메소드를 이용하면 "`food` 를 늘리려면 `increase_food` 를 이용하세요~ (나머지는 우리가 다 알아서 할께요)" 라는 것만 알아도 `increase_food(100)` 해버리면, 객체 내부적으로 알아서 처리되기 때문에 이를 사용하는 프로그래머가 굳이 이해하지 않아도 됩니다.

"내부적으로 어떻가 처리되는지는 알 필요가 없다!" 라는 말이 조금 못마땅 하다고 생각하시는 분들이 있을 것입니다. 사람이 그렇게 무책임 해서도 되나 말이죠. 하지만 곰곰히 생각해보면 우리가 접하는 모든 전자 기기들은 캡슐화 되어 있다고 볼 수 있습니다. 노트북의 경우도, 화면에 글자 'a' 를 띄우기 위해서 우리는 컴퓨터 내부에서 어떠한 연산이 처리되는지 알 필요 없습니다. 단순히 우리가 하는 일은 '키보드의 a 를 누른다' 라는, 마치 `my_computer.keyboard_hit('a');` 라는 메소드를 호출하는 것과 동일한 작업이지요. 만일 노트북이 캡슐화 되어 있지 않다면요? 그건 여러분의 상상에 맡기겠습니다.



###  클래스


자 그러면 객체는 C++ 상에서 어떻게 만들어낼까요. 이를 위해 C++ 에서 객체를 만들 수 있는 장치를 준비하였습니다. 쉽게 말하면 객체의 '설계도' 라고 볼 수 있지요. 바로 클래스(class) 입니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F16603A484F4D993B0DC2A3)

위와 같이 안의 내용은 차있지 않고 빈 껍질로만 생각할 수 있습니다. 그리고 우리는 이 객체의 설계도를 통해서 실제 객체를 만들게 되지요. C++ 에서 이와 같이 클래스를 이용해서 만들어진 객체를 인스턴스(instance) 라고 부릅니다. 앞서 객체의 변수와 메소드를 왜 인스턴스 변수와 인스턴스 메소드라고 했는지 아시겠죠?

```cpp-formatted
#include <iostream>
using namespace std;

class Animal {
 private:
  int food;
  int weight;

 public:
  void set_animal(int _food, int _weight) {
    food = _food;
    weight = _weight;
  }
  void increase_food(int inc) {
    food += inc;
    weight += (inc / 3);
  }
  void view_stat() {
    cout << "이 동물의 food   : " << food << endl;
    cout << "이 동물의 weight : " << weight << endl;
  }
};  // 세미콜론 잊지 말자!

int main() {
  Animal animal;
  animal.set_animal(100, 50);
  animal.increase_food(30);

  animal.view_stat();
  return 0;
}
```


성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F1324C5384F4D9B8B374245)


 와 같이 나오게 됩니다. 새로운 개념들이 왕창 많이 등장했으니 코드를 천천히 살펴봅시다.

```cpp-formatted
Animal animal;
```

먼저 `main` 함수에서 `Animal` 클래스의 인스턴스를 어떻게 생성하였는지 살펴 봅시다. 기존의 구조체에서 구조체 변수를 생성할 때와 동일한데, 구조체의 경우 앞에 `struct` 를 명시 했어야 했지만 여기서는 그러지 않아도 됩니다. 그냥 `int` 나 `char` 처럼 `Animal` 이라고 써주면 됩니다. 이와 같이 `Animal animal;` 을 했으면 `Animal` 클래스의 인스턴스 `animal` 을 만들게 된 것이지요. 이제 본격적으로 클래스가 어떻게 되어 있는지 살펴봅시다.

```cpp-formatted
class Animal {
 private:
  int food;
  int weight;

 public:
  void set_animal(int _food, int _weight) {
    food = _food;
    weight = _weight;
  }
  void increase_food(int inc) {
    food += inc;
    weight += (inc / 3);
  }
  void view_stat() {
    cout << "이 동물의 food   : " << food << endl;
    cout << "이 동물의 weight : " << weight << endl;
  }
};
```


위는 `Animal` 이라는 클래스를 나타낸 것으로 `Animal` 클래스를 통해서 생성될 임의의 객체에 대한 설계도라고 볼 수 있습니다. 즉, `Animal` 클래스를 통해서 생성될 객체는 `food, weight` 라는 변수가 있고, `set_animal, increase_food, view_stat` 이라는 함수들이 있는데, `Animal` 클래스 상에서 이들을 지칭할 때 각각 **멤버 변수(member variable) 과 멤버 함수(member function)** 라고 부릅니다.

즉, 인스턴스로 생성된 객체에서는 인스턴스 변수, 인스턴스 함수, 그리고 그냥 클래스 상에서는 멤버 변수, 멤버 함수 라고 부르는 것입니다. 멤버 변수와 멤버 함수는 실재 하는 것이 아니지요. 인스턴스가 만들어져야 비로소 세상에 나타나는 것입니다. 즉, 설계도 상에 있다고 해서 아파트가 실제로 존재하는 것이 아닌 것 처럼 말이지요.

```cpp-formatted
private:
int food;
int weight;
```

먼저 멤버 변수들을 정의한 부분을 봅시다. 처음 보는 키워드가 있지요? 이러한 키워드를 '접근 지시자' 라고 하는데,외부에서 이러한 멤버들에 접근을 할 수 있냐 없냐를 지시해주는 것입니다. `private` 키워드의 경우, 아래에 쓰여진 것들은 모두 객체 내에서 보호되고 있다 라는 의미이지요. 즉, 앞서 객체 그림을 떠올리면 멤버 변수들이 안에서 보호 받고 있던 것 기억하시죠? `private` 되고 있는 모든 것들은 자기 객체 안에서만 접근할 수 있을 뿐 객체 외부에서는 접근할 수 없게 됩니다. 다시 말해

```cpp-formatted
void set_animal(int _food, int _weight) {
  food = _food;
  weight = _weight;
}
```


와 같이 같은 객체 안에서 `food` 와 `weight` 에 접근하는 것은 가능한 일이지만

```cpp-formatted
int main() {
  Animal animal;
  animal.food = 100;
}
```


처럼 객체 밖에서 인위적으로 `food` 에 접근하는 것은 불가능 하다는 것입니다. (실제로 컴파일 해보면 오류가 발생합니다) 반면에 `public` 키워드의 경우,

```cpp-formatted
public:
void set_animal(int _food, int _weight) {
  food = _food;
  weight = _weight;
}
void increase_food(int inc) {
  food += inc;
  weight += (inc / 3);
}
void view_stat() {
  cout << "이 동물의 food   : " << food << endl;
  cout << "이 동물의 weight : " << weight << endl;
}
```


이와 같이 멤버 함수들을 `public` 으로 지정하였습니다. `public` 이라는 것은 말 그대로 공개된 것으로 외부에서 마음껏 이용할 수 있게 됩니다. 그래서 `main` 함수에서도 이들을

```cpp-formatted
animal.set_animal(100, 50);
animal.increase_food(30);
animal.view_stat();
```


처럼 마음껏 접근할 수 있었습니다. 만일 멤버 함수들을 `private` 로 설정해버렸다면 어떨까요. `public` 키워드를 지워봅시다.

그냥 컴파일 해보면

```warning
'Animal::set_animal' : cannot access private member declared in class 'Animal'
```


위와 같은 오류가 3 개 정도 등장하게 됩니다. 다시 말해, `Animal` 의 `private` 멤버 함수에 접근할 수 없다는 의미겠지요. 결과적으로 외부에서 접근을 할 수 없는 객체는 그냥 아무짝에도 쓸모 없는 덩어리로 남게 됩니다.

참고로 키워드 명시를 하지 않았다면 기본적으로 `private` 로 설정됩니다. 즉, 맨 위의 `private` 키워드를 지워도 상관이 없다는 것이지요. 그냥 `private` 없이

```cpp-formatted
class Animal {
  int food;
  int weight;
  // ... 생략
```


이렇게 해도 `food` 와 `weight` 는 알아서 `private` 로 설정 됩니다.

만일 멤버 변수들도 `public` 으로 공개해버리면 어떨까요. 그러면 `main` 함수에서 마치 예전에 구조체를 사용했던 것 처럼

```cpp-formatted
animal.food = 100;
```


로 손쉽게 접근할 수 있게 됩니다. 이제 멤버 변수에 대해 조금 더 자세히 살펴 보도록 합시다.

```cpp-formatted
void set_animal(int _food, int _weight) {
  food = _food;
  weight = _weight;
}
```


위는 각 멤버 변수들의 값을 설정하는 부분인데요, 여기서 `food` 와 `weight` 는 누구의 것일까요? 당연하게도, 객체 자신의 것입니다. 그렇기 때문에 `food` 와 `weight` 가 누구 것인지 명시할 필요 없이 그냥 `food, weight` 라고 사용하면 됩니다. `set_animal` 을 호출한 객체의 `food` 와 `weight` 값이기 때문이지요. 마찬가지로 `increase_food` 를 살펴보면

```cpp-formatted
void increase_food(int inc) {
  food += inc;
  weight += (inc / 3);
}
```


이와 같이 얼마나 `food` 를 증가시킬 지 입력 받은 다음에 내부적으로 `food` 와 `weight` 를 모두 처리해주게 됩니다.

이번 강좌는 여기서 마치도록 하겠습니다. 한 가지 꼭 기억하실 점은, 객체가 무엇인지, 그리고 클래스가 무엇인지 꼭 명심해 두시기 바랍니다. 또 앞으로 계속 나올 인스턴스, 인스턴스 변수, 인스턴스 함수, 멤버 변수, 멤버 함수 와 같은 용어들을 잘 파악하고 있어야지 뒤에가서 헷갈리지 않겠죠.

### 생각 해볼 문제

#### 문제 1

여러분은 아래와 같은 `Date` 클래스를 디자인 하려고 합니다. `set_date` 는 말그대로 `Date` 함수 내부를 초기화 하는 것이고 `add_day, add_month, add_year` 는 일, 월, 년을 원하는 만큼 더하게 됩니다. 한 가지 주의할 점은 만일 2012 년 2 월 28 일에 3 일을 더하면 2012 년 2 월 31 일이 되는 것이 아니라 2012 년 3 월 2 일이 되겠지요? (난이도 : 上)

```cpp-formatted
class Date {
  int year;
  int month;
  int day;

 public:
  void set_date(int _year, int _month, int _day) {}
  void add_day(int inc) {}
  void add_month(int inc) {}
  void add_year(int inc) {}
  void get_date() {}
};
```

##@ chewing-cpp-end
Link :  170
2012-01-01 21:16
----------------
title : C++ 레퍼런스 - ios::operator void*
cat_title :  ios::operator void*
publish_date : 2012-01-01 21:16
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::operator `void*`

```info
operator void * ( ) const;
```


포인터로 변환한다. (형 변환 연산자 이다)
`ios` 로 부터 얻어진 스트림 객체는 포인터로 캐스팅 될 수 있다. 만일 오류 플래그 (error flag - failbit 혹은 badbit) 중 어느 하나가 설정된다면 포인터는 `NULL` 포인터가 되고, 아니면 `NULL` 이 아닌 포인터가 된다.

리턴된 포인터는 다른 어떤 변수를 가리키는 것이 아니고 단순히 오류 플래그가 설정되었는지, 아닌지만 알려주는 역할을 한다.



###  인자




없다



###  리턴값




만일 `failbit` 이나 `badbit` 이 설정되어 있으면 `NULL` 포인터를 리턴하고 아니면 `NULL` 포인터가 아닌 것을 리턴한다.



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios/operator_voidpt/
에서 가져왔습니다.

*/
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  ifstream is;
  is.open("test.txt");

  if ((void*)is == 0) cerr << "Error opening 'test.txt'\n";

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F202325454F004D441E9371)



###  템플릿 멤버 정의




```cpp-formatted
(basic_ios<charT, traits>)operator void*() const;
```




###  연관된 것들

*  [ios::fail](http://itguru.tistory.com/165)  :  `failbit` 나 `badbit` 이 설정되었는지 확인한다.
*  [ios::operator!](http://itguru.tistory.com/168):  스트림 객체를 확인한다.
Link :  169
2012-01-01 20:53
----------------
title : 씹어먹는 C++ - <3. C++ 의 세계로 오신 것을 환영합니다. (new, delete)>
cat_title: 3. C++ 의 세계로 오신 것을 환영합니다. (new, delete)
next_page : 172
publish_date : 2012-01-01 20:53
--------------


이번 강좌에서는

* `new` 와 `delete` 의 사용

* **Welcome to Object Oriented Programming World!**
  
![](/img/ChewingCpplogo.png)

안녕하세요~ 여러분. 오랜 공백기간을 뚫고 찾아온 Psi 입니다. 그동안 많이 기다리셨죠? 이제 부터 본격적으로 이전의 C 에서 탈피하여 C++ 의 세계로 인도해드릴 것입니다.

메모리를 관리하는 문제는 언제나 중요한 문제입니다. 프로그램이 정확하게 실행되기 위해서는 컴파일 시에 모든 변수의 주소값이 확정되어야만 했습니다. 하지만, 이를 위해서는 프로그램에 많은 제약이 따르기 때문에 프로그램 실행 시에 자유롭게 할당하고 해제할 수 있는 **힙(heap)** 이라는 공간이 따로 생겼습니다.

하지만 이전에 컴파일러에 의해 완벽히 확정되어 안정성이 보장되는 **스택(stack)** 과는 다르게 힙은 사용자가 스스로 제어해야 하는 부분인 만큼 책임이 따릅니다. [위 문단이 이해되지 않는 분이라면 이 글을 읽어보도록 합시다](http://itguru.tistory.com/98)

C 언어에서는 `malloc` 과 `free` 함수를 지원하여 힙 상에서의 메모리 할당을 지원하였습니다. C++ 에서도 마찬가지로 `malloc` 과 `free` 함수를 사용할 수 있습니다.

하지만, 언어 차원에서 지원하는 것으로 바로 `new` 와 `delete` 라고 할 수 있습니다. `new` 는 말 그대로 `malloc` 과 대응되는 것으로 메모리를 할당하고 `delete` 는 `free` 에 대응되는 것으로 메모리를 해제합니다. 그럼 한 번 소스를 살펴볼까요.

```cpp-formatted
/* new 와 delete 의 사용 */
#include <iostream>
using namespace std;

int main() {
  int* p = new int;
  *p = 10;

  cout << *p << endl;

  delete p;
  return 0;
}
```



성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F134A4E3B4EFFDB710F5F69)

위와 같이 `int` 영역이 잘 할당 되어서 10 이 출력이 되었음을 알 수 있습니다.

```cpp-formatted
int* p = new int;
```


먼저 위와 같이 `int` 크기의 공간을 할당하여 그 주소값을 `p` 에 집어 넣었음을 알 수 있습니다. `new` 를 사용하는 방법은

```cpp-formatted
T* pointer = new T;
```


와 같습니다. `T` 에는 임의의 타입이 들어가겠지요. 그리고 이제 `p` 위치에 할당된 공간에

```cpp-formatted
*p = 10;
```


를 통해서 값을 집어넣었고 이를 출력하였습니다. 마지막으로 할당된 공간을 해제하기 위해서 `delete` 를 사용하였는데

```cpp-formatted
delete p;
```


위와 같이 `delete p` 를 하게 되면 `p` 에 할당된 공간이 해제됩니다. 물론 `delete` 로 해제할 수 있는 메모리 공간은 사용자가 `new` 를 통해서 할당한 공간만 가능합니다.

```cpp-formatted
/* 지역 변수 delete 하기 */
#include <iostream>
using namespace std;

int main() {
  int a = 5;

  delete &a;

  return 0;
}
```


만일 위 처럼 지역 변수를 무리하게 `delete` 로 해제해버리려 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F13656D404EFFDE912153AD)

위와 같이 `Heap` 이 아닌 공간을 해제하려고 한다는 경고 메세지가 나타나게 됩니다.



###  new 로 배열 할당하기


```cpp-formatted
/* new 로 배열 할당하기 */

#include <iostream>
using namespace std;
int main() {
  int arr_size;
  cout << "array size : ";
  cin >> arr_size;
  int *list = new int[arr_size];
  for (int i = 0; i < arr_size; i++) {
    cin >> list[i];
  }
  for (int i = 0; i < arr_size; i++) {
    cout << i << "th element of list : " << list[i] << endl;
  }
  delete[] list;
  return 0;
}
```


  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F133842454EFFE02A270E1B)

  위 소스에는 많은 새로운 내용이 담겨 있으니 차근 차근 살펴보도록 합시다.

```cpp-formatted
int arr_size;

cout << "array size : ";
cin >> arr_size;

int *list = new int[arr_size];
```


먼저 위와 같이 배열의 크기를 잡을 `arr_size` 라는 변수를 정의하였고 그 값을 입력 받았습니다. 그리고 `list` 에 `new` 를 이용하여 크기가 `arr_size` 인 `int` 배열을 생성하였습니다. 배열을 생성할 때 에는 `[]` 를 이용해 배열의 크기를 넣어주면 되는데,

```cpp-formatted
T* pointer = new T[size];
```


`T` 를 임의의 타입이라 하면 위와 같이 하면 됩니다. 따라서 `list` 는 이제 크기가 `arr_size` 인 `int` 배열을 가지게 됩니다. 사실 여기서 한 가지 놀라운 점이 있는데 C 에선 변수의 선언을 모두 최상단에 몰아서 해야 했지만 C++ 은 그렇지 않다는 점입니다. C++ 에서는 편리하게도 소스의 아무대서나 변수를 선언할 수 있으며, 그 변수는 그 변수를 포함하고 있는 중괄호를 빠져 나갈 때 소멸됩니다. 예를 들어서 아래와 같은 코드를 봅시다.

```cpp-formatted
// 생략
{
  int a = 4;
  cout << "안에서 a : " << a;
}

cout << "밖에서 a : " << a;
```


만일 여러분이 위와 같이 중괄호 안에서 변수 `a` 를 선언하였다면 변수 `a` 의 사용 범위는 그 중괄호 안 뿐입니다. 즉 안에서 `a` 는 4 로 잘 출력이 되겠지만 "밖에서 a :" 문장은 오류가 나게 될 것입니다. 왜냐하면 변수 `a` 가 그 곳에서는 존재하지 않기 때문이죠. 따라서 여러분은 이 점을 항상 유의하셔야 겠습니다. 또한 한 가지 더 재미있는 점은, 어떤 변수를 사용할 때 컴파일러는 그 변수를 가장 가까운 범위(scope) 부터 찾게 됩니다. 예를 들어 아래의 코드를 보세요

```cpp-formatted
int a = 4;
{
  cout << "외부의 변수 1" << a << endl;
  int a = 3;
  cout << "내부의 변수 " << a << endl;
}

cout << "외부의 변수 2" << a << endl;
```


외부의 변수 1 의 출력 결과를 보면 자명하게 4 가 될 것입니다. 왜냐하면 그 때까지 정의된 변수 `a` 는 앞서 정의한 `int a = 4` 하나 거든요. 하지만 그 아래에서 새롭게 `int a = 3;` 으로 정의한 후 (분명히 이 변수는 위에서의 `a = 4` 와 다른 변수 입니다) 내부의 변수를 출력해보면 3 이 나옵니다.

이는 앞서 말한 '가장 가까운 범위에서 찾는다' 라는 원칙 하에서 _'내부의 변수 << a '_ 에서 `a` 를 사용할 때 가장 가까운 범위 내에 있는 변수는 바로 같은 중괄호 내에 있는 `int a= 3;` 이므로 3 이 출력되는 것이지요. 바깥 범위에 있는 `a = 4` 의 `a` 는 내부에 있는 `a = 3` 의 `a` 에 의해 **가려집니다**. 그리고 중괄호를 지나면서 이 내부 변수는 소멸됩니다.

이제 다시 외부의 변수 2 를 출력할 때에는 `a = 4` 에서의 `a` 가 출력되어 4 가 나오게 되는 것입니다. 하지만 아래와 같이 같은 범위 안에 동일한 변수를 선언하는 것은 허용되지 않습니다.

```warning
    int a;
    a = 3;
    int a;
```


왜냐하면 그 다음에 `a` 를 사용하였을 때 둘 다 같은 범위 안에 있기 때문에 컴파일러는 어떠한 `a` 를 사용할 지 모르기 때문이지요. 한 가지 당부하고 싶은 말은 결코 위와 같은 변수의 선언 범위를 고려할 만큼 쪼잔하게 변수 이름을 짓지 말자 입니다.

사람의 눈은 컴파일러가 아니기 때문에 위와 같이 변수 이름을 중복해서 사용한다면 큰 혼동이 있을 뿐더러 나중에 디버깅시 곤란해질 수 있으니 항상 변수 이름은 다르게 짓는 습관을 들이는 것이 좋습니다.

이제 다시 본론으로 돌아와서 원래 코드를 살펴봅시다.

```cpp-formatted
for (int i = 0; i < arr_size; i++) {
  cin >> list[i];
}
for (int i = 0; i < arr_size; i++) {
  cout << i << "th element of list : " << list[i] << endl;
}
```


그림과 같이 `for` 문 안에서 `int i` 를 선언하여 `cin` 을 이용하여 `list` 를 받았습니다. 이렇게 `for` 문 초기식에서 정의된 `i` 는 과연 `for` 문 안에서 정의된 것일까요. `for` 문 밖에서 정의된 것일까요. 즉 `i` 를 `for` 문 밖에서도 사용할 수 있을까요? 

답은 안에서 정의된 것입니다. 즉 `i` 는 밖에서 사용할 수 없지요. 이렇게 `for` 문 초기식에 `i` 를 정의해버리면 좋은 점이 설사 밖에 `i` 를 다른 용도로 사용했더라도 `for` 문 안에서는 `i` 를 *카운터(counter)* 로 사용할 수 있기 때문에 오류가 발생할 가능성이 줄어듭니다.

아무튼 이렇게 해서 `list` 의 각 원소들을 입력받고 또 이를 출력할 수 있었습니다.

```cpp-formatted
delete[] list;
```


마지막으로 살펴볼 부분은 `delete` 하는 부분으로 앞서 `new []` 를 이용해서 할당 하였으면 아래에서는 `delete []` 를 통해서 해제하면 됩니다. 즉 `new - delete` 가 짝을 이루고 `new [] - delete []` 가 짝을 이루는 것이지요.



###  돌아온 마이펫



아마도 예전에 저의 C 언어 강좌를 보신 분들이라면 `switch` 문을 배우면서 간단하게 만들어보았던 마이펫을 기억하실 것입니다. 이번에는 그 때 기억을 살려서 동물 관리 프로그램을 간단하게 만들어보았습니다. 소스를 보기 전에 여러분들도 간단히 만들어보시는 것도 좋을 것 같습니다. 일단 조건은 다음과 같습니다.


* 동물(`struct Animal`) 이라는 구조체를 정의해서 이름(`char name[30]`), 나이(`int age`),체력(`int health`), 배부른 정도(`int food`), 깨끗한 정도의(`int clean`) 값을 가진다.
* 처음에 동물 구조체의 포인터 배열(`struct Animal* list[30]`)을 만들어서 사용자가 동물을 추가할 때 마다 하나씩 생성한다.
* `play` 라는 함수를 만들어서 동물의 상태를 변경하고 `show_stat` 함수를 만들어서 지정하는 동물의 상태를 출력한다.
* 1 턴이 지날 때 마다 동물의 상태를 변경한다 1 턴이 지날 때 마다 동물의 상태를 변경한다.

  대략 이 정도로만 하고 저는 한번 아래와 같이 소스를 짜보았습니다.

```cpp-formatted
#include <iostream>
using namespace std;

typedef struct Animal {
  char name[30];  // 이름
  int age;        // 나이

  int health;  // 체력
  int food;    // 배부른 정도
  int clean;   // 깨끗한 정도
} Animal;

void create_animal(Animal *animal) {
  cout << "동물의 이름? ";
  cin >> animal->name;

  cout << "동물의 나이? ";
  cin >> animal->age;

  animal->health = 100;
  animal->food = 100;
  animal->clean = 100;
}

void play(Animal *animal) {
  animal->health += 10;
  animal->food -= 20;
  animal->clean -= 30;
}
void one_day_pass(Animal *animal) {
  // 하루가 지나면
  animal->health -= 10;
  animal->food -= 30;
  animal->clean -= 20;
}
void show_stat(Animal *animal) {
  cout << animal->name << "의 상태" << endl;
  cout << "체력    : " << animal->health << endl;
  cout << "배부름 : " << animal->food << endl;
  cout << "청결    : " << animal->clean << endl;
}
int main() {
  Animal *list[10];
  int animal_num = 0;

  for (;;) {
    cout << "1. 동물 추가하기" << endl;
    cout << "2. 놀기 " << endl;
    cout << "3. 상태 보기 " << endl;

    int input;
    cin >> input;

    switch (input) {
      int play_with;
      case 1:
        list[animal_num] = new Animal;
        create_animal(list[animal_num]);

        animal_num++;
        break;
      case 2:
        cout << "누구랑 놀게? : ";
        cin >> play_with;

        if (play_with < animal_num) play(list[play_with]);

        break;

      case 3:
        cout << "누구껄 보게? : ";
        cin >> play_with;
        if (play_with < animal_num) show_stat(list[play_with]);
        break;
    }

    for (int i = 0; i != animal_num; i++) {
      one_day_pass(list[i]);
    }
  }
  for (int i = 0; i != animal_num; i++) {
    delete list[i];
  }
}
```


  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F153D833B4F0033FA2BEBE4)

  그림과 같이 잘 작동됨을 알 수 있습니다. 사실 위 코드에는 그다지 특별한 것이 없습니다. 일단 주요 부분을 살펴볼까요.

```cpp-formatted
typedef struct Animal {
  char name[30];  // 이름
  int age;        // 나이

  int health;  // 체력
  int food;    // 배부른 정도
  int clean;   // 깨끗한 정도
} Animal;
```


위와 같이 `Animal` 구조체를 만들어서 `typedef` 를 통해 `struct Animal` 을 `Animal` 로 간추렸습니다. 그리고,

```cpp-formatted
list[animal_num] = new Animal;
create_animal(list[animal_num]);
```


위와 같이 `Animal` 을 `new` 로 생성하면 `create_animal` 함수를 통해서 `Animal` 의 각 값들을 초기화 해주었고요, 사용자가 놀기를 요청하면

```cpp-formatted
if (play_with < animal_num) play(list[play_with]);
```

위 처럼 `play` 함수를 호출해서 놀기를 수행하였습니다. 마지막으로 사용자가 각 동물의 상태를 보기 원한다면

```cpp-formatted
if (play_with < animal_num) show_stat(list[play_with]);
```


`show_stat` 함수를 호출해서 사용자가 지정한 동물의 상태를 출력하도록 하였습니다. 사실 매우 간단한 이야기 입니다. 그런데 무언가 상당히 낭비 같지 않으세요? 사용자가 `play` 를 호출하면 `list[play_with]` 를 전달해야만 했습니다.

하지만 이러면 어떨까요?`Animal` 구조체 자체에 함수를 만들어서, 각 구조체 변수가 각각 자신의 함수를 가지게 되는 것입니다. 그러면 `list[play_with]->play()` 와 같이 "각 변수 자신의 함수" 를 호출하여 자신의 데이터를 이용해서 처리하게 되는 것이지요.

이렇게 할 수 만 있다면 `play` 함수에 귀찮게 인자를 전달할 필요도 없고 또 함수 내부에서도

```cpp-formatted
void play(Animal *animal) {
  animal->health += 10;
  animal->food -= 20;
  animal->clean -= 30;
}
```


위와 같이 귀찮게 `animal->` 을 앞에 붙여가면서 작업할 필요도 없습니다. 왜냐하면 `list[play_with]->play()` 라고 했을 때 `play` 는 '자기 자신의 함수' 이기 때문에

```cpp-formatted
health += 10;
food -= 20;
clean -= 30;
```


이렇게 해도 된다는 것입니다. 왜냐하면 `list[play_with]->play()` 이라 했을 때 `health, food, clean` 이 의미하는 것이 `list[play_with]` 의 것이기 때문입니다. 상당히 괜찮은 생각 아닌가요? 위 소스에서 불편한 점은 이것만이 아닙니다. `new` 를 통해 새로운 동물을 할당하는 부분을 살펴봅시다.

```cpp-formatted
list[animal_num] = new Animal;
create_animal(list[animal_num]);
```


`new Animal` 을 통해 동물을 생성한 다음에 반드시 `create_animal` 함수를 호출해야만 했습니다. 왜냐하면 `new Animal` 을 통해 새로운 `Animal` 을 할당한 상태라면 `health, food` 등 변수에 아무런 값이 들어가 있지 않기 때문이죠. 다시 말해서 만일 프로그래머가 실수로 `Animal` 을 생성한 후 `create_animal` 을 호출하지 않는다면 나중에 `play` 함수 등을 호출 할 때 끔찍한 오류가 발생하게 됩니다. 초기화 되지 않는 값에 연산을 수행하는 오류이지요.

그렇다면 만일 `new` 로새로운 `Animal` 을 생성할 때 자동으로 호출되는 함수가 있으면 어떨까요. 즉 `new` 가 알아서 호출해주는 그런 함수. 그렇게 된다면 사용자는 귀찮게 `create_animal` 을 호출할 필요도 없고, 자동으로 호출되는 함수에서 멤버 변수들 (health, food, ...) 들을 초기화 해준다면 나중에 초기화 되지 않아서 생기는 오류도 막을 수 있을 것입니다.

자 이제. 여러분은 위 동물 프로그램이 크나큰 인기를 얻어서 확장팩을 제작하게 되었습니다. `Animal` 이라 단순하게 분류하였던 것을 조금 더 세분화 해서 `Bird, Fish` 등으로 나누어서 처리하려고 합니다. `Bird` 와 `Fish` 는 기본적으로 `Animal` 과 유사하지만 `Bird` 에는 현재 날고 있는 고도를 나타내는 변수인 `int` height; 가 새로 추가되고, `Fish` 에는 현재 잠수하고 있는 수심을 나타내고 있는 변수인 `int` deep; 이 추가되었습니다.

그러면 여러분은 아래와 같이 소스를 짤 것입니다.

```cpp-formatted
typedef struct Bird {
  char name[30];  // 이름
  int age;        // 나이

  int health;  // 체력
  int food;    // 배부른 정도
  int clean;   // 깨끗한 정도

  // 여기까지는 Animal 과 동일하다.
  int height;  // 나는 고도

} Bird;

typedef struct Fish {
  char name[30];  // 이름
  int age;        // 나이

  int health;  // 체력
  int food;    // 배부른 정도
  int clean;   // 깨끗한 정도

  // 여기까지는 Animal 과 동일하다.
  int deep;  // 나는 고도

} Fish;
```


와 정말로 시간 낭비가 아닐 수 없었습니다. `Animal` 과 거의 똑같지만 조금조금씩 달라진 것 때문에 구조체를 새로 두 개나 만들어야 한다는 말입니다. 그냥`Animal` 과 동일한 부분은 가져다 쓰고 새로 추가된 부분만 살포시 추가해 주면 안될까요?

그런데 문제는 이 뿐만이 아닙니다. 여러분은 더이상 `Animal*` 배열 하나로 살 수 없게 됩니다. 이제 `Animal*` 따로, `Fish*` 따로, `Bird*` 따로 만들어서 관리해야 될 뿐더러` play` 함수, `show_stat` 함수도 모두 `Animal, Fish, Bird` 에 맞게 각각 새로 작성해야 합니다. 다시 말해서 고작 `int height` 나 `int deep` 변수 하나 추가한 덕분에 여태까지 짠 코드 양의 2 배를 써야 하는 위기 상황에 처했습니다.

정말 말이 안되지요. 하지만 C 언어의 세계에 살고 있던 여러분은 이 모든 것을 꿋꿋히 해내고 있었을 것입니다.

그리고 이제. 이곳을 탈출할 때가 온 것 같습니다.

여러분,

**객체지향프로그래밍의 세계로 오신것을 환영합니다.**

##@ chewing-cpp-end
Link :  141
2012-01-01 12:09
----------------
title : 씹어먹는 C++ - <2 - 2. C++ 은 C 친구일까?>
cat_title: 2 - 2. C++ 은 C 친구일까?
next_page : 169
publish_date : 2012-01-01 12:09
--------------

이번 강좌에서는

* 기초적인 함수의 사용


* C++ 레퍼런스(reference, 참조자) 의 도 C++ 레퍼런스(reference, 참조자) 의 도입

* 레퍼런스 배열과 배열의 레퍼런스


![](/img/ChewingCpplogo.png)

안녕하세요 여러분! 오랜만에 찾아온 Psi 입니다. 사실 이전 강좌에서 부터 강조해왔지만 C 언어에서 되던 것이 C++ 에서는 거의 100% 된다고 보셔도 무방합니다.

즉 기초적인 문법이 거의 똑같다는 것이지요. 이전 강좌에서는 기본적인 구문들, 예를 들어 변수의 정의 방법이나, 조건문(`if, else, switch`), 반복문(`for, while, do-while`) 등등을 살펴 보았는데요, 이번 강좌는 C++ 와 C 언어의 경계가 되는 강좌로 여러가지 중요한 내용을 배우게 됩니다. 그럼면서 여러분을 이끌고 자연스럽게 C++ 의 세계로 들어가도록 하겠습니다.


###  함수 사용하기


```cpp-formatted
#include <iostream>
using namespace std;

void print_square(int arg);
int main() {
  int i;

  cout << "제곱할 수 ? : ";
  cin >> i;

  print_square(i);

  return 0;
}

void print_square(int arg) { cout << "전달된 인자 : " << arg * arg << endl; }
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F11301F3F4E50A72113DE49)
와 같이 나옵니다.

위 소스를 보면, 사실 굳이 설명이 필요 없이 이해가 잘 되실 것입니다. C++ 에서 C 와 입출력 방법이 다를 뿐 다 똑같습니다. 일단, 아래의 코드에서 우리는 `void` 형의 (리턴값이 없는) 함수 `print_square` 을 선언합니다.

```cpp-formatted
void print_square(int arg);
```

그리고 이 함수는

```cpp-formatted
void print_square(int arg) { cout << "전달된 인자 : " << arg * arg << endl; }
```

와 같은 작업을 수행하지요. 즉 `arg* arg` 를 출력하는 것입니다. 그리고 `main` 함수에서 인자로 `i` 를 전달했지요.

```cpp-formatted
print_square(i);
```

따라서 `arg` 에 `i` 의 값이 들어가서 `i * i` 인, 우리의 실행 결과의 경우 12 를 전달해서 144 가 출력되게 되는 것이지요. 매우 간단합니다. 사실 C 하고 전혀 다를 바가 없어요!



###  레퍼런스의 도입


```cpp-formatted

#include <iostream>

using namespace std;
int change_val(int *p) {
  *p = 3;

  return 0;
}
int main() {
  int number = 5;

  cout << number << endl;
  change_val(&number);
  cout << number << endl;
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1669824B4EFEA22010493C)
 와 같이 나옵니다.

위 소스 코드 역시 저의 C 언어 강좌를 잘 따라오신 분이라면 무리없이 이해하실 수 있는 코드 입니다. 즉 `change_val` 함수의 인자 `p` 에 `number` 의 주소값을 전달하여, `*p` 를 통해 `number` 를 참조하여 `number` 의 값을 3 으로 바꾸었습니다. 그런데, 말이죠. 여러분 모두 `&` 키를 입력 하시는데에 진물이 나셨을 것입니다.

이런 분들 위해서 C++ 에서 새롭게 생겨난 개념이 있습니다. 바로 **레퍼런스** 입니다.

```cpp-formatted

#include <iostream>

using namespace std;
int change_val(int &p) {
  p = 3;

  return 0;
}
int main() {
  int number = 5;

  cout << number << endl;
  change_val(number);
  cout << number << endl;
}
```


  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1669824B4EFEA22010493C)

앞선 결과와 동일하게 나오는 것을 알 수 있습니다. 위 소스코드를 찬찬히  살펴보자면 일단 `change_val` 함수에서 `number` 앞에 `&` 를 붙이지 않았습니다. 그리고, `change_val` 함수에서도 `*p = 3;` 대신에 `p = 3;` 으로 바뀌었습니다. 그 대신에 `change_val` 에서 인자로 `int &p` 를 받고 있습니다. 이 것이 바로 **레퍼런스** 입니다.

레퍼런스(reference) 가 무엇인지 알기 위해 일단 사전에 그 의미를 검색해보았습니다.

```info
MENTIONING SB/STH |[C , U] ~ (to sb/sth) (… 에 대해) 말하기, 언급; 언급 대상, 언급한 것
LOOKING FOR INFORMATION |[U] (정보를 얻기 위해)찾아봄, 참고, 참조
```

 그랬더니 두번째 뜻으로 **참고** 라는 말이 나오네요. 맞습니다. 레퍼런스란, 어떤 다른 변수의 참고, 즉 **다른 이름** 이란 의미를 가지고 있습니다. 그래서 흔히 C++ 에서 레퍼런스를 참조자 라고도 합니다. 위 경우 `p` 가 `number` 변수의 다른 이름이 되는 것입니다. 따라서 `p = 3;` 이란 명령은 `number = 3;` 과 정확히 일치하는 명령이 되겠지요.

레퍼런스를 정의하는 방법은 아래와 같습니다.

```cpp-formatted
int& ref = number;
```

즉, `int` 타입의 변수의 레퍼런스를 만들기 위해서는 `int&` 로 하면 되고, 그 오른쪽에 참고하고 싶은 것을 써주면 되지요. 어떤 특정 타입 `T` 에 대해 참조자를 만들고 싶다면 `T&` 와 같이 정의하면 됩니다. 아무튼, 이렇게 한다면 여러분은 `number` 에 다른 이름인 `ref` 를 부여한 것이나 마찬가지 입니다. 즉 별명을 지어준 것이라 생각하세요. 참조자의 가장 중요한 특성으로 반드시 정의 시 초기화 되어야 한다 입니다. 다시 말해, 아래와 같은 문장은 존재할 수 없다는 것이지요.

```warning
int &ref;
```

왜냐하면 참조자라는 것이 반드시 **다른 어떤누구의 별명** 이 되어야 하는 것인데, 그 '누구' 가 존재하지 않는다면 참조자가 존재할 필요가 없어질테니까요. 물론 어떤 사람들은 '포인터 역시 다른 어떤 변수를 가리켜야 하는데 왜 초기화 하지 않고 정의할 수 있냐' 라고 물을 수 있습니다.

하지만 포인터 자체는 '메모리 값을 보관하는 변수' 자체로 활용될 수 있지만 참조자는 그렇지 않습니다. 참조자는 포인터 처럼 어떠한 메모리 공간에 할당되어서 자신을 참조하는 주소값을 보관하는 것이 아닙니다. 컴파일 시에 원래 가리키던 변수의 주소값으로 다 치환되버리죠. (`*(주소값)` 으로)

\sidenote{사실 이 이야기는 정확한 것은 아니고 항상 메모리 공간에 할당 되지 않는 것은 아닙니다. 예를 들어 함수에 인자로 넘겨 줄 때 레퍼런스가 메모리 상에 존재하겠지요. 하지만 일단 레퍼런스는 포인터 처럼 어떤 존재하는 실체가 아니고 단순히 '별명' 이라고 생각하시면 됩니다. 고수분들은 http://stackoverflow.com/questions/1164266/why-arrays-of-references-are-illegal
를 읽어보세요}

참고로 말하자면 레퍼런스는 한 번 초기화 되면 다른 변수의 별명이 될 수 없습니다. 예를 들어서

```cpp-formatted
int a = 10;
int &ref = a;
int b = 3;
ref = b;
```

를 하면 `ref = b;` 에서 `ref` 가 `b` 를 가리키는 것이 아니라, `a = b;`, 즉 `a` 에 3 이 대입되는 것입니다. 물론

```cpp-formatted
&ref = b;
```


와 같은 문장은 `&a = b;` 즉, "`a` 의 주소값을 3 으로 변경한다?" 라는 말이 안되는 문장이고

```cpp-formatted
ref &= b;
```

는 `ref = ref &b;`, 즉 `a = a & b;` 와 같은 문장으로 역시 전혀 의미가 다릅니다. 아무튼 레퍼런스는 포인터로 치면 `int const *` 와 같은 형태라 말할 수 있습니다. 즉 한 번 별명이 된다면 영원히 바뀔 수 없는 것이지요. (물론 포인터와 레퍼런스는 엄연히 다른 것입니다!)

  일부 C 언어를 배운 사람의 경우 레퍼런스와 포인터가 헷갈릴 수 있습니다. 예를 들어 아래와 같은 코드를 보세요.


```cpp-formatted

int number = 10;
int& ref = number;
int* p = &number;

ref++;
p++;
```




`p ++` 의 경우 C 언어를 배운 사람이라면 `p` 의 주소값이 4 만큼 증가되어서 (`int` 의 크기가 4 이니까) 아마 이상한 것을 가리키고 있겠지요. 반면에 `ref++` 의 경우 `ref` 가 아까 '`number` 의 다른 이름' 이라고 했으므로 `number++` 과 동일합니다. 즉 `number` 가 11 이 됩니다. 간단하지요? 이렇게 참조자를 사용한다면 귀찮았던 포인터 관련 연산들을 모두 생략할 수 있게 됩니다. 그냥 원래 변수라고 생각하면 되는 일이니까요.

  이제 다시 원래 소스를 다시 살펴보자면

```cpp-formatted
change_val(number);
```


위와 같이 `change_val` 함수를 호출하였고 인자로 `number` 을 전달하였습니다. 따라서

```cpp-formatted

int change_val(int &p) {
  p = 3;

  return 0;
}
```


위 문장에서 `int &p = number;` 로 `p` 가 `number` 의 별명이 됩니다. 따라서 `p = 3;` 이라 하는 것은 `main` 의 `number = 3;` 을 하는 것과 정확히 동일한 작업입니다.

```cpp-formatted
// 참조자 이해하기

#include <iostream>
using namespace std;

int main() {
  int x;
  int& y = x;
  int& z = y;

  x = 1;
  cout << "x : " << x << " y : " << y << " z : " << z << endl;

  y = 2;
  cout << "x : " << x << " y : " << y << " z : " << z << endl;

  z = 3;
  cout << "x : " << x << " y : " << y << " z : " << z << endl;
}
```


  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1246B0454EFEAB480EE198)
  사실 위 소스를 타이핑 하면서 고개를 갸우뚱 하시는 분들이 있을 지도 모릅니다. 왜냐하면 여러분들은 그간 C 언어의 '악마의 포인터 세계' 에서 사셨기 때문이지요. 하지만 여기서 강조하지만, 포인터와 레퍼런스는 비슷하면서도 다른 녀석들입니다. 먼저 다음과 같은 부분은 쉽게 이해하셨겠지요.


```cpp-formatted
int x;
int& y = x;
```


"음. `x` 에 대한 레퍼런스로 `y` 를 정의하였구나. 즉 `y` 는 `x` 의 또다른 별명이 되겠지." 라고 다들 생각하셨겠지요. 그러면서 여러분은 아마 제가 앞서 말한 "어떤 특정 타입 `T` 에 대해 참조자를 만들고 싶다면 `T&` 와 같이 정의하면 됩니다." 를 머리속에 떠올리면서 다음 소스를 보고 의문을 가졌을 것입니다.

```cpp-formatted
int& y = x;
int& z = y;
```



"`y` 가 `int&` 이므로 `z` 는 `int&&` 가 되야 하는데 왜 `int&` 이지?". 좋은 질문입니다. 물론 이 이야기가 포인터였다면 정확히 들어맞을 터 입니다. 포인터였다면


```cpp-formatted
int x;
int* y = &x;
int** z = &y;
```



  와 같이 소스를 작성했어야 맞겠죠. 하지만 포인터와 레퍼런스는 다릅니다. 앞선 소스를 다시 살펴봅시다.

```cpp-formatted

int& y = x;
int& z = y;
```


`y` 는 `x` 의 레퍼런스 입니다. 즉 우리가 코드 상에서 `y` 라고 표시한 것은 `y` 를 그대로 `x` 로 바꾸어도 의미가 변하지 않는 다는 것이지요. 다시 말해


```cpp-formatted
int& z = x;
int& z = y;
```


위 두 문장은 정확히 같은 문장이라는 것입니다. 따라서 앞선 논의에 따라서 역시 `int&` 가 되어야 합니다. 여러분은 레퍼런스를 포인터의 개념으로 생각하시면 안됩니다. 그냥 어떤 변수의 다른 이름이라고 생각하시면 편할 것입니다. 따라서 위 세 문장의 정의식은 결국 `x` 의 다른 이름인 `y` 와 `z` 를 만들어준 것 뿐입니다.


```cpp-formatted
x = 1;
cout << "x : " << x << " y : " << y << " z : " << z << endl;

y = 2;
cout << "x : " << x << " y : " << y << " z : " << z << endl;

z = 3;
cout << "x : " << x << " y : " << y << " z : " << z << endl;
```

결과적으로 위 문장들은 모두 `1,1,1` 과 `2,2,2` 와 `3,3,3` 을 출력하게 되겠지요.

사실 여러분들은 도대체 왜 레퍼런스를 도입했는지 의문을 가질지도 모릅니다. 왜냐하면 어차피 레퍼런스로 할 수 있는거 포인터로 모두 할 수 있기 때문이죠. 하지만 나중에 가면 레퍼런스의 진정한 위력.. 이라기 보단 편리함을 몸소 느낄 수 있을 것입니다.

아니면 이미 느꼈을 지도 모르죠. 지난 강좌에서 변수 입력시 배웠던 `cin` 을 기억하시나요? 아마 사용자로 부터 변수에 값을 입력 받을 때 다음과 같이 했었을 것입니다.

```cpp-formatted
cin >> user_input;
```


그런데 무언가 이상하지 않으세요? 예전에 `scanf` 로 이용할 때 분명히

```cpp-formatted
scanf("%d", &user_input);
```

와 같이 항상 주소값을 전달해 주었는데 말이죠. 왜냐하면 어떤 변수의 값을 다른 함수에서 바꾸기 위해서는 항상 포인터로 전달하였기 때문이니까요. 하지만 여기서는 `cin` 이라는 것에 그냥 `user_input` 을 전달했는데 잘 작동합니다. 왜 그럴까요? 바로 레퍼런스 형태로 전달하였기 때문이지요. 귀찮은 `&` 를 `user_input` 앞에 붙일 필요가 없게 되는 것입니다. 레퍼런스의 편리함은 이쯤에서 맛보기로 끝내도록 하고 계속 강좌를 진행해봅시다.



###  상수에 대한 참조자


```cpp-formatted

#include <iostream>
using namespace std;

int main() {
  int &ref = 4;

  cout << ref << endl;
}
```

위와 같은 소스를 살펴봅시다. 일단 컴파일 해보면 아래와 같은 오류가 나타날 것입니다.

```warning
error C2440: 'initializing' : cannot convert from 'int' to 'int &'
```

왜 오류가 나타날까요? 아마 여러분들은 다 알고 계시겠지요. 위 상수 값 자체는 '리터럴' 이기 때문에 ([리터럴이 무엇인지 모르겠으면 여기로](http://itguru.tistory.com/33)) 상수이고 따라서 위와 같이 레퍼런스로 참조한다면

```cpp-formatted
ref = 5;
```
로 리터럴의 값을 바꿀 수 있는 여지가 생기기 때문에 참조할 수 없습니다. 하지만 아래와 같이

```cpp-formatted
const int &ref = 4;
```


상수 참조자로 선언한다면 리터럴도 참조 할 수 있게 되는 것입니다. 예컨대

```cpp-formatted
int a = ref;
```

는 `a = 4;` 와는 문장과 동일합니다. 마찬가지 이유로 상수를 참조하기 위해서는 상수 레퍼런스를 선언하시면 됩니다.



###  레퍼런스의 배열과 배열의 레퍼런스


아마도 예전 C 강좌에서 포인터 가지고 한 이야기를 레퍼런스를 가지고 다시 한 번 재탕하는 기분입니다. 하지만 이 주제는 많은 C++ 초보자들의 머리를 아프게하는 문제이기도 하지요. 일단은, 레퍼런스의 배열이 과연 가능한 것인지에 대해 부터 생각해봅시다. 앞서 말했듯이 레퍼런스는 반드시 정의와 함께 초기화를 해주어야 한다고 했습니다. 따라서 여러분의 머리속에는 다음과 같이 레퍼런스의 배열을 정의하는 것을 떠올렸을 것입니다.


```cpp-formatted
int a, b;
int& arr[2] = {a, b};
```

  그런데 말이죠. 컴파일 하기도 전에 빨간줄이 그어지네요. 아무튼 컴파일을 해보면

```warning
 error C2234: 'arr' : arrays of references are illegal
```


레퍼런스의 배열을 **불법(illegal)** 이라고 하네요. 얼마나 불법인지 한 번 C++ 규정을 찾아 보았더니 C++ 표준안 8.3.2/4 를 보면 놀랍게도

```info
There shall be no references to references,no arrays of references, and no pointers to references
레퍼런스의 레퍼런스,레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다.
```


정말로 '불법' 인 것이 맞군요. 이것이 말이 돼냐 안돼냐를 떠나기 전에 C++ 규정에서 레퍼런스의 배열을 선언하는 것을 막아버리고 있습니다. 그러면 도대체 왜 안될까요? 왠지 위에서

```cpp-formatted
int& arr[2] = {a, b};
```

로 해서 "`arr[0]` 는 `a` 를 의미하고 `arr[1]` 은 `b` 를 의미하고.." 로 만들면 안될까요. 여러분은 먼저 '레퍼런스의 포인터는 존재할 수 없다' 에 대해 생각해보도록 합시다. 레퍼런스의 포인터는 왜 존재하지 않을까요. 당연한 이야기 입니다. 위에서 말했듯이 레퍼런스는 메모리 상에 특정 공간을 차지하는 것이 아니라 컴파일 시에 원래 레퍼런스가 참조하던 변수의 주소값으로 대체된다고 하였습니다. 따라서 메모리 공간을 차지하지 않는 것의 포인터를 생각한다는 것은 말이 안되는 것입니다.

그런데 말이죠. `arr` 은 무엇을 의미하는 것일까요. 바로 `arr` 배열의 첫 번째 레퍼런스를 가리키는 '포인터' 가 되는 것입니다. 이는 바로 앞에서 말한 내용에 정확히 모순이 되는 것입니다. 따라서 마찬가지로 레퍼런스의 배열도 존재할 수 없게 됩니다.

하지만 배열의 레퍼런스는 어떨까요?


```cpp-formatted
#include <iostream>
using namespace std;

int main() {
  int arr[3] = {1, 2, 3};
  int(&ref)[3] = arr;

  ref[0] = 2;
  ref[1] = 3;
  ref[2] = 1;

  cout << arr[0] << arr[1] << arr[2] << endl;
  return 0;
}
```

  성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F152AC9354EFFC5EC1771F8)

  먼저 가장 중요한 첫 두줄을 살펴봅시다.


```cpp-formatted
int arr[3] = {1, 2, 3};
int (&ref)[3] = arr;
```

위와 같이 `ref` 가 `arr` 을 가리키도록 하였습니다. 위와 같이 하면 `ref[0]` 부터 `ref[2]` 가 각각 `arr[0]` 부터 `arr[2]` 의 레퍼런스가 됩니다. 사실 배열의 레퍼런스는 잘 사용되지 않습니다. 왜냐하면 위와 같이 배열의 크기를 명확히 명시해 주어야 합니다. `int (&ref)[3]` 이라면 반드시 크기가 3 인 `int` 배열을 가리켜야 하고 `int (&ref)[5]` 라면 크기가 5 인 `int` 배열을 가리켜야 하겠지요.

하지만 포인터를 사용하면 굳이 그럴 필요 없이 단순히 `int *P` 하나로 모든 1 차원 배열들을 가리킬 수 있으니, 배열을 가리킬 필요가 있을 경우 레퍼런스 보다는 포인터를 사용하는 것을 훨씬 더 권장합니다. 참고로 그 이상 차원의 배열들도 마찬가지로 아래와 같이 레퍼런스를 사용하여 정의할 수 있습니다.


```cpp-formatted
int arr[3][2] = {1, 2, 3, 4, 5, 6};
int (&ref)[3][2] = arr;
```



  역시 일차원 배열을 했을 때와 동일합니다.





### 레퍼런스를 리턴하는 함수


C++ 를 처음 배우신 분들이 가장 많이 헷갈려 하는 부분이 바로 레퍼런스를 반환하는 함수 입니다. 아래의 코드를 살펴볼까요 C++ 를 처음 배우신 분들이 가장 많이 헷갈려 하는 부분이 바로 레퍼런스를 반환하는 함수 입니다. 아래의 코드를 살펴볼까요.

```cpp-formatted
#include <iostream>
using namespace std;

int fn1(int &a) { return a; }

int main() {
  int x = 1;
  cout << fn1(x)++ << endl;
}
```

당연히도 위 코드는 컴파일 되지 않습니다. 왜냐하면 `fn1(x)` 를 했을 때, "아 이제, `a` 를 `x` 의 별명으로 해야지~" 라고 한 후에, 이를 리턴하면서 그냥 평범한 `int` 로 리턴하였기 때문에 임시로 복사된 `x` 의 '값' 이 반환되는 것입니다 (이를 우측값이라 하는데, 나중에 자세히 다루도록 하겠습니다). 당연히도 이 값은 임시로 생성된 것이므로, 읽기만 가능하지 수정은 불가능 합니다.


```cpp-formatted
#include <iostream>
using namespace std;

int fn1(int &a) { return a; }

int &fn2(int &a) { return a; }
int main() {
  int x = 1;
  cout << fn2(x)++ << endl;
  cout << "x :: " << x << endl;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F222F1A4C58E54E22199A13)

아주 깔끔하게 잘 나옵니다.
놀라운 점은, `x` 의 값이 바뀌었다는 점입니다. 그 이유는 `fn2` 을 살펴보면 알 수 있습니다.

```cpp-formatted
int& fn2(int& a) { return a; }
```



`fn2` 를 보면 인자로 레퍼런스를 받아서, 다시 그것을 그대로 리턴합니다. 쉽게말해,

```cpp-formatted
fn2(x)
```

를 했을 때, `fn2` 내부에서 "아 이제 `a` 는 `x` 의 별명 (레퍼런스) 이다!", 이렇게 된 것이고, 다시 함수를 리턴할 때 "나 `x` 의 별명을 리턴함!" 이렇게 되는 것이지요. 따라서, `fn2(x) ++` 은 마치 `x++` 을 한 문장과 동일하게 된 것입니다.


만약에 C 언어 였다면, `x` 의 포인터를 리턴하고, 그걸 받아서 다시 역참조 해서 `(*)++` 을 해줬어야 하겠지요. 하지만 레퍼런스의 도입 덕분에 정말 편리해졌습니다.


### 생각해보기

#### 문제 1

레퍼런스가 메모리 상에 반드시 존재해야 하는 경우는 어떤 경우가 있을까요? 그리고 메모리 상에 존재할 필요가 없는 경우는 또 어떤 경우가 있을 까요? (난이도 : 上)

##@ chewing-cpp-end
Link :  168
2011-10-23 10:04
----------------
title : C++ 레퍼런스 - ios::operator!
cat_title :  ios::operator!
publish_date : 2011-10-23 10:04
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::operator!

```info
bool operator ! ( ) const;
```


스트림 객체의 오류 상태 플래그를 확인한다.
만일 스트림의 오류 상태 플래그인 `failbit` 와 `badbit` 중 어느 하나라도 설정되어 있다면 `true` 를 리턴하고 아니면 `false` 를 리턴한다.

이 연산자는 [fail()](http://itguru.tistory.com/165)함수의 동일한 작업을 한다.



###  인자


없다



### 
 리턴값




`failbit` 나 `badbit` 어느 하나라도 설정되어 있다면 `true` 를 리턴한다.
아니면 `false`



###  템플릿 멤버 정의




```cpp-formatted
(basic_ios<charT, traits>)bool operator!() const;
```




###  실행 예제



```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/iostream/ios/operatornot/
에서 가져왔습니다.

*/
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  ifstream is;
  is.open("test.txt");
  if (!is) cerr << "Error opening 'test.txt'\n";
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1265704E4EA3679D21067B)

###  연관된 함수

*  [ios::fail](http://itguru.tistory.com/165)  :  `failbit` 이나 `badbit` 이 설정되어 있는지 확인한다.
*  [ios::good](http://itguru.tistory.com/164):  스트림에 어떠한 오류 플래그도 설정되지 않았는지 확인한다.
Link :  167
2011-10-23 09:52
----------------
title : C++ 레퍼런스 - ios::eof 함수
cat_title :  ios::eof
ref_title : eof
publish_date : 2011-10-23 09:52
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ ios::eof

```info
bool eof ( ) const;
```


`eofbit` 이 설정되었는지 확인한다.

이 함수는 스트림의 `eofbit` 오류 상태 플래그가 이전의 입출력 작업으로 인해 설정되었을 때 `true` 를 리턴한다. `eofbit` 플래그는 입력 작업 중 **파일 끝(End Of File)** 에 도달하였을 때 설정되는 플래그 이다.



###  인자




없다



###  리턴값




스트림의 오류 상태 플래그 `eofbit` 이 설정되었을 때 `true` 를 리턴한다. `eofbit` 는 입력 작업 중 **파일 끝(End Of File)** 에 도달하였을 때 설정된다. 그 외의 경우 `false` 를 리턴한다.



###  템플릿 멤버 정의




```cpp-formatted
(basic_ios<charT, traits>)bool eof() const;
```




###  연관된 함수

*  [ios::fail](http://itguru.tistory.com/165)  :  `failbit` 이나 `badbit` 이 설정되어 있는지 확인한다.
*  [ios::bad](http://itguru.tistory.com/166)  :  `badbit` 이 설정되어 있는지 확인한다.
*  [ios::good](http://itguru.tistory.com/164):  스트림에 어떠한 오류 플래그도 설정되지 않았는지 확인한다.
*  [ios::rdstate](http://itguru.tistory.com/171)  :  오류 상태 플래그를 얻는다.
*  [ios::clear](http://itguru.tistory.com/180)  :  오류 상태 플래그를 설정한다.
Link :  188
2013-01-06 03:03
----------------
title : 씹어먹는 C++ - <4 - 3. 스타크래프트를 만들자 ① (복사 생성자, 소멸자)>
cat_title: 4 - 3. 스타크래프트를 만들자 ① (복사 생성자, 소멸자)
next_page : 197
publish_date : 2013-01-06 03:03
--------------

이번 강좌에서는

* 복사 생성자 (copy constructor) - 깊은 복사와 얕은 복사
* 소멸자 (destructor)

![](/img/ChewingCpplogo.png)

안녕하세요 여러분. 지난 강좌에서 생성자에 대해 처음 알게 된 이후로 생성자의 위력에 대해 감탄하지 않으셨나요? 생성자를 통해 이전에 C 프로그래밍 시에 변수 초기화를 하지 않아서 생겼던 수 많은 오류들을 효과적으로 없앨 수 있었습니다.

뿐만 아니라 C++ 에서 새로 도입된 함수 오버로딩 덕분에 함수 이름을 일일히 따로 지정하지 않더라도 성공적으로 인자들의 타입에 따라 원하는 함수들만 호출 할 수 있게 되었습니다. 실제로 C 언어 였다면 인자의 타입에 따라서 함수의 이름들을 외워야 했지만 C++ 에서는 그럴 필요가 전혀 없게 되었다는 것이지요.


###  스타크래프트 만들기

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2615CA3E50E902B432E7CF)

사실 제가 오늘 이 강좌에서 진행하고 싶었던 것은 바로 '스타크래프트 만들기' 이었습니다. 아니, 스타크래프트를 만들겠다니요. 그게 말이 됩니까? 넵. 말이 됩니다. 저는 앞으로 C++ 강좌를 진행해나가면서 '스타크래프트' 의 뼈대를 차근 차근 만들어 나가보고자 합니다. 그럼, 여러분 모두 준비 되셨나요?

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2331D74750E831DC17BE68)

스타크래프트라는 거대한 프로젝트를 진행하기에 앞서서 일단, 유닛 하나 부터 만들어 보도록 할 것입니다. 위에 조그만 사진에 있는 총들고 서 잇는 사람은 스타크래프트의 마린 이라는 유닛 입니다. (테란 유저로써 제가 가장 사랑하는 유닛 중 하나라고 볼 수 있죠) 위 유닛은 스타크래프트 유닛 중에서 가장 단순하고 기본이 되는 유닛이라고 할 수 있습니다. 그렇다면 한 번, 이 마린을 코드 상에서 구현해보도록 합시다.

```cpp-formatted
#include <iostream>
using namespace std;

class Marine {
  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  int damage;            // 공격력
  bool is_dead;

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.
};
Marine::Marine() {
  hp = 50;
  coord_x = coord_y = 0;
  damage = 5;
  is_dead = false;
}
Marine::Marine(int x, int y) {
  coord_x = x;
  coord_y = y;
  hp = 50;
  damage = 5;
  is_dead = false;
}
void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return damage; }
void Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;
}
void Marine::show_status() {
  cout << " *** Marine *** " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}

int main() {
  Marine marine1(2, 3);
  Marine marine2(3, 5);

  marine1.show_status();
  marine2.show_status();

  cout << endl << "마린 1 이 마린 2 를 공격! " << endl;
  marine2.be_attacked(marine1.attack());

  marine1.show_status();
  marine2.show_status();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F253FDC4E50E8394E27FA58)



어때요? 우리는 일단 위 소스코드에서 아주 초보적으로 작동하는 마린을 구현하였습니다. 한번 살펴볼까요?

```cpp-formatted
class Marine {
  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  int damage;            // 공격력
  bool is_dead;

 public:
  Marine();              // 기본 생성자
  Marine(int x, int y);  // x, y 좌표에 마린 생성

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.
};
```

위는 마린을 구현한 클래스 입니다. 즉, 위 클래스의 객체들이 바로 개개의 마린들이 되는 것이지요. 이전 강좌에서도 이야기 하였지만, 보통 어떠한 객체의 내부적 성질, 상태 등에 관련된 변수들은 모두 `private` 범주에 두고, 그 객체가 외부에 하는 행동들은 함수로써 구현하여 `public` 에 두면 된다고 하였습니다.

그렇다면, 마린의 경우, 마린의 상태에 관련된 것들 - 예를 들어서, 마린의 현재 `hp` 라던지, 위치, 공격력, 그리고 생존 여부 등은 `private` 범주에 두어서 관리하고, 마린이 하는 행동들 - 즉, 이동한다 던지 공격한다 던지, 혹은 외부로 부터 공격 받는 등에 관련된 것들은 메소드로 만들어서 `public` 에서 범주로 두면 좋을 것 같습니다.


따라서 위와 같이 코드를 구성하였습니다. 사실 나머지 함수들은 그 구현이 너무 간단해서 굳이 따로 집어서 살펴볼 필요는 없을 것 같습니다. 그래서 바로 `main` 함수의 코드들을 살펴보도록 합시다.

```cpp-formatted
Marine marine1(2, 3);
Marine marine2(3, 5);
```


먼저, 위 두개의 `marine1` 과 `marine2` 라는 이름의 `Marine` 객체들을 생성하였습니다. 물론 생성자 오버로딩에 의해 각각 (2,3), (3,5) 에 위치한 마린들이 생성되었지요.

```cpp-formatted
marine1.show_status();
marine2.show_status();
```



이제 위 함수들을 통해서 각각의 마린의 상태를 출력한 뒤에,


```cpp-formatted
cout << endl << "마린 1 이 마린 2 를 공격! " << endl;
marine2.be_attacked(marine1.attack());
```



마린 2 가 마린 1 로 부터 공격을 받는 상황을 그렸습니다. 어때요? 정말 단순한 코드이지요?


그런데 사실 위 코드에는 약간의 문제가 있습니다 (스타에서의 진짜 마린의 비해 너무 빈약한거 아니냐?? 라는 지적 말고) 만약에 실제 게임 에서 처럼 수십 마리의 마린들이 서로 뒹여켜 싸우기라도 하면 어떨까요.

그럴 때는 `marine1, marine2` 와 같이 일일히 이름 붙이기도 벅찰 뿐더러, 사용자가 몇 개의 마린을 만들겠다라고 컴파일 시점에 정해버리는 것도 아니기 때문에 수십개의 `marine1, marine2...` 를 미리 만들 수 도 없는 격입니다. 그럼 어떡할께요? 답은 단순합니다. `marine` 들을 배열로 정해버리면 되지요.

```cpp-formatted
/* int main 전 까지 내용은 동일 */
int main() {
  Marine* marines[100];

  marines[0] = new Marine(2, 3);
  marines[1] = new Marine(3, 5);

  marines[0]->show_status();
  marines[1]->show_status();

  cout << endl << "마린 1 이 마린 2 를 공격! " << endl;

  marines[0]->be_attacked(marines[1]->attack());

  marines[0]->show_status();
  marines[1]->show_status();

  delete marines[0];
  delete marines[1];
}
```




성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F253FDC4E50E8394E27FA58)






로 동일하게 나옵니다.


예전에, `new` 와 `delete` 에 대해서 배울 때 `malloc` 과의 차이점에 대해서 잠깐 언급 했던 것이 기억 나나요? 그 때는 아직 내용을 다 배우지 못해서, `new` 와 `malloc` 모두 동적으로 할당하지만 '무언가' 다르다고 했었는데, 위 코드에서 여러분들은 아마 눈치 채셨을 것이라 생각됩니다. 바로` new` 의 경우 객체를 동적으로 생성하면서와 동시에 자동으로 생성자도 호출해준다는 점입니다.


```cpp-formatted
marines[0] = new Marine(2, 3);
marines[1] = new Marine(3, 5);
```



위와 같이 `Marine(2,3)` 과 `Marine(3,5)` 라는 생성자를 자동으로 호출해주지요. 이것이 바로 C++ 에 맞는 새로운 동적 할당이라고 볼 수 있습니다.


```cpp-formatted
marines[0]->show_status();
marines[1]->show_status();
```



물론 `Marine` 들의 포인터를 가리키는 배열이기 때문에 메소드를 호출할 때 . 이 아니라 `->` 를 사용해줘야 되겠지요. 마지막으로, 동적으로 할당한 메모리는 언제나 해제해 주어야 된다는 원칙에 따라


```cpp-formatted
delete marines[0];
delete marines[1];
```



를 해주어야 하겠지요.


###  소멸자 (Destructor)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F26610A3850EAED8E11FFC5)

알고 보니 각각의 마린에도 이름을 지정할 수 있었습니다. 그래서, 우리는 만들어놓은 `Marine` 클래스에 `name` 이라는 이름을 저장할 수 있는 또다른 인스턴스 변수를 추가하도록 합시다.

```cpp-formatted
// 마린의 이름 만들기
#include <string.h>
#include <iostream>
using namespace std;

class Marine {
  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  int damage;            // 공격력
  bool is_dead;
  char* name;  // 마린 이름

 public:
  Marine();                                       // 기본 생성자
  Marine(int x, int y, const char* marine_name);  // 이름까지 지정
  Marine(int x, int y);  // x, y 좌표에 마린 생성

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.
};
Marine::Marine() {
  hp = 50;
  coord_x = coord_y = 0;
  damage = 5;
  is_dead = false;
  name = NULL;
}
Marine::Marine(int x, int y, const char* marine_name) {
  name = new char[strlen(marine_name) + 1];
  strcpy(name, marine_name);

  coord_x = x;
  coord_y = y;
  hp = 50;
  damage = 5;
  is_dead = false;
}
Marine::Marine(int x, int y) {
  coord_x = x;
  coord_y = y;
  hp = 50;
  damage = 5;
  is_dead = false;
  name = NULL;
}
void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return damage; }
void Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;
}
void Marine::show_status() {
  cout << " *** Marine : " << name << " ***" << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}

int main() {
  Marine* marines[100];

  marines[0] = new Marine(2, 3, "Marine 2");
  marines[1] = new Marine(1, 5, "Marine 1");

  marines[0]->show_status();
  marines[1]->show_status();

  cout << endl << "마린 1 이 마린 2 를 공격! " << endl;

  marines[0]->be_attacked(marines[1]->attack());

  marines[0]->show_status();
  marines[1]->show_status();

  delete marines[0];
  delete marines[1];
}
```




성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1568333450E8668B0D88C5)



와 같이 나옴을 알 수 있습니다.


그런데 사실, 위 코드에는 또다른 문제점이 있습니다.

```cpp-formatted
Marine::Marine(int x, int y, const char* marine_name) {
  name = new char[strlen(marine_name) + 1];
  strcpy(name, marine_name);
  coord_x = x;
  coord_y = y;
  hp = 50;
  damage = 5;
  is_dead = false;
}
```

우리는 분명히 위 코드에서 `name` 에 우리가 생성하는 마린의 이름을 넣어줄 때, `name` 을 동적으로 생성해서 문자열을 복사하였는데요, 그럼, 이렇게 동적으로 할당된 `char` 배열에 대한 `delete` 는 언제 이루어지는 것인가요?

안타깝게도, 우리가 명확히 `delete` 를 지정하지 않는 한 자동으로 `delete` 가 되는 경우는 없습니다. 다시 말해서 우리가 동적으로 할당했던 저 `name` 은 영원히 메모리 공간 속에서 둥둥 떠다닌다는 말이지요. 사실 몇 바이트 정도 밖에 되지 않을 것이지만 위와 같은 `name` 들이 쌓이고 쌓이게 되면 **메모리 누수 (Memory Leak)** 이라는 문제점이 발생하게 됩니다 (가끔 몇몇 프로그램들이 비정상적으로 많은 메모리를 점유하는 것 보이시지 않나요?)


그렇다면, 만일 `main` 함수 끝에서 `Marine` 이 `delete` 될 때, 즉 우리가 생성했던 객체가 소멸 될 때 자동으로 호출되는 함수 - 마치 객체가 생성될 때 자동으로 호출 되었던 생성자 처럼 소멸 될 때 자동으로 호출되는 함수가 있다면 얼마나 좋을까요? 놀랍게도 이미 C++ 에서는 이 기능을 지원하고 있습니다. 바로 **소멸자(Destructor)** 이죠.


```cpp-formatted
#include <string.h>
#include <iostream>
using namespace std;

class Marine {
  int hp;                // 마린 체력
  int coord_x, coord_y;  // 마린 위치
  int damage;            // 공격력
  bool is_dead;
  char* name;  // 마린 이름

 public:
  Marine();                                       // 기본 생성자
  Marine(int x, int y, const char* marine_name);  // 이름까지 지정
  Marine(int x, int y);  // x, y 좌표에 마린 생성
  ~Marine();

  int attack();                       // 데미지를 리턴한다.
  void be_attacked(int damage_earn);  // 입는 데미지
  void move(int x, int y);            // 새로운 위치

  void show_status();  // 상태를 보여준다.
};
Marine::Marine() {
  hp = 50;
  coord_x = coord_y = 0;
  damage = 5;
  is_dead = false;
  name = NULL;
}
Marine::Marine(int x, int y, const char* marine_name) {
  name = new char[strlen(marine_name) + 1];
  strcpy(name, marine_name);

  coord_x = x;
  coord_y = y;
  hp = 50;
  damage = 5;
  is_dead = false;
}
Marine::Marine(int x, int y) {
  coord_x = x;
  coord_y = y;
  hp = 50;
  damage = 5;
  is_dead = false;
  name = NULL;
}
void Marine::move(int x, int y) {
  coord_x = x;
  coord_y = y;
}
int Marine::attack() { return damage; }
void Marine::be_attacked(int damage_earn) {
  hp -= damage_earn;
  if (hp <= 0) is_dead = true;
}
void Marine::show_status() {
  cout << " *** Marine : " << name << " ***" << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}
Marine::~Marine() {
  cout << name << " 의 소멸자 호출 ! " << endl;
  if (name != NULL) {
    delete[] name;
  }
}
int main() {
  Marine* marines[100];

  marines[0] = new Marine(2, 3, "Marine 2");
  marines[1] = new Marine(1, 5, "Marine 1");

  marines[0]->show_status();
  marines[1]->show_status();

  cout << endl << "마린 1 이 마린 2 를 공격! " << endl;

  marines[0]->be_attacked(marines[1]->attack());

  marines[0]->show_status();
  marines[1]->show_status();

  delete marines[0];
  delete marines[1];
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1845C14550E8690807C5D5)



와 같이 나오게 됩니다.




생성자가 클래스 이름과 똑같이 생겼다면 소멸자는 그 앞에 `~` 만 붙여주시면 됩니다.

```info
~(클래스의 이름)
```



우리의 `Marine` 클래스의 소멸자의 경우

```cpp-formatted
~Marine();
```



위와 같이 생겼지요. 생성자와 한 가지 다른 점은, 소멸자는 인자를 아무것도 가지지 않는다는 것입니다. 생각해보세요. 소멸하는 객체에 인자를 넘겨서 무엇을 하겠습니까? 다시 말해, 소멸자는 오버로딩도 되지 않습니다.


우리의 소멸자의 내용을 살펴보자면


```cpp-formatted
Marine::~Marine() {
  cout << name << " 의 소멸자 호출 ! " << endl;
  if (name != NULL) {
    delete[] name;
  }
}
```

위와 같이 `name` 이 `NULL` 이 아닐 경우에 (즉 동적으로 할당이 되었을 경우에) 만 `delete` 로 `name` 을 삭제하는 것을 알 수 있습니다. 참고로 `name` 자체가 `char` 의 배열로 동적할당 하였기 때문에 `delete` 역시 `delete [] name,` 즉 `[]` 를 꼭 써주어야만 합니다.

```cpp-formatted
delete marines[0];
delete marines[1];
```

객체가 소멸될 때 소멸자가 호출된다고 출력하도록 했는데, 실제로 위 코드가 실행 시 소멸자 호출 메세지가 뜬다는 것을 확인할 수 있습니다.

```cpp-formatted
// 소멸자 호출 확인하기
#include <string.h>
#include <iostream>
using namespace std;

class Test {
  char c;

 public:
  Test(char _c) {
    c = _c;
    cout << "생성자 호출 " << c << endl;
  }
  ~Test() { cout << "소멸자 호출 " << c << endl; }
};
void simple_function() { Test b('b'); }
int main() {
  Test a('a');
  simple_function();
}
```

성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2560573750E8FA8A309B30)

와 같이 나옵니다. 위 코드에서 여러분은 '객체가 파괴될 때 호출되는 소멸자' 를 확실하게 확인할 수 있었을 것입니다.

```cpp-formatted
class Test {
  char c;

 public:
  Test(char _c) {
    c = _c;
    cout << "생성자 호출 " << c << endl;
  }
  ~Test() { cout << "소멸자 호출 " << c << endl; }
};
```

`Test` 클래스는 매우 간단한데, 생성자와 소멸자 호출 때 어떤 객체의 것이 호출되는지 확인하기 위해 `char c` 를 도입하였습니다.


```cpp-formatted
int main() {
  Test a('a');
  simple_function();
}
```

일단 가장 먼저 `main` 함수에서 `a` 객체를 생성하였으므로 `a` 의 생성자가 호출됩니다. 그리고 `simple_function` 을 실행하게 되면,


```cpp-formatted
void simple_function() { Test b('b'); }
```

`simple_function` 안에서 또 `b` 객체를 생성하므로 `b` 의 생성자가 호출되지요. 하지만 `b` 는 `simple_function` 의 지역 객체이기 때문에 `simple_function` 이 종료됨과 동시에 `b` 역시 소멸되게 됩니다. 따라서 끝에서 `b` 의 소멸자가 호출되지요.


```cpp-formatted
int main() {
  Test a('a');
  simple_function();
}
```

`simple_function` 호출 후, 이제 `main` 함수가 종료될 때 마찬가지로 `main` 함수의 지역 객체였던 `a` 가 소멸되면서 `a` 의 소멸자가 호출됩니다. 자, 이제 그러면 왜 출력 결과가 `a - b - b - a` 순으로 나타났는지 이해가 되셨나요?


소멸자가 뭐 별거 있어? 라고 생각하시는 분들도 있겠지만, 사실은 소멸자의 역할은 상당히 중요합니다. 이 세상에 태어나는 일이 중요한 일이지만, 그 보다 더 중요한 일은 이 세상을 떠날 때 얼마나 깔끔하게 떠나는 지가 더욱 중요한 일이 듯이, 객체가 다른 부분에 영향을 끼치지 않도록 깔끔하게 소멸되는 일은 매우 중요한 일입니다.


소멸자가 하는 가장 흔한 역할은 위에서도 나타나 있지만, 객체가 동적으로 할당받은 메모리를 해제하는 일이라고 볼 수 있습니다. 그 외에도 (아직 배우진 않았지만) 쓰레드 사이에서 `lock` 된 것을 푸는 역할이라던지 등의 역할을 수행하게 됩니다.


참고로 우리가 따로 생성자를 정의하지 않더라도 디폴트 생성자가 있었던 것 처럼, 소멸자도 **디폴트 소멸자(Default Destructor)**가 있습니다. 물론, 디폴트 소멸자 내부에선 아무런 작업도 수행하지 않습니다. 만일 소멸자가 필요 없는 클래스라면 굳이 소멸자를 따로 써줄 필요는 없습니다.



###  복사 생성자


사실 스타 유즈맵을 조금이나마 해본 사람이라면 아래 그림과 같은 '포토캐논 겹치기' 정도는 한 번 접해보셨을 것입니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1943D23F50E8DCF635139F)

사실 위에 나타나 있는 포토캐논의 모습은 한 개가 아니라 수십 개의 포토캐논이 서로 겹친 모습입니다. 다시 말해 같은 포토캐논들이 수 백개 '복사' 되었다고 볼 수 있지요. 위와 같이 동일한 포토캐논을 만들어 내는 방법은 각각의 포토캐논을 일일히 생성자로 생성 할 수 도 있지만, 1 개만 생성해 놓고, 그 한 개를 가지고 나머지 포토캐논들은 '복사 생성' 할 수 도 있는 것입니다.

```cpp-formatted
// 포토캐논
#include <string.h>
#include <iostream>
using namespace std;

class Photon_Cannon {
  int hp, shield;
  int coord_x, coord_y;
  int damage;

 public:
  Photon_Cannon(int x, int y);
  Photon_Cannon(const Photon_Cannon& pc);

  void show_status();
};
Photon_Cannon::Photon_Cannon(const Photon_Cannon& pc) {
  cout << "복사 생성자 호출 !" << endl;
  hp = pc.hp;
  shield = pc.shield;
  coord_x = pc.coord_x;
  coord_y = pc.coord_y;
  damage = pc.damage;
}
Photon_Cannon::Photon_Cannon(int x, int y) {
  cout << "생성자 호출 !" << endl;
  hp = shield = 100;
  coord_x = x;
  coord_y = y;
  damage = 20;
}
void Photon_Cannon::show_status() {
  cout << "Photon Cannon " << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}
int main() {
  Photon_Cannon pc1(3, 3);
  Photon_Cannon pc2(pc1);
  Photon_Cannon pc3 = pc2;

  pc1.show_status();
  pc2.show_status();
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F0258084050E90978091530)

와 같이 나옵니다.


먼저 우리가 제작한 **복사 생성자 (copy constructor)** 부터 살펴보도록 합시다.

```cpp-formatted
Photon_Cannon(const Photon_Cannon& pc);
```

사실 위는 복사 생성자의 표준적인 정의라고 볼 수 있습니다. 즉, 복사 생성자는 어떤 클래스 `T` 가 있다면

```cpp-formatted
T(const T& a);
```

라고 정의됩니다. 즉, 다른 `T` 의 객체 `a` 를상수 레퍼런스로 받는 다는 이야기 입니다. 여기서 `a` 가 `const` 이기 때문에 우리는 복사 생성자 내부에서 `a` 의 데이터를 변경할 수 없고, 오직 새롭게 초기화 되는 인스턴스 변수들에게 '복사' 만 할 수 있게 됩니다. 다시 말해,


```cpp-formatted
Photon_Cannon::Photon_Cannon(const Photon_Cannon& pc) {
  cout << "복사 생성자 호출 !" << endl;
  hp = pc.hp;
  shield = pc.shield;
  coord_x = pc.coord_x;
  coord_y = pc.coord_y;
  damage = pc.damage;
}
```

위와 같이 복사 생성자 내부에서 `pc` 의 인스턴스 변수들에 접근해서 객체의 `shield, coord_x, coord_y` 등을 초기화 할 수 는 있지만

```cpp-formatted
pc.coord_x = 3;
```

처럼 `pc` 의 값 자체는 변경할 수 없다는 이야기 입니다. (왜냐하면 `const` 레퍼런스로 인자를 받았기 때문이죠! 아직도 이해가 안되시면 이전에 [포인터에서 const 의](http://itguru.tistory.com/24) [용법](http://itguru.tistory.com/24)을 떠올려보시기 바랍니다. 정확히 하는 동작이 동일합니다.)


한 가지 중요한 점은 함수 내부에서 받은 인자의 값을 변화시키는 일이 없다면 꼭 `const` 를 붙여주시기 바랍니다. 위와 같이 복사 생성자의 경우도, 인자로 받은 `pc` 의 값을 변경할 일이 없기 때문에 아예 처음부터 `const` 인자로 받았지요. 이렇게 된다면 후에 발생 할 수 있는   실수들을 효과적으로 막을 수 있습니다. (예를 들어 `pc.coord_x = coord_x` 로 쓴다던지)


```warning
인자로 받는 변수의 내용을 함수 내부에서 바꾸지 않는다면 앞에 const 를 붙여 주는 것이 바람직합니다.
```


이제 위와 같이 정의된 복사 생성자를 실제로 어떻게 이용하는지 살펴보도록 합시다.

```cpp-formatted
Photon_Cannon pc1(3, 3);
Photon_Cannon pc2(pc1);
```

일단 `pc1` 은 `int x, int y` 를 인자로 가지는 생성자가 오버로딩 되었고, `pc2` 의 경우 인자로 `pc1` 을 넘겼으므로 복사 생성자가 호출되었음을 알 수 있습니다.

```cpp-formatted
Photon_Cannon pc3 = pc2;
```

그렇다면 위 코드는 어떻까요? 놀랍게도, 위 코드 역시 복사 생성자가 호출됩니다. C++ 컴파일러는 위 문장을 아래와 동일하게 해석합니다.

```cpp-formatted
Photon_Cannon pc3(pc2);
```

따라서 복사 생성자가 호출되게 되는 것입니다. 물론, 위는 아주아주 특별한 경우 입니다. 만일 그냥

```cpp-formatted
pc3 = pc2;
```

를 했다면 이는 평범한 대입 연산 이겠지만, 생성 시에 대입하는 연산, 즉 위에 같이 `Photon_Cannon pc3 = pc2;` 한다면, 복사 생성자가 호출되게 되는 것입니다. 이런식으로 `Photon_Cannon pc3 = pc2;` 를 해석함으로써 사용자가 상당히 직관적이고 깔끔한 프로그래밍을 할 수 있습니다.


참고로 한 가지 더 말하자면,


```cpp-formatted
Photon_Cannon pc3 = pc2;
```

와

```cpp-formatted
Photon_Cannon pc3;
pc3 = pc2;
```

는 엄연히 다른 문장입니다. 왜냐하면 위의 것은 말 그대로 복사 생성자가 1 번 호출되는 것이고, 아래 것은 그냥 생성자가 1 번 호출되고, `pc3 = pc2;` 라는 명령이 실행되는 것이지요. 다시 한 번 강조하지만, 복사 생성자는 오직 '생성' 시에 호출된다는 것을 명심하시면 됩니다.


그런데, 사실 디폴트 생성자와 디폴트 소멸자 처럼, C++ 컴파일러는 이미 **디폴트 복사 생성자(Default copy constructor)** 를 지원해 주고 있습니다. 위 코드에서 복사 생성자를 한 번 지워보시고 실행해보면, 이전과 정확히 동일한 결과가 나타남을 알 수 있습니다.  디폴트 복사 생성자의 경우 기존의 디폴트 생성자와 소멸자가 하는 일이 아무 것도 없었던 것과는 달리 실제로 '복사' 를 해줍니다.


만일 우리가 위 `Photon_Cannon` 의 디폴트 복사 생성자의 내용을 추정해 본다면


```cpp-formatted
Photon_Cannon::Photon_Cannon(const Photon_Cannon& pc) {
  hp = pc.hp;
  shield = pc.shield;
  coord_x = pc.coord_x;
  coord_y = pc.coord_y;
  damage = pc.damage;
}
```



와 같이 생겼을 것입니다. 대응되는 원소들을 말 그대로 1 대 1 복사해주게 됩니다. 따라서 위와 같이 간단한 클래스의 경우 귀찮게 복사생성자를 써주지 않고도 디폴트 복사 생성자만 이용해서 복사 생성을 쉽게 처리할 수 있습니다.


###  디폴트 복사 생성자의 한계


이번에도 위의 마린 처럼 포토 캐논의 이름을 지어줄 수 있다는 사실을 알고 클래스 `Photon_Cannon` 에 `char *name` 을 추가 해주었습니다. 그리고, 복사 생성자는 그냥 위에서 처럼 디폴트 복사 생성자를 사용하기로 했죠. 그 코드는 아래와 같습니다.

```cpp-formatted
// 디폴트 복사 생성자의 한계
#include <string.h>
#include <iostream>
using namespace std;

class Photon_Cannon {
  int hp, shield;
  int coord_x, coord_y;
  int damage;

  char *name;

 public:
  Photon_Cannon(int x, int y);
  Photon_Cannon(int x, int y, const char *cannon_name);
  ~Photon_Cannon();

  void show_status();
};

Photon_Cannon::Photon_Cannon(int x, int y) {
  hp = shield = 100;
  coord_x = x;
  coord_y = y;
  damage = 20;

  name = NULL;
}
Photon_Cannon::Photon_Cannon(int x, int y, const char *cannon_name) {
  hp = shield = 100;
  coord_x = x;
  coord_y = y;
  damage = 20;

  name = new char[strlen(cannon_name) + 1];
  strcpy(name, cannon_name);
}
Photon_Cannon::~Photon_Cannon() {
  // 0 이 아닌 값은 if 문에서 true 로 처리되므로
  // 0 인가 아닌가를 비교할 때 그냥 if(name) 하면
  // if(name != 0) 과 동일한 의미를 가질 수 있다.

  // 참고로 if 문 다음에 문장이 1 개만 온다면
  // 중괄호를 생략 가능하다.

  if (name) delete[] name;
}
void Photon_Cannon::show_status() {
  cout << "Photon Cannon :: " << name << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}
int main() {
  Photon_Cannon pc1(3, 3, "Cannon");
  Photon_Cannon pc2 = pc1;

  pc1.show_status();
  pc2.show_status();
}
```

컴파일 후 실행해보면 아래와 같은 오류를 만나게 될 것입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2366084650EA5E22315B30)



이럴 수가. 오래간만에 보는 런타임 오류입니다. 왜 이런 오류가 발생하였을까요? 분명히 디폴트 복사 생성자는 1 대 1 로 원소들 간의 정확한 복사를 수행해 준다고 했었는데 말이죠. 그럼 일단, 여기서 우리의 디폴트 복사 생성자가 어떻게 생겼는지 살펴보도록 합시다. 아마두 추정컨대, 컴파일러는 솔직하게 1 대 1 복사를 해주는 디폴트 복사 생성자를 아래와 같이 만들어 주었을 것입니다.

```cpp-formatted
Photon_Cannon::Photon_Cannon(const Photon_Cannon& pc) {
  hp = pc.hp;
  shield = pc.shield;
  coord_x = pc.coord_x;
  coord_y = pc.coord_y;
  damage = pc.damage;
  name = pc.name;
}
```

그렇다면 위 복사 생성자를 호출한 뒤에 `pc1` 과 `pc2` 가 어떻게 되었는지 살펴보도록 합시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F22164C4050EA5FBC054927)

당연히도, `hp, shield, ...` 그리고 `name` 까지 모두 같은 값을 갖게 됩니다. 여기서 `name` 이 같은 값 - 즉 두 개의 포인터가 같은 값을 가진 다는 것은 같은 주소 값을 가리킨다는 말이 됩니다. 즉, 우리는 `pc1` 의 `name` 이 동적으로 할당받아서 가리키고 있던 메모리 ("Cannon" 이라는 문자열이 저장된 메모리) 를 `pc2` 의 `name` 도 같이 가리키게 되는 것이지요.


물론 이 상태에서는 별 문제가 안됩니다. 뭐, 같은 메모리를 두 개의 서로 다른 포인터가 가리켜도 되기 때문이죠. 하지만 진짜 문제는 소멸자에서 일어납니다.


`main` 함수가 종료되기 직전에 생성되었던 객체들은 파괴되면서 소멸자를 호출하게 되죠. 만일 먼저 `pc1` 이 파괴되었다고 해봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F11769B4150EA60A022B9A3)

그러면 소멸자는 `pc1` 의 내용을 모두 파괴 함과 동시에 `0x125ADD3` 에 할당한 메모리 까지 `delete` 하게 됩니다. 그런데 문제는 `pc2` 의 `name` 이 해제된 메모리인 `0x125ADD3` 을 가리키고 있다는 것입니다.


```cpp-formatted
Photon_Cannon::~Photon_Cannon() {
  if (name) delete[] name;
}
```

`pc2` 에서 일단 `name` 은 `NULL` 이 아니므로 (0x125ADD3 이라는 주소값을 가지고 있음) `delete [] name` 이 수행되고, 이미 해제된 메모리에 접근해서 다시 해제하려고 하였기 때문에 (사실 접근한 것 자체만으로 오류) 위 그림과 같이 무서운 런타임 오류가 발생하게 됩니다. 그렇다면 이러한 문제를 막으로면 어떡할까요?


그 답은 간단합니다. 복사 생성자에서 `name` 을 그대로 복사하지 말고 따로 다른 메모리에 동적 할당을 해서 그 내용만 복사하면 되겠지요?이렇게 메모리를 새로 할당해서 내용을 복사하는 것을 **깊은 복사(deep copy)** 라고 부르며 아까 처럼 단순히 대입 만 해주는 것을 **얕은 복사(shallow copy)** 라고 부릅니다. 컴파일러가 생성하는 디폴트 복사 생성자의 경우 얕은 복사 밖에 할 수 없으므로 위와 같이 깊은 복사가 필요한 경우에는 사용자가 직접 복사 생성자를 만들어야 합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F0304814650EA6367159FB1)



위 과정을 그림으로 설명하자면 복사 생성자에서 `hp, shield` 와 같은 변수 들은 얕은 복사를 하지만, `name` 의 경우 따로 메모리를 할당해서 그 내용만 복사하는 깊은 복사를 수행하게 되는 것이지요. 그러면 소멸자에서도 메모리 해제시 각기 다른 메모리를 해제하는 것이기 때문에 전혀 문제가 발생하지 않습니다. 이를 바탕으로 복사 생성자를 만들어보면 아래와 같습니다.

```cpp-formatted
// 복사 생성자의 중요성
#include <string.h>
#include <iostream>
using namespace std;

class Photon_Cannon {
  int hp, shield;
  int coord_x, coord_y;
  int damage;

  char *name;

 public:
  Photon_Cannon(int x, int y);
  Photon_Cannon(int x, int y, const char *cannon_name);
  Photon_Cannon(const Photon_Cannon &pc);
  ~Photon_Cannon();

  void show_status();
};
Photon_Cannon::Photon_Cannon(int x, int y) {
  hp = shield = 100;
  coord_x = x;
  coord_y = y;
  damage = 20;

  name = NULL;
}
Photon_Cannon::Photon_Cannon(const Photon_Cannon &pc) {
  cout << "복사 생성자 호출! " << endl;
  hp = pc.hp;
  shield = pc.shield;
  coord_x = pc.coord_x;
  coord_y = pc.coord_y;
  damage = pc.damage;

  name = new char[strlen(pc.name) + 1];
  strcpy(name, pc.name);
}
Photon_Cannon::Photon_Cannon(int x, int y, const char *cannon_name) {
  hp = shield = 100;
  coord_x = x;
  coord_y = y;
  damage = 20;

  name = new char[strlen(cannon_name) + 1];
  strcpy(name, cannon_name);
}
Photon_Cannon::~Photon_Cannon() {
  if (name) delete[] name;
}
void Photon_Cannon::show_status() {
  cout << "Photon Cannon :: " << name << endl;
  cout << " Location : ( " << coord_x << " , " << coord_y << " ) " << endl;
  cout << " HP : " << hp << endl;
}
int main() {
  Photon_Cannon pc1(3, 3, "Cannon");
  Photon_Cannon pc2 = pc1;

  pc1.show_status();
  pc2.show_status();
}
```



성공적으로 컴파일 하였다면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1760A34550EA643721382F)



와 같이 제대로 작동하는 것을 볼 수 있습니다.



자, 이것으로 이번 강좌는 마치도록 하겠습니다. 사실 이 강좌에서 스타크래프트의 0.01% 도 구현 하지 못한 것이지만, 차츰 우리는 그 뼈대를 만들어 나갈 것입니다. 자, 모두 화이팅!


###  생각해보기

#### 문제 1

아래와 같은 문자열 클래스를 완성해보세요 (난이도 : 中)

```cpp-formatted
class string {
  char *str;
  int len;

 public:
  string(char c, int n);  // 문자 c 가 n 개 있는 문자열로 정의
  string(char *s);
  string(const string &s);
  ~string();

  void add_string(const string &s);   // str 뒤에 s 를 붙인다.
  void copy_string(const string &s);  // str 에 s 를 복사한다.
  int strlen();                       // 문자열 길이 리턴
};
```

##@ chewing-cpp-end
Link :  195
2013-01-05 16:17
----------------
title : 비주얼 스튜디오 2010 에서 C 및 C++ 프로그래밍 하기
publish_date : 2013-01-05 16:17
--------------

```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```


```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```


안녕하세요 여러분! 제가 [첫 씹어먹는 C 언어 강좌](http://itguru.tistory.com/5)를 올렷을 때가 벌써 2009년 초 일때, 그러니까 한창 마이크로소프트에서 `Visual Studio 2008 Express` 버전을 공개해서 시끌시끌 했을 때 였습니다. 그 후로 시간이 무려 4년 이나 흘렀네요. 이제는 `Visual Studio 2008` 이 아니라, `Visual Studio 2012` 를 바라볼 시간이 되었습니다.


하지만 안타까운 일은 `Visual Studio 2012 Express` 버전이 애석하게도윈도우 8 에서만 돌아간다는 점 윈도우 7 이상에서만 돌아간다는 점입니다. 아마도 이 글을 읽고 계신 여러분 대부분은 윈도우 8 을 설치하지 않으셨을 텐데요, 하지만 걱정하지는 마세요. 저희에게는 `Visual Studio 2012` 만큼이나 강력한 `Visual Studio 2010 Express` 버전이 있으니까요. 적어도 C++ 컴파일러로써의 역할로는 두 소프트웨어가 거의 비슷하다고 볼 수 있습니다. 그렇기에, 혹시라도 '헉 2년이나 전 버전을 쓰는게 꿀리는거 아니야?' 라는 생각은 버려두세요.


제가 이 강좌를 쓰는 이유는 씹어먹는 C 언어 첫 강좌에서 비주얼 스튜디오 2008 버전을 설치하는 것으로 시작하였는데 많은 여러분들이 링크가 깨졌고 너무 오래된 것 아니냐라는 문의가 계속 들어와서 새롭게 업데이트를 하기로 하였습니다. (참고로 2008 버전은 [여기서 다운 받을 수 있습니다](http://www.microsoft.com/en-us/download/details.aspx?id=6506)`. )`


일단 다음 [링크를 클릭하셔서 들어가시기 바랍니다.](http://www.microsoft.com/visualstudio/eng/downloads)
 [http://www.microsoft.com/visualstudio/eng/downloads](http://www.microsoft.com/visualstudio/eng/downloads)


아래로 조금 스크롤 하다보면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F193DED3850E7D22524EF0E)



위와 같이 `Visual Studio 2010 Express` 라고 큼지막하게 써져 있는 것을 보실 수 있는데, 여기서 `Visual Studio C++ 2010 Express` 를 클릭해주시기 바랍니다. 그러면, 아래와 같이 밑에 쭈르륵 나옵니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F2054B73550E7D2B513AE75)





참고로 언어를 한국어로 바꿀 수 있지만 그냥 영어 버전으로 설치하시기 바랍니다. 그게 나중에 더 편하고, 또 여러 옵션 설정할 때 영어 버전 기준으로 설명해 놓은 것이 많기 때문에 영어버전으로 택하는 것이 도움이 됩니다. 그래서 `Install now` 를 누르시면 프로그램을 다운 받을 수 있고 그 프로그램을 실행시키면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F112EDC3850E7D2252B340C)





위와 같이 `Visual Studio C++ 2010` 을 설치한다는 화면이 뜨게 됩니다. `Next` 를 누르면




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F212E443850E7D2252CE10D)



여러가지 약관 이야기가 나오는데 물론 읽었다고 표시하고 `Next` 를 누릅니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1529293850E7D225317C72)



`Microsoft SQL Server 2008 Express` 를 받을 것이냐고 물어보는데, 받지 맙시다. C++ 이나 C 공부에는 아무 상관 없는 프로그램이므로 공간만 차지할 뿐입니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F222FC93850E7D2262B4F44)



그래서 `Install` 을 누르면 실제 웹에서 프로그램을 다운로드 하게 됩니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F202D9B3850E7D2262C8B6A)



위와 같은 인스톨 화면이 끝나게 되면, 이제 프로그램을 실행할 수 있게 됩니다.





![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F0239843450E7FC560AE84B)



프로그램을 실행 시킨 후 위와 같이 메뉴바에서 `File` → `New` → `Project` 를 클릭하면





![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F02154F3450E7FC57358833)



위와 같이 왼쪽의 `Templates` 에서 `Win32` 를 누른 뒤, `Win 32 Console Application` 을 선택하고 (반드시 `Console Application),` 하단에 `Name` 에 자신의 프로젝트 이름을 입력해주세요. 저의 경우 `Hello` 를 입력하였습니다. 그리고 마지막으로 `OK` 를 누르면 프로젝트가 생성됩니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F021B1F3450E7FC552B4726)



`Next` 를 누릅니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F0215093450E7FC55347D9D)



여기서는 프로젝트 설정을 하는 곳인데요, 일단 `Application Type` 에 `Console application` 이 선택되었을 것이고, `Additional Options` 에 `Empty Project` 를 눌러줍니다. 그리고 `Finish` 를 누르면 프로젝트가 생성됩니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F131DAA3450E7FC552988BA)



프로젝트가 생성되었다면 위와 같이 왼쪽 사이드바에 `Solution` 'Hello' 라고 생성되었고 여러 폴더들이 있는 것을 볼 수 있는데요, `Source Files` 를 택한 뒤 마우스 오른쪽 클릭을 해서 `Add` → `New Item` 을 해서 소스 파일을 만들어줍시다.



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F023D683450E7FC5604530B)



왼쪽에서 `Code` 를 선택한 뒤에 `C++ File` 을 누르고, 아래 `Name` 에 소스 파일 이름을 적어주면 됩니다. 저는 그냥 `new` 라고 적었습니다. `Add` 를 누르면 소스 파일이 새로 추가됩니다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F213F513450E7FC56025B8D)



여기서 주의해야 할 부분은, C++ 프로그래밍하는 분들은 그냥 나두고C 언어 프로그래밍 하는 분들은 위와 같이 파일을 누르고 오른쪽 클릭을 해서 `Rename` 을 눌러 확장자를 `.c` 로 바꿔주어야 한다는  C 언어 프로그래밍 하는 분들은 위와 같이 파일을 누르고 오른쪽 클릭을 해서 `Rename` 을 눌러 확장자를 `.c` 로 바꿔주어야 한다는 것입니다. 그냥 `.cpp` 로 하면 C++ 컴파일러가, `.c` 로 하면 C 컴파일러가 컴파일 하므로, C 언어를 습득하고자 하는 분은 꼭 `.c` 로 확장자를 변경해야 합니다.


그럼 여러분 모두 즐거운 프로그래밍 하시기 바랍니다.
Link :  194
2012-11-09 07:55
----------------
title : C++ 레퍼런스 - istream::peak 함수
cat_title :  istream::peak
ref_title : peak
publish_date : 2012-11-09 07:55
--------------

```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ istream::peek

```info

int peek ( );
```



그 다음 문자를 살짝 훔쳐본다(즉, 스트림에서 빼오지는 않고 읽기만 한다)
따라서 [get](http://itguru.tistory.com/191)처럼 스트림에서 문자를 빼내는 것이 아니라, 그 문자는 그냥 스트림에 남아있게 된다.

###  인자

없음



###  리턴값




그 다음 문자의 값을 리턴한다. 오류가 발생 시에 이 함수는 `EOF` 를 리턴하며, 내부 상태 플래그를 다음과 같은 상황에 맞게 변경하게 된다.

|플래그|오류|
|----|----|
|`eofbit`|작업 중 문자들의 끝에 도달하였을 때|
|`failbit`|-|
|`badbit`|위 같은 일들 외의 다른 오류가 발생시|


위와 같은 플래그들이 [ios::exceptions](http://itguru.tistory.com/150)함수들로 설정되었다면, ios_base::failure 가 `throw` 된다.



###  실행 예제


```cpp-formatted
/*


이 예제는
 [http://www.cplusplus.com/reference/iostream/istream/peek/](http://www.cplusplus.com/reference/iostream/istream/peek/)
에서 가져왔습니다.


*/
#include <iostream>
using namespace std;

int main() {
  char c;
  int n;
  char str[256];

  cout << "Enter a number or a word: ";
  c = cin.peek();

  if ((c >= '0') && (c <= '9')) {
    cin >> n;
    cout << "You have entered number " << n << endl;
  } else {
    cin >> str;
    cout << " You have entered word " << str << endl;
  }

  return 0;
}
```




실행 결과




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F205F8A46509C37A00C73BC)







###  템플릿 멤버 정의




```cpp-formatted
(basic_istream<charT, traits>)typedef traits::int_type int_type;
int_type peek();
```






###  연관된 함수

*  [istream::get](http://itguru.tistory.com/191): 스트림에서 서식화 되지 않은 데이터를 가져온다.
*  [istream::operator>>](http://itguru.tistory.com/147): 스트림에서 서식화 된 데이터를 가져온다.
Link :  193
2012-11-07 22:48
----------------
title : C++ 레퍼런스 - istream::ignore 함수
cat_title :  istream::ignore
ref_title : ignore
publish_date : 2012-11-07 22:48
--------------

```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ istream::ignore

```info

istream&  ignore ( streamsize n = 1, int delim = EOF );
```

문자를 스트림에서 입력 받고 버린다.


문자를 스트림에서 입력 받는 작업은 `n` 개의 문자를 읽어들이고 버렸거나, 제한 문자 `delim` 을 만났을 때 중단된다. 참고로, 후자의 경우 제한 문자 `delim` 역시 스트림에서 추출된다.

###  인자

`n`
추출할 최대 문자의 개수. 이는 `streamsize` 타입이다.
`delim`
제한 문자



###  리턴값


`*this` 를 리턴한다.
작업 도중 오류 발생시 다음과 같은 내부 상태 플래그의 값이 변화될 수 있다.

|플래그|오류|
|-----|----|
|`eofbit`|작업 중 문자들의 끝에 도달하였을 때|
|`failbit`| -|
|`badbit`|위 같은 일들 외의 다른 오류가 발생시|



위와 같은 플래그들이 [ios::exceptions](http://itguru.tistory.com/150)함수로 설정되었다면, `ios_base::failure` 가 `throw` 된다.


###  실행 예제





```cpp-formatted
/*


이 예제는
 [http://www.cplusplus.com/reference/iostream/istream/ignore/](http://www.cplusplus.com/reference/iostream/istream/ignore/)
에서 가져왔습니다.


*/
#include <iostream>
using namespace std;

int main() {
  char first, last;

  cout << "Enter your first and last names: ";

  first = cin.get();
  cin.ignore(256, ' ');  // 스트림에서 ' ' 를 지워버린다.

  last = cin.get();

  cout << "Your initials are " << first << last;

  return 0;
}
```

실행 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F01016F33509A678D2D4CCE)


###  템플릿 멤버 정의


```cpp-formatted
(basic_istream<charT, traits>)typedef traits::int_type int_type;
basic_istream& ignore(streamsize n = 1, int_type delim = traits::eof());
```

###  연관된 함수

*  [istream::peek](http://itguru.tistory.com/194): 그 다음 문자를 추출하지는 않고 읽기만 한다.
*  [istream::get](http://itguru.tistory.com/191): 스트림에서 서식화 되지 않는 데이터를 얻는다.
*  [istream::getline](http://itguru.tistory.com/149): 스트림에서 한 줄 입력받는다.
* istream::read : 데이터 블록을 읽는다.
* istream::readsome : 버퍼에 가능한 데이터 블록을 읽는다.
Link :  192
2012-11-07 22:16
----------------
title : C++ 레퍼런스 - istream::gcount 함수
cat_title :  istream::gcount
ref_title : gcount
publish_date : 2012-11-07 22:16
--------------

```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ istream::gcount

```info

streamsize  gcount ( ) const;
```



마지막 서식화 되지 않은 (unformatted) 입력 작업에서 읽어들인 문자의 개수를 리턴한다.


서식화 되지 않는 작업을 하는 함수들은 [get](http://itguru.tistory.com/191), [getline](http://itguru.tistory.com/149), `ignore`, [peek](http://itguru.tistory.com/194), `read, readsome, putback, unget` 을 들 수 있는데, [peek](http://itguru.tistory.com/194), `putback, unget` 의 경우 문자를 추출하는 함수가 아니기 때문에 `gcount` 의 리턴값은 항상 0 이 되게 된다.

###  인자

없음

###  리턴값

`streamsize` 타입의 정수값으로, 마지막 서식화되지 않는 입력 작업에서 읽어들인 문자의 수를 리턴한다.

###  실행 예제


```cpp-formatted
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  char str[256];
  ifstream is;

  cout << "Enter the name of an existing text file: ";
  cin.get(str, 256);

  is.open(str);          // open file
  is.getline(str, 256);  // 파일의 내용을 읽는다.

  cout << str << endl;
  cout << is.gcount() << endl;  // 입력 받은 문자의 수

  is.close();  // close file

  return 0;
}
```



실행 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1320A43E509A5E7910D3F4)


###  템플릿 멤버 정의


```cpp-formatted
(basic_istream<charT, traits>)streamsize gcount() const;
```

###  연관된 함수

*  [istream::get](http://itguru.tistory.com/191): 스트림에서 서식화 되지 않은 데이터를 입력 받는다.
*  [istream::getline](http://itguru.tistory.com/149): 스트림에서 한 줄 입력받는다.
*  [istream::ignore](http://itguru.tistory.com/193): 스트림에서 문자를 받고 버린다.
* istream::read : 한 데이터 블록을 읽는다.
* istream::readsome : 버퍼에 가능한 데이터 블록을 읽는다.
Link :  191
2012-11-07 21:50
----------------
title : C++ 레퍼런스 - istream::get 함수
cat_title : istream::get
ref_title : get
publish_date : 2012-11-07 21:50
--------------

```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ istream::get

```info

int get();
istream& get ( char& c );
istream& get ( char* s, streamsize n );
istream& get ( char* s, streamsize n, char delim );
istream& get ( streambuf& sb);
istream& get ( streambuf& sb, char delim );
```



스트림에서 서식화되지(unformatted) 않는 데이터를 가져온다.
이 멤버 함수들은 서식화되지 않는 입력 연산을 수행한다. 함수 호출 시 인자의 타입과 개수에 따라서 다음과 같이 오버로딩 된다.


`int get();`

스트림에서 문자 한 개를 가져온뒤, 그 값을 리턴한다 (int 로 형변환 됨)


`istream& get ( char& c );`

스트림에서 문자 한 개를 가져온 뒤, `c` 에 저장한다.


`istream& get (char* s, streamsize n );`

스트림에서 문자들을 가져온 뒤, `s` 에 C 형식 문자열로 저장한다. 문자는제한 문자 '\n' 이 나올 때 까지나, `n - 1` 개의 문자를 받을 때 까지 입력받게 된다. 또한 입력 작업 시 오류가 발생할 경우 또한 중단되게 된다. 또한 이 함수는 제한 문자는 스트림에서 빼내지 않기 때문에 (즉, 다음 번 입력 시 가장 첫번째로 입력 받는 것이 그 제한 문자일 것이다) 만일 제한 문자를 스트림에서 빼내 버리기 위해서는 [getline](http://itguru.tistory.com/149)과 같은 함수를 이용해야만 한다. `s` 맨 마지막에는 자동으로 널 문자(Null terminating character)가 붙여지게 된다.


`istream& get (char* s, streamsize n, char delim );`

위와 동일하지만, 제한 문자를 '\n' 대신에 사용자가 임의로 지정할 수 있다.


`istream& get (streambuf& sb);`

스트림에서 문자들을 받는뒤, 이를 스트림 버퍼 `sb` 에 입력 한다. 문자는 제한 문자 '\n' 이 나올 때 까지나, 파일 끝에 도달할 때 까지 입력 받는다. 또한, 이 함수는 입력 스트림에서 입력 과정에 오류가 발생하였을 때나, `sb` 에서 출력시 오류가 발생하였을 때 중단하게 된다.


`istream& get (streambuf& sb, char delim );`

위와 동일하지만 제한 문자를 '\n' 대신에 사용자가 원하는 것으로 설정할 수 있다.


바로 직전의 입력 과정에서 읽어들인 문자의 수는 [gcount](http://itguru.tistory.com/192)함수로 알아 낼 수 있다.




###  인자


`c`

추출한 문자를 저장할 `char` 변수

`s`

추출한 문자열을 C 형식 문자열로 저장하기 위한 포인터

`n`

입력 받을 최대 문자의 수 (널 종료 문자열을 포함해서) 이는 또한 `streamsize` 타입의 정수값이다.

`delim`

제한 문자. 이 문자를 읽어들이기게 되면 입력 작업이 종료된다. 만일 이 문자를 사용자가 지정하지 않았다면 디폴트로 '\n' 이 설정된다.

`sb`

출력 스트림 버퍼 (streambuf 의 객체 혹은 이 스트림을 상속하고 있는 클래스들의 객체)


###  리턴값




맨 첫 번째 오버로딩의 경우 이 함수는 읽어들인 문자의 수를 리턴한다. 나머지 것들의 경우 `*this` 를 리턴한다.
스트림 상의 오류는 다음과 같은 내부 상태 플래그들로 설정된다.

|플래그|오류|
|-----|----|
|`eofbit`|작업 중 문자들의 끝에 도달하였을 때|
|`failbit`|끝에 바로 도달해버려서 어떠한 문자도 추출해 낼 수 없을 경우. (`streambuf` 를 사용하는 경우 sb 에 문자 출력 불가시에도 설정될 수 있다) 또한 `eofbit` 이 설정되는 경우 `failbit` 또한 같이 설정될 수 있다|
|`badbit`|위 같은 일들 외의 다른 오류가 발생시|


위와 같은 플래그들이 [ios::exceptions](http://itguru.tistory.com/150) 함수로 설정되었다면, `ios_base::failure` 가 `throw` 된다.


###  실행 예제




```cpp-formatted
/*


이 예제는
 [http://www.cplusplus.com/reference/iostream/istream/get/](http://www.cplusplus.com/reference/iostream/istream/get/)
에서 가져왔습니다.


*/
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  char c, str[256];
  ifstream is;

  cout << "Enter the name of an existing text file: ";
  cin.get(str, 256);

  is.open(str);  // open file

  while (is.good())  // loop while extraction from file is possible
  {
    c = is.get();  // get character from file
    if (is.good()) cout << c;
  }

  is.close();  // close file

  return 0;
}
```



실행 결과




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F130C9946509A59621796E3)







###  템플릿 멤버 정의




```cpp-formatted
(basic_istream<charT, traits>)

  typedef charT char_type;
int_type get();
basic_istream& get(char_type& c);
basic_istream& get(char_type* s, streamsize n);
basic_istream& get(char_type* s, streamsize n, char_type delim);
basic_istream& get(basic_streambuf<char_type, traits>& sb);
basic_istream& get(basic_streambuf<char_type, traits>& sb, char_type delim);
```

###  연관된 함수


*  [istream::getline](http://itguru.tistory.com/149): 스트림에서 한 줄을 입력받는다.
*  [istream::ignore](http://itguru.tistory.com/193): 문자를 스트림에서 입력받고 버린다.
*  [istream::gcount](http://itguru.tistory.com/192): 마지막 서식화되지 않는 입력 작업에서 입력 받은 문자의 수를 얻는다.
Link :  190
2012-11-07 20:19
----------------
title : C++ 레퍼런스 - ios::tie 함수
cat_title :  ios::tie
publish_date : 2012-11-07 20:19
--------------

```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```




#@ ios::tie




```info

ostream* tie ( ) const;
ostream* tie ( ostream* tiestr );
```



엮여진(tied) 스트림을 얻거나설정한다.
첫 번째 함수는 엮여진 출력 스트림을 가리키는 포인터를 리턴한다.
두 번째 함수는 tiestr 이 가리키는 객체와 엮고, 이전에 엮여져 있던 객체를 가리키는 포인터를 리턴한다.

디폴트로, 표준 객체인인 `cin, cerr, clog` 는 `cout` 에 엮여져 있고, 그들의 `wide character` 버전인 `wcin, wcerr, wclog` 는 `wcout` 에 엮여져 있다.






###  인자




`tiestr`
엮을 출력 스트림



###  리턴값




호출 이전에 엮여있던스트림 객체를 가리키는 포인터를 리턴한다. 만일 엮여있던 객체가 없다면 널 포인터를 리턴한다.



###  실행 예제




```cpp-formatted
/*


 처음에 *cin.tie() 를 통해 cout 에 내용을 출력한 뒤, cin.tie(&ofs) 로
 파일으로 엮여진 출력스트림을 변경 한 뒤, 다시 그 내용을 출력한다.
 이 예제는


 [http://www.cplusplus.com/reference/iostream/ios/tie/](http://www.cplusplus.com/reference/iostream/ios/tie/)


 에서 가져왔습니다.


*/
#include <fstream>
#include <iostream>
using namespace std;

int main() {
  ostream *prevstr;
  ofstream ofs;
  ofs.open("test.txt");

  cout << "tie example:" << endl;

  *cin.tie() << "This is inserted into cout";
  prevstr = cin.tie(&ofs);
  *cin.tie() << "This is inserted into the file";
  cin.tie(prevstr);

  ofs.close();

  return 0;
}
```



실행 결과



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F155C9141509A42E43CB76F)



파일에 출력된 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F0160DD43509A432F0179D7)




###  템플릿 멤버 정의


```cpp-formatted
(basic_ios<charT, traits>)basic_ostream<charT, traits>* tie() const;
basic_ostream<charT, traits>* tie(basic_ostream<charT, traits> tiestr);
```
Link :  189
2012-11-03 14:47
----------------
title : 씹어먹는 C++ 토막글 ① - Rvalue(우측값) 레퍼런스에 관해
publish_date : 2012-11-03 14:47
--------------

```warning
이 글은 http://thbecker.net/articles/rvalue_references/section_01.html 에서 가져왔고 한국말로 번역되었습니다. 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
이 글을 이해하기 위해서는 초보 이상의 C++ 지식이 필요합니다.
 아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```


안녕하세요? 이 글은 씹어먹는 C++ 과 이어지는 강좌는 아니고, 이번 새로나온 C++ 표준안 (C++11) 에 새로 포함되어 있는 `R-value` 레퍼런스, 흔히 말해 우측값 참조라는 새로운 기능에 대해 잘 정리 되어 있는 글을 번역한 내용 입니다. 원문은 [http://thbecker.net/articles/rvalue_references/section_01.html](http://thbecker.net/articles/rvalue_references/section_01.htmlhttp://thbecker.net/articles/rvalue_references/section_01.html) 에서 확인하실 수 있습니다.



###  서론


**우측값 참조(R value reference)** 는 C++ 11 표준안에 새롭게 추가된 C++ 의 새 기능 인데 상당히 이해하기 까다롭습니다. 저는 C++ 커뮤니티에서 많은 사람들이 다음과 같이 말하는 것을 매우 자주 보았습니다.

```warning
"내가 우측값 참조를 이해했다고 생각했었는데... 또 잘 모르겠네"
"망할 우측값 참조들! 들을 때 마다 뭔 소린지 잘 모르겠어"
"우측값 참조를 어떻게 가르칠지... 공포스럽다"
```

우측값 참조를 이해하기 위해 가장 짜증나는 부분은, 도대체 우측값 참조를 왜 도입하였으며, 이를 통해 무엇을 해결하고자 하는지가 명확하지가 않기 때문입니다. 따라서 는 우측값 참조를 이해하기 위해서는 막무가내로 그 정의부터 보는 일은 올바르지 않다고 생각합니다. 더 나은 방법은, 우측값 참조 이전에 C++ 에서 어떠한 문제들이 제기되어 왔으며, 우측값 참조 기능의 도입으로 이 문제를 어떻게 해결하였는지 알아가는 것이 우선이라고 생각합니다. 이를 통해 이 글을 읽는 여러분들은 우측값 참조의 정의가 조금 더 마음에 와닿고 더 자연스러울 것입니다.


사실 우측값 참조를 통해 적어도 다음 두 개의 문제를 해결 할 수 있었습니다.

```info
1. "move" 의 구현 (move semantics)
2. 완벽한 전달(perfect forwarding)
```

위 두 개의 문제에 대해 잘 모르겠더라도 걱정하실 필요 없습니다. 모두 아래에 다 잘 설명하였으니까요. 먼저, "move" 라는 것이 무엇인지 부터 살펴보도록 할 것인데요, 본론으로 들어가기 전에 C++ 에서 좌측값(lvalue) 와 우측값(rvalue) 가 무엇인지 부터 잠깐 동안 살펴보도록 합시다. 이들에 대한 완벽한 정의를 내리는 것은 조금 복잡한데요, 아래 예들을 보면 대충 무엇인지는 감이 잡힐 것입니다.
좌측값과 우측값의 대한 이전의 정의는 C 에서 부터 내려옵니다.

```info

"좌측값은 대입(assignment) 시에 왼쪽 혹은 오른쪽에 오는 식(expression)이고, 우측값은 대입 시에 오직 오른쪽에만 오는 식이다"
```



예를 들어

```cpp-formatted
int a = 42;
int b = 43;

// a 와 b 는 모두 좌측값이다.
a = b;      // ok
b = a;      // ok
a = a * b;  // ok

// a * b 는 우측값이다.
int c = a * b;  // ok. 우측값이 대입 연산에서 우측에 있으니까
a* b = 42;  // error. 우측값이 대입 연산에서 좌측에 있으니까
```



C++ 에서도 위와 같이 간단하게 생각 할 수 는 있지만, C++ 에서 여러가지 사용자 정의의 타입 때문에 C 에서의 정의가 직접적으로 들어맞지는 않습니다. 그래서 C++ 에서는 조금 다른 방법으로 정의를 하였는데, (물론 논쟁의 여지는 있지만) 이는 아래와 같습니다 C++ 에서도 위와 같이 간단하게 생각 할 수 는 있지만, C++ 에서 여러가지 사용자 정의의 타입 때문에 C 에서의 정의가 직접적으로 들어맞지는 않습니다. 그래서 C++ 에서는 조금 다른 방법으로 정의를 하였는데, (물론 논쟁의 여지는 있지만) 이는 아래와 같습니다.

```info
"좌측값은 어떠한 메모리 위치를 가리키는데, & 연산자를 통해 그 위치를 참조할 수 있다. 우측값은 좌측값이 아닌 값들이다"
```



예를 들면

```cpp-formatted
// 좌측값들
//
int i = 42;
i = 43;            // ok, i 는 좌측값
int* p = &i;       //&i 를 쓸 수 있다.
int& foo();        // int& 을 리턴하는 함수
foo() = 42;        // ok, foo() 는 좌측값
int* p1 = &foo();  // ok, &foo() 를 할 수 있다.

// 우측값들
//
int foobar();  // int 를 리턴하는 함수
int j = 0;
j = foobar();         // ok. foobar() 는 우측값이다
int* p2 = &foobar();  // error. 우측값의 주소는 참조할 수 없다.
j = 42;               // 42 는 우측값이다.
```






###  Move 의 구현 (Move Semantics)


`X` 를 어떠한 리소스에 대한 포인터(예를 들어 `m_pResource`) 를 담고 있는 클래스라고 생각합니다. 참고로 여기서 '리소스' 라고 말하는 것은, 생성 또는 복사, 소멸 하기에 많은 시간이 걸리는 거대한 어떤 무언가를 의미합니다. 클래스 `X` 의 가장 좋은 예로 `std::vector` 를 들 수 있습니다. 

`std::vector` 는 동적으로 할당 된 배열에 객체들을 보관하는 것인데요, 여태까지 C++ 을 충실히 배우신 분이라면 이 `X` 의 복사 대입 연산자는 아마 이렇게 구현하였을 것입니다.

```cpp-formatted
X& X::operator=(X const& rhs) {
  // [...]
  // m_pResource 가 가리키는 리소스를 소멸한다.
  // rhs.m_pResource 의 복제된 버전을 생성한다.
  // m_pResource 가 복제된 버전을 가리키게 한다
  // [...]
}
```



그리고 비슷한 방법으로 복사 생성자를 구현하였다면 아래 코드에서;

```cpp-formatted
X foo();  // foo 는 X 타입의 객체를 리턴하는 함수 이다!
X x;
x = foo();
```



위 소스의 마지막 줄에서는 만일 위의 X::operator= 의 과정을 따른다면 다음과 같은 일들이 진행됩니다.

```warning
1. x 가 가지고 있는 리소스가 소멸된다.
1. (foo 가 리턴한) 임시 객체의 리소스의 복제된 버전이 생성된다.
1. x 가 복제된 리소스를 가리키고, 임시로 생성된 객체의 리소스는 소멸된다.

```



하지만 위 과정은 단순히 생각해보아도, 임시로 생성된 객체의 리소스의 복사된 버전을 굳이 만들 필요가 없습니다. 그냥,임시로 생성된 객체가 가리키고 있는 `m_pResource` 를 `X` 의 `m_pResource` 와 서로 교환(swap) 만 해주면 됩니다. 그러면 어차피 나중에 임시 객체는 위 문장이 끝나면 알아서 소멸되니까 `X` 가 원래 가리키고 있던 객체도 소멸될 것이고, 또 임시 객체의 복사 버전을 만드는 고생스러운 일을 안해도 되니까 시간의 거의 `50%` 줄어들게 되는 것이지요 . 그러면 어차피 나중에 임시 객체는 위 문장이 끝나면 알아서 소멸되니까 `X` 가 원래 가리키고 있던 객체도 소멸될 것이고, 또 임시 객체의 복사 버전을 만드는 고생스러운 일을 안해도 되니까 시간의 거의 `50%` 줄어들게 되는 것이지요.


이와 같은 일이 가능했던 것은 위 `x = foo()` 에서 `foo()` 가 바로 우측값 이기 때문이입니다. 우측값을 대입하는 경우 다음과 같이 단순하게 복사 연산자를 구현할 수 있습니다.

```cpp-formatted
// [...]
// m_pResource 와 rhs.m_pResource 를 교환
// [...]
```



이를 바로 `move` 연산 이라고 하는 것입니다. `0x C++` 초기 버전에서는 위와 같은 과정이 템플릿 메타프로그래밍으로 가능했다는 이야기를 들었는데 분명 매우 복잡했을 것입니다. `C++11` 에서는 아래와 같은 함수의 오버로딩으로 구현할 수 있습니다.

```cpp-formatted
X& X::operator=(<미지의 타입> rhs) {
  // [...]
  //  m_pResource 와 rhs.m_pResource 를 교환
  // [...]
}
```



지금 우리는 복사 대입 연산자의 오버로드(overload)를 정의하고 있는 것입니다. 따라서 우리의 '미지의 타입' 은 레퍼런스 임에 분명하지요 (그리고 반드시 그렇게 되어야만 합니다)  또한 우리의 미지의 타입이 지켜야 할 것은, 기존의 레퍼런스 (&) 와 차별화를 두어서 '미지의 타입' 과 '보통의 레퍼런스 타입' 을 사용한 두 함수 사이에서 좌측값의 경우 '보통의 레퍼런스 타입' 을, 우측값의 경우 '미지의 타입' 을 택하도록 만들어야 할 것입니다.


그래서 C++ 개발자들은 이 미지의 타입에 **우측값 참조 (rvalue reference)**라는 이름을 붙였습니다.

###  우측값 참조 (rvalue reference)


임의의 타입 `X` 에 대해 `X&&` 를 `X` 의 우측값 참조라고 정의합니다. 또, 쉽게 구별하기 위해 기존의 레퍼런스 `X&` 를 좌측값 참조 라고 부르도록 합시다.


우측값 참조는 기존의 레퍼런스 `X&` 와 몇 가지 예외를 제외하고는 유사하게 작동합니다. 다만 둘의 가장 큰 차이점은 함수 오버로딩에서 좌측값은 좌측값 레퍼런스를, 우측값은 우측값 레퍼런스를 선호한다는 것이지요.

```cpp-formatted
void foo(X& x);   // 좌측값 참조 오버로드
void foo(X&& x);  // 우측값 참조 오버로드

X x;
X foobar();

foo(x);  // 인자에 좌측값이 들어 갔으므로 좌측값 참조 함수가 오버로딩
foo(foobar());  // 인자에 우측값이 들어 갔으므로 우측값 참조 함수가 오버로딩
```



내용을 요약해보자면


우측값 참조는 컴파일러로 하여금 컴파일 시에 자신의 인자로 좌측값이 오는지, 우측값이 오는지에 따라 오버로딩을 할 수 있도록 도와주는 것이라고 볼 수 있습니다.


어떠한 함수라도 인자로 우측값을 받도록 할 수 있지만, 대다수의 경우 `move` 연산을 위해서는 우측값 참조로 인자를 받는 경우는 복사 생성자나 대입 연산자들 밖에 없습니다.

```cpp-formatted
X& X::operator=(X const& rhs);  // 기존의 구현 방법
X& X::operator=(X&& rhs) {
  // Move 연산: this 와 rhs 의 내용을 swap 한다.
  return *this;
}
```



우측값 참조를 인자를 받는 복사 생성자를 구현하는 일도 역시 비슷합니다. 주의할 점은 위와 같이 우측값 참조하는 대입 연산자를 구현하는 것이 완벽하게 구현한 것은 아닙니다. 뒤에서 그 이유를 이야기 하겠지만, `this` 와 `rhs` 의 내용을 단순히 `swap` 하는 것 만으로 충분하지 않습니다.


한 가지 참고할 사항은 만일 여러분이
```cpp-formatted
void foo(X&);
```



만 구현하고

```cpp-formatted
void foo(X&&);
```



를 구현하지 않는다면, 예전부터 해왔던 것 처럼 `foo` 는 인자로 좌측값만 받을 수  있고 우측값을 받을 수 없습니다. 반면에 여러분이

```cpp-formatted
void foo(X const &);
```



만 구현하고

```cpp-formatted
void foo(X&&);
```



를 구현하지 않는다면, `foo` 는 좌측값 및 우측값 모두 인자로 받을 수 있지만, 좌측값과 우측값일 때를 구별해서 처리할 수 없기 때문에 `move` 연산시 많은 불필요한 작업이 수행됩니다. 따라서 이를 해결할 수 있는 유일한 방법은

```cpp-formatted
void foo(X&&);
```



를 구현하는 것인데, 만일 아래 두 함수들 중 어느 하나라도 정의하지 않는다면

```cpp-formatted
void foo(X &);
void foo(X const &);
```



오히려 좌측값을 제대로 처리할 수 없게 됩니다.



###  강제적으로 `move` 하기




우리가 잘 알고 있듯이 C++ 표준의 첫 번째 십계명에 따르면 "우리 C++ 위원회는 C++ 프로그래머의 (때론 무모하더라도) 자유를 막는 규칙을 만들면 안된다 - *The committee shall make no rule that prevents C++ programmers from shooting themselves in the foot* 라고 명시되어 있습니다.

조금 더 진지하게 말하자면, 만일 C++ 위원회에서 프로그래머에게 조금 더 많은 자유를 주는 것과, 많은 자유로 인해 실수를 하는 일을 막기 위해 자유를 억제하는 일 사이에서 고른다면, C++ 은 프로그래머의 실수를 야기할 수 있더라도 좀 더 많은 자유를 주는 것을 선호합니다.

따라서, 이러한 신념을 바탕으로 `C++11` 에서는 `move` 연산을 우측값에만 제공하는 것이 아닙니다. 프로그래머가 사용 시에 조금 더 주의를 기울여야 하겠지만, 좌측값에서도 사용할 수 있게 하였습니다. 가장 좋은 예로 표준 라이브러리의 `swap` 함수를 들 수 있습니다. 클래스 `X` 를 우측값에 대한 `move` 연산들이 적용된 복사 생성자와 대입 생성자가 있는 어떤 클래스로 생각합시다.

```cpp-formatted
template <class T>
void swap(T& a, T& b) {
  T tmp(a);
  a = b;
  b = tmp;
}

X a, b;
swap(a, b);
```



위 소스에는 우측값이 없습니다. 따라서 `swap` 코드의 3 줄 모두 `move` 연산을 사용하고 있지 않습니다. 하지만 우리는 이 과정에서 `move` 연산을 사용하더라도 무방하다는 사실을 잘 알고 있습니다. 왜냐하면 `swap` 의 소스에서 복사 및 대입 과정에서의 `source` 는 다시는 사용되지 않거나 다른 대입 및 복사연산의 `target` 으로 사용되기 때문이지요. (※ `target = source;` ) 다시 말해 `tmp(a)` 에서 `tmp` 에 `a` 를 아예 `move` 해도 상관 없는 것이고 `a = b;` 에서 `b` 를 굳이 `a` 에 복사할 필요 없이 그냥 `a` 에 `b` 를 `move` 해도 괜찮다는 것입니다.


따라서 `C++11` 에서는 표준 라이브러리 함수인 `std::move` 가 이를 위해 등장하였습니다. 이 함수는 인자로 받은 것을 우측값으로 바꿔주는 역할을 합니다. 따라서 `C++11` 에서 표준 라이브러리의 `swap` 함수는 아래와 같이 생겼습니다.

```cpp-formatted
template <class T>
void swap(T& a, T& b) {
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}

X a, b;
swap(a, b);
```



이를 통해 `swap` 코드의 세 줄에서 모두 `move` 연산을 할 수 있게 되었습니다. 한 가지 명심할 점은 만일 클래스 `T` 에 대해 `move` 연산을 구현하지 않았더라면 (즉, `T` 의 우측값 참조를 하는 복사 생성자와 대입 연산자를 제공하지 않음), 위 새로운 `swap` 함수는 그냥 예전의 `swap` 처럼 작동할 것입니다.


`std::move` 는 매우 단순한 함수 입니다. 하지만 일단은 어떻게 구현했는지는 나중에 설명하도록 하겠습니다.위 `swap` 함수 에서 처럼 어디에서든지 `std::move` 를 사용할 수 있는 일은 아래와 같은 장점들이 있습니다.

* `move` 연산을 구현하는 일은 여러 표준 알고리즘에 엄청난 속도 향상을 가져 옵니다. 예를 들어서 내부 정렬을 들을 수 있는데, 내부 정렬 알고리즘(퀵정렬, 버블 정렬 등등)은 오직 원소들 간의 `swap` 연산만을 하는데, `move` 연산 덕분에 `swap` 연산이 매우 빨라졌으므로 상당한 속도 향상이 되었습니다.
* 기존의 `STL` 에서는 많은 경우 특정 타입의 복사 가능(copyability)을 요구하였습니다. 하지만 자세한 조사 결과 많은 경우에 굳이 복사 가능 까지 보다 `move` 가능(moveability) 정도로 충분하다는 것을 밝혀내었습니다. 따라서 이제 우리는 `copy` 가능하지 않고 `move` 만 가능해서 사용 불가능 하였던 타입들에게 `STL` 을 사용할 수 있게 됩니다. 이렇게 새롭게 사용할 수 있게된 것으로는, 예를 들어 STL `Containter` 가 있습니다.



이제 우리는 `std::move` 에 대해 조금 알게 되었으니, 이전에 복사 대입 연산자의 우측값 레퍼런스를 이용한 구현이 조금 문제가 있었는지 이해할 수 있는 수준이 되었습니다. 아래와 같은 두 개 변수 사의 단순한 대입 연산을 생각해봅시다.

```cpp-formatted
a = b;
```



여기서 어떠한 일이 발생할까요? 아마 여러분은 `a` 에 보관되어 있던 객체가 `b` 의 복사본으로 교체될 것이고, 이 교체 과정에서 `a` 가 이전에 보관하였던 객체는 파괴될 것이라고 생각하실 수 있습니다. 그렇다면 아래의 예는 어떨까요?

```cpp-formatted
a = std::move(b);
```



일단 앞서 많은 경우 대입 연산자가 swap 으로 구현된다고 하였으므로 a 와 `b` 가 가리키는 객체들은 서로 교환되게 됩니다. 아직 이 과정에서 소멸되는 객체는 없습니다. 하지만 `a` 가 이전에 가리키고 있었던 객체는 언젠가는 소멸되는데, 정확히 말하자면 `b` 가 범위(scope) 를 벗어날 때 라고 볼 수 있습니다. 물론 만일 `b` 가 다시 `move` 연산을 수행하게 된다면 `a` 가 이전에 가리키는 객체 역시 교환되게 됩니다. 따라서, 복사 대입 연산자를 만든 사람 입장에서 볼 때 `a` 가 이전에 가리키는 객체가 언제 소멸될 지 예측할 수 없게 됩니다.


우리는 언제 객체가 소멸될지 모르는 끔찍한 상황에 직면하였습니다. 물론 객체가 소멸되지 않아도 별 문제를 야기하지 않는다면 상관이 없습니다만, 어떤 경우에는 객체의 소멸이 다른 영향을 끼칠 수 도 있다는 것입니다. 예를 들어서 소멸자 안에서 `thread` 의 `lock` 을 푼다 든지 말이지요. 따라서, 객체의 소멸 시에 수행되는 작업들이 외부에 다른 영향을 주게 된다면, 이는 반드시 우측값 참조 복사 생성자 내부에서 수행되어야만 합니다.

```cpp-formatted
X& X::operator=(X&& rhs) {
  // 소멸자에서 수행되는 내용들 중 외부에 영향을 줄 수 있는 것들은
  // 여기서 수행해야만 합니다. 물론 객체를 실제로 파괴하면 안되고
  // 언제나 대입 가능한 상태로 유지해야만 합니다.

  // Move 연산: this 와 rhs 의 내용을 swap 한다.

  return *this;
}
```


###  우측값 레퍼런스는 우측값 일까요?





이전처럼 `move` 를 사용하는 오버로딩 된 복사 생성자와 복사 대입 연산자가 있는 클래스라고 생각합시다. 그렇다면 아래와 같은 함수를 살펴봅시다.

```cpp-formatted
void foo(X&& x) {
  X anotherX = x;
  // ...
}
```



그렇다면 여기서 어떠한 `X` 의 복사 생성자가 `foo` 내부에서 호출이 되는 것일까요? 우측값을 인자로 받는 것일까요, 좌측값을 인자로 받는 것일까요? 여러분이 언뜻 보시기에 `x` 가 `X` 의 우측값 참조로 정의되어 있으니 아마도 우측값을 인자로 받는 복사 생성자가 호출이 될 것이라고 생각 하실 것입니다. 왜냐하면

```cpp-formatted
X(X&& rhs);
```



우측값을 인자로 받는 복사 생성자는 딱 `x` 에 들어 맞게 위 처럼 생겼기 때문이죠. 즉 여러분들은 어떤 변수가 우측값 참조라 선언되었다면, 그 자체 만으로 우측값이라 생각하시는 것입니다. 하지만 우측값 참조를 설계한 사람들은 다음과 같이 정의하였습니다.

```info

우측값 참조라 정의한 것들도 좌측값 혹은 우측값이 될 수 있다. 이를 판단하는 기준은,만일 이름이 있다면 좌측값, 없다면 우측값이다.
```


무슨말인지 잘 모르겠다면 아래의 예를 보면 이해가 더 빠릅니다. 아래 함수 내에서 `x` 는 우측값 레퍼런스로 정의되었고 이름이 있기 때문에 (x 라는 이름이 있잖아요!) 위 정의에 따라 좌측값 입니다.

```cpp-formatted
void foo(X&& x) {
  X anotherX = x;  // 좌측값 이므로 X(X const & rhs) 가 호출됨
}
```



반면에 아래의 `goo` 함수의 경우 `X&&` 타입의 데이터를 리턴하고 그 것의 이름은 없기 때문에 이는 우측값이 됩니다.

```cpp-formatted
X&& goo();
X x = goo();  // 이름이 없으므로 우측값. 즉 X(X&& rhs) 가 호출됨
```



여기서 우리는 왜 이러한 방식으로 설계를 하였는지 알 수 있습니다. 만일 아래와 같은 코드에서 이름이 있는 것에 `move` 연산을 적용하게 되면

```cpp-formatted
X anotherX = x;
// 만일 여기서 실수로 x 를 이용한 코드를 작성하면 ???
```



아직 `x` 가 `scope` 안에 있기 때문에 `x` 를 사용할 수 있지만 `x` 에는 지금 아무것도 들어있지 않은 상태이기에 실수로 사용하기라도 하면 어떠한 오류가 발생할지 아무도 모르는 것입니다. 즉 C++ 에서는 `move` 연산을 오직 '사용해도 상관 없는 곳' 에서만 사용하도록 되어 있기 때문에 (이동 즉시 소멸되서 아래에서 접근이 불가능 하게 된다) 위와 같이 "이름이 있다면 좌측값이다" 라고 정의한 것이지요.


그렇다면 "이름이 없다면 우측값이다" 는 어떨까요. 위의 `goo()` 를 살펴봅시다. 사실 드물게도 goo() 가 가리키는 객체가 `move` 이후에도 접근 가능한 것일 수 도 있는 것입니다. 그런데, 이전의 내용을 상기해보세요 - 우리가 종종 이 기능을 필요로 하지 않았나요? 우리는 앞에서 좌측값에 대해 강제적으로 `move` 연산을 적용시키기를 원했습니다. 그런데, 규칙에 따르면 "이름이 없다면 우측값이다" 를 통해 이를 성공적으로 수행할 수 있었지요. 이것이 바로 `std::move` 가 작동하는 원리 입니다. 사실 정확한 구현을 보여주기에는 아직도 갈길이 남아있지만, 우리는 `std::move` 를 이해하는데 한 발짝 더 가까이 다가갔습니다. 이 함수는 레퍼런스로 인자를 받은 뒤에 아무것도 하지 않고, 다시 이를 우측값 참조로 리턴하게 되는 것이지요. 따라서

```cpp-formatted
std::move(x)
```



는 우측값 참조로 정의되었고, 이름을 가지지 않습니다. 따라서 이는 우측값이 됩니다. 즉, `std::move` 는 "이름을 가리기" 를 통해 우측값이 아닌 인자 조차도 우측값으로 바꿔주는 역할을 합니다. 사실 이러한 '이름의 유무' 에 대한 규칙은 매우 중요하므로 잘 알고 계셔야 합니다. 예를 들어서 여러분이 `Base` 라는 클래스를 만들었고, `move` 연산을 `Base` 의 복사 생성자와 대입 연산자에 구현하였다고 해봅시다.

```cpp-formatted
Base(Base const& rhs);  // move 연산 아님
Base(Base&& rhs);       // move 연산
```



이제 여러분이 `Base` 를 상속 받은 `Derived` 라는 클래스를 만들었다고 생각합시다. `Derived` 클래스의 `Base` 클래스 부분에서 `move` 연산이 잘 작용하려면, 여러분은 반드시 `Derived` 에 복사 생성자와 대입 연산자를 오버로딩 해야 할 것입니다. 그럼 복사 생성자를 어떻게 구성하였는지 살펴볼까요. 좌측값을 사용한 버전은 단순합니다.

```cpp-formatted
Derived(Derived const& rhs) : Base(rhs) {
  // Derived 에 관련된 작업들
}
```



그렇다면 우측값을 사용한 버전은 어떨까요. 만일 여러분이 앞선 '이름에 관한 규칙' 을 잘 이해하지 못했더라면 아래와 같이 구현했을 것입니다.

```cpp-formatted
Derived(Derived&& rhs)
    : Base(rhs)  // wrong: rhs 는 좌측값!
{
  // Derived 에 관련된 작업들
}
```



위와 같이 한다면, `Base` 의 좌측값 버전의 복사 생성자가 호출될 것입니다. 왜냐하면 `rhs` 는 명백하게도 'rhs' 라는 이름이 있기에 좌측값이기 때문이죠. 우리가 `Base` 의 `move` 복사 생성자를 호출하려면 아래와 같이 해야 할 것입니다.

```cpp-formatted
Derived(Derived&& rhs)
    : Base(std::move(rhs))  // good: Base(Base&& rhs) 를 호출
{
  // Derived 에 관련된 작업들
}
```



###  Move 연산과 컴파일러 최적화




아래와 같은 함수의 정의를 살펴봅시다.
```cpp-formatted
X foo() {
  X x;
  // x 에 어떤 작업을 한다
  return x;
}
```



이전처럼 `X` 를 move 연산이 적용된 복사 생성자와 복사 대입 연산자가 있는 클래스라고 생각해봅시다. 위 함수를 잘 살펴본 여러분은, `move` 연산에 너무나 심취해버린 나머지 foo 의 리턴값과 `x` 와의 값 복사가 일어나고 있기 때문에 다음과 같이 `move` 연산을 적용해서 바꿀 것이라고 생각됩니다.

```cpp-formatted
X foo() {
  X x;
  // perhaps do something to x
  return std::move(x);  // making it worse!
}
```



사실 위와 같이 바꾸어 버리면 오히려 작업 속도를 더 늦추게 할 뿐입니다. 현대의 컴파일러들은 '리턴값 최적화(return value optimization)' 라는 작업을 통해서 `x` 를 생성한 뒤에 리턴값에 복사하는 것이 아니라, `x` 자체를 함수의 리턴값 부분에 생성해버리기 때문이지요.

사실 이렇게 되면 오히려 `move` 연산 보다 더 빠른 수행 시간 향상이 있게 됩니다. 따라서, 위 예에서도 볼 수 있듯이, 우측값 참조와 `move` 연산을 효율적으로 사용하기 위해서는 여러분은 현대의 컴파일러의 여러가지 기법들 (리턴값 최적화나 복사 생략(copy elision) 등등)을 잘 알고 계셔야만 할 것입니다.


###  완벽한 전달(perfect forwarding)


맨 처음에도 말했지만 우측값 참조를 통해 해결할 수 있는 문제로 `move` 연산 뿐만이 아니라 완벽한 포워딩 문제도 있습니다. 아래와 같은 간단한 `factory` 함수를 살펴보도록 합시다.
```cpp-formatted
template <typename T, typename Arg>
shared_ptr<T> factory(Arg arg) {
  return shared_ptr<T>(new T(arg));
}
```



명백하게도, 여기서 하고자 하는 일은 인자 `arg` 를 `T` 의 생성자에게 전달(forward) 하는 일입니다. 이상적으로 생각해볼 때, 인자 `arg` 가 생성자에게 마치 `factory` 함수가 없이 직접 전달되는 것처럼 전달되면 가장 좋겠지요. 즉 **완벽하게 전달(perfect forwarding)** 된다는 말입니다. 하지만 불행히도 위 코드는 이를 성공적으로 수행할 수 없습니다. 왜냐하면 위 `factory` 함수는 `call-by-value` 를 하기 때문인데, 특히 `T` 의 생성자가 인자를 레퍼런스로 가진다면 더욱 안좋지요.


가장 널리 쓰이는 해결책은 (boost::bind 에서 사용한 해결책) 바깥의 함수가 인자를 레퍼런스로 가지면 되는 것입니다.

```cpp-formatted
template <typename T, typename Arg>
shared_ptr<T> factory(Arg& arg) {
  return shared_ptr<T>(new T(arg));
}
```



위 방법은 좀 더 낫지만 완벽하지는 않습니다. 왜냐하면 이제 `factory` 함수는 우측값에 대해 성공적으로 호출이 되지 않기 때문이죠.

```cpp-formatted
factory<X>(hoo());  // error.
factory<X>(41);     // error.
```



이 문제는 인자를 `const` 참조로 바꾼다면 해결할 수 있습니다.

```cpp-formatted
template <typename T, typename Arg>
shared_ptr<T> factory(Arg const& arg) {
  return shared_ptr<T>(new T(arg));
}
```



그런데 이 방법 역시 두 개의 문제를 내포하고 있습니다. 만일 `factory` 가 한 개가 아니라 여러개의 인자를 가지고 있다면, 여러분은 `const` 와 `non-const` 참조 인자들의 모든 조합들에 대해 오버로드 함수를 제공해야만 할것입니다. 따라서 위와 같은 해결책은 만일 함수의 인자가 여러개라면 좋지 않음을 알 수 있습니다. 두 번째 문제로 위와 같은 전달은 `move` 연산을 할 수 없기 때문에 완벽하다고 볼 수 없습니다. 왜냐하면 `factory` 함수에서 `T` 의 복사생성자에 전달되는 인자는 좌측값이기 때문입니다.


이 문제들은 우측값 참조를 통해 해결할 수 있었습니다. 즉, 우측값 참조를 통해 오버로드 없이도 완벽한 전달 문제를 완벽하게 해결할 수 있게 되었지요. 이를 이해하기 위해서는 우측값 참조에 대한 두 개의 규칙을 더 살펴보도록 합시다.




###  완벽한 전달 문제 해결책


두 개의 규칙 중 첫번째 것은 이전의 좌측값 참조와 관련된 것입니다. `C++11` 이전에는 레퍼런스의 레퍼런스를 취하는 것은 불가능 했다라고 알고 계셨을 것입니다. 즉 `A& &` 는 컴파일 오류 였죠. 하지만 `C++11` 에서는 다음과 같은 `&` 겹침에 관한 규칙을 도입하였습니다.

```info
A& & → A&
A& && → A&
A&& & → A&
A&& && → A&&
```



두 번째로 템플릿 인자로 우측값 참조를 받는 함수 템플릿에는 아래와 같은 **특수 템플릿 인자 유추 규칙(special template argument deduction rule)** 이 있습니다.

```cpp-formatted
template <typename T>
void foo(T&&);
```



위 템플릿을 예를 들어 설명하자면, 규칙은 다음과 같습니다.

* 만일 `foo` 가 `A` 의 좌측값으로 호출된다면, `T` 는 `A&` 로 변환되고, 따라서 위의 `&` 겹침 규칙에 따라 인자 타입은 `A &` 가 된다.
* 만일 `foo` 가 `A` 의 우측값으로 호출된다면, `T` 는 `A` 로 변환되고, 따라서 위의 & 겹침 규칙에 따라 인자 타입은 `A&&` 가 된다.



이러한 규칙을 바탕으로 우리는 이제 완벽한 전달 문제를 위해 우측값 참조를 사용할 수 있게 됩니다. 아래는 그 해결책 입니다.

```cpp-formatted
template <typename T, typename Arg>
shared_ptr<T> factory(Arg&& arg) {
  return shared_ptr<T>(new T(std::forward<Arg>(arg)));
}
```



이 때 std::forward 는 아래와 같이 정의되어 있습니다.

```cpp-formatted
template <class S>
S&& forward(typename remove_reference<S>::type& a) noexcept {
  return static_cast<S&&>(a);
}
```



(※ `noexcept`  키워드에 대해서는 아래에서 자세히 설명할 것이니 잠시동안만 무시하도록 합시다. 간략하게 설명하자면 `noexcept` 키워드는 이 함수가 절대로 예외를 `throw` 하지 않을 것이라고 말해주는 것입니다)


위 코드가 어떻게 완벽한 전달 문제를 해결하는지 살펴보기 위해 `factory` 함수가 각각 좌측값과 우측값으로 호출 될 때 어떻게 작동하는지 살펴보도록 합시다.`A` 와 `X` 를 타입이라고 하고, `factory<A>` 가 `X` 의 좌측값 타입으로 호출되었다고 합시다.  아래와 같이요.

```cpp-formatted
X x;
factory<A>(x);
```



앞서 특수 템플릿 인자 유추 규칙에 따라 `factory` 의 템플릿 인자 `Arg` 는 `X&` 로 변환됩니다. 따라서, 컴파일러는 아래와 같이 `factor` 와 `std::forward` 의 템플릿 인스턴스화 (instantiation) 을 수행하게 됩니다.

```cpp-formatted
shared_ptr<A> factory(X&&& arg) {
  return shared_ptr<A>(new A(std::forward<X&>(arg)));
}

X&&& forward(remove_reference<X&>::type& a) noexcept {
  return static_cast<X&&&>(a);
}
```



`remove_reference` 를 수행하고 & 겹침 규칙을 적용하게 되면,

```cpp-formatted
shared_ptr<A> factory(X& arg) {
  return shared_ptr<A>(new A(std::forward<X&>(arg)));
}

X& std::forward(X& a) { return static_cast<X&>(a); }
```



와 같이 됩니다. 좌측값에 대한 완벽한 전달이 잘 수행되었다고 볼 수 있죠. `factory` 함수의 인자 `arg` 가 `A` 의 생성자로 2 번의 좌측값 참조를 거쳐서 전달됩니다.


이번에는 `factory<A>` 가 `X` 의 우측값으로 호출되었다고 생각해봅시다.

```cpp-formatted
X foo();
factory<A>(foo());
```



그러면 위의 특수 템플릿 인자 유추 규칙에 따라 `factory` 의 템플릿 인자 `Arg` 는 `X` 로 변환되게 됩니다. 따라서 컴파일러는 아래와 같은 함수 인스턴스화 된 함수 템플릿을 생성하게 되겠지요.

```cpp-formatted
shared_ptr<A> factory(X&& arg) {
  return shared_ptr<A>(new A(std::forward<X>(arg)));
}

X&& forward(X& a) noexcept { return static_cast<X&&>(a); }
```



이는 실제로 우측값에 대한 완벽한 전달이라고 볼 수 있습니다. `factory` 함수의 인자가 `A` 의 생성자에 두 개의 단계를 거쳐서 전달됩니다. 특히 `A` 의 생성자는 자신의 인자로 전달된 것을 '이름이 없기에' 우측값 이라고 생각하기 때문에 성공적으로 우측값에 대한 복사 생성자 호출을 수행할 수 있게 됩니다.


위 완벽한 전달 과정에서 가장 중요한 것은 바로 `std::forward` 라고 볼 수 있는데, `std::forward` 없이는 `A` 의 생성자로 '이름이 언제나 있기에' 좌측값이 전달되게 됩니다. 따라서 `std::forward` 의 역할은 처음의 템플릿 인자로 우측값이냐 좌측값이냐에 따라서 생성자에 우측값을 전달할지, 좌측값을 전달할지 결정하는 일을 한다고 볼 수 있습니다.



`forward` 함수를 조금 더 깊게 파고든다면, 아마 여러분은 "왜 굳이 `remove_reference` 가 `std::forward` 정의에 필요할까?" 라고 생각하실 수 있습니다. 그리고 그 답은 "사실은 필요 없다" 입니다. 여러분은 그냥 `remove_reference<S>::type&` 대신에 그 자리에 `S&` 를 사용하셔도 무방합니다. 하지만 이는 오직 우리가 `Arg` 를 `std::forward` 의 템플릿 인자로 명시적으로 사용하고 있을 때 만 잘 작동하겠지요. `remove_reference` 를 `std::forward` 의 정의에 넣은 것도 강제로 그렇게 하기 위해서 입니다.


자. 그럼 이제 우리의 여정은 끝에 다다랐습니다. 이제 해야될 것은 `std::move` 의 정의를 살펴보는 일입니다. `std::move` 는 레퍼런스로 받은 인자를 우측값 처럼 행동하게 하는 것임을 기억하고 계시죠? 아래는 그 구현입니다.

```cpp-formatted
template <class T>
typename remove_reference<T>::type&& std::move(T&& a) noexcept {
  typedef typename remove_reference<T>::type&& RvalRef;
  return static_cast<RvalRef>(a);
}
```



만일 우리가 좌측값 `X` 에 대해 `std::move` 를 호출하였다고 해봅시다.

```cpp-formatted
X x;
std::move(x);
```



그리고 우리의 특수 템플릿 인자 유추 규칙에 따라서 템플릿 인자 `T` 는 `X&` 로 바뀔 것이고, 따라서 컴파일러는 아래와 같이 템플릿 인스턴스화를 수행하게 됩니다.

```cpp-formatted
typename remove_reference<X&>::type&& std::move(X&&& a) noexcept {
  typedef typename remove_reference<X&>::type&& RvalRef;
  return static_cast<RvalRef>(a);
}
```



`remove_reference` 와 `&` 겹침 규칙을 적용하고 나면

```cpp-formatted
X&& std::move(X& a) noexcept { return static_cast<X&&>(a); }
```



와 같이 됩니다. 바로 우리가 원하는 작업이군요. 우리의 좌변값 `x` 는 인자인 좌변값 참조를 통해 인자로 전달되어서 이름없는 우변값 참조로 변호나될 것입니다. `std::move` 가 우변값에서도 작동하는지 확인하는 일은 여러분의 몫으로 남겨두겠습니다. 그런데, `std::move` 가 받은 인자를 우변값으로 바꿔주는 일이라면 도대체 왜 사람들이 우변값에 대해 `std::move` 를 호출할까요?

```cpp-formatted
std::move(x);
```



로 쓰는 대신에 그냥

```cpp-formatted
static_cast<X&&>(x);
```



위와 같이 하면 되니까요. 하지만 `std::move` 가 더 보기도 좋고 잘 표현하고 있기 때문에 `std::move` 로 표현하는 것을 권장합니다.


###  우측값 참조와 예외


보통의 경우, C++ 로 소프트웨어를 개발 할 때, 여러분의 코드에서 예외 처리를 하는 것은 여러분의 몫입니다. 우측값 참조의 경우는 여기서 사실 살짝 다릅니다. 만일 여러분이 복사 생성자와 복사 대입 연산자를 `move` 연산을 위해 오버로드 할 때, 아래와 같이 수행하는 것을 매우 권장합니다.

오버로드 함수가 예외를 `throw` 하지 않도록 함수를 구성하세요. 사실, `move` 연산은 두 객체의 포인터와 리소스 간의 단순한 `swap` 이기 때문에 어려운 일은 이닙니다.

만일 위와 같이 `throw` 하지 않도록 구성하였다면, 이를 `noexcept` 키워드를 이용하여 명확히 나타내도록 합니다.

만일 위 두 작업을 하지 않는다면, 종종 `move` 연산이 적용될 것이라 예상했음에도 불구하고 `move` 연산이 적용되지 않는 경우들이 있을 것입니다. 예를 들어 std::vector 의 크기가 변경될 때, 여러분은 아마 `move` 연산을 통해 이미 존재하는 벡터의 원소들을 새로운 메모리 블록으로 이동시키려고 할 텐데요, 위 조건 `1,2` 가 모두 충족되지 않는다면 이러한 `move` 연산은 수행되지 않습니다.

이러한 일이 발생하는 이유는 꽤 복잡한데, 자세한 내용을 알기 위해서는 [Dave Abrahams 의 글을 참조](http://cpp-next.com/archive/2009/10/exceptionally-moving/)하시기 바랍니다. 참고로 이 글은 `noexcept` 키워드가 도입되기 이전이니, `noexcept` 키워드가 어떻게 문제를 해결하였는지 보고 싶다면 글 상단의 `update` #2 를 클릭하시기 바랍니다.



###  암시적(implicit) Move


우측값 참조에 관한 토의에서, 표준 위원회는 우측값 참조를 사용하는 복사 생서자와 복사 대입 연산자들이 사용자가 제공하지 않는다면 컴파일러가 스스로 제공하도록 결정하였습니다. 사실 컴파일러가 보통의 복사 생성자나 복사 대입 연산자들을 디폴트로 제공하고 있었다는 것을 생각해보면 매우 타당한 일입니다. 그런데 2010년 8월에 `Scott Meyers` (그 유명한 `Effective C++` 의 저자) 는 `c` [omp.lang.c++ 에 컴파일러가 제공하는 move 생성자가 원래의 코드를 심각하게 손상 시킬 수 있다는 것을 밝혀](https://groups.google.com/forum/?fromgroups=#!topic/comp.lang.c++/1R1igvCYs8o)내었습니다. [Dave Abrahams 는 그 내용을 자신의 블로그에](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3153.htm) 잘 정리해놓았습니다.

따라서 위원회는 기존의 방식으로 `move` 생성자와 `move` 대입 연산자들을 컴파일러가 생성하는 것을 제한하고,코드를 손상시키는 것이 거의 불가능하도록 (아예 불가능 한 것은 아님)  결정하였습니다. 그 내용은 `Herb Sutter` 의 블로그에 잘 설명되어 있습니다.

사실 명시적이지 않은 `move` 에 관한 문제는 계속 해서 논쟁 거리로 남아서 표준 최종 결정의 마지막 단계 까지 남아 있었습니다. 애초에 위원회가 명시적이지 않은 `move` 를 도입한 이유는 웃기게도, 위에서 말한 우측값 문제와 예외 처리 때문인데, 이 문제는 `noexcept` 키워드를 도입함으로써 좀 더 만족스러운 방법으로 해결되었습니다. 만일 `noexcept` 키워드가 몇 달 앞서 도입되었더라면 이 문제는 수면 위로 떠오르지도 않았을 것입니다. 

아무튼. 그리하여, 컴파일러가 제공하는 암시적 `move` 는 사라졌습니다.

자 이게 우측값에 관한 이야기의 끝입니다. 여러분이 보았듯이, 우측값으로 인한 이점은 상당합니다. 여러분이 C++ 을 능숙하게 다루기 위해서는 이러한 세세한 사항들을 모두 이해하고 있어야만 할 것입니다. 그렇지 않다면 여러분은 C++ 의 모든 기능을 사용하고 있다고 볼 수 없지요. 이 많은 것들을 기억하기에는 벅차다고요? 그렇다면 우측값에 관렪나 아래 3 개 내용만 꼭 기억하시면 되겠습니다.

```info
함수의 오버로딩에서 :
void foo(X& x); // 좌측값 참조 오버로드
void foo(X&& x); // 우측값 참조 오버로드
여러분은 이를 통해 foo 가 좌측값에, 혹은 우측값에 호출됨에 따라서 상황을 적절하게 처리할 수 있게 됩니다. 또한 특히 우측값 처리시에, 예외 처리에 신경을 써주어서, 예외를 throw 하지 않도록, 그리고 마지막에는 꼭 noexcept 키워드를 넣어 주어야만 합니다.


`std::move` 는 받은 인자를 우측값으로 변환한다.


std::forward 는 완벽한 전달을 할 수 있도록 도와준다.
```














###  감사의 말


이 글을 제공해주신 `Thomas Becker` 님에게 감사의 말을 드립니다. 원문 `Acknowledgements` 를 보시려면 [http://thbecker.net/articles/rvalue_references/section_11.html](http://thbecker.net/articles/rvalue_references/section_11.html) 로 들어가시면 됩니다.
Link :  187
2012-08-06 02:40
----------------
title : 씹어먹는 C 언어 강좌 - PDF 파일
publish_date : 2012-08-06 02:40
--------------






![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1401963D501EB00C116535)



안녕하세요? 여러분들의 요청에 따라 씹어먹는 C 언어 강좌 전체를 `PDF` 파일로 제작하였습니다. 덕분에 인터넷이 끊긴 환경이나 모바일 기기에 가지고 다니시며 편하게 보실 수 있습니다 :)


일단 전체 강좌를 모두 포함하고 있고요, 2012 년 8월 6일 현재 여러분들이 지적하신 모든 오탈자 및 오류를 수정하였고 사진의 크기도 조금씩 조정하였습니다.


참고로 용량이 `10 MB` 를 살짝 초과해서 `zip` 파일로 압축 하였으니, 혹시 모바일 기기에 넣으실 분은 미리 컴퓨터에서 압축을 푸신 후에 넣으시길 바랍니다. 파일은 아래 링크를 클릭하시면 다운이 됩니다.


그럼, 즐거운 C 프로그래밍 되세요 :)

 [Chewing C Language.zip](/attachment/Chewing C Language.zip)
Link :  186
2012-08-05 19:03
----------------
title : C++ 레퍼런스 - vector::insert
cat_title :  vector::insert
ref_title : insert
path : /C++ Reference/Containers/vector
publish_date : 2012-08-05 19:03
--------------


```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```



#@ vector::insert


```info
iterator insert ( iterator position, const T& x );
    void insert ( iterator position, size_type n, const T& x );
template <class InputIterator>
    void insert ( iterator position, InputIterator first, InputIterator last );
```



원소를 추가한다.
특정 위치에 원소를 추가함으로써 벡터가 확장된다.


이 함수는 벡터의 크기를 효과적으로 증가시키는데, 만일 새로운 벡터의 size 가 현재 벡터의 `capacity` 보다 크다면 재할당을 하게 된다. 재할당 시, 벡터 컨테이너의 이전에 얻은 모든 반복자(iterator), 레퍼런스들은 무효화 된다.


벡터는 배열의 형태로 저장되기 때문에 벡터 끝이 아닌 임의의 위치에 원소를 삽입하게 되면 그 뒤에 있는 원소들을 뒤로 이동시키게 된다. 따라서 벡터에서 원소들 중간에 새로운 원소들을 삽입하는 일은 그다시 효율적이지 못하다.

따라서 이러한 작업을 많이 하게 된다면 다른 순차 컨테이너 ( [deque](http://itguru.tistory.com/176), [list](http://itguru.tistory.com/177)) 를 참고하기 바란다.




###  인자


`position`

새로운 원소가 추가될 위치

`iterator` 은 멤버 타입으로 임의 접근 반복자 타입(random access iterator type) 이다.

`x`

삽입할 원소의 값으로 `T` 형이다. (T 는 벡터에 삽입되는 원소들의 타입)

`n`

삽입할 원소의 수. 각 원소들은 같은 값 `x` 로 초기화된다.멤버 타입 `size_type` 은 부호 없는 정수 이다.

`first, last`

특정 범위의 원소들을 지칭하는 반복자이다. `first` 에서 `last` 전 까지의 원소들을 `position` 에 삽입하게 된다. 한 가지 주의할 것은 `first` 에서 `last` 까지가 아닌 `last` 직전 까지의 원소들이다. 즉 `last` 번째의 원소는 삽입되지 않는다.



###  리턴값




`iterator insert ( iterator position, const T& x );` 

함수만 리턴값이 있는데 이는 새롭게 추가된 원소를 가리키는 반복자를 리턴한다.
만일 재할당이 일어나게 되면 `Allocator::allocate()` 를 이용해서 할당을 하게 되는데 성공적으로 할당이 되지 않았을 경우 예외를 던지(throw) 게 된다. 디폴트 할당자의 경우 `bad_alloc` 을 던진다.



###  실행 예제




```cpp-formatted
/*

이 예제는
 [http://www.cplusplus.com/reference/stl/vector/insert/](http://www.cplusplus.com/reference/stl/vector/insert/)
에서 가져왔습니다

*/
#include <iostream>
#include <vector>
using namespace std;

int main() {
  vector<int> myvector(3, 100);
  vector<int>::iterator it;

  it = myvector.begin();
  it = myvector.insert(it, 200);

  myvector.insert(it, 2, 300);

  // "it" no longer valid, get a new one:
  it = myvector.begin();

  vector<int> anothervector(2, 400);
  myvector.insert(it + 2, anothervector.begin(), anothervector.end());

  int myarray[] = {501, 502, 503};
  myvector.insert(myvector.begin(), myarray, myarray + 3);

  cout << "myvector contains:";
  for (it = myvector.begin(); it < myvector.end(); it++) cout << " " << *it;
  cout << endl;

  return 0;
}
```



실행 결과



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1243AE4F501DDDF2111AAA)





###  시간 복잡도



삽입 이후의 벡터의 크기가 삽입 이전에 결정될 수 있다면 입력되는 원소의 개수와 (복사 생성) 삽입 위치 뒤에 있는 원소들의 개수 (이동 연산) 의 합에 선형으로 비례한다.

만일 삽입 이후의 벡터의 크기가 삽입 이전에 결정되지 않는다면 (이는 `void insert ( iterator position, InputIterator first, InputIterator last );` 함수에서 `InputIterator` 가 순방향, 양방향, 임의 접근 반복자 모두가 아닐 경우) 삽입되는 원소의 수와 삽입 위치 뒤에 있는 원소의 개수의 곱에 비례한다.



###  연관된 함수


*  [vector::push_back](http://itguru.tistory.com/185): 벡터 끝에 원소를 추가한다.
* vector::erase : 원소를 삭제한다.
Link :  185
2012-08-05 11:17
----------------
title : C++ 레퍼런스 - vector::push_back
cat_title : vector::push_back
ref_title : push_back
path : /C++ Reference/Containers/vector
publish_date : 2012-08-05 11:17
--------------

```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ vector::push_back

```info
void push_back ( const T& x );

```

벡터 끝에 원소를 추가한다.

현재의 마지막 원소 뒤에 새로운 원소를 추가하며, 그 원소의 값은 `x` 의 복사본으로 초기화 된다.


이 함수는 효과적으로 벡터의 크기를 1 늘리는데, 만일 `capacity` 와 벡터 `size` 가 같다면 내부적으로 재할당이 일어나게 된다. 이 때 이전에 사용되었던 반복자(iterator) , 레퍼런스, 포인터들은 사용할 수 없게 된다.




###  인자


* `x` : 새로 추가 될 원소에 복사 될 원소`T` 는 벡터에 저장되어있는 원소들의 타입이다.


###  리턴값

없음

만일 재할당이 발생한다면 이는 `Allocator::allocate()` 를 이용해서 수행되는데, 예외를 던질(throw) 수 있다. (디폴트 할당자의 경우 만일 요청한 할당이 성공하지 않을 경우 `bad_alloc` 이 던져진다)




###  실행 예제




```cpp-formatted
/*

이 예제는
 [http://www.cplusplus.com/reference/stl/vector/push_back/](http://www.cplusplus.com/reference/stl/vector/push_back/)
에서 가져왔습니다

*/
#include <iostream>
#include <vector>
using namespace std;

int main() {
  vector<int> myvector;
  int myint;

  cout << "Please enter some integers (enter 0 to end):\n";

  do {
    cin >> myint;
    myvector.push_back(myint);
  } while (myint);

  cout << "myvector stores " << (int)myvector.size() << " numbers.\n";

  return 0;
}
```




실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1519CE4C501DD721070E78)





###  시간 복잡도



상수 (다만 재할당이 일어 날 수 있음)


###  연관된 함수




* `vector::pop_back` : 마지막 원소를 삭제한다.
*  [vector::insert](http://itguru.tistory.com/186): 원소를 추가한다.
Link :  173
2012-08-04 23:26
----------------
title : 씹어먹는 C++ - <4 - 2. 클래스의 세계로 오신 것을 환영합니다. (함수의 오버로딩, 생성자)>
cat_title: 4 - 2. 클래스의 세계로 오신 것을 환영합니다. (함수의 오버로딩, 생성자)
next_page : 188
publish_date : 2012-08-04 23:26
--------------




이번 강좌에서는* 함수의 오버로딩 (function overloading)
* 생성자 (constructor)
* 디폴트 생성자 (default constructor)

에 대해 배웁니다

![](/img/ChewingCpplogo.png)


안녕하세요 여러분. 이제 본격적으로 객체 지향 프로그래밍을 시작 하도록 하겠습니다. 아마도 지난번 생각해보기를 열심히 하셨던 분들이라면, `Date` 클래스에서 `add_day` 함수는 조금 어렵더라도, `add_month` 나 `add_year` 정도는 가뿐하게 만드셨을 것이라고 생각합니다. 사실, `add_day` 도 `add_month` 함수를 응용해서 만들면 쉬웠을 것입니다. 이번 강좌에서는 저와 함께 다시 새로운 방법으로 `Date` 클래스를 만들어가면서 객체 지향 프로그래밍에 조금 더 친숙해져 보도록 하겠습니다.


###  함수의 오버로딩 (Overloading)


본격적으로 객체 지향 프로그래밍을 시작하기에 앞서 C++ 에 C 와는 다른 새로운 기능을 잠시 살펴 보도록 하겠습니다. 바로 '함수의 오버로딩' 이라고 하는 것인데요, 사실 오버로드를 사전에서 찾아보면 다음과 같은 뜻이 나옵니다.

```info
1. 과적하다
2.~ sb (with sth) 너무 많이 주다[부과하다]
3.(컴퓨터・전기 시스템 등에) 과부하가 걸리게 하다
```

음.. 그렇다면 함수의 오버로딩이라는 것은 '함수에 과부하를 주는 것' 인가 라는 생각도 드실 텐데요, 사실 맞는 말씀입니다. 사실 C 언어 에서는 하나의 이름을 가지는 함수는 딱 1 개만 존재할 수 밖에 없기에 과부하라는 말 자체가 성립이 안됬지요.

`printf` 는 C 라이브러리에 단 한 개 존재하고, `scanf` 도 C 라이브러리에 단 1 개 만 존재합니다. 하지만 C++ 에서는 같은 이름을 가진 함수가 여러개 존재해도 됩니다 C++ 에서는 같은 이름을 가진 함수가 여러개 존재해도 됩니다. 즉, 함수의 이름에 '과부하' 가 걸려도 상관이 없다는 것이지요!

그렇다면 도대체 C++ 에서는 같은 이름의 함수를 호출했을 때 구분을 어떻게 하는 것일까요. 물론 단순합니다. 함수를 호출 하였을 때 사용하는 인자를 보고 결정하게 됩니다.

```cpp-formatted
/* 함수의 오버로딩 */
#include <iostream>
using namespace std;

void print(int x) { cout << "int : " << x << endl; }
void print(char x) { cout << "char : " << x << endl; }
void print(double x) { cout << "double : " << x << endl; }
int main() {
  int a = 1;
  char b = 'c';
  double c = 3.2f;

  print(a);
  print(b);
  print(c);

  return 0;
}
```


성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1103BB41501C84C0399BB2)



일단 위 소스를 보게 된다면 이름이 'print' 인 함수 3 개가 정의가 되었음을 알 수 있습니다. 고전적인 C 컴파일러에서는 오류가 발생했겠지만 C++ 에서는 '함수의 이름이 같더라도 인자가 다르면 다른 함수' 라고 판단하기 때문에 오류가 발생하지 않는 것입니다.

```cpp-formatted
void print(int x) void print(char x) void print(double x)
```



위와 같이 정의된 함수들을 `main` 에서 아래와 같이 호출하게 됩니다.


```cpp-formatted
int a = 1;
char b = 'c';
double c = 3.2f;

print(a);
print(b);
print(c);
```

여기서 한 가지 눈여겨 보아야 할 점은 `a` 는 `int, b` 는 `char, c` 는 `double` 타입이라는 것인데, 이에 따라 각각의 타입에 맞는 함수들, 예를 들어 `print(b)` 는 `b` 가 `char` 이므로 `char` 형의 인자를 가지는 두 번째 `print` 가 호출 된 것입니다.


C 언어였을 경우 `int, char, double` 타입에 따라 함수의 이름을 제각각 다르게 만들어서 호출해 주어야 했던 반면에 C++ 에서는 컴파일러가 알아서 '적합한 인자를 가지는 함수' 를 찾아서 호출해 주게 됩니다 C 언어였을 경우 `int, char, double` 타입에 따라 함수의 이름을 제각각 다르게 만들어서 호출해 주어야 했던 반면에 C++ 에서는 컴파일러가 알아서 '적합한 인자를 가지는 함수' 를 찾아서 호출해 주게 됩니다.

```cpp-formatted
/* 함수의 오버로딩 */
#include <iostream>
using namespace std;

void print(int x) { cout << "int : " << x << endl; }
void print(double x) { cout << "double : " << x << endl; }

int main() {
  int a = 1;
  char b = 'c';
  double c = 3.2f;

  print(a);
  print(b);
  print(c);

  return 0;
}
```


성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197D1342501C882703189B)


이번에는 조금 특이한 경우 입니다. 일단 함수는

```cpp-formatted
void print(int x) void print(double x)
```

`int` 타입의 인자나 `double` 타입의 인자를 하나 받는 함수 하나 밖에 없습니다. 하지만 `main` 에서 각기 다른 타입의 인자들 (int, char, double) 로 `print` 함수를 호출하게 됩니다. 물론 `a` 나 `c` 의 경우 각자 자기를 인자로 하는 정확한 함수들이 있어서 성공적으로 호출 될 수 있겠지만,`char` 의 경우 자기와 정확히 일치하는 인자를 가지는 함수가 없기 때문에 '자신과 최대로 근접한 함수'를 찾게 됩니다.


C++ 컴파일러에서 함수를 오버로딩하는 과정은 다음과 같습니다 C++ 컴파일러에서 함수를 오버로딩하는 과정은 다음과 같습니다.


1 단계 : 자신과 타입이 정확히 일치하는 함수를 찾는다 1 단계 : 자신과 타입이 정확히 일치하는 함수를 찾는다.

2 단계 : 정확히 일치하는 타입이 없는 경우 아래와 같은 형변환을 통해서 일치하는 함수를 찾아본다.
* `Char, unsigned char, short` 는 `int` 로 변환된다.
* `Unsigned short` 는 `int` 의 크기에 따라 `int` 혹은 `unsigned int` 로 변환된다.
* `Float` 은 `double` 로 변환된다.
* `Enum` 은 `int` 로 변환된다.


3 단계 : 위와 같이 변환해도 일치하는 것이 없다면 아래의 좀더 포괄적인 형변환을 통해 일치하는 함수를 찾는다.

* 임의의 숫자(numeric) 타입은 다른 숫자 타입으로 변환된다. (예를 들어 `float -> int)`
* `Enum` 도 임의의 숫자 타입으로 변환된다 (예를 들어 `Enum -> double)`
* `0` 은 포인터 타입이나 숫자 타입으로 변환된 0 은 포인터 타입이나 숫자 타입으로 변환된다
* 포인터는 `void` 포인터로 변환된다.

4 단계 : 유저 정의된 타입 변환으로 일치하는 것을 찾는다 (이 부분에 대해선 나중에 설명!)
(출처 : [http://www.learncpp.com/cpp-tutorial/76-function-overloading/](http://www.learncpp.com/cpp-tutorial/76-function-overloading/))


만약에 컴파일러가 위 과정을 통하더라도 일치하는 함수를 찾을 수 없거나 같은 단계에서 두 개 이상이 일치하는 경우에 '모호하다 (ambiguous)' 라고 판단해서 오류를 발생하게 됩니다.


그렇다면 우리의 소스 코드에서

```cpp-formatted
print(b);
```



는 어떻게 될까요. 1 단계에서는 명백하게도 `char` 타입의 인자를 가진 `print` 가 없기에 2 단계로 넘어오게 됩니다. 그런데 2 단계에서는 `char` 이 `int` 로 변환된다면 `print (int x)` 를 호출할 수 있기 때문에 결국 `print (int x)` 가 호출되게 되는 것이지요.

```cpp-formatted
// 모호한 오버로딩

#include <iostream>
using namespace std;

void print(int x) { cout << "int : " << x << endl; }
void print(char x) { cout << "double : " << x << endl; }

int main() {
  int a = 1;
  char b = 'c';
  double c = 3.2f;

  print(a);
  print(b);
  print(c);

  return 0;
}
```

  위 소스를 컴파일 하였다면 오류가 발생함을 알 수 있습니다. 오류를 살짝 보자면

```warning
 error C2668: 'print' : ambiguous call to overloaded function
 could be 'void print(char)'
 or       'void print(int)'
while trying to match the argument list '(double)'
```


와 같이 나오는데요, 왜 오류가 발생하였는지 살펴보도록 합시다. 일단 위 소스에서는 함수가 `print (int x)` 와 `print (char x)` 밖에 없으므로 관건은 `print(c);` 를 했을 때 어떠한 함수가 호출되어야 하는지 결정하는 것인데요, `print(c)` 를 했을 때 1 단계에서는 명백하게 일치하는 것이 없습니다. 2 단계에서는 마찬가지로 `double` 의 캐스팅에 관련한 내용이 없기에 일치하는 것이 없고 비로소 3 단계로 넘어오게 됩니다. 3 단계에서는 '임의의 숫자 타입이 임의의 숫자 타입' 으로 변환되서 생각되기 때문에 `double` 은 `char` 도, `int` 도 변환 될 수 있게 되는 것입니다.


따라서 같은 단계에 두 개 이상의 가능한 일치가 존재하므로 오류가 발생하게 되는 것이지요.


위와 같은 C++ 오버로딩 규칙을 머리속에 숙지 하는 일은 매우 중요한 일입니다. 왜냐하면 나중에 복잡한 함수를 오버로딩할 때 여러가개 중복되서 나온다면 눈물없이 볼 수 없는 오류의 향연을 만날 수 있을 것입니다!

###  Date 클래스


```cpp-formatted
#include <iostream>

using namespace std;
class Date {
  int year;
  int month;
  int day;

 public:
  void set_date(int _year, int _month, int _date);
  void add_day(int inc);
  void add_month(int inc);
  void add_year(int inc);
  void show_date();
};

void Date::set_date(int _year, int _month, int _day) {
  year = _year;
  month = _month;
  day = _day;
}

void Date::add_day(int inc) {
  int month_day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  int i = month;

  if (month_day[i - 1] - day >= inc) {
    day += inc;
    return;
  } else {
    add_month(1);
    day = 1;

    inc = inc - (month_day[i - 1] - day) - 1;
    i++;
  }
  while (true) {
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
      month_day[1] = 29;  // 윤년
    } else {
      month_day[1] = 28;
    }

    // 만약에 그 달을 추가할 수 있다면
    if (inc - month_day[i - 1] >= 0) {
      add_month(1);
      inc = inc - month_day[i - 1];
    } else if (inc - month_day[i - 1] < 0) {
      day = day + inc;
      break;
    }

    i++;
    if (i > 12) i = i - 12;
  }
}

void Date::add_month(int inc) {
  add_year((inc + month - 1) / 12);
  month = month + inc % 12;
  month = (month == 12 ? 12 : month % 12);
}

void Date::add_year(int inc) { year += inc; }

void Date::show_date() {
  cout << "오늘은 " << year << " 년 " << month << " 월 " << day << " 일 입니다 "
       << endl;
}
int main() {
  Date day;
  day.set_date(2011, 3, 1);
  day.show_date();

  day.add_year(10);
  day.show_date();
  return 0;
}
```

 성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1252FE404F4F07F611AF58)



위의 코드는 간단한 것들 (`add_year, set_date, show_date`) 만 만들어 놓은 상태입니다. 그런데, 이상한 것이 있죠? `class` 내부에는 아래 코드와 같이

```cpp-formatted
public:
void set_date(int _year, int _month, int _date);
void add_day(int inc);
void add_month(int inc);
void add_year(int inc);
void show_date();
```



함수의 정의만 나와 있고, 함수 전체 몸통은

```cpp-formatted
void Date::set_date(int _year, int _month, int _day) {
  year = _year;
  month = _month;
  day = _day;
}
```



처럼 밖에 나와 있습니다. `Date::` 을 함수 이름 앞에 붙여주게 되면 이 함수가 "`Date` 클래스의 정의된 함수" 라는 의미를 부여하게 됩니다. 만일 그냥

```cpp-formatted
void set_date(int _year, int _month, int _day) {
  // 생략
```

했다면이 함수는 아예 다른 함수가 되는 것이지요. 보통 간단한 함수를 제외하면 대부분의 함수들은 클래스 바깥에서 위와 같이 정의하게 됩니다. 왜냐하면 클래스 내부에 쓸 경우 클래스 크기가 너무 길어져서 보기 좋지 않기 때문이죠.

특히 나중에 클래스 자체만 따로 헤더파일로 뺄 수 도 있는데, 이 때 클래스 코드 길이가 너무 길면 불편하겠지요 . 보통 간단한 함수를 제외하면 대부분의 함수들은 클래스 바깥에서 위와 같이 정의하게 됩니다. 왜냐하면 클래스 내부에 쓸 경우 클래스 크기가 너무 길어져서 보기 좋지 않기 때문이죠. 특히 나중에 클래스 자체만 따로 헤더파일로 뺄 수 도 있는데, 이 때 클래스 코드 길이가 너무 길면 불편하겠지요.

```cpp-formatted
Date day;
day.set_date(2011, 3, 1);
day.show_date();

day.add_year(10);
day.show_date();
```


그럼 이제 `main` 함수를 살펴 봅시다. 위 처럼 `day` 인스턴스를 생성해서 `set_date` 로 초기화 한 다음에 `show_date` 로 내용을 한 번 보여주고, 또 `add_year` 을 해서 10 년을 증가 시킨뒤 다시 새로운 날짜를 출력하도록 하였습니다. 여기서 가장 중요한 부분은 무엇일까요? 당연하게도, 처음의 `set_date` 부분 입니다. 만일 `set_date` 를 하지 않았더라면 초기화 되지 않은 값들에 덧셈 과 출력 명령이 내려져서


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1479614F4F4F099D33A88E)


위 처럼 이상한 쓰레기 값이 출력되게 되거든요. 그런데 문제는 이렇게 `set_date` 함수를 사람들이 꼭 뒤에 써주지 않는 다는 말입니다. 물론 훌륭한 프로그래머들은 '생성 → 초기화' 단계를 명확하게 머리속에 박아 넣고 있겠지만 간혹 실수로 초기화를 하지 않는다면 끔찍한 일이 벌어지게 됩니다.

다행이도 C++ 에서는 이를 언어 차원에서 도와주는 장치가 있는데 바로 **생성자(constructor)** 입니다.



###  생성자 (Constructor)


```cpp-formatted
#include <iostream>
using namespace std;
class Date {
  int year;
  int month;
  int day;

 public:
  void set_date(int _year, int _month, int _date);
  void add_day(int inc);
  void add_month(int inc);
  void add_year(int inc);
  void show_date();

  Date(int _year, int _month, int _day) {
    year = _year;
    month = _month;
    day = _day;
  }
};

// 생략

int main() {
  Date day(2011, 3, 1);
  day.show_date();

  day.add_year(10);
  day.show_date();
  return 0;
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F192EB24B4F4F0AB008BA89)


위와 같이 초기화가 잘 되서 출력됨을 알 수 있습니다.

생성자는 기본적으로 "객체 생성시 자동으로 호출되는 함수" 라고 볼 수 있습니다. 이 때 자동으로 호출 되면서 객체를 초기화 해주는 역할을 담당하게 됩니다. 생성자는 아래와 같이 정의합니다.

```info

// 객체를 초기화 하는 역할을 하기 때문에 리턴값이 없다!
(클래스 이름) ( 인자 )
{
}
```



예를 들어서 위 경우 저는 아래와 같이 `Date` 의 생성자를 정의하였습니다.

```cpp-formatted
Date(int _year, int _month, int _day)
```



이렇게 정의가 된 생성자는 객체를 생성할 때 다음과 같이 위 함수에서 정의한 인자에 맞게마치 함수를 호출하듯이써준다면 위 생성자를 호출하며 객체를 생성할 수 있게 됩니다. 즉, 우리의 경우 아래와 같이 객체를 생성하였지요.

```cpp-formatted
Date day(2011, 3, 1);
```


이는 곧 "`Date` 클래스의 `day` 객체를 만들면서 생성자 `Date(int _year, int _month, int _day)` 를 호출한다" 라는 의미가 됩니다. 따라서 `Date` 의 객체를 생성할 때 생성자의 인자 `_year, _month, _day` 에 각각 `2011, 3, 1` 을 전달하며 객체를 생성하게 되는 것이지요. 매우 간단한 원리 입니다. 그러한 맥락에서 볼 때 아래와 같이 객체를 생성하는 것도 동일한 의미 입니다.

```cpp-formatted
Date day = Date(2012, 3, 1);
```


이는 역시 `day` 객체를 생성하고, 이 때 생성자 `Date(2012, 3, 1)` 을 호출해서 이를 토대로 객체를 생성하라는 의미가 됩니다. 사실 객체를 정의하는 두 방식에는 각각 이름이 붙어 있는데,

```cpp-formatted
Date day(2011, 3, 1);         // 암시적 방법 (implicit)
Date day = Date(2012, 3, 1);  // 명시적 방법 (explicit)
```



마치 함수를 호출하듯이 사용하는 것이 암시적 방법, 명시적으로 생성자를 호출한다는 것을 보여주는 것이 명시적 방법 인데 많은 경우 암시적 방법으로 축약해서 쓸 수 있으므로 이를 선호하는 편입니다.


###  디폴트 생성자 (Default constructor)


그런데 한 가지 궁금증이 생겼습니다. 맨 처음에 단순히 `set_date` 함수를 이용해서 객체를 초기화 하였을 때 우리는 생성자를 명시하지 않았습니다. 즉 처음에 생성자 정의를 하지 않은 채 (`set_date` 함수를 사용했던 코드)

```cpp-formatted
Date day;
```

로 했을 때 과연 생성자가 호출 될 까요? 답은 Yes 입니다. 생성자가 호출됩니다. 그런데, 우리가 생성자를 정의하지도 않았는데 어떤 생성자가 호출이 될까요? 바로 **디폴트 생성자(Default Constructor)** 입니다. 디폴트 생성자는 인자를 하나도 가지지 않는 생성자인데, 클래스에서 사용자가 어떠한 생성자도 명시적으로 정의하지 않았을 경우에 컴파일러가 자동으로 추가해주는 생성자입니다. 
\sidenote{사용자가 어떤 다른 생성자를 추가한 순간 컴파일러는 자동으로 디폴트 생성자를 삽입하지 않는 다는 것을 명심하세요!} 물론 컴파일러가 자동으로 생성할 때에는 아무런 일도 하지 않게 되지요. 그렇기에 맨 처음에 `set_date` 를 하지 않았을 때 쓰레기 값이 나왔던 것입니다.


물론 여러분이 직접 디폴트 생성자를 정의할 수 도 있습니다. 아래와 같이요.

```cpp-formatted
// 디폴트 생성자 정의해보기

#include <iostream>
using namespace std;
class Date {
  int year;
  int month;
  int day;

 public:
  void set_date(int _year, int _month, int _date);
  void add_day(int inc);
  void add_month(int inc);
  void add_year(int inc);
  void show_date();

  Date() {
    year = 2012;
    month = 7;
    day = 12;
  }
};

// 생략

int main() {
  Date day = Date();
  Date day2;

  day.show_date();
  day2.show_date();
  return 0;
}
```



성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1233FC35501D1C6A0CA47B)


와 같이 나오게 됩니다. 여러분은 아래와 같이 디폴트 생성자 `Date()` 를 정의하였습니다.


```cpp-formatted
Date() {
  year = 2012;
  month = 7;
  day = 12;
}
```



즉 `year` 에는 `2012, month` 에는 `7, day` 에는 2 를 집어넣게 되지요.



```cpp-formatted
Date day = Date();
Date day2;
```



그래서 사용하게 되면 위와 같이 디폴트 생성자를 이용해서 `day` 와 `day2` 를 추가할 수 있게 되는 것입니다. 한 가지 주의할 점은 위에서 인자가 있는 생성자에서 적용했던 것 처럼

```cpp-formatted
Date day3();
```



와 하면 `day3` 객체를 디폴트 생성자를 이용해서 초기화 하는 것이 아니라,리턴값이 `Date` 이고 인자가 없는 함수 `day3` 을 정의하게 된 것으로 인식합니다. 이는 암시적 표현으로 객체를 선언할 때 반드시 염두해 두어야 할 사항입니다.


###  생성자 오버로딩


앞서 함수의 오버로딩에 대해 설명을 하였는데요, 생성자 역시 같은 함수이기에 오버로딩이 가능합니다.

```cpp-formatted
#include <iostream>
using namespace std;
class Date {
  int year;
  int month;
  int day;

 public:
  void set_date(int _year, int _month, int _date);
  void add_day(int inc);
  void add_month(int inc);
  void add_year(int inc);
  void show_date();

  Date() {
    cout << "기본 생성자 호출!" << endl;
    year = 2012;
    month = 7;
    day = 12;
  }
  Date(int _year, int _month, int _day) {
    cout << "인자 3 개인 생성자 호출!" << endl;
    year = _year;
    month = _month;
    day = _day;
  }
};

// 생략
void Date::show_date() {
  cout << "오늘은 " << year << " 년 " << month << " 월 " << day << " 일 입니다 "
       << endl;
}
int main() {
  Date day = Date();
  Date day2(2012, 10, 31);

  day.show_date();
  day2.show_date();
  return 0;
}
```
성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F20654C3F501D25D315F080)


와 같이 적절히 오버로딩이 되서 사용자가 원하는 생성자를 호출할 수 있게 됩니다.

이것으로 생성자에 대해 간단히 설명을 마치겠습니다. 물론 아직 생성자에 대해 이야기 할 거리는 무궁무진하게 남아 있지만 일단 오늘은 함수의 오버로딩과 생성자에 대한 입문으로 충분히 여러분의 머리가 지끈지끈 달아 올랐을 테니 '생각해 보기'를 통해 머리를 식히도롭 합시다!


### 생각 해보기

#### 문제 1

`Date` 클래스에 여러가지 생성자들을 추가해보세요 (난이도 : 下)

#### 문제 2

수학 관련 소프트웨어를 만드는 회사에서 의뢰가 들어왔습니다. 중학생용 기하학 소프트웨워를 만드는 것인데요, 클래스는 총 두 개로 하나는 `Point` 로 점에 관한 정보를 담는 것이고 다른 하나는 `Geometry` 로 점들을 가지고 연산을 하는 클래스 입니다. 즉 아래와 같은 두 클래스의 함수들을 모두 정의하세요 (난이도 : 上)


```cpp-formatted
class Point {
  int x, y;

 public:
  Point(int pos_x, int pos_y);
};
class Geometry {
  Point *point_array;
  // 현재 공간에 대한 점들의 정보를 담고 있는 배열
  // 물론 배열의 크기는 생성자에서 초기화 하고 충분히
  // 크게 잡도록 합시다 (점 100 개 정도?)

 public:
  Geometry(Point *point_list);
  Geometry();

  void Add_Point(Point &point);

  // 모든 점들 간의 거리를 출력하는 함수 입니다.
  void Print_Distance();

  // 모든 점들을 잇는 직선들 간의 교점의 수를 출력해주는 함수 입니다.
  // 참고적으로 임의의 두 점을 잇는 직선의 방정식을 f(x,y) = ax+by+c = 0
  // 이라고 할 때 임의의 다른 두 점 (x1, y1) 과 (x2, y2) 가 f(x,y)=0 을 기준으로
  // 서로 다른 부분에 있을 조건은 f(x1, y1) * f(x2, y2) <= 0 이면 됩니다.
  void Print_Num_Meets();
};
```

##@ chewing-cpp-end
Link :  184
2012-03-25 19:56
----------------
title : 씹어먹는 C 언어 - 찾아보기
publish_date : 2012-03-25 19:56
--------------




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1740D8454F6EF9B4012A93)



  안녕하세요. 여러분! 오랜 간만 입니다. 이 글은 그냥 여러분이 편하게 궁금한 키워드들을 쉽게 찾을 수 있도록 링크를 걸어놓은 페이지 입니다. 다른 검색 엔진에 귀찮게 검색할 필요 없이 궁금한 것들은 `Ctrl + F` 를 이용해서 쉽게 찾을 수 있습니다.  그럼 즐겨 찾기 해주시고, 자주 이용해주세요~~

ㄱ
관계 연산자
 [/10](/10)



공백 문자
 [/32](/32)



공용체
 [/71](/71)



구조체
 [/55](/55)



구조체 대입
 [/60](/60)



구조체 동적 할당
 [/100](/100)



구조체 리턴
 [/71](/71)



구조체 변수
 [/55](/55)



구조체 인자
 [/60](/60)



구조체 포인터
 [/55](/55)



기수법
 [/21](/21)

ㄴ

널
 [/29](/29)



널 종료 문자열
 [/29](/29)



노드
 [/100](/100)



논리 연산자
 [/10](/10)



니블
 [/21](/21)

ㄷ

단항 연산자
 [/23](/23)



대입 연산자
 [/8](/8)

더블 워드
 [/21](/21)



더블 포인터
 [/25](/25)



더블 포인터 인자
 [/28](/28)



동적 할당
 [/98](/98)



디버그
 [/31](/31)

ㄹ
라이브러리
 [/88](/88)



램 (RAM)
 [/7](/7) [/83](/83) [/23](/23) [/18](/18)



롬(ROM)
 [/21](/21)



리터럴
 [/33](/33)



리턴값
 [/26](/26)



링킹
 [/87](/87)

ㅁ

매크로
 [/88](/88)



매크로 함수
 [/99](/99)



메모리
`Goto` 램



메인 함수
 [/26](/26)



메인 함수 인자
 [/89](/89)



모듈화
 [/87](/87)



문자
 [/9](/9)



문자열
 [/29](/29)



문자열 조작
  복사 [/33](/33)
  합치기 [/33](/33)
  비교 [/33](/33)



문자열 리터럴
`Goto` 리터럴

ㅂ

바이트
 [/21](/21)



반복문
 [/12](/12)



반전 연산자
 [/8](/8)



배열
 [/18](/18)



배열의 배열
 [/20](/20)



배열을 인자
 [/27](/27)



배열과 포인터
 [/24](/24)



배열을 가리키는 포인터
 [/25](/25)



버그
 [/31](/31)



버블 정렬
 [/30](/30)



버퍼
 [/32](/32)



변수
 [/7](/7)



버퍼 오버플로우
 [/9](/9)



부동 소수점 표현
 [/17](/17)



비트
 [/21](/21)



비트 연산자
 [/8](/8)

ㅅ

산술 변환
 [/8](/8)



산술 연산자
 [/8](/8)



상수
 [/18](/18)



상수 포인터
 [/24](/24)



선언

  공용체 [/71](/71)
  구조체 [/55](/55) [/71](/71)
  다차원 배열 [/20](/20)
  배열 [/18](/18)
  변수 [/7](/7)
  상수 [/18](/18)
  열거형 [/71](/71)
  함수 [/26](/26)



실수
 [/17](/17)



실수형 변수
 [/7](/7)




쉬프트 연산자
 [/8](/8)



스택 (Stack)
 [/83](/83)



스트림
 [/32](/32) [/117](/117)

ㅇ
에라토스테네스의 체
 [/30](/30)



연산자 우선순위
 [/8](/8)



열거형
 [/71](/71)



유클리드 호제법
 [/30](/30)



워드
 [/21](/21)



원형
  함수 [/27](/27)



인덱스
 [/18](/18)



인라인 함수
 [/99](/99)



인자
`Goto` 함수의 인자



입력 스트림
 [/117](/117)

ㅈ

작명 (Naming)

  변수 [/7](/7)



재귀 호출
 [/30](/30)



전역 변수 (Global variable)
 [/83](/83)



전위형
 [/8](/8)



전처리기
 [/88](/88)



정수형 변수
 [/7](/7)



정의
`Goto` 선언



정적 변수(Static `variable)`
 [/83](/83)



조건문
 [/10](/10)



조건식
 [/12](/12)



주소
 [/23](/23)



주석
 [/19](/19)



증감식
 [/12](/12)



증감 연산자
 [/8](/8)



지역 변수 (Local variable)
 [/83](/83)



ㅊ

초기식
 [/12](/12)



최적화
 [/129](/129)



출력 스트림
 [/117](/117)

ㅋ

컴파일
 [/87](/87)



캐스팅
 [/17](/17)



코드 영역 (코드 세그먼트)
 [/83](/83)

ㅌ

타입 범위
 [/7](/7)



ㅍ

파일 입출력
 [/117](/117)



파일 위치 지정자
 [/117](/117) [/123](/123)



파일 포인터
 [/117](/117)



포인터
 [/23](/23)



포인터 배열
 [/25](/25)



포인터 연산
 [/24](/24)



포인터 인자
 [/27](/27)



포인터 타입
 [/23](/23) [/25](/25)



포인터의 포인터
 [/25](/25)



프로그램을 어떻게 만들까
 [/43](/43)

ㅎ

함수
 [/26](/26)



함수의 인자
 [/26](/26)



함수의 원형
`Goto` 원형



헤더 파일
 [/87](/87)



형변환
 [/17](/17)



후위형
 [/8](/8)



힙(Heap)
 [/83](/83) [/98](/98)

`A`

`Address`
 [/23](/23)



`And operator`
 [/8](/8) [/10](/10)



`Arithmetic operator`
 [/8](/8)



`argc`
 [/89](/89)



`Argument`
 [/26](/26)



`Array`
 [/18](/18)



`argv`
 [/89](/89)



`ASCII Table`
 [/9](/9)



`Assignment operator`
 [/8](/8)

`B`

`Base`
 [/21](/21)



`Bias`
 [/17](/17)



`Big endian`
 [/71](/71)



`Bit`
 [/21](/21)



`Bit operator`
 [/8](/8)



`Binary`
 [/21](/21)



`break`
 [/12](/12)



`Bubble sorting`
 [/30](/30)



`Buffer`
 [/32](/32)



`Buffer Overflow`
 [/9](/9)



`Bug`
 [/31](/31)



`Byte`
 [/21](/21)

`C C

`case`
 [/16](/16)



`Casting`
 [/17](/17)



`char`
 [/9](/9)



`Code segment`
 [/83](/83)



`continue`
 [/12](/12)



`Constant`
 [/18](/18)



`Comment`
 [/19](/19)



`Compile`
 [/87](/87)

`D`

`Debug`
 [/31](/31)



`Declaration`

  `Array` [/18](/18)
  `Constant` [/18](/18)
  `enum` [/71](/71)
  `Function` [/26](/26)
  `struct` [/55](/55)
  `union` [/71](/71)
  `Variable` [/7](/7)



`Definition`

  `Goto Declaration`



`double`
 [/8](/8)



`Double word`
 [/21](/21)



`do` – `while`
 [/12](/12)



`Dynamic memory allocation`
 [/98](/98)

`E`﻿

`else statement`
 [/10](/10)



`else if statement`
 [/10](/10)



`ENIAC`
 [/12](/12)



`enum`
 [/71](/71)



`Exponent`
 [/21](/21)

`F`

`fclose`
 [/117](/117)



`fflush`
 [/32](/32) [/123](/123)



`fgetchar`
 [/117](/117)



`fgets`
 [/117](/117)



`float`
 [/8](/8)



`Floating point`
 [/17](/17)



`Function`
 [/26](/26)



`Function pointer`
 [/28](/28)



`fopen`
 [/117](/117) [/123](/123)



`for statement`
 [/12](/12)



`fputs`
 [/117](/117)



`free`
 [/98](/98)



`fseek`
 [/117](/117) [/123](/123)

`G`

`GCC`
 [/14](/14)



`getchar`
 [/32](/32)



`Global variable`
 [/83](/83)


`H`

`Header file`
 [/87](/87)



`Heap`
 [/83](/83) [/98](/98)

`I`


`include`
 [/87](/87)



`Index`
 [/18](/18)



`Inline function`
 [/99](/99)



`IEEE 754`
 [/17](/17)


`if statement`
 [/10](/10)


`inline`﻿` function`
 [/99](/99)



`int`
 [/8](/8)

`J`

`Jump table`
 [/16](/16)

`K`
`L`

`Library`
 [/88](/88)



`Linking`
 [/87](/87)



`Literal`
 [/33](/33)



`Little endian`
 [/71](/71)



`Local variable`
 [/83](/83)

`M`

`Macro`
 [/88](/88)



`Macro function`
 [/99](/99)



`Main function`
 [/26](/26)



`malloc`
 [/98](/98)



`Mantissa`
 [/17](/17)



`memcmp`
 [/100](/100)



`memcpy`
 [/100](/100)



`memmove`
 [/100](/100)



`memset`
 [/100](/100)



`Modular programming`
 [/87](/87)

`N`
`Naming`

  `Variable` [/7](/7)



`Numeral system`
 [/21](/21)



`Null`
 [/29](/29)



`Null terminating string`
 [/29](/29)



`Node`
 [/100](/100)



`Not operator`
 [/10](/10)

`O`

`Optimization`
 [/129](/129)



`OR operator`
 [/8](/8) [/10](/10)

`P`

#pragma
 [/103](/103)



#pragma `pack`
 [/103](/103)



#pragma `once`
 [/103](/103)



`prefix`
 [/8](/8)



`printf`
 [/6](/6) [/35](/35)



`Pointer`
 [/23](/23)



`Pointer Arithmetics`
 [/24](/24)



`Position indicator`
 [/117](/117)



`postfix`
 [/8](/8)



`Prototype`
 [/27](/27)

`Q`
`R`
`RAM (Random Access Memory)`
 [/7](/7) [/83](/83)



`Read Only data`
 [/83](/83)



`Recursive function`
 [/30](/30)



`ROM (Read Only Memory)`
 [/21](/21)

`S`
`scanf`
 [/9](/9) [/29](/29) [/32](/32)



`scanf_s`
 [/9](/9)



`SEEK_CUR`
 [/117](/117)



`SEEK_END`
 [/117](/117)



`SEEK_SET`
 [/117](/117)



`shift operator`
 [/8](/8)



`short`
 [/8](/8)



`stdin`
 [/32](/32)



`stack`
 [/83](/83)



`static variable`
 [/83](/83)



`String`
 [/29](/29)



`struct`
 [/55](/55)



`Swap`
 [/27](/27)



`switch statement`
 [/16](/16)

`T`
`Type conversion`
 [/17](/17)



`typedef`
 [/103](/103)

`U`

`Ubuntu Linux`
 [/14](/14)



`Unary operator`
 [/23](/23)



`Unicode`
 [/9](/9)



`union`
 [/71](/71)

`V`
`variable`
 [/7](/7)



`VIM`
 [/14](/14)



`void`
 [/89](/89)



`volatile`
 [/103](/103)

`W`

`while statement`
 [/12](/12)



`Whitespace character`
 [/32](/32)



`Word`
 [/21](/21)

`X`

`XOR operator`
 [/8](/8)

`Y`
`Z`

1,2,….

1.#INF00
 [/10](/10)



`2` 차원 배 2 차원 배열
 [/20](/20)



8진법
 [/21](/21)


16진법
 [/21](/21)



`[]` 연산자
 [/24](/24)



&연산자
 [/23](/23)



`*` 연산자
 [/23](/23)



`->` 연산자
 [/55](/55)



#define, #ifdef, #ifndef, #endif
 [/88](/88)
Link :  183
2012-03-25 12:54
----------------
title : C++ 레퍼런스 - STL 컨테이너 - vector::assign 함수
cat_title :  vector::assign
ref_title : assign
path : /C++ Reference/Containers/vector
publish_date : 2012-03-25 12:54
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ vector::assign

```info
template <class InputIterator>
  void assign ( InputIterator first, InputIterator last );
void assign ( size_type n, const T& u );

```

벡터에 새로운 내용을 집어 넣는다.
벡터 객체에 이전에 있었던 원소들은 모두 삭제하고, 인자로 받은 새로운 내용을 집어 넣는다.

첫번째 형태의 함수의 경우 `first` 부터 `last` 까지에 있는 원소들의 내용이 벡터에 들어가게 된다. (first 부터 last 바로 직전 원소 까지) 물론, 원래 벡터에 있었던 원소들은 삭제된다.

두번째 형태는 원래 내용을 다 지우고 원소 `u` 를 `n` 개 가지는 벡터로 만든다.



###  인자





`first, last`

`first` 부터 `last` 바로 직전까지의 원소들을 벡터에 대입한다.

`n`

몇번 `u` 를 반복해서 집어 넣을 지에 대해 전달한다. 이 때 `n` 은 `size_type` 타입으로, 부호 없는 정수 타입이다.

`u`

반복될 원소로 `T` 타입이다.



###  리턴값


없다



###  실행 예제



```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/stl/vector/assign/
에서 가져왔습니다

*/
#include <iostream>
#include <vector>
using namespace std;

int main() {
  vector<int> first;
  vector<int> second;
  vector<int> third;

  first.assign(7, 100);  // 100 을 7 번 반복해서 집어 넣는다.

  vector<int>::iterator it;
  it = first.begin() + 1;

  second.assign(it, first.end() - 1);  // first 의 처음과 끝을 제외한 원소들

  int myints[] = {1776, 7, 4};
  third.assign(myints, myints + 3);  // 배열로 부터 받는다.

  cout << "Size of first: " << int(first.size()) << endl;
  cout << "Size of second: " << int(second.size()) << endl;
  cout << "Size of third: " << int(third.size()) << endl;
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F19102C4E4F6E967A10EEAF)




###  연관된 함수

* vector::operator= : 벡터 내용을 복사한다.
Link :  178
2012-03-25 12:17
----------------
title : C++ 레퍼런스 - STL 컨테이너 - vector 생성자

cat_title :  vector 생성자
publish_date : 2012-03-25 12:17
--------------



```warning
이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
```

```info
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
```

#@ vector::vector


```info
explicit vector ( const Allocator& = Allocator() );
explicit vector ( size_type n, const T& value= T(), const Allocator& = Allocator() );
template <class InputIterator>
         vector ( InputIterator first, InputIterator last, const Allocator& = Allocator() );
vector ( const vector<T,Allocator>& x );
```


벡터를 생성한다.
벡터 컨테이너 객체를 생성하고, 사용한 생성자에 따라서 벡터 원소들을 초기화 한다.

```cpp-formatted
explicit vector(const Allocator& = Allocator());
```

▶ 디폴트 생성자(default `constructor)` 로 빈 벡터를 생성한다. 어떠한 원소도 담지 않고 있으므로 `size` 는 0 이다.


```cpp-formatted
explicit vector(size_type n, const T& value = T(),
                const Allocator& = Allocator());
```

▶값이 `T` 인 원소를 `n` 개 가지는 벡터 컨테이너를 생성한다.


```cpp-formatted
template <class InputIterator>
vector(InputIterator first, InputIterator last, const Allocator& = Allocator());
```

▶`first` 부터 `last` 번째 원소 까지 반복자가 순회(iterate) 하며, 각각의 원소들을 생성되는 벡터 컨테이너의 원소로 복사한다.


```cpp-formatted
vector(const vector<T, Allocator>& x);
```

▶복사 생성자. 벡터 `x` 와 동일한 원소 (복사본) 를 가지는 벡터를 생성한다.




###  인자




`n`

몇 번이나 원소를 반복해서 생성할지 나타낸다. 이 때 `n` 은 부호 없는 정수 타입이다.

`value`

벡터 컨테이너 객체에서 `n` 번 반복될 원소의 값
따라서 `value` 의 타입은 `T` 이다.

`first, last`

복사할 범위의 시작과 끝을 나타내는 반복자이다. 이 때 `first` 가 가리키는 원소 부터, `last` 가 가리키는 원소바로 직전까지 복사가 된다 (즉, 원소 전체를 복사하기 위해서는 `last` 에 `end` 를 전달하면 된다)

`x`

같은 클래스 템플릿 인자 (`T, Allocator`) 을 가지는 벡터 객체로, 이 객체가 복사되어 생성된다.



###  실행 예제



```cpp-formatted
/*이 예제는http://www.cplusplus.com/reference/stl/vector/vector/에서
 * 가져왔습니다.*/

#include <iostream>
#include <vector>
using namespace std;
int main() {
  unsigned int i;  // 위에서 설명한 생성자들을 차례대로 오버로딩함 vector<int>
                   // first;                                // int 를 보관할 빈
                   // 벡터 생성    vector<int> second (4,100); // 값이 100 인
                   // int 원소 4 개 보관    vector<int> third
                   // (second.begin(),second.end());  // second 의 처음 ~ 끝으로
                   // 생성    vector<int> fourth (third); // 세 번째 벡터 복사본
  // 배열을 통해서도 생성 가능하다.

  int myints[] = {16, 2, 77, 29};
  vector<int> fifth(myints, myints + sizeof(myints) / sizeof(int));
  cout << "The contents of fifth are:";
  for (i = 0; i < fifth.size(); i++) cout << " " << fifth[i];
  cout << endl;
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F181EE0434F6DEDE33C9FD7)





###  시간 복잡도





디폴트 생성자의 경우 상수 시간
동일한 원소 반복해서 생성하는 생성자 경우, `n` 에 비례
반복자를 이용해서 생성하는 경우, 두 반복자 사이 거리에 비례.
복사 생성자의 경우 `x` 의 크기에 비례한다.




###  연관된 함수


* vector::assign : 벡터 내용을 대입한다.
Link :  4
2009-01-12 13:25
Link :  3
2009-01-09 23:59
Link :  2
2009-01-09 00:23
Link :  1
2009-01-09 00:22
Link :  40
2010-02-02 20:56
----------------
title : C 언어 레퍼런스 - fputs 함수
cat_title :  fputs
publish_date : 2010-02-02 20:56
--------------


```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fputs

```info


﻿<stdio.h> // C++ 에서는 <cstdio>﻿﻿﻿int fputs ( const char * str, FILE * stream );
```

스트림에 문자열을 쓴다.

`str` 이 가리키는 문자열을 `stream` 에 씁니다.
`fputs` 는 `str` 이 가리키는 문자열을 `NULL` 문자 ('\0') 에 도달할 때 까지 스트림에 복사합니다. 마지막 `NULL` 문자는 스트림에 복사되지 않습니다.



###  인자




`str`

스트림에 쓰여질 널 문자로 끝나는 문자들의 배열.

`stream`

문자열을 쓸 스트림의 `FILE` 객체를 가리키는 포인터



###  리턴값




쓰기를 성공한다면 음이 아닌 수가 리턴된다.
오류가 발생한다면 `EOF` 를 리턴한다.



###  실행 예제




```cpp-formatted
/* 화면에 str 의 내용을 출력한다. */
#include <stdio.h>
int main() {
  char str[] = "string to print \n";

  fputs(str, stdout);

  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F18309F0C4B6811F13F2A5C)

화면(stdout) 에 `str` 의 내용인 `string to print` \n 이 출력된 것을 볼 수 있다.

```cpp-formatted
/*

mylog.txt 에 (없으면 파일을 생성한다) 사용자로 부터 입력받은 문자열을 추가한다.
(기존의 파일 내용은 삭제되지 않고 끝에 덧붙인다)
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fputs/
에서 가져왔습니다.

*/

#include <stdio.h>
int main() {
  FILE* pFile;
  char sentence[256];

  printf("mylog.txt 에 추가할 문자열을 입력하세요: ");
  fgets(sentence, 255, stdin);
  pFile = fopen("mylog.txt", "a");
  fputs(sentence, pFile);
  fclose(pFile);
  return 0;
}
```

실행 화면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1931E40B4B68116928BD26)

파일의 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F171D710B4B6811A4481109)




###  연관된 함수





*  [puts](http://itguru.tistory.com/39)   : `stdout` 에 문자열을 쓴다.

*  [fgets](http://itguru.tistory.com/38)  : 스트림에서 문자열을 받아온다.

*  [fputc](http://itguru.tistory.com/39)  : 스트림에 한 문자를 쓴다.

*  [fprintf](http://itguru.tistory.com/64): 특정한 형식으로 스트림에 쓴다.

*  [fwrite](http://itguru.tistory.com/69): 스트림에 데이터 블록을 쓴다.
Link :  33
2010-02-01 15:14
----------------
title : 씹어먹는 C 언어 - <15 - 3. 일로와봐, 문자열(string) - 문자열 지지고 볶기 & 리터럴>
cat_title : 15 - 3. 일로와봐, 문자열(string) - 문자열 지지고 볶기 & 리터럴
next_page : 43
publish_date : 2010-02-01 15:14
--------------


이번 강좌에서는

* 문자열 리터럴(literal)에 대한 이해

* 문자열 다루기 (복사, 합치기, 비교하기)


![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요~ 여러분. 문자열의 3 번째 강의 입니다. 아마도 지난번 강의에서 좌절을 느끼신 분들은 아마 이번 강의는 아주 아주 수월하게 이해해 나갈 수 있으리라 믿고 있습니다. 끝이 보이지 않는 C 언어 강좌 이지만 이제 거의 70 ~ 80% 정도를 지나 왔다고 해도 무방 합니다. 문자열이 끝나게 되면 구조체에 대해 다루게 되는데, 구조체가 끝나면 잡다한 것들만 남아서 슝슝슝 지나갈 수 있습니다. 또한 조금만 더 지나면 C 언어에 대한 강좌 보다는 여러가지 프로그램을 만들어 보며 C 언어를 익혀 보는 강좌를 중심으로 진행할 것입니다.

인터넷 강좌 치고 체계적인 것 같죠? 아무튼. 15 - 3 강, 전체 강좌 수로 치면 25 번째 강좌를 시작하겠습니다.

일단, 아래 코드를 실행해봅시다.

```cpp-formatted
/* 문자열 */
#include <stdio.h>
int main() {
  char str[] = "sentence";
  char *pstr = "sentence";

  printf("str : %s \n", str);
  printf("pstr : %s \n", pstr);

  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F11100D0D4B5C7D143D8049)

```cpp-formatted
char str[] = "sentence";
char *pstr = "sentence";
```

일단, 여러분들은 당연하게도 위 두 개의 문장을 보고 이상하다고 생각하셨을 것입니다. 일단 첫번째 문장은 평범한 문장 입니다. `sentence` 라는 문자열을 `str` 이라는 배열에 집어 넣고 있지요. 그런데 두 번째 문장은 말이죠. 상당히 이상합니다. 왜냐하면 일단 "sentence" 는 문자열이고, 어떤 변수의 주소값이 아닙니다. `pstr` 는 `char` 형을 가리키는 포인터 이므로 `char` 형 변수의 주소값이 들어가야되기 때문이죠.

그런데 우리는 마치 "sentence" 를 특정한 주소값 마냥 사용하고 있습니다. 그런데, 말이죠. "sentence" 는 주소값 맞습니다. 그렇다면 무엇의 주소값이죠? 바로, "sentence" 라는 문자열이 저장된 주소값 (시작 주소값) 을 말합니다. 정말로 놀랍지 않습니까? 사실 저도 잘 믿기지 않습니다. 만일 믿기지 않는다면 아래 문장을 넣어 실행해 보세요.

```cpp-formatted
printf("%d \n", "sentence");
```

정말로, 특정한 수가 출력됨을 알 수 있습니다. 그렇다면 이 "sentence" 는 도대체 뭘까요?

일단, "sentence" 의 정체를 먼저 파악하기 전에 다음의 소스 코드를 실행해보시기 바랍니다.

```cpp-formatted
/* 문자열 */
#include <stdio.h>
int main() {
  char str[] = "hello";
  char *pstr = "goodbye";

  str[1] = 'a';
  pstr[1] = 'a';

  return 0;
}
```

  성공적으로 컴파일 했어도 실행해 보면 오류가 날 것입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1109D1264B5D46B4234850)

Windows 7 의 경우 위와 같은 화면이 나오며 다른 운영체제의 경우 다른 화면이 나올 수 있습니다.

헐.. 왜 오류가 난 것일까요? 일단, `pstr[1] = 'a';` 를 주석 처리한 후 다시 실행해 보면 제대로 실행됨을 알 수 있습니다. 다시말해,

```cpp-formatted
pstr[1] = 'a';
```

가 문제인 것이군요. 그런데 말이죠. 왜 문제가 발생한 것일까요? 맨 위의 예제에서 `pstr` 의 값을 읽기만 하였을 때(`printf` 함수는 값을 읽기만 하지 변경하지 않는다) 정상적으로 실행되었지만 아래에서 `pstr[1] = 'a';` 를 통해 `pstr` 의 값을 변경하였을 때 오류가 출력된 것을 보아 마치 상수 처럼 컴퓨터에서 값을 변경하도록 허락 하지 않는 것 같습니다.


###  리터럴(literal)

 프로그래밍 언어에서 **리터럴(literal)**이란, 소스 코드 상에서 고정된 값을 가지는 것을 일컫습니다. 특히, C 언어의 경우 큰 따옴표(") 로 묶인 것들을 **문자열 리터럴(string literal)** 이라 부릅니다.

```cpp-formatted
char str[] = "hello";
char *pstr = "goodbye";
printf("why so serious?");
scanf("%c", str[0]);
```

그렇다면 위 4 개의 문장에서 문자열 리터럴은 무엇일까요? 물론, 짐작하였던 대로 `hello, goodbye, why so serious, %c` 모두 리터럴이 됩니다. 왜냐하면 모두 큰따옴표로 묶여져 있잖아요? 그런데 왜 `hello, goodbye, why so serious, %c` 처럼 큰따옴표로 둘러쌓인 것들을 왜 리터럴이라 부르는 것일까요?

답은 간단합니다. 이들은 소스 코드 상에서 고정된 값을 가지기 때문이죠. 예를 들어서 `hello` 가 소스 코드 상에서 고정된 값을 가지지 않는 다고 해봅시다. 만일 내가 아래와 같은 문장을 이용했다고 하면

```cpp-formatted
char str[] = "hello";
```

실제 프로그램에서는 `str` 에 `hello` 가 아닌 다른 값 `-` 예를 들어 `hi` 가 들어갈 수 도 있다는 것입니다.

이는 마치....

```cpp-formatted
int i, j;
// 잡다한 작업들...
i = j;
```

위와 같은 코드에서 맨 마지막 문장이 `i` 에 3 을 대입되기를 기대하는 것과 같은 것입니다.

하지만 다행스럽게도 `hello` 는 리터럴이기 때문에 우리가 `char str[] = "hello";` 라고 쓴 이상 컴퓨터는 `str` 이라는 배열에 `hello` 라는 문자열을 대입할 것입니다. 마찬가지로 `why so serious` 의 경우에도 리터럴 이기 때문에 `prinf` 가 이상하지 않은 이상 컴퓨터는 `why so serious` 를 화면에 출력할 것입니다.

컴퓨터는 이러한 리터럴들을 따로 모아서 보관합니다. 즉, 프로그램을 실행하면 메모리 상의 특별한 곳에 `hello, goodbye, why so serious, %c` 와 같은 리터럴들이 쭈르륵 보관되어 있는 공간이 생긴다는 것입니다. \sidenote{좀 더 궁긍하신 분들을 위해 추가적으로 설명하자면, 프로그램이 실행되서 메모리에 로드되면, 5 가지 종류의 영역(text segment, data segment, bss segment, heap, stack) 이 존재합니다. 이 때, text segment 에 프로그램 코드와 상수, 리터럴 등이 여기서 정의됩니다. 왜냐하면 text segment 에 있는 내용들은 읽기만 가능하기 때문이지요.} 그러다가 컴퓨터가 `char str[] = "hello";` 라는 문장을 실행하게 되면 컴퓨터는 "야, 리터럴 있는 곳에서 첫번째 리터럴 좀 가져와서 `str` 에 대입좀 해라" 와 같은 명령을 실행하게 되는 것이지요.

마찬가지로 `char *pstr = "goodbye";` 을 실행하게 되면 컴퓨터는 "야, 리터럴 있는 곳에서 두번째 리터럴 (물론 두번째가 아닐 수도 있지만 여기선 예시의 단순화를 위해서..) 의 주소값 좀 가져와서 `pstr` 에 대입좀 해라" 라는 의미의 작업을 실행합니다. 따라서, `pstr` 은 "goodbye" 라는 리터럴을 가리키고 `printf("%s", pstr)` 을 했을 때 `goodbye` 를 성공적으로 출력할 수 있게 되었던 것이죠.

그런데 말이죠. 아까 위에서 이야기 하였던 리터럴의 조건 기억 하시나요? 아까 분명히 리터럴은 소스 코드 상에서 고정된 값을 가지는 것들 이라고 이야기 했습니다. 다시 말해서 실제 프로그램 실행 중에서도 리터럴의 값은 절대로 변경 되서는 안된다는 것입니다. 아까도 말했듯이 만일 `hello` 라는 리터럴의 값을 실수로 (물론 내가 했을 수도 있고 컴퓨터의 버그로 그랬을 수 도 있고) `hi` 로 변경하였다면 사용자는 분명히 `str` 에 `hello` 라는 값을 넣으라고 명령했지만 `hi` 가 들어가게 되어 큰 문제를 야기할 수 있게 됩니다.

따라서 리터럴이 보관되는 곳은 "오직 읽기만 가능한 곳" 이 됩니다. 다시 말해 이곳에 한 번 저장된 값은 죽었다 깨어나도 영원이 동일하게 유지가 되는 것입니다. 만일 이곳을 함부로 변경하려고 하는 시도가 있다면 바로 오류를 삑 출력하게 되죠. 그렇기 때문에 우리는 `char str[] = "hello";` 를 했다면 `str` 에 `hello` 가 들어가고 `printf("why so serious?");` 를 했다면 화면에 `why so serious` 가 출력될 것이라고 보장할 수 있다는 것이죠. 왜냐하면 이 모든 문자열들이 "문자열 리터럴" 이라는 이름 하에 메모리 상의 특별한 공간에서 철저히 보호 받고 있기 때문입니다.

```cpp-formatted
char *pstr = "goodbye";
pstr[1] = 'a';
```

그럼 위 코드를 다시 살펴봅시다. 우리는 앞서 `goodbye` 역시 문자열 리터럴 이기 때문에 "리터럴 들의 세상 (정확히 말하면 이 곳에는 리터럴들만 있는 것이 아니라 우리가 프로그램 상에서 정의한 상수들도 이곳에 저장됩니다) " 에 저장된다고 했습니다. 그런데 이 곳은 오직 읽기만 가능한 곳이므로 쓰기를 시도 하려고 할 시에 오류를 뿜게 된다고 했습니다. 그런데 말이죠. 제가 무례하게도 `pstr[1] = 'a';` 을 통해 "리터럴 세상에 저장된 리터럴 goodbye" 의 값을 변경하려고 했습니다. 따라서 컴퓨터에서 오류를 삑 뿜게 되는 것이죠.

  반면에

```cpp-formatted
printf("pstr : %s \n", pstr);
```

와 같이 오직 읽기 작업만을 수행하는 `printf` 의 경우 잘 실행되지요. 왜냐하면 리터럴 세상에 저장된 리터럴들에 쓰기는 불가능 하지만 적어도 읽기는 허용되기 때문입니다.

사실 위 리터럴들을 굳이 비유하자면 다음과 같습니다.

```info
옛날에 부자가 있었습니다. 이 부자는 돈이 너무나 많아서 금고에 보관하려고 하는데, 돈을 넣다 보니 금고가 200 개나 필요하게 되었습니다. 그런데 이 금고의 비밀번호를 모두 똑같게 하면 안되니까 이 금고에 비밀번호를 모두 다르게 하려고 합니다. 하지만 200 개의 금고의 비밀번호를 막상 정하고 나니 이를 어디에 기록할 곳이 없는 것입니다. 종이에 써놓기도 조금 위험하고, 그렇다고 컴퓨터에 저장하기에는 해킹에 위협이 있고... 그래서 부자는 알바생 200 명(== 리터럴) 을 데리고 와서 한 명씩 자기 금고의 비밀번호를 알려주었습니다.

그리고는 이 알바생들을 수용소(== 리터럴이 저장되는 영역) 에 가두어놓았지요. 물론 수용소에는 어떤 사람도 출입할 수 없습니다. 왜냐하면 어떤 이상한 사람이 들어와 알바생과 이야기를 나누다가 알바생이 비밀번호를 까먹으면, 아니 비밀번호를 조금 이라도 잊어 버리면 금고의 문을 절대로 열 수 없게 되기 때문이죠. 따라서 이 수용소는 철통 보안 24 시간 내내 감시되어야 합니다 (== 리터럴이 저장되는 영역에는 쓰기가 불가능 하다). 하지만 부자가 금고문을 열어야 할 때 에는 반드시 알바생을 불러서 비밀번호를 알아야 문을 열어야 겠죠? (== 리터럴은 오직 읽기만 가능하다)
```

###  문자열 다시 가지고 놀기

C 언어에서 문자열을 다루는 일은 생각보다 불편한 편입니다. 예를 들어서 `int` 형 변수의 경우

```cpp-formatted
int i, j = 0;
i = j + 3;
```

  과 같이 값을 더하는 것이 가능하지만 문자열의 경우

```cpp-formatted
char str1[] = {"abc"};
char str2[] = {"def"};
str1 = str1 + str2;
```

를 한다고 해서 `str1` 이 "abcdef" 가 되는 것이 절대로 아니지요. `str1 + str2` 는 각 배열의 주소값을 더하는 것인데, 이전에도 말했듯이 배열의 이름은 포인터 상수 이기 때문에 대입 연산을 수행시 오류가 나게 됩니다.

  뿐만 아니라 다음과 같이 문자열을 비교하는 것도 불가능합니다.

```cpp-formatted
if (str1 == str2) ```

왜냐하면 위 문장의 의미는 "`str1` 의 문자열이 들어있는 메모리 상의 (시작)주소와 `str2` 의 문자열이 들어있는 메모리 상의 (시작) 주소값을 비교해라" 라는 의미의 문장이기 때문입니다. 따라서 역시 우리가 원하던 기능이 실행 될 수가 없습니다. 물론 다음과 같은 문장도 원하는 대로 실행이 되지 않습니다.

```cpp-formatted
if (str1 == "abc") ```

잘 알겠지만 "abc" 은 리터럴 입니다. 즉, `str1` 과 "abc" 를 비교한다는 뜻은 "str1 이 저장된 메모리 상의 주소값과 `abc` 라는 문자열 리터럴이 보관된 메모리 상의 주소값을 비교" 하는 문장이기 때문에 절대로 우리가 원하는 "str1 의 문자열과 `abc` 를 비교한다" 라는 뜻을 가질 수 없습니다.

가장 짜증나는 문제는 문자열을 원하는 대로도 복사를 못한다는 것입니다. 다시말해 `int` 형 변수처럼 원하는 값을 "대입" 할 수 없다는 말입니다. 만일 우리가

```cpp-formatted
str1 = str2;
```

라는 문장을 쓴다라면 "`str1` 에 `str2` 의 값을 대입해라" 라는 문장이 되는데 역시 `str1` 의 값은 바뀔 수 없는 포인터 상수 이기 때문에 오류가 발생하게 됩니다. 여하튼 문자열을 다루는데에는 제약이 너무나 많습니다. 하지만 다행스럽게 함수를 이용해서 그나마 편리하게 다룰 수 있습니다.

일단, 위에서 지적한 내용을 바탕으로 문자열을 자유롭게 다루려면 다음과 같은 함수들이 필요할 것입니다.


* 문자열 내의 총 문자의 수를 세는 함수
* 문자열을 복사하는 함수
* 문자열을 합치는 함수 (즉 더하는)
* 문자열을 비교하는 함수

  제 강좌에서는 위 4 개의 함수들을 모두 구현해 보도록 할 것입니다. (1 번의 경우 [15 -1](http://itguru.tistory.com/29)강에서 한 내용이므로 생략하도록 하겠습니다) 제가 이를 모두 구현하기 전에 여러분들이 한 번 어떻게 하면 만들 수 있는지 생각해 보도록 했으면 합니다.

#### 문자열을 복사하는 함수

문자열을 복사하는 함수는 어떻게 하면 만들 수 있을까요? 우리가 무언가를 작업하는 함수를 만들기 전에 반드시 고려해야 하는 사항들은 다음과 같습니다. (이 사실을 이전 함수 단원에서 이야기 했으면 더 좋았을 것을..)


1. 이 함수는 무슨 작업을 하는가? (자세할 수록 좋다)

2. 함수의 리턴형이 무엇이면 좋을까?

3. 함수의 인자으로는 무엇을 받아야 하는가?


특히 ① 번의 경우 상당히 중요합니다. "무슨 무슨 함수를 만들어야 겠다" 라고 정하지도 않고 무턱대고 함수를 만들다 보면 소스 코드가 상당히 난잡해지고 이해하기 힘들게 됩니다. 이 경우 우리는 말그대로 문자열을 복사하는 함수, 즉 `a` 라는 문자열이 있다면 `a` 문자열의 모든 내용을 `b` 로 복사하는 함수 입니다.

두번째로 함수의 리턴형을 생각해봅시다. 문자열을 복사하는 함수에서 무슨 리턴형이 필요하냐고 물을 수도 있는데 저의 경우 복사가 성공적으로 되었다면 1 을 리턴하도록 만들어보고 싶습니다. 즉 `char` 형의 함수를 만들 것 입니다.

세번째로 함수의 인자로 무엇을 받아야 할 지 생각해 봅시다. 당연하게도 두 개의 문자열을 받아야 하므로 포인터를 사용해야겠죠? 이 때 문자열들은 `char` 형 배열 이기에 `char*` 을 인자로 2 개 가지는 함수를 만들 것 입니다.

```cpp-formatted
/*

char copy_str(char *dest, char *src);

src 의 문자열을 dest 로 복사한다. 단, dest 의 크기가 반드시 src 보다 커야 한다.

*/
char copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;  // 그 다음 문자를 가리킨다.
    dest++;
  }
  *dest = '\0';

  return 1;
}
```

예를 들어 위 함수를 써먹어 봅시다.

```cpp-formatted
/* copy_str 사용 예제 */
#include <stdio.h>
char copy_str(char *src, char *dest);
int main() {
  char str1[] = "hello";
  char str2[] = "hi";

  printf("복사 이전 : %s \n", str1);

  copy_str(str1, str2);

  printf("복사 이후 : %s \n ", str1);

  return 0;
}
char copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F173D41124B5F0F2B065F6E)

현재 여러분 정도의 수준이 되었다면 위 `copy_str` 함수 정도는 손쉽게 분석할 수 있으리라 믿지만 그래도 만약을 위해서 한 번 설명 해보도록 하겠습니다.

```cpp-formatted
while (*src) {
  *dest = *src;
  src++;
  dest++;
}
```

먼저 `while` 문 부분을 살펴봅시다. `while` 문의 조건이 `*src` 입니다. 뭔 뜻인지 알겠죠? 문자열을 다룰 때 많이 쓰는 방법인데, `NULL` 문자의 값이 0 이므로 `*src` 가 `NULL` 문자에 도달하기 전 까지 `while` 문이 계속 돌아가게 됩니다.

그리고 `*dest = *src` 를 통해서 `src` 의 문자를 `dest` 에 대입하였습니다. 그리고 `src` 와 `dest` 를 각각 1 씩 증가시켰는데.. 포인터의 연산 기억 하시죠? 포인터에 1 을 더하면 단순히 주소값이 1 이 들어가는 것이 아니라 포인터가 가리키는 타입의 크기를 곱한 만큼 증가한다는 사실. 다시말해 배열의 그 다음 원소를 가리킬 수 있다는 것입니다.

```cpp-formatted
*dest = '\0';
```

마지막으로 `dest` 에 '\0' ,  즉 `NULL` 문자를 집어 넣었습니다. 아까 위의 `while` 문에서 `src` 가 `NULL` 이 된다면 `while` 문을 종료해 버렸기 때문에 `src` 에 넣을 틈이 없었는데 마지막에 위와 같이 처리해줌으로써 `dest` 에 `NULL` 문자를 끝부분에 삽입할 수 있게되었습니다.

참고적으로 이야기 하지만 이 함수는 상당히 위험한 편인데 왜냐하면 `dest` 의 크기가 `src` 의 크기보다 큰지 작은지 검사하지 않기 때문입니다. 만일 `dest` 의 크기가 `src` 보다 작다면 메모리의 허락 되지 않는 공간까지 침범하므로 큰 문제를 야기할 수 있습니다.

잠깐만요! 아마도 이 문자열을 복사하는 함수를 만들면서 "굳이 이 함수를 만들어야 되나?" 라고 생각하시는 분들이 있나요? 아마 있겠지요. 저도 그랬으니까요. 보통 이런 생각을 하시는 분들은 다음과 같은 코드를 제안합니다.

```cpp-formatted
char str[100];
str = "abcdefg"; /* str 에 abcdefg 가 복사되지 않을까? */
```

  그러나 이 방법으로 컴파일을 하게 되면 아래와 같은 오류를 만나게 됩니다.

```warning
error C2106: '=' : 왼쪽 피연산자는 l-value이어야 합니다.

```

도대체 왜 그런 것일까요? 아마 리터럴과 배열을 제대로 이해한 사람이라면 쉽게 답을 알 수 있을 것입니다. 일단, `str = "abcdefg"` 라는 문장은 '`str` 에 문자열 리터럴 `abcdefg` 가 위치한 곳의 주소값을 넣어라' 입니다. 그런데 말이죠. 우리가 이전에 배열에 대해 공부한 바로는 배열 이름은 상수 입니다. 즉, 배열의 주소값을 바꿀 수 없다는 것입니다!

  따라서, 위와 같은 코드는 상수에 값을 대입하는 의미이기 때문에 오류가 발생하게 됩니다.

  그런데 말이죠. 왜 다음 문장은 말이 되는 것일까요?

```cpp-formatted
char str[100] = "abcdefg";
```

이는 단순히 C 언어에서 사용자의 편의를 위해 제공하는 방법이라 생각하면 됩니다. 오직 배열을 정의할 때 사용할 수 있는 방법이죠. 기억하세요!오직 배열을 정의할 때 에만 위 방법을 사용할 수 있습니다. 위처럼 사용하면 우리가 예상하던 대로 `str` 의 각각의 원소에 `a` 부터 `g` 까지 들어가게 됩니다.

#### 문자열을 합치는 함수

  문자열을 합치는 함수라 하면 다음과 같은 작업을 하는 함수를 말합니다.

```info
    char str1[100]="hello my name is ";
    char str2[]="Psi";

    stradd(str1, str2);

    // str1 은 "hello my name is Psi" 가 된다.
```

 한 번 만들어보세요.

완성된 소스는 아래와 같습니다.

```cpp-formatted
/*

stradd 함수

dest 에 src 문자열을 끝에 붙인다.
이 때 dest 문자열의 크기를 검사하지 않으므로 src 가 들어갈 수 있는 충분한 크기가
있어야 한다.

*/
char stradd(char *dest, char *src) {
  /* dest 의 끝 부분을 찾는다.*/
  while (*dest) {
    dest++;
  }

  /*
  while 문을 지나고 나면 dest 는 dest 문자열의 NULL 문자를 가리키고 있게 된다.
  이제 src 의 문자열들을 dest 의 NULL 문자 있는 곳 부터 복사해넣는다.
  */
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  /* 마지막으로 dest 에 NULL 추가 (왜냐하면 src 에서 NULL 이 추가 되지
   * 않았으므로) */
  *dest = '\0';

  return 1;
}
```


  이제 위 함수를 써먹어 봅시다.

```cpp-formatted
#include <stdio.h>
char stradd(char *dest, char *src);
int main() {
  char str1[100] = "hello my name is ";
  char str2[] = "Psi";

  printf("합치기 이전 : %s \n", str1);

  stradd(str1, str2);

  printf("합친 이후 : %s \n", str1);

  return 0;
}
char stradd(char *dest, char *src) {
  /* dest 의 끝 부분을 찾는다.*/
  while (*dest) {
    dest++;
  }

  /*
  while 문을 지나고 나면 dest 는 dest 문자열의 NULL 문자를 가리키고 있게 된다.
  이제 src 의 문자열들을 dest 의 NULL 문자 있는 곳 부터 복사해넣는다.
  */
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  /* 마지막으로 dest 에 NULL 추가 (왜냐하면 src 에서 NULL 이 추가 되지
   * 않았으므로) */
  *dest = '\0';

  return 1;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F164FD7164B6053842AAC39)

역시. 제대로 출력이 됩니다. 일단 `stradd` 의 구조는 단순합니다. `dest` 의 끝에 문자열을 덧붙이기 위해서는 먼저 `dest` 문자열의 끝 부분을 찾아야겠죠? 따라서

```cpp-formatted
while (*dest) {
  dest++;
}
```

를 통해서 `dest` 의 널문자의 위치를 찾습니다. (물론 그 위치는 `dest` 가 가리키고 있겠지요) 이제, 그 널문자가 들어갔던 곳을 포함하여 `dest` 의 끝에 `src` 문자열을 덧쓰면 됩니다. 아래와 같이죠.

```cpp-formatted
while (*src) {
  *dest = *src;
  src++;
  dest++;
}
```

물론 이때도 주의해야 할 점은 `*src` 가 `NULL` 이 되면 `while` 문이 종료되므로 `src` 의 널문자를 복사할 수 없게 됩니다. 따라서 아래와 같이 `dest` 의 끝부분에 `NULL` 문자를 집어 넣어주어야 합니다.

```cpp-formatted
*dest = '\0';
```

자. 그럼 이해가 되셨는지요?

#### 문자열을 비교하는 함수

  문자열을 비교하는 함수라 하면 다음과 같은 작업을 하는 함수를 의미합니다.

```info
if(compare(str1, str2))
{
/*
 만일 str1 과 str2 가 같다면 이 부분이 실행되고 아니면 지나갑니다.
참고로 if 문에서 0 이 아닌 값만 들어가면 무조건 참으로 처리되는 사실은 알고 계시죠?
*/
}

```

한 번 만들어보세요.

완성된 소스는 아래와 같습니다.

```cpp-formatted
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```


이제 위 함수를 써먹어 봅시다.

```cpp-formatted
#include <stdio.h>
char compare(char *str1, char *str2);
int main() {
  char str[20] = "hello every1";
  char str2[20] = "hello everyone";
  char str3[20] = "hello every1 hi";
  char str4[20] = "hello every1";

  if (compare(str, str2)) {
    printf("%s 와 %s 는 같다 \n", str, str2);
  } else {
    printf("%s 와 %s 는 다르다 \n", str, str2);
  }

  if (compare(str, str3)) {
    printf("%s 와 %s 는 같다 \n", str, str3);
  } else {
    printf("%s 와 %s 는 다르다 \n", str, str3);
  }

  if (compare(str, str4)) {
    printf("%s 와 %s 는 같다 \n", str, str4);
  } else {
    printf("%s 와 %s 는 다르다 \n", str, str4);
  }

  return 0;
}
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```

성공적으로 컴파일 했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F157547154B66543065C1EF)

   `compare` 함수가 어떻게 작동하는지 알아보도록 합시다,.

```cpp-formatted
while (*str1) {
  if (*str1 != *str2) {
    return 0;
  }

  str1++;
  str2++;
}
```


일단 `while` 문에서 `str1` 의 끝에 도달할 때 까지 각 문자들을 비교합니다. 만일 한 문자라도 다르다면 `if` 문에 의해 0 이 리턴되고 함수는 종료됩니다. 그렇지 않다면 `while` 문을 끝가지 통과하게 되죠.

그런데 여기서 끝난 것이 아닙니다. 만일 `str1` 과 `str2` 가 `str1` 부분만 일치하였다면 어떨까요? 다시말해 `str1` 은 "abc" 이지만 `str2` 는 "abcd" 라면? 그렇다면 `while` 문에서 검사할 때 `str1` 이 끝날 때 까지만 검사하므로 `while` 문을 잘 통과하게 됩니다. 따라서 여러분은 `str1` 이 끝났을 때 `str2` 도 끝났는지 확인해볼 필요성이 있습니다.

```cpp-formatted
if (*str2 == '\0') return 1;
```

따라서 위 문장을 추가해줌으로써 우리는 `str2` 가 끝이 났는지 확인할 수 있게 됩니다. 만일 `*str2` 가 \0 이 아니라면, 즉 `str2` 가 끝난 것이 아니라면 `str1` 과 `str2` 는 다른 것이 되므로 함수는 0 을 리턴하게 됩니다. 어때요? 간단하죠? 사실 위에서 설명한 4 개의 함수들만 이용하면 문자열을 이용한 왠만한 작업들은 수행이 가능합니다. 이번 강좌는 이쯤게 끝내도록 하겠습니다. 문자열 함수를 이용해서 문자열들을 적절히 가지고 노는 것은 여러분의 몫입니다. 부디 문자열을 가지고 여러가지 재미있는 프로그램을 만들어보았으면 합니다.

### 생각해보기

#### 문제 1

길이가 최대 100 인 문자열을 하나 입력 받아서 문자열을 역순으로 출력하는 함수를 만들어보세요. (난이도 : 下)
예를 들어서 "abcde" 입력 --> "edcba" 출력

#### 문제 2

길이가 최대 100 인 문자열을 입력 받아서 소문자는 대문자로, 대문자는 소문자로 출력하는 함수를 만들어보세요. (난이도 : 下)
예를 들어서 "aBcDE" 입력 --> "AbCde" 출력

#### 문제 3

두 개의 문자열을 입력 받아서 같다면 "같다", 다르면 "다르다" 라고 출력하는 함수를 만들어보세요. (난이도 : 下)

#### 문제 4

문자열을 두 개 입력 받아서 먼저 입력받은 문자열에서 나중에 입력받은 문자열의 위치를 검색하는 함수를 만들어보세요. 만일 없다면 -1 을 리턴하고 있다면 그 위치를 리턴합니다. (난이도 : 中)

예를 들어먼저 처음 입력한 것이 `I_am_a_boy` 이고, 나중에 입력한 것이 `am` 이였다면 컴퓨터는 `I_am_a_boy` 에서 `am` 의 위치를 찾는다. 이 경우에는 `am` 의 위치는 2 (처음에서 세번째) 이므로 2 를 리턴한다. 만일 `am` 이라는 문자열이 없다면 -1 을 리턴한다.

#### 문제 5

5. 도서 관리 프로그램을 만들어봅시다. 프로그램에는 다음과 같은 기능들이 구현되어 있어야 합니다. (난이도 : 上)

* 책을 새로 추가하는 기능 (책의 총 개수는 100 권이라 하자. 이 때, 각 책의 정보는 제목, 저자의 이름, 출판사로 한다)

* 책의 제목을 검색하면 그 책의 정보가 나와야 한다.

* 위와 마찬가지로 저자, 출판사 검색 기능이 있어야 한다.

* 책을 빌리는 기능.

* 책을 반납하는 기능


##@ chewing-c-end
Link :  39
2010-01-29 02:29
----------------
title : C 언어 레퍼런스 -  fputc 함수
cat_title :   fputc
publish_date : 2010-01-29 02:29
--------------


```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fputc

```info

#include <stdio.h> //C++ 의 경우 <cstdio>
int fputc ( int character, FILE * stream );
```



스트림에 한 문자를 쓴다.스트림(stream) 에 한 문자를 쓰고 위치 표시자를 증가시킨다.
스트림에 써질 문자의 위치는 위치 표시자에 의해 지정되며, 한 문자를 쓴 후에 위치 표시자가 한 칸 증가된다.



### 인자
### 

`character`

쓰여질 문자. 이 때, 문자는 `int` 로 형변환 되어서 전달된다.

`stream`

문자가 쓰여질 스트림의 `FILE` 객체를 가리키는 포인터.



### 리턴값
### 

오류가 없다면 쓰여진 문자가 그대로 반환된다.
만일 오류가 발생하였다면 `EOF` 가 리턴되고, 오류 표시자가 설정된다. ( [ferror](http://itguru.tistory.com/52)참조)



### 실행 예제
### 

```cpp-formatted
/* 표준출력(stdout) 에 문자열을 출력한다 */
#include <stdio.h>

int main() {
  char str[20] = "hello every1";
  int i = 0;

  while (str[i]) {
    fputc(str[i], stdout);
    i++;
  }

  return 0;
}
```



실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1738630D4B61C80E01732A)

화면에 문자열 `str` 의 내용이 표시된다.

```cpp-formatted
/*
alphabet.txt 라는 파일을 (없으면) 생성하고 A 부터 Z 까지 쓴다.
참고로 이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fputc/
에서 가져왔습니다.
*/
#include <stdio.h>
int main() {
  FILE* pFile;
  char c;

  pFile = fopen("alphabet.txt", "w");
  if (pFile != NULL) {
    for (c = 'A'; c <= 'Z'; c++) {
      fputc((int)c, pFile);
    }
    fclose(pFile);
  }
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F1869230C4B61C795010616)

제목이 `alphabet.txt` 이고 내용이 `A~Z` 인 파일이 생성된다.



###  관련된 함수들




*  [putc](http://itguru.tistory.com/46): 스트림에 문자를 쓴다.

*  [fgetc](http://itguru.tistory.com/37): 스트림에서 문자를 가져온다.

* `fwrite` : 스트림에 데이터 블록을 쓴다.

*  [fopen](http://itguru.tistory.com/58): 파일을 연다.
Link :  38
2010-01-28 01:34
----------------
title : C 언어 레퍼런스 - fgets 함수
cat_title :  fgets
publish_date : 2010-01-28 01:34
--------------

```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fgets


```info
#include <stdio.h> // C++ 의 경우 <cstdio>
char * fgets ( char * str, int num, FILE * stream );
```

스트림(stream)에서 문자열을 받는다.

스트림에서 문자열을 받아서 `(num - 1)` 개의 문자를 입력 받을 때 까지나, 개행 문자나 파일 끝(End-of-File) 에 도달할 때 까지 입력 받아서 C 형식의 문자열로 저장한다. 개행 문자는 `fgets` 로 하여금 입력을 끝나게 하지만 이 문자 역시 `str` 에 저장한다. `NULL` 문자는 자동적으로 마지막으로 입력받은 문자 뒤에 붙는다.

참고적으로 `fgets` 함수는 [scanf](http://itguru.tistory.com/36)함수와는 달리 오직 개행 문자에 의해서만 입력이 끝나기 때문에 띄어쓰기가 있는 문자열도 입력 받을 수 있다. 반면에 `scanf` 함수의 경우 개행 문자 뿐만이 아니라 ' ' 와 '\t' 에 의해서도 입력이 끝나기 때문에 띄어쓰기가 있는 문자열은 입력 받을 수 없다.



###  인자


`str`

읽어들인 문자열을 저장할 `char` 배열을 가리키는 포인터.

`num`

마지막 `NULL` 문자를 포함하여, 읽어들일 최대 문자 수. 다시 말해 이 값이 10 이면 컴퓨터는 최대 9 문자를 입력 받는다.

`stream`

문자열을 읽어들일 스트림의 `FILE` 객체를 가리키는 포인터. 특히, 표준 입력(stdin) 에서 입력을 받으려면 여기에 `stdin` 을 써주면 된다. (예를 들어 `fgets (str, 100, stdin);` 과 같이)



###  리턴값




성공적으로 읽어들였다면 함수는 `str` 을 리턴한다.

만일 파일 끝에 도달하였는데 아무런 문자도 읽어들이지 않았다면 `str` 의 내용은 변하지 않고 그 대신 `null` 포인터가 리턴된다.

또한 오류가 발생해도 `null` 포인터가 리턴된다.

[ferror](http://itguru.tistory.com/52)함수나 [ feof](http://itguru.tistory.com/51)를 사용해서 각각 어떤 오류가 발생하였는지, 파일 끝에 도달하였는지 알 수 있다.



###  실행 예제


```cpp-formatted
/* 화면에서 문자열을 읽어들인다. */

#include <stdio.h>
#define MAX_STR_SIZE 100
int main() {
  char str_read[MAX_STR_SIZE];
  fgets(str_read, MAX_STR_SIZE, stdin);
  printf("읽어들인 문자열 : %s \n", str_read);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1349861C4B6069D5B11BBE)

이 때 유의해서 볼 점은 `str_read` 에 개행 문자도 입력 되어서 `printf` 문 출력결과에서 개행이 두 번 되었다는 점을 볼 수 있다.

```cpp-formatted
/*

myfile.txt 에서 읽어들인 문자열을 출력한다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fgets/
에서 가져왔습니다.

*/
#include <stdio.h>
int main() {
  FILE* pFile;
  char mystring[100];

  pFile = fopen("myfile.txt", "r");
  if (pFile == NULL)
    perror("Error opening file");
  else {
    fgets(mystring, 100, pFile);
    puts(mystring);
    fclose(pFile);
  }
  return 0;
}
```

위 예제는 `myfile.txt` 의 첫 번째 문장을 입력 받되 최대 100 문자만 입력 받는다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F123F321D4B606A8F0198ED)



###  관련된 함수들





*  [fputs](http://itguru.tistory.com/40):   스트림에 문자열을 쓴다.

*  [fgetc](http://itguru.tistory.com/37):   스트림에서 문자 하나를 읽어온다.

*  [gets](http://itguru.tistory.com/45)  :  표준 입력(stdin) 에서 문자열을 읽어온다.
Link :  37
2010-01-28 01:01
----------------
title : C 언어 레퍼런스 - fgetc 함수
cat_title :  fgetc
publish_date : 2010-01-28 01:01
--------------


```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fgetc

```info

#include <stdio.h> // C++ 에서는 <cstdio>

int fgetc ( FILE * stream );
```



스트림(stream) 에서 문자 하나를 읽어온다

인자로 전달한 `stream` 의 파일 위치 지정자가 가리키는 문자를 리턴한다. 이 때 파일 위치 지정자는 그 다음 문자를 가리키게 된다. `fgetc` 와 `getc` 는 동일하지만 `getc` 의 경우 매크로의 형태로 만들어져 있기 때문에 인자가 만일을 위해 식이 아닌 형태여야 한다.



###  인자



스트림(stream)

`fgetc` 가 읽어들인 스트림의 `FILE` 객체에 대한 포인터



###  리턴값

읽어들인 문자는 `int` 값으로 리턴된다.

만일 파일의 끝(End-of-File) 에 도달하였거나, 읽는 도중 오류가 발생하였다면 `EOF` 를 리턴하고, 이에 대응하는 오류 표시자나 파일 끝 표시자가 설정된다.

[ferror](http://itguru.tistory.com/52)이나 `feof` 함수를 이용하여 각각 어떤 오류가 발생하였는지, 파일 끝에 도달하였는지 확인할 수 있다.



###  실행 예제




```cpp-formatted
/*

stdin 에서 문자를 입력받는다.

*/
#include <stdio.h>
int main() {
  int i = fgetc(stdin);

  printf("입력 값 : %c \n", i);
  return 0;
}
```

  실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1521E9184B60618605A0D0)

또다른 예제

```cpp-formatted
/*

myfile.txt 에서의 $ 의 개수를 센다
참고로, http://www.cplusplus.com/reference/clibrary/cstdio/fgetc/
에서 가져온 예제입니다.

*/
#include <stdio.h>
int main() {
  FILE* pFile;
  int c;
  int n = 0;
  pFile = fopen("myfile.txt", "r");
  if (pFile == NULL)
    perror("Error opening file");
  else {
    do {
      c = fgetc(pFile);
      if (c == '$') n++;
    } while (c != EOF);
    fclose(pFile);
    printf("The file contains %d dollar sign characters ($).\n", n);
  }
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F155C96174B6060F23B9824)




###  관련된 함수들



*  [getc](http://itguru.tistory.com/41)   :  스트림에서 문자 한 개를 읽어온다.

*  [fputc](http://itguru.tistory.com/39)  :  스트림에 문자 한 개를 쓴다.

*  [fread](http://itguru.tistory.com/68)  :  스트림에서 데이타 한 블록을 읽어온다.

*  [fscanf](http://itguru.tistory.com/65)  : 스트림에서 형식화 된 데이터를 읽어온다.
Link :  34
2010-01-25 22:28
----------------
title : C 언어 레퍼런스 - stdio.h (cstdio) 헤더파일
cat_title :  stdio.h (cstdio)
publish_date : 2010-01-25 22:28
--------------




```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?
```

#@ Stdio.h (cstdio)

C 언어에서 입출력 작업은 **표준 입출력 라이브러리 (Standard Input and Output Library)** 를 이용해서 수행될 수 있다. (C++ 에서는 cstdio 라는 이름으로 사용된다). 이 라이브러리는 스트림(stream) 을 이용해서 키보드나 프린터, 터미널과 같은 장비들이나 시스템이 지원하는 특정한 형태의 파일들과 작업할 수 있다. 모든 스트림들은 작업하고자 하는 장비들과 관계 없이 공통된 특징들을 가지고 있기 때문이 매우 편리하다.

`FILE` 객체에 대한 포인터는 각각의 스트림들을 구분하기 때문에 스트림을 이용한 작업시 인자로 전달된다.

또한 `stdio.h` 라이브러리를 사용하는 프로그램에서 자동으로 생성되고 열리는(open) 표준 스트림들이 있는데 이는`stdin, stdout, stderr`이다.



###  스트림의 특징

스트림의 속성 중에는 "어떠한 함수들 만이 스트림을 사용할 수 있다" 와 "이 스트림이 어떠한 방식으로 데이터를 입출력 하느냐" 가 있다. 이러한 속성들은 `fopen` 함수를 통해 스트림이 파일과 어떠한 방식으로 연관되어 있는지에 따라 달라지게 된다.

#### 읽기 쓰기 권한 (Read/Write Access)

이 스트림이 연관된 물리 장비로 부터 읽거나 쓸 수 있는지 (또는 둘 다)에 대한 정보를 알려준다.

#### 텍스트 / 바이너리 (Text/Binary)

텍스트 스트림들은 말그대로 문장을 중심으로 작동하며 각 문장은 개행 문자로 끝나게 된다. 텍스트 스트림은 받아들인 각 문자를 번역을 하게 되는데 프로그램이 작동되는 환경에 따라 일부 문자들을 다른 방식으로 번역할 수 도 있다.

실제 예시로, MacOS 에서는 개행 문자(new-line character)로 `CR` (캐리지 리턴, carriage return) 한 문자를 사용한다. 하지만 리눅스와 같은 유닉스 기반 컴퓨터들은 개행문자로 `LF` (라인 피드, line feed) 한 문자를 사용한다. 그러나 DOS 나 윈도우즈, OS/2 계열의 운영체제들은 `CR + LF` 를 사용해서 두 문자로 개행 문자임을 표시한다.

이렇게, 운영체제 마다 똑같은 개행 문자를 다른 방식으로 번역하기 때문에 텍스트 스트림에 경우 각 프로그램의 작동 환경에 영향을 받을 수 밖에 없다. 그러나 바이너리 스트림 (이진 스트림) 의 경우 단순히 장비로 부터 순차적으로 이진 데이터를 입력 받는 것이기 때문에 번역 과정이 필요 없을 뿐더러 각 환경에 영향을 받지도 않는다.

#### 버퍼(Buffer)

버퍼는 메모리의 일부분으로 장치나 파일로 부터 읽거나 쓰기 전에 저장되는 곳이다. 스트림은 *fully buffered, line buffered, unbuffered* 중 하나가 될 수 있다.

fully buffered 스트림의 경우, 데이터는 버퍼가 꽉 찰 경우 데이터가 읽어/쓰여 지고, line buffered 스트림의 경우 개행 문자가 버퍼에 들어왔을 때, unbuffered 스트림의 경우 어떠한 상태에서도 바로 데이터가 읽어/쓰여지는 스트림이다.

기본적으로 `stdin` 은 fully bufferd, stderr 은 unbuffered, stdout 은 터미널일 경우 line buffered, 아니면 fully buffered 상태로 설정되어 있다.


###  스트림 상태 표시자(indicator)

스트림은 현재의 상태를 나타내기 위해 특정한 표시자가 있으며, 이는 스트림의 입출력 형태에 영향을 줄 수 있다.

#### 오류 표시자 (Error indicator)

이 표시자는 스트림 관련한 연산에서 오류가 발생하였을 때 설정(set) 된다. 이 표시자의 상태는 `ferror` 함수를 통해 확인할 수 있으며 `clearerr` 함수나 [rewind](http://itguru.tistory.com/75), [fseek](http://itguru.tistory.com/72), [fsetpos](http://itguru.tistory.com/73)함수들을 통해 표시자의 상태를 초기화 할 수 있다.

#### 파일 끝 표시자 (End-Of-File indicator)

이 표시자가 설정되면 스트림의 읽기 혹은 쓰기 연산이 파일의 끝 부분에 도달하였다는 뜻을 나타낸다. 이는 [feof](http://itguru.tistory.com/51)함수를 통해 확인할 수 있으며 `clearerr` 함수나 [rewind](http://itguru.tistory.com/75), [fseek](http://itguru.tistory.com/72), [fsetpos](http://itguru.tistory.com/73)함수를 통해 초기화 할 수 있다.

#### 위치 표시자 (Position Indicator)

이는 포인터로 스트림이 입출력 연산에서 다음으로 읽거나 쓸 문자를 가리킨다. 이 표시자가 가리키는 값은 [ftell](http://itguru.tistory.com/74)이나 `fgetpos` 함수를 통해 알아낼 수 있으며 역시 [rewind](http://itguru.tistory.com/75), [fseek](http://itguru.tistory.com/72), [fsetpos](http://itguru.tistory.com/73)함수를 이용해서 표시자의 값을 바꿀 수 있다.


###  stdio.h 에 정의된 함수들


파일 작업 관련:


* `remove` : 파일을 삭제한다

* `rename` : 파일 이름을 변경한다.

* `tempfile` : 임시 파일을 연다

* `tempnam` : 임시 파일의 이름을 생성한다.


파일 접근 관련:


*  [fclose](http://itguru.tistory.com/54): 파일을 닫는다

*  [fflush](http://itguru.tistory.com/57): 스트림을 비운다 (flush)

*  [fopen](http://itguru.tistory.com/58): 파일을 연다

*  [freopen](http://itguru.tistory.com/59): 다른 파일이나 모드로 스트림을 다시 연다.

*  [setbuf](http://itguru.tistory.com/61): 스트림 버퍼를 설정한다.

*  [setvbuf](http://itguru.tistory.com/62): 스트림의 버퍼 및 모드(fully `buffered, line buffered, unbuffered)` 까지 설정한다.


형식 있는(formatted) 입출력:


*  [fprintf](http://itguru.tistory.com/64): 형식 있는 데이터를 스트림에 쓴다.

*  [fscanf](http://itguru.tistory.com/65): 형식 있는 데이터를 스트림에서 읽는다.

*  [printf](http://itguru.tistory.com/35): `stdout` 에 형식 있는 데이터를 출력한다.

*  [scanf](http://itguru.tistory.com/36): 형식 있는 데이터를 `stdin` 에서 읽는다.

*  [sprintf](http://itguru.tistory.com/66): 문자열에 형식 있는 데이터를 쓴다.

*  [sscanf](http://itguru.tistory.com/67): 문자열에서 형식 있는 데이터를 읽는다.

* `vfprintf` : 스트림에 형식 있는 가변 인자 목록(variable `argument` list)을 쓴다.

* `vprintf` : `stdout` 에 가변 인자 목록을 출력한다.

* `vsprintf` : 문자열에 가변 인자 목록을 출력한다.


문자(character) 입출력:


*  [fgetc](http://itguru.tistory.com/37): 스트림에서 문자를 받는다.



*  [fgets](http://itguru.tistory.com/38): 스트림에서 문자열을 받는다.



*  [fputc](http://itguru.tistory.com/39): 스트림에 문자를 쓴다.

*  [fputs](http://itguru.tistory.com/40): 스트림에 문자열을 쓴다.

*  [getc](http://itguru.tistory.com/41): 스트림에서 문자를 받는다.



*  [getchar](http://itguru.tistory.com/44): `stdin` 에서 문자를 받는다.

*  [gets](http://itguru.tistory.com/45):  `stdin` 에서 문자열을 받는다.



*  [putc](http://itguru.tistory.com/46): 스트림에 문자를 쓴다.

*  [putchar](http://itguru.tistory.com/47): 문자를 `stdout` 에 쓴다.



*  [puts](http://itguru.tistory.com/48): 문자열을 `stdout` 에 쓴다.

*  [ungetc](http://itguru.tistory.com/49): 스트림으로부터 문자를 `unget` 한다. (마지막으로 읽어들인 위치로 되돌림)


직접적인 입출력:


*  [fread](http://itguru.tistory.com/68): 스트림으로 부터 데이터 블록을 읽는다.

*  [fwrite](http://itguru.tistory.com/69): 스트림에 데이터 블록을 쓴다.


파일 위치 지정:


*  [fgetpos](http://itguru.tistory.com/70): 현재 스트림의 (읽어들이는) 위치를 얻는다.

*  [fseek](http://itguru.tistory.com/72): 스트림 위치 표시자의 위치를 재조정한다.

*  [fsetpos](http://itguru.tistory.com/73): 스트림의 위치 표시자를 설정한다.

*  [ftell](http://itguru.tistory.com/74): 스트림의 현재 위치를 얻는다.

*  [rewind](http://itguru.tistory.com/75): 위치 표시자의 위치를 맨 앞으로 조정한다.


오류 처리:


*  [clearerr](http://itguru.tistory.com/50): 오류 표시자를 초기화한다.



*  [feof](http://itguru.tistory.com/51): 파일 끝 표시자 (End of file indicator) 을 확인한다.

*  [ferror](http://itguru.tistory.com/52): 오류 표시자를 확인한다.

*  [perror](http://itguru.tistory.com/53): 오류 메세지를 출력한다.




###  매크로

* `EOF` : 파일 끝(end `of file)`

* `FILENAME_MAX` : 파일 이름의 최대 길이

* `NULL` : 널 포인터



* `TMP_MAX` : 임시 파일의 (최대) 개수

이 외에도 `_IOFBF, _IOLBF, _IONBF, BUFSIZ, FOPEN_MAX, L_tmpnam, SEEK_CUR, SEEK_END, SEEK_SET` 이 있는데 이는 이들을 이용하는 함수들에 설명되어 있다.





###  타입 (형)





* `FILE` : 스트림을 제어하는 정보를 가지고 있는 객체

* `fpos_t` : 파일의 (읽어들이는) 위치를 설정하기 위한 정보를 가지는 객체

* `size_t` : 부호 없는 정수

위 글의 모든 자료들은 다음 사이트에서 번역한 내용입니다. [http://www.cplusplus.com/](http://www.cplusplus.com/)
Link :  32
2010-01-25 00:58
----------------
title : 씹어먹는 C 언어 - <15 - 2. 일로와봐, 문자열(string) - 버퍼에 관한 이해>
cat_title : 15 - 2. 일로와봐, 문자열(string) - 버퍼에 관한 이해
next_page : 33
publish_date : 2010-01-25 00:58
--------------


이번 강좌에서는

* 버퍼(stdin)에 대한 이해

* 고질적인 `scanf` 문제에 대한 해결 및 이해

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분. 요즘에 제가 많이 바빠서 글을 자주 못올리고 있지만 여러분은 너그러운 마음으로 이해해 주시라 믿고 있습니다. 그렇다면, 지난번의 강좌를 계속 이어 나가도록 하겠습니다.

```cpp-formatted
/* 이상한 scanf */
#include <stdio.h>
int main() {
  int num;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);
  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F140352134B5440620BC727)

허거걱! 여러분은 위 소스를 실행했을 때 충격을 금치 못했을 것입니다. 분명히 우리는 다음과 같이 `scanf` 를 이용해서 정수를 입력 받고 그 다음에 문자를 입력받으라고 명시했습니다.

```cpp-formatted
printf("숫자를 입력하세요 : ");
scanf("%d", &num);

printf("문자를 입력하세요 : ");
scanf("%c", &c);
```

 분명히 우리는 컴퓨터로 하여금 숫자를 입력받은 후, "문자를 입력하세요 : " 를 출력한 다음, `c` 에 문자를 입력받으라고 명령하였습니다. 그리고, 컴퓨터가 정말 특별히 우리를 싫어하지 않는 한 무조건 우리의 말을 따라아 하는 것이지요. 그런데, 이게 무슨 일입니까? 우리의 컴퓨터는 우리가 친절히 명시해 준 `scanf("%c", &c);` 명령을 완전히 무시한 것 아닙니까? 이게 도대체 무슨 일이죠?? 사실, 우리가 컴퓨터에게 화풀이를 하기 전에 `scanf` 함수가 어떻게 작동하는 것인지 먼저 확인해볼 필요가 있습니다.

우리가 컴퓨터에 무언가를 입력하면 컴퓨터는 어떻게 처리를 할까요? 예를 들어서 우리가 컴퓨터에게 `abcde` 를 입력하였을 때, 컴퓨터가 각 문자를 입력받을 때 마다 처리를 한다면 (즉 우리가 `a` 를 누르는 순간 `a` 라는 문자를 변수에 저장하고 등등 작업을 하고 그 다음에 `b` 가 들어오면 다시 이 문자를 `...)` 상당히 `CPU` 사용량이 높아질 것입니다.

하지만 이렇게 하면 어떨까요. 우리가 문자를 입력한다면 다른 곳에 잠시 보관해 놓았다가 우리의 입력이 끝난다면 잠깐 보관해 놓았던 곳의 정보를 한꺼번에 처리하는 것입니다. 따라서, 만일 우리가 `abcde` 를 입력하였다면 `abcde` 를 잠시 다른 곳에 보관해놓았다가 입력이 끝난다면 이를 한꺼번에 처리하는 것입니다.

사실, 이 두 방법이 어떤 차이가 있을 수 있느냐 라고 물을 수 있지만 아래 비유를 보면 쉽게 이해가 될 것입니다. 우리가 만일 약수터에 가서 물을 떠온다고 해봅시다. 물을 3 L 받아 온다고 했을 때 우리는 물을 두 가지 방법으로 받아올 수 있습니다. 하나는 손에 물을 받아서 약수터까지 수십번 왔다 갔다 하는 것이고, 다른 방법은 양동이를 들고가서 3 L를 채운 후, 다시 양동이를 가지고 내려오는 것입니다.

자. 그럼 어떤 방법이 합리적인것 같습니까? 손으로 조금씩 조금씩 받아서 수십번 왔다갔다 하는 것이 나을 까요? 아니면 양동이를 들고 한 번만 갔다오는 것이 나을까요? 당연히, 후자가 훨씬 좋은 방법이겠지요. 컴퓨터도, 원리는 조금 더 복잡하지만 이러한 방법을 채택하고 있는 것입니다.

그렇다면 컴퓨터의 '양동이'에 해당하는 부분은 무엇일까요? 바로, **버퍼(buffer)** 라고 부르는 것입니다. 또한, 수 많은 버퍼 중에서도 키보드의 입력을 처리하는 버퍼는 바로 입력 버퍼, 혹은 `stdin` (흔히 입력 스트림) 이라 부르는 것입니다.

다시말해 우리가 키보드로 쳐다는 모든 정보는 일시적으로 `stdin` 에 저장되었다가 나중에 입력이 종료되면 한꺼번에 처리를 하는 것입니다. 그런데, 컴퓨터가 어떻게 우리가 입력을 종료했는지 알 수 있죠? 딱 10 초만 생각해보세요.. 알겠나요? 바로 엔터를 치면 됩니다. 왜냐하면 이전에도 우리가 계속 보았듯이 엔터를 치기만 하면 입력을 끝내고 프로그램이 계속 실행되었잖아요. 안그래요?

다시말해 컴퓨터는 개행 문자, 즉 `\n` 을 '입력을 종료하였으니 버퍼에 들어 있는 내용을 가지고 놀아라' 라는 뜻으로 받아 들입니다. \sidenote{잘 알고 게시고 있겠지만 \n 은 두 개의 문자 '\' 와 'n' 이 아니라, 하나의 문자 (개행문자 - 키보드 상의 엔터)를 의미합니다!} 그런데, 말이죠. 컴퓨터는 공교롭게도 `\n` 까지 버퍼에 저장하게 됩니다. 즉, 우리가 1 을 쓰고 엔터를 딱 치면 버퍼에 다음과 같은 모습으로 들어간다는 말이죠.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F130AA41A4B59433D75F8F5)

자. 그럼 입력을 끝냈다면 컴퓨터는 `scanf` 함수를 이용해서 `stdin` 으로 부터 숫자를 얻어옵니다. 왜 숫자냐면, 잘 아겠지만 우리가

```cpp-formatted
scanf("%d", &num);
```

로 하였기 때문이죠. 즉 오직 숫자 데이터만 `stdin` 에서 얻어온다는 말입니다. 그렇다면 `scanf` 함수는 언제까지 `stdin` 으로 부터 데이터를 얻어올까요? 바로 `' ', '\n', '\t'` 를 만날 때 까지 입니다. 여기서 `' '` 는 띄어쓰기 한 칸을 의미합니다. 또한 `\t` 는 여러분들이 아직 본적도 없고 제가 이야기 한 적은 없지만 `TAB` 문자로 여러분이 키보드에 `TAB` 키를 누르게 되면 이 문자를 쓰는 것입니다. 또한 `\n` 은 이야개 했던데로, 엔터 이죠. 다시 말해 `scanf` 함수는 `stdin` 에서 위 세 개의 문자들을 만난다면 '아. 여기서 입력은 끝이구나' 하고 입력을 종료해 버립니다.

참고적으로 `%d` 계열의 것들, 즉 수를 입력받는 형식은 수가 아닌 데이터가 와도 입력을 종료해 버립니다. 즉, `a` 를 입력했다면 `num` 에는 아무런 값이 들어가지 않아 치명적인 결과를 야기할 수 있습니다. 뿐만 아니라 수 데이터를 입력받는 형식의 경우 처음 부터 공백문자가 나타나면 수가 나타날 때 까지 입력을 계속 받게 됩니다. (다시 말해, 수를 입력 받는데 엔터를 아무리 쳐도 숫자를 치기 전까지 넘어가지 않는다) 암튼 `scanf` 함수는 공백 문자(`' ', '\n', '\t'`) 를 만나기 전까지 `stdin` 에서 데이터를 가져간 후 버퍼에서 삭제해 버립니다. 다시말해, 위 `scanf` 함수가 `num` 에 1 을 저장한 후 버퍼의 모습은 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F18672D274B594AE6470168)

자, 이제. 우리의 말을 아주 잘 듣는 컴퓨터는

```cpp-formatted
scanf("%c", &c);
```

를 실행하게 됩니다. 그런데 말이죠, `%c` 는 이유를 불문하고 `stdin` 에서 딱 한개의 문자만을 가져오게 됩니다. 만일 `stdin` 에 아무것도 없다면 사용자의 입력을 기다리고 있겠지만 `stdin` 에 무언가가 있다면 그 것을 냉큼 가져오게 되지요. 그런데 공교롭게도 위에서 \n 을 버퍼에 남겨 놓았기 때문에 `scanf` 는 냉큼 이를 `c` 에 저장하게 됩니다. 즉, `c` 에는 사용자의 입력을 받지도 않고 '\n' 을 집어 넣은 것이지요.

따라서 만일 우리가 `printf("%c 출력", c);` 를 해보게 된다면 '출력'이 한 칸 개행(엔터가 쳐져서)되어 나타나게 됩니다.

```cpp-formatted
/* 그렇다면 %s 는 ? */
#include <stdio.h>
int main() {
  char str[30];
  int i;

  scanf("%d", &i);
  scanf("%s", str);

  printf("str : %s", str);

  return 0;
}
```

  성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F145FB9234B59DDEE44C052)

오오.. 이번에는 다행입니다. `%c` 와는 달리 `%s` 의 경우 컴퓨터가 사용자로 부터 입력을 잘 받았습니다. 사실, 그 이유는 간단합니다. 일단,

```cpp-formatted
scanf("%d", &i);
```

를 실행하여 사용자로 부터 수를 입력 받게 된다면 역시 `stdin` 에는 \n 이 남아있게 됩니다. 그리고

```cpp-formatted
scanf("%s", str);
```

를 실행하게 되면 역시 수 데이터를 입력 받는 형식 처럼실질 적인 데이터 (공백 문자가 아닌 것들) 이 나오기 전 까지 버퍼에 남아 있던 공백 문자들은 무시하고 실질 적인 문자(공백 문자가 아닌 것들)가 입력이 된다면 그 다음 부터 등장하게 되는 공백 문자에서는 종료하게 됩니다. 즉, 기존에 1 을 입력하였을 때 남아있었던 \n 은 사라지고, 내가 `aasdfdasfads` 를 입력하고 난 후, 엔터를 쳤을 때 들어가는 \n 을 인식 하게 된다는 것이지요.

아무튼, 결론적으로 요약하자면 `%s` 나 `%d` 그리고 다른 모든 수 데이터를 입력 받는 형식은 버퍼에 신경 쓸 필요 없이 자유롭게 사용할 수 있습니다. 하지만 `%c` 를 이용할 때 에는 버퍼에 무엇이 남아 있는지 잘 고려해야 합니다. 이는 정말로 번거로운 일이 아닐 수 없습니다. 물론, 이를 대체할 수 있는 멋진 대안이 있지만 이는 조금 있다가 고려하도록 하고 다음 예제를 살펴 보도록 합시다.

```cpp-formatted
/* 마지막 stdin 예제 */
#include <stdio.h>
int main() {
  char str1[10], str2[10];

  printf("문자열을 입력하세요 : ");
  scanf("%s", str1);
  printf("입력한 문자열 : %s \n", str1);

  printf("문자열을 입력하세요 : ");
  scanf("%s", str2);
  printf("입력한 문자열 : %s \n", str2);

  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F195676114B543EF05F68A3)

  상당히 평범한 내용입니다. 여태까지의 강좌를 잘 따라오고 있었다면 위 내용쯤이야 쉽게 이해할 수 있을 것입니다.

  그렇다면 다음과 같이 입력 해보도록 하겠습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1432D61B4B59E220047477)

헉.. 이번에는 우리의 두번째 `scanf` 를 완전히 무시하고 지나갔습니다. 하지만 똑똑한 여러분이라면 왜 두번째 `scanf` 에서 사용자로 부터 입력을 받지 않았고, `str1` 에는 `hello, str2` 에는 `baby` 가 제대로 들어갔는지도 알 수 있을 것입니다. 우리가 "hello baby" 를 입력하였을 때 `stdin` 의 상태를 살펴봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F127C1E1D4B59E46F05B6EA)

  그렇다면

```cpp-formatted
scanf("%s", str1);
```

`scanf` 함수는 `stdin` 으로 부터 '의미가 있는 문자 (공백 문자(`' ', '\n', '\t'`) 를 제외한 나머지 문자)' 가 나올 때 까지 모든 공백 문자들을 무시합니다. 위의 경우 `stdin` 에서 처음에 공백 문자가 하나도 없으므로 바로 `stdin` 으로 부터 데이터를 가져오겠군요. 데이터를 가져오다가 공백 문자를 만나게 되면 입력을 중지합니다. 위의  경우 ' ' 이 공백 문자의 역할을 하기 때문에 `str1` 에는 `hello` 까지만 입력이 됩니다.

첫번째 `scanf` 함수를 지나게 되면 `stdin` 의 모습은 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F207CC11D4B59E5270372BB)
  이제 두번째 `scanf` 를 지나갈 차례입니다.

```cpp-formatted
scanf("%s", str2);
```

`scanf` 함수는 `stdin` 에 아무 것도 없거나, 공백 문자들 밖에 없다면 사용자가 무언가 의미 있는 문자를 입력해줄 때 까지 기다리겠지만 위 경우는 상황이 다릅니다. 일단, 처음에 공백 문자인 띄어쓰기는 살포시 무시합니다. 왜냐하면 아직 의미 있는 문자를 받지 않았기 때문이죠. 그 다음에 `b` 를 보고 `str2` 에 입력을 쭉 받기 시작합니다. 그러다가 마지막에 공백 문자인 \n 을 보고 입력을 중지합니다. 따라서 메모리에는 다음과 같이 \n 만이 덩그러니 남아있게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F163DC31C4B59E62A0DE398)

아무튼. `scanf` 는 상당히 이해하기 복잡한 것임은 틀림이 없습니다. 가뜩이나 머리 아픈데 `%c` 를 이용하면 고려해야 될 것이 더욱 많아지니 정말 짜증이 나는 것 같습니다. 하지만 다행스럽게도 이러한 문제를 해결할 수 있는 방법이 있을 뿐더러 실질 적으로 `%c` 는 많이 쓰이지 않으니 다행인 것 같습니다.



###  도대체 이 문제를 어떻게 해결하냐


하지만, 아무리 `%c` 를 사용하지 않는다고 해도 필연적으로 사용할 일이 생기게 됩니다. 그렇다면 그 때 마다 이처럼 버퍼에 \n 이 남아 있는 것을 고려해야 할까요? 정말 번거로운 일이 아닐 수 없습니다. 하지만 걱정 마십시오. 이를 해결할 수 있는 방법이 여러 가지가 있습니다.

```cpp-formatted
/*

버퍼 비우기

주의하실 점은 반드시 MS 계열의 컴파일러로 컴파일 해주세요. 즉, Visual Studio
계열의 컴파일러로 말이죠. 이 말이 무슨 말인지 모르면 그냥 늘 하던대로 하면
됩니다.

gcc 에서는 정상적으로 작동되지 않는 위험한 코드 입니다.

*/
#include <stdio.h>
int main() {
  int num;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  fflush(stdin);

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);
  return 0;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F1130C20E4B5B07C295272E)

아마도 여러분은 컴파일 하면서 포스 넘치는 주석을 보며 무언가 당황 하셨을 수 도 있습니다. 하지만 걱정하진 마세요. 지금 수준의 프로그래밍에서는 크게 걱정할 문제는 아닙니다. 먼저 위 소스가 어떻게 해서 올바르게 작동하는지 부터 살펴보도록 합시다. 사실, 올바르게 라는 말 보다는 'scanf 가 사용자의 입력을 무시하지 않는지' 가 적당할 듯 하네요.

```cpp-formatted
printf("숫자를 입력하세요 : ");
scanf("%d", &num);
```

위까지 실행했을 때 에는 이전처럼 `stdin` 에 '\n' 이 남아 있습니다. 그런데 말이죠.

```cpp-formatted
fflush(stdin);
```

두둥. 새로운 문장이 등장했습니다. 위 문장의 의미는 'stdin 을 비워버려라' 라는 의미이죠. 다시말해 `stdin` 에 있는 모든 데이터들을 날려버리게 되는 것입니다. 따라서 버퍼가 완전히 비워지게 됩니다. 즉 버퍼에 가시 처럼 남아 있던 \n 이 사라지게 됩니다.

```cpp-formatted
scanf("%c", &c);
```


따라서 그러한 상태에서 `scanf` 를 호출하게 되면 `%c` 는 버퍼에 아무것도 남아 있는 것이 없으므로 사용자의 입력을 차분히 기다리고 있게 됩니다. 즉, 우리가 `c` 에 원하는 값을 넣을 수 있다는 뜻이 되죠. 하지만 프로그램 코드 상단에 있는 무서운 주석을 보면 알겠지만 사실 위 코드는 추천하고 싶지 않습니다. 왜냐하면 `fflush` 가 표준으로 '무슨 역할은 한다' 라고 정해진 것이 아니기 때문입니다.

다시 말해 우리의 `Visual Studio` 에선 `fflush` 함수가 버퍼를 비우는 훌륭한 역할을 하지만 다른 것 - 예를 들면 `gcc` 같은 데에서는 이러한 작업을 하지 않을 가능성이 매우 매우 큽니다. 다시 말해, 위 방법은 그다지 권장하고 싶은 방법은 아니지만 적어도 우리의 수준에서는 정확하게 작동하고 편리하기 때문에 많이 사용합니다.

```cpp-formatted
/* getchar 함수 이용 */
#include <stdio.h>
int main() {
  int num;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  getchar();

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);

  return 0;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F135951184B5C64FD8C3628)

  오. 이번에도 제대로 작동하고 있습니다.

```cpp-formatted
printf("숫자를 입력하세요 : ");
scanf("%d", &num);
```

일단, 위 부분까지만 실행하면 역시 `stdin` 에는 \n 이 남아있게 됩니다. 상당히 곤란한 일이죠.

```cpp-formatted
getchar();
```

그렇데 말이죠, 우리가 `getchar` 이라는 함수를 호출했습니다. 이 함수의 역할은 'stdin 에서 한 문자를 읽어와서 그 값을 리턴한다' 입니다. 물론 한 문자를 읽어오면 읽어온 문자는 `stdin` 에서 사라지게 되지요. 따라서 위 함수를 호출 함으로써 \n 을 `stdin` 에서 읽어와 지워버릴 수 있는 것이지요.

  만일 우리가

```cpp-formatted
ch = getchar();
prinf("%c", ch);
```

을 해서 `getchar` 함수가 리턴한 값을 출력해보았다면 화면상에 한 칸 엔터(== \n)가 쳐진 것이 출력될 것입니다. (여러분이 한 번 해보세요~) 이제, 버퍼가 비워진 상태에서 `scanf` 함수를 호출하게 되면 성공적으로 사용자의 입력을 받게 되는 것입니다. 상당히 단순하지요?

`getchar` 함수를 호출한 방법은 여러 모로 많이 쓰이는 방법 입니다. 기본적으로 `scanf` 에서 `%c` 형식을 사용하는 것을 권하고 싶지는 않지만 정 사용하고자 한다면 `getchar()` 을 `scanf` 이전에 호출해서 버퍼를 비워주기 바랍니다. 그런데 말이지요. 위 방법도 문제가 어지간히 있습니다. 만일 버퍼에 한 문자만 남겨져 있는 것이 아니면 어떡할까요? 한 번 숫자를 입력할 때 `123abc` 를 쳐 보았습니다.

```cpp-formatted
/* c 에 무엇이 들어가는지 살짝 보아야 하므로 코드를 약간 수정했습니다 */
#include <stdio.h>
int main() {
  int num, i;
  char c;

  printf("숫자를 입력하세요 : ");
  scanf("%d", &num);

  getchar();

  printf("문자를 입력하세요 : ");
  scanf("%c", &c);

  printf("입력한 문자 : %c", c);
  return 0;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1841A9184B5C684CBB6CE9)

아.. 역시 제가 우려했던 대로 `scanf` 에서 사용자의 입력을 기다리지 않고 지나쳐 버렸습니다. 뿐만 아니라 `c` 에도 우리가 원하지 않던 `b` 라는 값이 들어가 있습니다. 도대체 왜 이런 일이 발생한 것일까요? 일단 버퍼에서 무슨 일이 벌어지고 있는지 차근 차근 살펴보도록 합시다.

```cpp-formatted
printf("숫자를 입력하세요 : ");
scanf("%d", &num);
```

일단 위 코드가 실행되어서 사용자로 부터 입력을 기다립니다. 사악한 Psi 는 `123abc` 를 쳤습니다. 그렇다면 버퍼에 다음과 같이 들어가겠지요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1416F5184B5C68F604F2AF)

이제, `scanf` 함수가 `stdin` 에서 차례 차례 데이타를 읽어옵니다. 그 때도 말했들이 데이타를 읽어올 때 공백문자(' ' 나 '\n' 이나 '\t') 나 숫자가 아닌 것들을 만나게 되면 `stdin` 에서 부터 그만 읽어온다고 했죠? 이 때 `a` 가 숫자가 아니기 때문에 123 까지 읽은 후 `stdin` 에서 부터 그만 읽어 옵니다. 따라서 `stdin` 은 다음과 같은 모습이 되겠군요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F196982264B5C697793720F)
그렇다면 아래의 문장이 실행됩니다.

```cpp-formatted
getchar();
```

이는 이전의 문제점을 말끔히 해결해 주었죠. `stdin` 으로 부터 한 문자를 얻어오는 방법으로 말이지요. 여기서도 `getchar` 은 똑같은 역할을 수행합니다. 즉 `stdin` 으로 부터 한 문자, 위 경우 `a` 를 읽어옵니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F116E46254B5C69DB816B7D)

  아 이런. 버퍼가 깔끔하게 비워지지 않았습니다. 이러한 우려 속에서 아래의 코드가 실행됩니다.

```cpp-formatted
printf("문자를 입력하세요 : ");
scanf("%c", &c);
```

음.. `scanf` 의 입장에서 버퍼에 읽어올 것들이 잔뜩 있으니 행복할 것 같습니다. 버퍼에서 한 문자를 읽어 옵니다. 그것이 바로 `b` 가 됩니다. 따라서 `c` 에는 우리가 원하지 않던 `b` 가 들어가게 됩니다. 그리고 물론 `b` 는 `stdin` 에서 사라지게 되죠. 다음에 또 scnaf("%c", &c"); 를 하게 되면 이번에는 `c` 가, 한 번 더하면 \n 이 읽어지겠죠?

아무튼. 여기서 내릴 수 있는 결론은 "되도록이면 `%c` 를 사용하지 말자" 입니다. `scanf` 에서 `%c` 를 사용하는 것은 정말로 권장하고 싶지 않은 일입니다. 만일 정말로 문자 하나만을 입력받는 프로그램을 만드려면 `scanf` 에서 `%s` 형태로 문자열을 입력 받은 뒤에 맨 앞의 한 문자만 취하는 식으로 만들면 되겠습니다.

```warning
결론 : 문자 대신 문자열을 입력 받도록 하자!

```

### 생각해보기

#### 문제 1

키보드로 부터 입력을 받는 함수는 `scanf` 나 `getchar` 말고도 여러가지가 있습니다. 이들에 대해 조사해 보는 것이 어떨까요? (난이도 : 無 *쉬운 것도 아니고 어려운 것도 아님)

#### 문제 2

화면에 출력하는 함수도 `printf` 만 있는 것이 아닙니다. 화면에 출력하는 함수에 대해서 알아보는 것이 어떨까요?(난이도 : 無)

##@ chewing-c-end
Link :  29
2009-12-29 01:53
----------------
title : 씹어먹는 C 언어 - <15 - 1. 일로와봐, 문자열(string)>
cat_title : 15 - 1. 일로와봐, 문자열(string)
next_page : 32
publish_date : 2009-12-29 01:53
--------------


이번 강좌에서는

* 널 종료 문자열(Null terminated string)
* 문자열 활용
* 문자열 입력

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요. 벌써 15 강에 도달하였습니다. 정말로, 거대한 숲을 거침없이 헤쳐왔다는 느낌이 듭니다. 제가, 첫 강좌를 올린 것이 2009년 4월 16일 이였는데, 벌써 2009년의 마지막에 다다르고(제가 이 글을 처음 시작했을 때만)있습니다. 인터넷을 뒤져보면 많은 C 언어 강좌들이 있는데, 유료 강좌 빼고는 제 강좌처럼 근성 있게 올라오는 것도 드문 것 같네요. 암튼, 저나 여러분이나 정말로 대단한 사람들 입니다 ㅎㅎ.

그 동안, 따분한 숫자들만 가지고 놀아서 조금 지루한 면이 적지 않아 있었습니다. 그래서, 이번 강좌에서는 문자들, 말그대로 문자의 나열인 **문자열(string)**에 대해서 이야기 해보도록 하겠습니다. 

문자열은 영어로 `string` 이라고 하는데, 원래의 의미는 실 입니다. 그런데, 문자열을 `string` 이라 부르는 이유는 정말 문자열이 실 처럼 문자들이 쭈르륵 나열 된 것이기 때문이죠. 참고적으로 문자열에 대해 지금 처음 배우시는 분들은 5 강을 다시 한 번 읽어보시기 바랍니다. 아무래도 예전에 배운 내용이라 까먹었을 확률이 매우 높거든요.

그렇다면, 컴퓨터는 문자열을 어떻게 저장할까요. 앞서, 제가 쭈르륵 나열 되어 있다는 사실을 강조했다는 부분을 생각해보면, 문자열을 문자들의 배열, 즉 `char` 배열에 저장함을 알 수 있습니다.



###  널 - 종료 문자열 (Null-terminated string)


위 소제목이 무슨 뜻인지 모른다고 해서 겁을 먹으신 분들이 있을텐데, 조금 있다가 알게 될 것입니다. 앞서, 컴퓨터에서는 문자열을 `char` 배열에 저장한다고 하였습니다. 다시말해, 아래 그림과 같이요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2076890C4B38DF862E1961)



근데, 말이죠. 위와 같이 문자열 `s` 를 정의하였을 때, 무언가가 불편할 것 같지 않나요? 만일, 우리가 `char` 배열 `s` 에 저장된 문자들을 화면에 출력한다고 해봅시다. 이상적인 상황으로는 컴퓨터에게 "s 의 문자열을 출력해" 라고 말하면 알아서 출력해주는 것입니다. 그러나, 위와 같이 배열 `s` 에 문자를 저장하면 "s 의 문자열을 출력해. 근데, 그 문자가 아마 3 문자일거야" 라고 말해주어야 하는 불편함이 생긴다는 말입니다.

문자열은 말그대로 문자들이 하나로 뭉쳐서 다니는 것이기 때문에 (만일 우리가 `s` 의 문자열을 이용한다고 하면 첫글자 `P` 만 이용할 것입니까? 아니죠. 상식적으로 Psi 전체를 하나로 이용하는 것이죠), 문자열을 이용할 때 마다 문자열의 길이를 알아야 한다면 정말로 불편한 일이 아닐 수 없습니다. 그래서, C 개발자들은 아래와 같이 멋진 대안을 내놓았습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F157C99014B39BF690F65F6)

위와 같이 문자열의 끝에, **여기 까지가 문자열이였습니다** 라고 알려주는 종료 문자를 넣은 것입니다. 이 종료 문자는 아스키 값이 0 이고, '\0' 라고도 나타냅니다. 절대 문자 '0' 하고 헷갈리면 안됩니다. 문자 0 은 아스키 코드 값이 0 이 아니라 48 입니다. 흔히, 이 종료 문자를 가리켜서 **널(Null)** 이라고 부릅니다. 이제, 널 종료 문자라는 말의 의미를 알겠죠? 말그대로, 널로 끝나는 문자 라는 의미 입니다. 이것이 바로, C 언어의 문자열의 기본적인 형태 입니다.

널 문자가 들어갈 공간이 있어야 하기 때문에 3 글자라고 해도, 배열은 4 칸이 필요하게 됩니다. 위와 같이 `s[4]` 처럼요. 그럼, 위와 같이 널 종료 문자가 편리한 이유는 컴퓨터가 문자열의 끝을 쉽게 구할 수 있기 때문입니다. 우리가 굳이 '이 `s` 문자열은 3 문자인데, 출력해죠' 라고 말할 필요 없이, '`s` 문자열을 출력해' 란 말만 해주어도 컴퓨터가 알아서 '음, 널이 나올때 까지 출력해야지' 라고 출력한다는 것입니다.

```cpp-formatted
/* 널 뽀개기 */
#include <stdio.h>

int main() {
  char null_1 = '\0';  // 이 3 개는 모두 동일하다
  char null_2 = 0;
  char null_3 = NULL;  // 모두 대문자로 써야 한다

  char not_null = '0';

  printf("NULL 의 정수(아스키)값 : %d, %d, %d \n", null_1, null_2, null_3);
  printf("'0' 의 정수(아스키)값 : %d \n", not_null);

  return 0;
}
```

  성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F14383A0C4B39C28A05E150)

  와우. `NULL` 의 정수값은 모두 0 이 출력되었고, 문자 '0' 의 정수값은 42 가 출력되었습니다.

```cpp-formatted
char null_1 = '\0';  // 이 3 개는 모두 동일하다
char null_2 = 0;
char null_3 = NULL;
```

위 세개의 문장의 각 `char` 변수에는 모두 동일한 값, 즉 0 이 들어가게 됩니다. `null_1` 의 경우 '\0' 의 값, 즉 '\0' 의 아스키 값이 들어가는데 \0 의 아스키 값은 0 입니다. 왜 '0' 이라 안쓰고 '\0' 이라 쓰는지는 알겠죠? '0' (문자 `0)` 의 아스키값은 42 이기 때문입니다. (위에서 확인할 수 있듯이) 마찬가지로 `null_2` 에는 0 이 들어가고, `null_3` 에는 `NULL` 의 값이 들어가는데, `NULL` 은 0 이라고 정의되어 있는 상수 입니다. 따라서, `null_3` 에도 0 이 들어갑니다.

```cpp-formatted
char not_null = '0';
```

반면의 `not_null` 의 경우 문자 '0' 의 아스키값이 들어가는데, 문자 0 의 아스키값은 42 입니다. 따라서, `not_null` 의 정수값을 출력할 때 42 가 출력되었습니다. 위 예제를 통해 우리는 문자열의 마지막에는 종료 문자로 `'\0'` 이나 `NULL` 혹은 문자 0 이 아닌 0 이란 값 자체를 사용할 수 있음을 알았습니다.

```warning
warning C4047: '초기화 중' : 'char'의 간접 참조 수준이 'void *'과(와) 다릅니다.
```

참고적으로, 컴파일 시 위와 같은 경고를 만나는 분들이 있을 것입니다. 대다수의 경우 경고는 중요한 역할을 하지만 여기서의 경고는 별로 중요하지 않으니 상관하지 않으셔도 됩니다. 나중에, 위 경고가 왜 나왔는지 이야기 해보죠.

아래 예제를 통해 확실히 알아보죠.

```cpp-formatted
/* 문자열의 시작 */
#include <stdio.h>
int main() {
  char sentence_1[4] = {'P', 's', 'i', '\0'};
  char sentence_2[4] = {'P', 's', 'i', 0};
  char sentence_3[4] = {'P', 's', 'i', NULL};
  char sentence_4[4] = {"Psi"};

  printf("sentence_1 : %s \n", sentence_1);  // %s 를 통해서 문자열을 출력한다.
  printf("sentence_2 : %s \n", sentence_2);
  printf("sentence_3 : %s \n", sentence_3);
  printf("sentence_4 : %s \n", sentence_4);

  return 0;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1131DF044B39C11B2AF364)

  오오오. 모두 Psi 가 성공적으로 출력되었습니다. 일단, 각 문자열을 정의하는 것 부터 살펴보도록 합시다.

```cpp-formatted
char sentence_1[4] = {'P', 's', 'i',
                      '\0'};  // \0 는 아스키값이 0 인 문자, 즉 종료 문자이다
```

일단, 첫번째 형식. 위는 `sentence_1` 이라는 크기가 4 인 `char` 배열을 정의하는 문장입니다. 각 원소에 차례로 `'P', 's', 'i'` 가 들어가고 그 뒤에 종료 문자 '\0' 이 들어갔습니다. 즉, `sentence_1` 은 완벽한 널 종료 문자열입니다. 마찬가지로 생각하면 `sentence_2, sentence_3` 도 널 종료 문자열 임을 알 수 있습니다. 그렇다면 `sentence_4` 의 정의 부분을 봅시다.

```cpp-formatted
char sentence_4[4] = {"Psi"};
```

음. 이전까지 보아왔던 정의 형태 보다 약간 다르군요. 사실, 각 문자를 작은 따옴표로 표시해서 배열에 저장하는 일은 매우 번거로운 일이 아닐 수 없습니다. 그래서 C 언어에서는 위와 같이 문자들을 쭉 나열한 것을 큰 따옴표로 묶어주게 되면 알아서 각각의 문자로 넣어줍니다. 이 때, 널 문자는 뒤에 자동으로 추가 되니 굳이 큰따옴표 안에 특별히 명시해줄 필요는 없습니다. 초보자들이 흔히 하는 실수가 위와 같이 "Psi" 로 정의해놓고 배열의 크기를 3 으로 잡는 사람들이 간혹 있습니다. 이렇게 되면 `sentence` 에는 끝에 `NULL` 이 들어가지 않으므로 `sentence` 의 문자열을 출력하라고 했을 때 어떤 이상한 값이 뒤에 출력될지 모를 뿐더러 매우 위험한 작업 입니다. 꼭 널 문자를 위한 공간 하나를 더 추가하는 것을 잊지 마세요~

아무튼, 위와 같이 정의하면 이전의 `sentence_1~3` 과 정확히 동일한 문자열이 됩니다.

```cpp-formatted
printf("sentence_4 : %s \n", sentence_4);
```

위는 '`sentence_4` 부터 들어 있는(`sentence_4` 는 배열의 시작점을 가리키고 있다는 사실을 알고 있겠죠?) 문자열을 출력해달라' 라는 의미로 `%s` 를 이용하였습니다. 이전의 `%c` 는 한 문자만을 출력하는 것이지만 `%s` 를 이용한다면 `sentence_4` 에서 부터 널이 나올 때 까지 문자를 계속 출력하게 됩니다.

  따라서, 위와 같이 Psi 가 예쁘게 출력된 것입니다.

여기 까지 도달 하셨다면 약간 헷갈리는 것이 있을 수 있습니다. " " 와 '' 의 차이점은 뭐지? 말이죠. 저의 경우 이를 잘 이해하지 몰라서 많은 시간 애를 먹었는데 여기 여러분을 위해 "" 와 '' 의 차이점을 깔끔하게 정리한 표를 소개합니다.

| `""`                                       | `''`                                                |
| ------------------------------------------ | --------------------------------------------------- |
| 큰따옴표는 문자열 (한 개 이상의 문자)를 지정할 때 사용된다.        | 작은 따옴표는 한 개의 문자를 지정할 때 사용된다.                        |
| 예) `"abd", "asdfasdf", "sentence", "a"` 등등 | 예) `'a', 'b', '\0'` (틀린표현 : `'abc', 'ab', 'cd'` 등등) |

무언가 깔끔하게 정리된 느낌이 드나요? 사실, 아직 들기는 힘듧니다. 다만, 이 강좌의 끝부분을 읽고 있을 때 쯤이면 그 차이가 완전히 머리속에서 정리 되기를 바랍니다.

```cpp-formatted
/* 포인터 간단 복습 */
#include <stdio.h>
int main() {
  char word[30] = {"long sentence"};
  char *str = word;

  printf("%s \n", str);

  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F13600D054B4C0BC713146E)

위 예제는 사실 단순합니다. 우리가 이전에 배운 내용에 따르면 `char*` 을 이용해서 `char` 배열을 가리킬 수 있다고 하였습니다. 위는 이를 그대로 적용 시킨 것으로 `str` 이라는 `char` 을 가리키는 포인터가 배열 `word` 를 가리키고 있습니다. 따라서,

```cpp-formatted
printf("%s \n", str);
```

에서 `str` 이 가리키는 것을 문자열로 출력 (즉, 널이 나올때 까지 출력) 해 위와 같이 `long sentence` 가 나오게 된 것입니다.

```cpp-formatted
/* 문자열 바꾸기 */
#include <stdio.h>
int main() {
  char word[] = {"long sentence"};

  printf("조작 이전 : %s \n", word);

  word[0] = 'a';
  word[1] = 'b';
  word[2] = 'c';
  word[3] = 'd';

  printf("조작 이후 : %s \n", word);

  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F12290F044B4C0C9F013CBC)

  사실 위 과정도 매우 단순합니다. 일단, 첫번째로 문자열을 정의하는 부분부터 살펴봅시다.

```cpp-formatted
char word[] = {"long sentence"};
```

오잉? 원소의 개수를 지정하는 부분에 아무런 숫자도 써있지 않습니다. 하지만, 여태까지 강좌를 열심히 보아왔던 분들에게는 별 이상하게 느껴지지 않을 것 입니다. 왜냐하면 `[ ]` 안을 빈칸으로 두었다는 뜻은 컴파일러가 알아서 원소의 수를 세어서 빈칸을 채워 넣으라는 뜻이지요. 따라서, 우리는 귀찮게 한글자 한글자 세어서 값을 써줄 필요 없이 단순히 빈칸으로 남겨 놓으기만 하면 됩니다. (물론 배열의 정확한 크기를 알아야 할 상황이 온다면 특별히 값을 명시해 주어야 겠지만)

```cpp-formatted
word[0] = 'a';
word[1] = 'b';
word[2] = 'c';
word[3] = 'd';
```

위와 같이 `word` 배열의 첫 4 개의 원소를 각각 `a,b,c,d` 로 변경하였습니다. 따라서 아래 `printf` 문에서 `long` 부분이 `abcd` 로 변경된 모습을 볼 수 있게 됩니다.



###  문자의 개수를 세자

나중에 프로그래밍을 하다 보면 특정한 문자열에 들어 있는 문자의 개수를 세는 일이 많을 것 입니다. 이를 수행하는 함수를 만들어 봅시다. 먼저, 여러분들께서 아래의 코드를 보지 말고 한 번 직접 작성해 보세요.

```cpp-formatted
#include <stdio.h>
int str_length(char *str);
int main() {
  char str[] = {"What is your name?"};

  printf("이 문자열의 길이 : %d \n", str_length(str));

  return 0;
}
int str_length(char *str) {
  int i = 0;
  while (str[i]) {
    i++;
  }

  return i;
}
```


  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F191B931F4B4FBBAF4C3629)

  소스 코드가 머리에 잘 다가오면 좋겠지만 일단 중요한 부분만 설명하고자 합니다.

```cpp-formatted
int str_length(char *str) {
  int i = 0;
  while (str[i]) {
    i++;
  }

  return i;
}
```

일단 우리가 만들게 될 함수 이름은 `str_length` 함수 입니다. 인자는 `char` 형을 가리키는 포인터 형태 이므로, `char` 배열을 취할 수 있음을 알 수 있습니다. 이전에 함수 강좌에서도 이야기 했지만 일차원 배열을 가리키는 포인터는 (그 배열의 형)* 이라고 했죠? 아무튼, `str` 을 통해 문자열 배열을 가리킬 수 있습니다.

```cpp-formatted
while (str[i]) {
  i++;
}
```

일단 `while` 문의 조건 부분에는 `str[i]` 가 들어 있습니다. 이 말은 즉슨, `str[i]` 가 0 이 될 때 까지 `i` 의 값을 계속 증가 시키겠다죠? 그런데 문자열에서 `str[i]` 가 0 이 되는 순간은 언제일까요. 바로 `NULL` 문자 일 때, 즉 문자열의 끝 부분에 도달하였을 때 0 이 되는 것입니다. 다시말해 `while` 문에서 `str[i]` 가 문자열의 끝 부분이 될 때 `i` 값의 증가를 멈춘다는 것이지요.

따라서 `i` 에는 맨 마지막의 `NULL` 문자를 제외한 나머지 문자들의 총 개수가 되는 것입니다.



###  문자열 입력받기


```cpp-formatted
/* 문자열 입력 */
#include <stdio.h>
int main() {
  char words[30];

  printf("30 자 이내의 문자열을 입력해주세요! : ");
  scanf("%s", words);

  printf("문자열 : %s \n", words);

  return 0;
}
```


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F14678F224B4C128F0D82A6)


이번에는 문자열을 입력 받는 방법에 대해 이야기 하고자 합니다. 이전에 5 강에서 문자를 입력받는 방법에 대해 이야기한 적이 있는데 기억이 나실련지요? 문자열을 입력 받는 것도 그다지 다를 바 없습니다.

```cpp-formatted
char words[30];
```

일단 최대 29 글자 까지 저장할 수 있는 문자 배열 `words` 를 생성하였습니다. 왜 30 글자가 아니라 29 글자인지는 잘 알겠지요? 끝에 널이 들어가기 때문이죠.

```cpp-formatted
printf("30 자 이내의 문자열을 입력해주세요! : ");
scanf("%s", words);
```

이제, `scanf` 를 통해서 문자열을 입력받습니다. 일단, 입력 받는 형식이 `%s` 입니다. 기존의 하나의 문자는 `%c` 였는데 , 문자열의 경우 `%s` 를 이용합니다. 또한, 두번째 인자에 `words` 를 써주었는데, 약간 이상합니다. 이전에 입력 받을 때 에는

```cpp-formatted
char c;
scanf("%c", &c);
```

와 같이 `&` 를 이용해서 주소값을 전달하였는데 여기서는 `&` 를 붙이지 않았습니다. 하지만, 여태까지의 강좌를 잘 읽어보셨고 특히 함수에 대해 잘 공부하신 분이라면 별 이상한 점을 못느꼇을 것입니다. 왜냐하면 `words` 라는 배열의 이름 자체가 배열을 가리키고 있는 포인터 이기 때문에 `words` 의 값을 전달함으로써 배열의 (시작) 주소값을 잘 전달할 수 있습니다.

`scanf` 함수는 잘 아시다싶이 엔터가 나올 때 까지 입력을 받습니다. 그런데 말이죠. 우리가 문자열을 적는데 띄어쓰기를 한다면 아래와 같이 이상한 일이 발생한다는 사실을 알 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F126D81194B4FBDA13E777C)

분명히 `scanf` 는 엔터가 나오면 입력을 종료하는데 왜 `what is your name?` 에서 `what` 부분만 입력이 되었냐죠. 사실 이 부분에 대해서 설명하면 이번 강좌가 너무너무 길어지기 때문에 다음 강좌로 미루도록 합시다. 아무튼. 다음 강좌가 나올 때 까지 인터넷으로 조사 좀 해보세요. 그럼 이번 강좌는 여기에서 마칩니다.

### 생각해보기

#### 문제 1

놀랍게도 배열을 할당하지 않고도 다음과 같이 문자열을 지정할 수 있습니다.

```cpp-formatted
char *str = "abcdefghi";
printf("%s", str); /* 하면 잘 출력된다.*/
```

그렇다면 위 `str` 과 `char c_str[]={"abcdefghi"};` 의 차이점은 무엇일까요? (난이도 : 上)

#### 문제 2

다음 문장이 왜 성립하지 않는지 생각해보세요 (난이도 : 中上)

```cpp-formatted
char str_a[] = "abc";
char str_b[] = "abc";

if (str_a == str_b) {
  /* 이 부분이 실행되지 않는다.*/
}
```

#### 문제 3

(2) 의 답을 얻었다면 두 개의 문자열을 비교하는 함수를 만들어서 같으면 1, 다르면 0 을 리턴하게 해보세요. (난이도 : 中)

##@ chewing-c-end
Link :  31
2009-12-29 00:44
----------------
title : 씹어먹는 C 언어 - <14. 컴퓨터의 머리로 따라가보자 - 디버깅(debugging)>
cat_title : 14. 컴퓨터의 머리로 따라가보자 - 디버깅(debugging)
next_page : 29
publish_date : 2009-12-29 00:44
--------------


이번 강좌에서는

* 버그란 말의 유래

* 디버깅


![씹어먹는 C 언어](/img/ChewingClogo.png)

우리는 흔히 컴퓨터에 오류가 생기면 **버그(bug)** 가 생겼다고 합니다. 그런데 왜 하필이면 버그 일까요? 

곤충? 곤충이 뭐 어째서 말이지요. 사실 이 말이 나온 계기는 먼 옛날 1940 년대로 돌아갑니다. 유명한 여자 컴퓨터 과학자였던 **그레이스 호퍼(Grace Hopper)** 는 하버드 대학교의 Mark II 컴퓨터를 작동시키던 중 연산에 문제가 생기는 바람에 원인을 분석하다가 컴퓨터에 나방이 들어가 일으켰다는 사실을 알게되었습니다. \sidenote{당시 컴퓨터는 지금의 쬐그만한 컴퓨터가 아니라 거의 학교 교실 만한 수 톤짜리 덩치였습니다. 현대의 개인용 컴퓨터에 나방이 들어가는 것은 이상한 일이지만 옛날에는 충분히 있을만한 일이였지요}. 호퍼는 이 나방을 꺼내고는 곤충을 잡았다 해서 디버그(Debug) 했다고 기록했습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F134C76244B3635E6888448)


이 일을 이후로 컴퓨터에 발생한 문제는 버그라고 하게 되었고, 이를 고치는 일은 **디버그** 라고 부르게 되었습니다. 참고적으로 이야기 하자면 기술적인 결함을 지칭하는 용어 버그는 호퍼 보다 훨씬 이전인 에디슨이 가장 먼저 사용하였습니다. 하지만 실질적으로 컴퓨터에서 버그가 사용된 것은 그레이스 호퍼가 처음이였지요.

우리는 이렇게 프로그램을 짜다 보면은 버그를 만나는 일이 종종 있습니다. 이번 강좌에서는 우리가 만든 프로그램의 버그를 찾아내는데 큰 도움을 주는 비주얼 스튜디오의 디버깅을 이용해보도록 하겠습니다. 뜬금없이 C 언어 강좌에 왜 이것을 갑자기 끼워넣었냐면 이 디버깅은 많은 C 언어 책들이 다루고 있는 내용은 아니지만 여러분이 C 프로그래밍을 배우다 보면 꼭 필요한 스킬이기 때문입니다. 적절한 디버깅을 통해서 여러분의 프로그램의 골치아픈 문제점들을 찾아낼 수 있습니다.

먼저 `Visual Express 2008` 을 실행하셔서 다음의 코드를 복사해 넣어 봅시다.

```cpp-formatted
#include <stdio.h>
int main() {
  char a, b, c;
  a = 100;
  b = 300;
  c = a + b;

  printf("%d + %d = %d \n", a, b, c);
  return 0;
}
```

  성공적으로 컴파일 하면 아래의 화면을 볼 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F19046A164B38B0AE70BEF1)

으응? 우리는 흠칫 놀랄 수 밖에 없습니다.내가 `b` 에 300 이라는 값을 주었는데 위에 출력된 결과는 44 로 나왔습니다.게다가 44 는 그렇다 치고, 양수 `+` 양수를 했는데 음수가 나오다니요. 컴퓨터가 계산을 잘못한 것일까요? 음.. 아무리 생각해도 그럴 일은 있을 수 없겠군요. 그렇다면 우리는 여기서 두 가지 방법으로 왜 틀린 결과가 나왔는지 찾아낼 수 있습니다.

첫번째 방법은 밤새도록 머리를 쥐어 짜고 도대체 왜 저딴 결과가 나왔는지 고민하는 것입니다. 아무래도 일찍 자기 위해서는 효과적인 방법이 아니지요. 하지만 다행이도 두번째 방법이 있습니다. 바로, '컴퓨터의 관점에서 코드를 따라가 보는 것' 입니다. 말이 조금 어렵지만, 이 과정이 바로 앞서 이야기 한 '디버그' 입니다.

일단, `Visual Express` 에서 `F10` 을 눌러 봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1430E2184B38B1E2233760)


오오. 무언가 새로운 창이 떳습니다. 일단, 메뉴바 쪽에 알 수 없는 내용들은 무시하고 중점적으로 살펴볼 것은 아래와같습니다. 붉은색 박스로 친 노란색의 화살표와,


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2079BD164B38B242927092)

맨 아래쪽의 '조사식' 부분을 살펴봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F18515E194B38B2DF75F781)

  앞에서도 말했듯이 우리가 디버깅을 하는 이유는 버그를 찾아 내기 위해서입니다. 그런데, 우리가 쉽게 버그를 찾지 못하는 이유는 바로 컴퓨터가 눈 깜짝할 사이에 명령을 다 실행해 버리기 때문이죠. 만일 우리가 컴퓨터가 수를 더하고 출력하는 과정을 천천히 눈으로 볼 수 있다고 치면, 굳이 버그를 쉽게 찾을 수 있습니다. 디버깅을 하면 사용자로 하여금 각 문장이 실행되는 과정을 천천히 살펴 볼 수 있게 해서 어느 문장에서 문제가 발생하는지 알 수 있게 해줍니다. 즉, 우리가 프로그램을 실행해 버리면 컴퓨터는 문장을 순식간에 다 실행해 버리지만 디버깅을 통해 사용자가 순차적으로 문장을 하나씩 하나씩 실행할 수 있게 해주는 것입니다.

  위 말이 이해가 잘 안되도 직접 해보면 쉽게 느낄 수 있을 것입니다.

  먼저, 노란색 화살표 부터 살펴봅시다. 이는 '내가 다음에 실행한 코드' 를 가리키는 역할을 합니다.

아래 조사식은 내가 값을 보고 싶은 식을 써 넣으면 됩니다. 예를 들어서 내가 변수 `a` 의 값을 보고 싶다면 `a` 를 치고, `a + b` 의 값을 보고싶다면 `a + b` 의 값을 치면 됩니다. 이 디버깅 과정에서 문제가 생기는 것은 `b, c` 이므로, 일단 변수 `a,b,c` 의 값들이 어떻게 변화하는지 살펴보도록 합시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F182098054B38B52F6973F6)

위와 같이 `a,b,c` 를 차례로 입력합니다. 어랏. 이상합니다. 변수 `a,b,c` 의 값이 출력되고 있지 않습니다. 왜 그럴까요? 사실, 당연한 일이지요. 노란색 화살표를 보면 현재 `{` 를 가리키고 있었습니다. 다시 말해 다음에 실행할 문장이 `{` 이므로 `char a,b,c` 는 실행 조차 되지 않았기 때문이죠. 따라서 컴퓨터는 `a,b,c` 라는 변수가 정의되어 있는지 모르기 때문에 위와 같이 `a,b,c` 라는 변수가 없다는 오류를 내게 됩니다.

  그 다음 문장을 실행하기 위해서는 `F10` 을 누르면 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F122E961D4B38B95F6E366E)

어랏. 분명히 그 다음 문장을 실행한다고 그랬는데 두 줄이나 내려왔습니다. 이는 사실, 컴퓨터에서 사용자의 편의를 위해 변수를 정의하는 부분은 일일이 귀찮게 `F10` 을 누르지 않도록 자동으로 실행해 준 것입니다. 아무튼. 크게 중요한 부분은 아닙니다. 다음 문장을 실행하기 전에, 조사식이 어떻게 되었는지 봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F153B801D4B38B9D35B3A0B)

모두 -52 라는 값을 갖고 있는 것처럼 보입니다. 사실, 그렇지 않습니다. 우리가 `a,b,c` 에 아직 아무런 값을 대입하지 않았기 때문에 현재 쓰레기 값으로 초기화 된 것입니다. 즉, -52 라는 것은 아무런 의미가 없습니다. 단순히 `a,b,c` 에 아무런 값도 대입되지 않았음을 나타냅니다.

이제, `F10` 을 또 한번 눌러봅시다. 화살표가 b=300; 을 가리켰으므로, 그 위의 문장, 즉 `a = 100;` 이란 문장을 실행했다는 것입니다. 따라서, 조사식을 보면,


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F181CE91A4B38BA8E868174)

위와 같이 `a` 의 값이 100 이라고 나옵니다. 이 때 옆의 'd' 는 100 에 해당하는 아스키 문자(기억 하시죠? 모르면 [5강 참조](http://itguru.tistory.com/9)) 을 나타낸 것으로, 사용자의 편의를 위해 컴퓨터가 나타내주었습니다.

마찬가지로 `F10` 을 눌러서 `b` 의 값도 정의해줍시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F124508114B38BC1256E611)

허걱. 분명히 `b = 300` 을 했는데 `b` 에는 44 가 들어갔습니다. 무언가 문제가 있어 보입니다. 사실, 이쯤 되면 무엇이 문제인지 짐작할 수 있겠지만, 아래에서 설명하도록 하죠. 마찬가지로 `F10` 을 또 한번 눌러서 `c = a + b;` 를 실행해 보면 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1619871A4B38BB035A1B9A)
조사식을 살펴 보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F15181D1A4B38BB1F8B7D88)

 `c` 의 값이 -112 로 되었음을 볼 수 있습니다. 또한, -112 에 해당하는 아스키문자가 `?` 여서 '?' 로 출력된 것이 아니라 아스키 표에 해당하지 않는 수이기 때문에 알 수 없음의 의미로 `?` 가  출력된 것입니다. 음. `c = a + b;` 를 했는데 왜 `c` 에 -112 가 들어갔을까요? 사실, 여러분이 다 짐작하고 있겠지만 이유는 간단합니다. `char` 의 범위가 128 까지 이기 때문이죠. 즉, `b` 값에 44 가 들어간 것도, `100 + 44` 를 했는데 -112 가 출력된 것도 모두 `char` 의 범위가 128 까지 이기 때문에 발생한 일들입니다.

만일 우리가 디버깅을 하지 않았다고 칩시다. 과연 우리는 `char` 의 범위 때문에 그렇다라는 것을 알 수 있었을까요? 물론, 위 예제에선 그렇습니다. 예제가 간단하기 때문이죠. 우리는 손쉽게 내가 `char` 형의 범위를 무시하고 값을 대입해서 오류가 떴구나 라는 사실을 알 수 있습니다. 그러나, 실제 예제는 이와 같이 단순하지 않습니다. 위는 그냥 설명하기 편하게 하기 위해 위와 같이 예를 잡은 것이고, 실제 우리가 만들게 될 프로그램은 이것보다 100 배는 더 복잡합니다.

예를 들어 아래의 코드를 봅시다(사실 아래 것도 그리 복잡한 것은 아니지만 적절한 예제가 없어서.. 여러분이 직접 프로그래밍 하시다 보면 알게 될것입니다) .

```cpp-formatted
/* 샘플 코드 */
#include <stdio.h>

int main() {
  int arr[10];
  int i;

  for (i = 0; i < 10; i++) {
    scanf("%d", &arr[i]);
  }
  for (i = 0; i <= 10; i++) {
    printf("%d \n", arr[i]);
  }
  return 0;
}
```

  성공적으로 컴파일 해보면 아래와 같이 맨 아래에 이상한 값이 출력됨을 볼 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F1861B60B4B38C4D96C91B5)

도대체 -858993460 은 어디서 나온 것일까요? 한 번 여러분이 디버깅을 통해 코드의 어느 부분이 잘못되었는지 찾아서 수정해보세요 :)

##@ chewing-c-end
Link :  30
2009-12-27 00:45
----------------
title : 씹어먹는 C 언어 - <13 - 4. 마술 상자 함수 (생각해볼 문제에 대한 아이디어)>
cat_title : 13 - 4. 마술 상자 함수 (생각해볼 문제에 대한 아이디어)
next_page : 31
publish_date : 2009-12-27 00:45
--------------


이번 강좌에서는

* 재귀 함수에 대한 이해

* 여러가지 주요 알고리즘. (버블 정렬, 유클리드 호제법, 에라토스테네스의 체)

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분. [이전 강좌의 예제](http://itguru.tistory.com/28)가 중요한 만큼, 예제에 좀더 쉽게 접근할 수 있는 아이디어에 관해서 짧은 힌트 형식으로 강좌를 작성하도록 하겠습니다. 물론, 언제까지나 힌트일 뿐 완전한 코드는 여러분이 완성시켜야 합니다.

### 생각해볼 문제 1

```info
사용자로 부터 5 명의 학생의 수학, 국어, 영어 점수를 입력 받아서평균이 가장 높은 사람 부터 평균이 가장 낮은 사람까지 정렬되어 출력하도록 하세요. 특히, 평균을 기준으로 평균 이상인 사람옆에는 '합격', 아닌 사람은 '불합격' 을 출력하게 해보세요.
```

일단, 여러분이 직면했을 가장 큰 문제는 '어떻게 정렬하는 프로그램' 을 만드느냐 이였겠습니다. 정렬을 하는 방법 (보통 알고리즘 이라 표현합니다) 에는 여러가지가 있습니다. 가장 직관적으로 이해하기 쉬운 것은버블 정렬(Bubble sorting) 이라 불리는 것인데 컴퓨터가 다음과 같은 규칙을 통해 작업을 합니다.

예를 들어 5, 1, 4, 2, 8 을 정렬한다고 합시다.

( **5 1** 4 2 8 ) -> ( **1 5** 4 2 8 )

버블 정렬 알고리즘은 처음 두 개의 원소를 비교해 왼쪽이 크면 자리를 바꿉니다. 이 경우, 5 가 1 보다 더 크기 때문에 1 과 5 의 자리를 바꾸었습니다.

( 1 **5 4** 2 8 ) -> ( 1 **4 5** 2 8 )

그 다음 두 원소를 비교합니다. 이번에도 5 가 더 크므로 4 와 자리를 바꿉니다.

( 1 4 **5 2** 8 ) -> ( 1 4 **2 5** 8 )

그 다음 두 원소 5,2 를 비교합니다. 이번에도 5 가 더 크므로 자리를 바꿉니다.

( 1 4 2 **5 8** ) -> ( 1 4 2 **5 8** )

그 다음 두 원소 5,8 를 비교합니다. 이번에는 오른쪽이 더 크므로 자리를 안바꿔도 됩니다. 끝 원소 까지 비교하였다면, 가장 큰 원소가 가장 오른쪽에 위치하게 됩니다. (왜 그런지는 잘 알겠지요?)

( **1 4** 2 5 8 ) -> ( **1 4** 2 5 8 )

이제 다시 처음부터 두 원소를 골라 비교합니다.

( 1 **4 2** 5 8 ) -> ( 1 **2 4** 5 8 )

위와 같은 작업들을 쭉 시행합니다.

( 1 2 **4 5** 8 ) -> ( 1 2 **4 5** 8 )

( 1 2 4 **5 8** ) -> ( 1 2 4 **5 8** )

마지막까지 비교하였다면 다시 처음으로 갑니다.

그렇다면 이를 언제까지 반복해야 할까요? 더이상 자리가 바뀌는 원소들이 없을 때 까지 해야 하겠죠?

( **1 2** 4 5 8 ) -> ( **1 2** 4 5 8 )

( 1 **2 4** 5 8 ) -> ( 1 **2 4** 5 8 )

( 1 2 **4 5** 8 ) -> ( 1 2 **4 5** 8 )

( 1 2 4 **5 8** ) -> ( 1 2 4 **5 8** )

위 작업을 완료하였다면, 컴퓨터는 더이상 자리가 바뀌는 원소들이 없다는 것을 알아채고 정렬을 그만하게 됩니다. 음, 역시 정확하게 `1,2,4,5,8` 로 정렬이 되었군요.

일단, 위 버블 정렬 알고리즘을 C 언어에서 구현하기 위해서 저는 여러분들이 다음과 같은 함수를 만들어주기를 원합니다.

```cpp-formatted
Bubble_sort(int* arr, int num_elements), swap(int* pele)
```

`Bubble_sort` 함수는 말그대로 정렬을 하는 함수 입니다. 이 때, `num_elements` 로 `arr` 이 가리키는 배열의 원소 개수를 알아야 하겠죠? 그리고 `swap` 함수는 `pele` 가 가리키는 원소와 그 다음 원소를 서로 뒤바꿔주는 함수 입니다. 따라서 `Bubble_sort` 함수가 `pele` 함수를 호출해야 되겠죠?

사실 버블 정렬은 매우 비효율적인 정렬 알고리즘 입니다. 하지만 구현하가 매우 단순하여 정렬해야 될 것이 작은 경우에는 이를 자주 이용하게 되지요. 정렬 알고리즘에 대해 궁금하신 분들은 [여기를 클릭](http://en.wikipedia.org/wiki/Sorting_algorithm)해서 정렬 알고리즘의 세상에 빠져보세요.

### 생각해볼 문제 2

```info
유클리도 호제법을 이용해서 N 개의 수들의 최대공약수를 구하는 함수를 만들어보세요. 유클리드 호제법이 무엇인지 모르신다면, 인터넷 검색을 활용하는것을 추천합니다. (댓글을 달아도 돼요)
```

유클리드 호제법은 어떠한 두 수의 최대공약수를 계산하는데 쓰이는 방법입니다. 방법 자체는 간단합니다.


1. 두 수를 `m` 과 `n` 이라 하자. (`m > n`)
1. `m` 을 `n` 으로 나눈 나머지를 계산한다. (`m % n`)
1. `m % n` 이 0 이라면 `n` 값이 맨 처음 두 수의 최대공약수이다. (종료)
1. `m % n` 이 0 이 아니였다면, `m % n` 과 `n` 중 큰 것을 `m,` 작은 것을 `n` 이라 한 후 ① 로 돌아간다.


예를 들어서 63 와 35 의 최대공약수를 구한다고 합시다. 그렇다면 유클리드 호제법을 이용하면 아래와 같은 과정을 거칩니다.


1. `m = 63, n = 35`
1. `63 % 35 = 28`
1. 28 이 0 이 아니므로, 28 과 35 를 비교한느데 35 가 크므로 `m = 35, n = 28`
1. `m = 35, n = 28`
1. `35 % 28 = 7`
1. 7 이 0 이 아니므로, 7 과 28 을 비교, 28 이 크므로 `m = 28, n = 7`
1. `m = 28, n = 7`
1. `28 % 7 = 0`
1. 0 이므로, `n` 값 ( 7 ) 이 맨 처음 두 수의 최대공약수. 즉, 63 과 35 의 최대공약수는 7 이다

사실, 왜 위 과정을 거치면 두 수의 최대공약수가 나오는지에 대한 증명은 간단합니다. 수학적 지식이 없다면 이해가 안갈 수 도 있지만,

$$m = qn + r, (0 \le r < q), \text{gcd}(m, n) = \text{gcd}(qn + r, n) = \text{gcd}(r, n)$$

때문에 그렇습니다. 유클리드 호제법은 두 개의 수의 최대공약수를 찾는데에만 사용하였지만 이를 어떻게 `N` 개의 수의 공통된 최대공약수를 찾는데 응용할 수 있을까요? 답은 간단합니다. 처음 두 수의 최대 공약수를 구합시다. 그리고, 그 다음수와 구한 최대공약수의 최대 공약수를 계산합니다. 그리고 이를 쭈우욱 반복합니다.

예를 들어서 `18, 24, 40, 60` 의 최대공약수를 구한다고 해봅시다. 18 과 24 의 최대공약수는 6 입니다. 그러면 이제 6 과 40 의 최대공약수를 계산합니다. 이는 2 입니다. 그러면 이제 2 와 60 의 최대공약수를 계산합니다. 이는 2 입니다. 따라서, 이 4 개의 수의 공통된 최대공약수는 2 가 됩니다.

  여기에도 수학적 원리가 있지만 간단하기 때문에 넘어가도록 하겠습니다. 여러분이 생각해보세요~

### 생각해볼 문제 4

```info
자기 자신을 호출하는 함수를 이용해서 1 부터 특정한 수까지의 곱을 구하는 프로그램을 만들어보세요.
```

  여러분은 '자기 자신을 호출한다' 에 대해서 많은 고민을 많이 하셨을 것입니다. 일단, 아래의 코드를 직접 컴파일 후 실행해보세요

```cpp-formatted
#include <stdio.h>
int recursive(int n) {
  printf("난 인자가 %d 에요! \n");
  if (n <= 0) return 0;

  recursive(0);
}
int main() {
  recursive(3);
  return 0;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1903D2284B36263D76E85B)

  흠. 어느 정도 예측 가능했던 결과입니다. 그렇다면, 아래의 코드는 어떨까요?

```cpp-formatted
#include <stdio.h>
int recursive(int n) {
  printf("난 인자가 %d 에요! \n", n);
  if (n <= 0) return 0;

  recursive(n - 1);

  return 0;
}
int main() {
  recursive(3);
  return 0;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F176283254B362678AE89BF)

일단, 컴퓨터 상에서 위 코드는 아래의 순서로 실행됩니다.


1. `main` 함수에서 `recursive(3)` 을 호출함
1. `recursive` 에서 `n = 3` '난 인자가 3 이에요' 를 출력
1. `n` 이 0 이하가 아니므로 넘어감
1. `recursive(n-1)` 즉 `recursive(2)` 를 호출
1. `recursive` 에서 `n = 2` '난 ~ 2 ~ ' 를 출력 (~ 는 생략)
1. `n` 이 0 이하가 아니므로 넘어감
1. `recursive(n-1)` 즉 `recursive(1)` 을 호출
1. `recursive` 에서 `n = 1`, ' ~ 1 ~ ' 를 출력
1. `n` 이 0 이하가 아니므로 넘어감
1. `recursive(n-1)` 즉 `recursive(0)` 을 호출
1. `recursisve` 에서 `n = 0`, '~ 0 ~' 을 출력
1. `n` 이 0 이하이므로 `return 0;`
1. `n = 1` 이였던 `recursive` 에서 `return 0;`
1. `n = 2` 이였던 `recursive` 에서 `return 0;`
1. `n = 3` 이였던 `recursive` 에서 `return 0;`
1. `main` 함수로 돌아감.


사실, 위 작업이 이해가 잘 안되는 수도 있습니다만.. 나중에 변수의 정의 범위에 대해 배우게 된다면 좀더 쉽게 이해할 수 있으실 것입니다. 아무튼 위 사실을 활용해서 1 부터 `n` 까지 곱하는 재귀 함수를 만들어보세요 (위와 같이 자기 자신을 호출하는 함수를 **재귀함수**, 영어로 **recursive function** 이라 합니다.)

### 생각해볼 문제 4

```info
계산기를 만들어보세요. 사용자가 1 을 누르면 +, 2 를 누르면 - 와 같은 방식으로 해서 만들면 됩니다. 물론 이전의 계산 결과는 계속 누적되어야 하고, 지우기 기능도 있어야 합니다. (물론하나의 함수에 구현하는 것이 아니라 여러개의 함수로 분할해서 만들어야겠죠?)
```

이 문제는 그다지 어려운 아이디어 같은 것이 필요한 것이 아니므로 생략하도록 하겠습니다. 사실, 난이도는 중하 정도 됩니다.

### 생각해볼 문제 5

```info
N 진법에서 M 진법으로 변환하는 프로그램을 만들어보세요. (난이도 : 中)
```

사실 이 문제는 잘못낸 문제입니다. 물론 아이디어는 충분히 구현할 수 있지만 여러분은 아직 '문자열'에 대한 개념이 없기 때문에 정확하게 구현할 수 는 없지만 생각 정도는 할 수 있습니다. 일단 위 프로그램을 어떻게 만들 것인지에 대해 생각해 놓은 것을 보세요. 나중에 필요한 개념을 다 배우고 나면 하실 수 있을 것입니다. (참고적으로 문제에 조건 하나가 빠졌는데 `N,M` 은 모두 36 이하 입니다. 왜냐하면 숫자를 이용시 `0,1,...,9,A,B,..` 로 사용하는데 알파벳이 26 개이므로 총 36 진수 까지 나타낼 수 있거든요)


* 사용자로 부터 무슨 진법에서 무슨 진법으로 변환할 지 입력받습니다. (`N,M` 입력)
* `N` 진법의 수를 입력받습니다.
* 그 수를 각 자리로 분해해 `int` 배열에 값을 넣습니다. 이 때, 값은 십진수로 넣습니다. 예를 들어서 16 진법으로 `7AE` 를 입력받았다면 `digit[0] = 14, digit[1] = 10, digit[2] = 7` 로 넣으면 됩니다. 참고로, 올바르지 않은 숫자가 사용되면 종료합니다. (예를 들어서 2 진법인데 3 이란 숫자를 사용함)
* 이 수를 십진수로 변환합니다. (`NtoDec` 함수 제작 요망)
* 이 십진수를 다시 `M` 진법의 수로 변환합니다. (`DectoM` 함수 제작 요망)


물론, 이 문제는 꼭 안푸셔도 됩니다. 나중에 개념을 좀더 배우다 보면 풀 수 있는 스킬들을 습득하실 것입니다.

### 생각해볼 문제 6

```info
에라토스테네스의 체를 이용해서 1 부터 N 까지의 소수를 구하는 프로그램을 만들어보세요. (난이도 : 中)
```

에라토스테네스의 체.. 이름이 참 어렵군요. 사실 이는 간단합니다. 말그대로 숫자들만 걸러내는 **체(sieve)** 인데, 아래와 같은 방식으로 숫자를 걸러내어 소수들을 찾습니다.


* 수들을 쭉 쓴다.
* 2 의 배수들을 다 지운다.
* 2 에서 가장 가까운 안지워진 수를 찾는다. 아마도 3 일 것이다. (소수 찾았다!)
* 3 의 배수들을 다 지운다.
* 3 에서 가장 가까운 안지워진 수를 찾는다. 아마도 5 일 것이다. (소수 찾았다!)
* 5 의 배수들을 다 지운다.
* 5 에서 가장 가까운 안지워진 수를 찾는다. 아마도 7 일 것이다. (소수 찾았다!)
* 7 의 배수들을 다 지운다.
* 그 뒤로 쭈우욱 같은 작업을 실시


위키피디아에서 이 과정을 알기 싶게 애니메이션으로 나타낸 자료가 있으니 보시기 바랍니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2037AA0E4B362D7CB91FA1)

### 생각해볼 문제 7

```info
1000 자리의 수들의 덧셈, 뺄셈, 곱셈, 나눗셈을 수행하는 프로그램을 만들어보세요. 나눗셈의 경우 소수 부분을잘라버리세요. 물론, 소수 부도 1000 자리로 구현해도 됩니다. 1000 자리 수들의 연산 수행 시간은 1 초 미만이여야합니다. (난이도 : 上)
```

`int` 자료형은 대략 42 억, 그러니까 10 자리 정도의 수 밖에 사용할 수 없었습니다. 그런데 문제에서 요구하는 것은 무려 1000 자리나! 이걸 도대체 어떻게 하라는 말일까요. 사실, 간단합니다. 크기가 1000 인 `char` 배열을 만들어서 배열의 한 원소를 수의 한 자리라고 생각하면 되죠. 이게 도대체 무슨 말이냐고요?

예를 들어서 `char BigNum[1000];` 을 정의하였다고 할 때, 사용자가 만일 123456 을 입력하였다면 `BigNum[999] = 6, BigNum[998] = 5, ... BigNum[994] = 1` 로 하면 되죠. 이러한 형식의 두 수를 더하는 연산을 하기 위해서는 각 원소를 더한 뒤, 받아올림이 있으면 그 다음 원소에 더해주고 하는 방식으로 쭉 나가면 됩니다. 어때요? 간단하죠.

곱셈은 쉽게 하면 덧셈을 여러번 반복해서 호출하는 것으로 해결될 수 있지만 연산 속도가 느리므로 인간이 곱셈하는 방식으로 하는 것을 권합니다. 그렇다면 문제는 나눗셈인데 나눗셈 역시 뺄셈을 반복하는 것으로 해결 될 수 있지만 역시 느리므로, 인간이 나눗셈 하는 방식으로 계산하는 함수를 만들어보세요. 그럼. 행운을 빕니다.

##@ chewing-c-end
Link :  28
2009-12-22 17:44
----------------
title : 씹어먹는 C 언어 - <13 - 3. 마술 상자 함수 3 (function)>
cat_title : 13 - 3. 마술 상자 함수 3 (function)
next_page : 30
publish_date : 2009-12-22 17:44
--------------


이번 강좌에서는

* 더블 포인터 인자

* 2 차원 배열 인 2 차원 배열 인자
* 상수 인자

* 함수 포인터

에 대해서 배웁니다.

![씹어먹는 C 언어](/img/ChewingClogo.png)

와.. 드디어, 함수만 세번째 강의입니다. 아마 이전 강좌에서 배운 내용들 중 어려운 것은 없으리라 생각됩니다. 물론, 이번 강좌의 내용도 이전까지의 내용을 잘 숙지 하셨더라면 무난하게 넘어갈 수 있으리라 생각됩니다.



###  지난번 내용을 상기해보며


지난번 내용은 잘 기억하고 있는지요? 다시 한 번 요약해 보자면, "어떠한 함수가 특정한 타입의 변수/배열의 값을 바꾸려면 함수의 인자는 반드시 타입을 가리키는 포인터 형을 이용해야 한다!" 였습니다.사실, 이 문장이 이해가 잘 되지 않았던 분들이 있으리라 생각됩니다. 하지만, 이번 강좌를 보고 난다면 이 문장의 의미를 정확하게 파악할 수 있을 것입니다.

```cpp-formatted
/* 눈 돌아가는 예제. 포인터가 가리키는 변수를 서로 바꾼다.  */
#include <stdio.h>

int pswap(int **pa, int **pb);
int main() {
  int a, b;
  int *pa, *pb;

  pa = &a;
  pb = &b;

  printf("pa 가 가리키는 변수의 주소값 : %x \n", pa);
  printf("pa 의 주소값 : %x \n \n", &pa);
  printf("pb 가 가리키는 변수의 주소값 : %x \n", pb);
  printf("pb 의 주소값 : %x \n", &pb);

  printf(" ------------- 호출 -------------- \n");
  pswap(&pa, &pb);
  printf(" ------------- 호출끝 -------------- \n");

  printf("pa 가 가리키는 변수의 주소값 : %x \n", pa);
  printf("pa 의 주소값 : %x \n \n", &pa);
  printf("pb 가 가리키는 변수의 주소값 : %x \n", pb);
  printf("pb 의 주소값 : %x \n", &pb);
  return 0;
}
int pswap(int **ppa, int **ppb) {
  int *temp = *ppa;

  printf("ppa 가 가리키는 변수의 주소값 : %x \n", ppa);
  printf("ppb 가 가리키는 변수의 주소값 : %x \n", ppb);

  *ppa = *ppb;
  *ppb = temp;

  return 0;
}
```

  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F114B5C164B2CAA6E6CA90F)
여러분의 출력결과는 위 사진과 다를 수 있습니다.

일단, 붉은색으로 박스 친 부분을 잘 살펴보기 바랍니다. `pa` 가 가리키는 변수의 주소값은 (즉, `pa` 의 값이지요) `31FBCC` 였습니다. 물론, 여러분이 실행했을 때 에는 결과가 다르게 나올 것입니다. (거의 99% 확률로 다르게 나옵니다) `pb` 가 가리키는 변수의 주소값은 `31FBC0` 이였습니다. 그런데 말이죠. `pswap` 함수를 호출하고 나니, `pa` 가 가리키는 변수의 주소값은 `31FBC0` 이 되고, `pb` 가 가리키는 변수의 주소값은 `31FBCC` 가 되었습니다. 즉, 두 포인터가 가리키는 변수가 서로 뒤바뀐 것이지요.

이 때, 우리는 이와 같은 함수를 만들기 위해서, 인자를 어떤 형식으로 취해야 될까요? 앞서 말했듯이, 특정한 타입의 변수의 값을 바꾸려면, 특정한 타입을 가리키는 포인터로 인자를 취해야 된다고 했습니다. 그런데, 이 예제의 경우, 특정한 타입은 `int*` 타입입니다. 그렇다면 `int*` 타입을 가리키는 포인터의 타입은? 음. 강좌를 잘 복습하였다면 `int**` 타입 이라고 말할 수 있겠지요. (잘 모르겠다면 [12-3 강, 포인터는 영희이다!](http://itguru.tistory.com/25)를 보세요)

  따라서, 우리는 위 이야기를 토대로 아래와 같이 함수를 정의하였습니다.

```cpp-formatted
int pswap(int **ppa, int **ppb)
```

  상당히, 잘한 것이지요. 이제, 함수의 몸체를 봐봅시다.

```cpp-formatted
int pswap(int **ppa, int **ppb) {
  int *temp = *ppa;

  printf("ppa 가 가리키는 변수의 주소값 : %x \n", ppa);
  printf("ppb 가 가리키는 변수의 주소값 : %x \n", ppb);

  *ppa = *ppb;
  *ppb = temp;

  return 0;
}
```

일단, `int*` 형의 `temp` 변수를 만들어서 `*ppa` 의 값을 저장하고 있습니다. 그런데, `*ppa` 의 값은 무엇일까요? 

만일 우리가 위 예제 처럼 `pswap` 함수를 호출하였다고 하면, `ppa` 는 `pa` 를 가리키고 있고, `ppb` 는 `pb` 를 가리키고 있겠지요. 따라서, `*ppa` 라 하면 `pa` 의 값을 이야기 합니다. 그런데, `pa` 는 `int*` 형이므로, `pa` 의 값을 보관하는 변수는 반드시 `int*` 이여야 되겠지요. 따라서, 우리는 `int*` 형의 `temp` 변수를 정의하였습니다. 그 아래의 내용은 이전에 만들어 보았던 `swap` 함수와 동일합니다.

```cpp-formatted
printf("ppa 가 가리키는 변수의 주소값 : %x \n", ppa);
printf("ppb 가 가리키는 변수의 주소값 : %x \n", ppb);
```

그렇다면 우리는 위 두개의 `printf` 문장에서 어떤 결과가 출력될 지 예측 가능합니다. 위 예제에서 `ppa` 가 `pa` 를 가리키고 있으므로 `ppa` 의 값을 출력하면 `pa` 의 주소값이 나오고, `ppb` 도 마찬가지로 나오겠죠. 위 출력결과에서 실제로 같다는 것을 확인할 수 있습니다. 어때요. `pswap` 함수가 이해가 되나요?

위 과정을 그림으로 표현하면 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F146B111F4B2CB12B40F6C1)


그렇다면, 이번에는 이차원 배열을 인자로 받는 함수에 대해서 생각해 보도록 합시다.

```cpp-formatted
/* 2 차원 배열의 각 원소를 1 씩 증가시키는 함수 */
#include <stdio.h>
/* 열의 개수가 2 개인 이차원 배열과, 총 행의 수를 인자로 받는다. */
int add1_element(int (*arr)[2], int row);
int main() {
  int arr[3][2];
  int i, j;

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
      scanf("%d", &arr[i][j]);
    }
  }

  add1_element(arr, 3);

  for (i = 0; i < 3; i++) {
    for (j = 0; j < 2; j++) {
      printf("arr[%d][%d] : %d \n", i, j, arr[i][j]);
    }
  }
  return 0;
}
int add1_element(int (*arr)[2], int row) {
  int i, j;
  for (i = 0; i < row; i++) {
    for (j = 0; j < 2; j++) {
      arr[i][j]++;
    }
  }

  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1739B8224B2CB4F71E3A75)

역시 잘 실행되는군요. 일단, 함수의 정의부분 부터 살펴봅시다.

```cpp-formatted
int add1_element(int (*arr)[2], int row) {
  int i, j;
  for (i = 0; i < row; i++) {
    for (j = 0; j < 2; j++) {
      arr[i][j]++;
    }
  }

  return 0;
}
```

이 함수는 인자를 두 개 받고 있는데 하나는 열의 개수가 2 개인 이차원 배열을 가리키는 포인터 이고, 하나는 함수의 행의 수를 받는 인자입니다.

```cpp-formatted
for (i = 0; i < row; i++) {
  for (j = 0; j < 2; j++) {
    arr[i][j]++;
  }
}
```

우리는 `row` 를 통해 이 이차원배열의 행의 개수를 알 수 있고, 열의 개수는 이미 알고 있으므로 (배열 포인터에서) 각 원소를 1 씩 증가시키는 작업을 시행할 수 있게됩니다. 위와 같이 말이죠. 우리는 포인터를 잘 배워서 헷갈릴 문제는 없지만 많은 사람들에게 다음과 같이 인자를 받는것이 어렵게 느껴집니다.

```cpp-formatted
int add1_element(int (*arr)[2], int row)
```

그래서, 오직 함수의 인자의 경우에서만 위 형태의 인자를 다음과 같이도 표현할 수 있습니다.

```cpp-formatted
int add1_element(int arr[][2], int row)
```

  이는 오직 함수의 인자에서만 적용되는 것입니다. 만일

```cpp-formatted
int parr[][3] = arr;
```

와 같은 문장을 이용했더라면 컴퓨터는 `parr` 을 '열의 개수가 3 개이고 행의 개수는 정해지지 않는 배열' 이라 생각해서 오류를 내게 됩니다. (만일 행의 개수를 생략했다면 배열을 정의시 초기화도 해주어야 되는데는 위는 그러지 않으므로) 암튼, 함수의 인자에서만 가능한 형태라는 것을 기억해 주시기 바랍니다.

덧붙여서 응용력을 살짝 이용하면 다차원 배열의 인자도 정의할 수 있습니다. 예를 들어서

```cpp-formatted
int multi(int (*arr)[3][2][5]) {
  arr[1][1][1][1] = 1;
  return 0;
}
```

  혹은

```cpp-formatted
int multi(int arr[][3][2][5]) {
  arr[1][1][1][1] = 1;
  return 0;
}
```
  
로 하면 됩니다.



###  상수인 인자

```cpp-formatted
/* 상수를 인자로 받아들이기 */
#include <stdio.h>
int read_val(const int val);
int main() {
  int a;
  scanf("%d", &a);
  read_val(a);
  return 0;
}
int read_val(const int val) {
  val = 5;  // 허용되지 않는다.
  return 0;
}
```

컴파일 하게 되면 아래와 같은 오류를 만나게 됩니다.

```warning
 error C2166: l-value가 const 개체를 지정합니다.
```

흠.. 이건 우리가 이전에 상수의 값을 변경하려고 했었을 때 만났던 오류 인것 같습니다. 맞습니다. 우리가 `val` 을 `const int` 로 선언하였기 때문에 함수를 호출 할 때, `val` 의 값은 인자로 전달된 값으로 초기화 되고 결코 바뀌지 않습니다. 즉, `val` 은 `a` 의 값으로 상수로 초기화 된 것입니다. 따라서, 함수 내부에서 `val = 5` 와 같이 `val` 의 값을 바꾸려 한다면 오류가 나겠지요. 왜냐하면 `val` 은 상수이니까요.

상수로 인자를 받아들이는 경우 대부분은 함수를 호출 해도 그 인자의 값이 바뀌지 않는 경우에 자주 사용합니다만, 자세한 내용은 나중에 좀더 다루도록 하겠습니다.



###  함수 포인터

아마, '함수 포인터' 라는 말을 들었을 때는 조금 의아하는 감이 있지 않을까 합니다. 함수 포인터라니, 함수를 가리킨다는 것인가? 그럼, 함수가 메모리 상에 있다는 거야? 네. 맞습니다. 사실, 프로그램의 코드 자체가 메모리 상에 존재합니다. 우리는 이전에 컴파일러가 하는 작업이 바로 우리가 '인간에 친숙한 언어' 로 쓰여진 프로그램 코드를 '컴퓨터에 친숙한 언어, 즉 수 데이터들' 로 바꿔주어 실행 파일을 생성한다고 배웠습니다. 이렇게, 바뀐 실행 파일을 실행하게 되면 프로그램의 수 코드가 메모리 상에 올라가게 됩니다. 다시말해, 메모리 상에 함수의 코드가 들어간다는 것입니다. 이 때, 변수를 가리키는 포인터 처럼 함수 포인터는 메모리 상에 올라간 함수의 시작 주소를 가리키는 역할을 하게 됩니다.

그렇다면, 함수 포인터가 함수를 가리키기 위해서는 그 함수의 시작 주소값을 알아야 합니다. 그런데, 배열과 마찬가지로 함수의 이름이 바로 함수의 시작 주소값을 나타냅니다.

```cpp-formatted
/* 함수 포인터 */
#include <stdio.h>

int max(int a, int b);
int main() {
  int a, b;
  int (*pmax)(int, int);
  pmax = max;

  scanf("%d %d", &a, &b);
  printf("max(a,b) : %d \n", max(a, b));
  printf("pmax(a,b) : %d \n", pmax(a, b));

  return 0;
}
int max(int a, int b) {
  if (a > b)
    return a;
  else
    return b;

  return 0;
}
```

성공적으로 컴파일 했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F177417244B3072794C0316)

역시 우리가 예상했던 데로 잘 흘러가는 것 같습니다. 함수 포인터는 어떻게 정의하는지 살펴봅시다.

```cpp-formatted
int (*pmax)(int, int);
```

일단, 위는 함수 포인터 `pmax` 의 정의 입니다. 위 정의를 보고 다음과 같은 사실을 알 수 있습니다. '이 함수 포인터 `pmax` 는 함수의 리턴값이 `int` 형이고, 인자 두 개가 각각 `int` 인 함수를 가리키는구나!'. 따라서, 우리는 `pmax` 함수 포인터로 특정한 함수를 가리킬 때, 그 함수는 반드시 `pmax` 의 정의와 일치해야 합니다. 함수 포인터의 일반적인 정의는 다음과 같습니다.

```info
(함수의 리턴형) (*포인터 이름)(첫번째 인자 타입, 두번째 인자 타입,....)
// 만일 인자가 없다면 그냥 괄호 안을 비워두면 된다. 즉, int (*a)() 와 같이 하면 된다
```

이제 `pmax` 가 `max` 를 가리키게 되는 부분을 봅시다.

```cpp-formatted
pmax = max;
```

`max` 함수를 살펴보면 `pmax` 의 정의와 일치하므로, `max` 함수의 시작 주소값을 `pmax` 에 대입할 수 있게 됩니다. 이 때, 앞에서도 말했듯이 특정한 함수의 시작 주소값을 알려면 그냥 함수 이름을 넣어주면 됩니다. `pmax = &max` 와 같은 형식은 틀린 것입니다.

```cpp-formatted
printf("max(a,b) : %d \n", max(a, b));
printf("pmax(a,b) : %d \n", pmax(a, b));
```

`pmax` 는 이제 `max` 함수를 가리키므로 `pmax` 를 통해 `max` 함수가 할 수 있었던 모든 작업들을 할 수 있게 됩니다. 이때도 역시 그냥 `pmax` 를 `max` 처럼 이용하면 됩니다. 이는 배열에서

```cpp-formatted
int arr[3];
int *p = arr;

arr[2];  // p[2] 와 정확히 일치
p[2];
```

와 같이 `arr[2]` 와 `p[2]` 가 동일한 것과 같습니다. 아무튼 `max(a,b)` 를 하나 `pmax(a,b)` 를 하나 결과는 똑같이 나오게 됩니다.

```cpp-formatted
/* 함수 포인터 */
#include <stdio.h>

int max(int a, int b);
int donothing(int c, int k);
int main() {
  int a, b;
  int (*pfunc)(int, int);
  pfunc = max;

  scanf("%d %d", &a, &b);
  printf("max(a,b) : %d \n", max(a, b));
  printf("pfunc(a,b) : %d \n", pfunc(a, b));

  pfunc = donothing;

  printf("donothing(1,1) : %d \n", donothing(1, 1));
  printf("pfunc(1,1) : %d \n", pfunc(1, 1));
  return 0;
}
int max(int a, int b) {
  if (a > b)
    return a;
  else
    return b;

  return 0;
}
int donothing(int c, int k) { return 1; }
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1427D7224B3075AA319947)

일단, 우리는 이전의 예제와 동일한 형태의 함수 포인터 `pfunc` 을 정의하였습니다.

```cpp-formatted
int (*pfunc)(int, int);
```

이는 '리턴형이 `int` 이고 두 개의 인자 각각의 포인터 형이 `int` 인 함수를 가리킵니다. 그런데, `donothing` 함수와 `max` 함수 모두 이 조건을 만족하고 있습니다. 즉, 이들은 인자의 변수들도 다루고 하는 일도 다르지만 리턴값이 `int` 로 같고 두 개의 인자 모두 `int` 이므로 `pfunc` 이 이 두개의 함수를 가리킬 수 있는 것입니다.

```cpp-formatted
pfunc = max;

scanf("%d %d", &a, &b);
printf("max(a,b) : %d \n", max(a, b));
printf("pfunc(a,b) : %d \n", pfunc(a, b));

pfunc = donothing;

printf("donothing(1,1) : %d \n", donothing(1, 1));
printf("pfunc(1,1) : %d \n", pfunc(1, 1));
```

따라서, 위와 같이 했을 때 `pfunc` 이, 자기가 가리키는 함수의 역할을 제대로 하고 있다는 것을 알 수 있습니다. 그런데 말이죠. 함수 포인터를 만들 때, 인자의 형이 무엇인지 알기 힘든 경우가 종종 있습니다. 예를 들어 아래와 같은 함수의 원형을 봅시다.

```cpp-formatted
int increase(int (*arr)[3], int row)
```

흠... 두 번째 인자의 형은 `int` 라는 것은 알겠는데 첫번째 인자의 형은 도대체 뭘까요? 사실, 간단합니다. 특정한 타입의 인자를 판별하는 일은 단순히변수의 이름만을 빼버리면 됩니다. 따라서, 첫번째 인자의 형은 `int (*)[3]` 입니다. 즉, `increase` 함수를 가리키는 함수 포인터의 원형은 아래와 같습니다.

```cpp-formatted
int (*pfunc)(int (*)[3], int);
```

  간단하지요? 이것을 이전에 이차원 배열을 인자로 받았던 함수에 적용시켜 보면 정확히 작동한다는 것을 알 수 있습니다.

그럼, 이번 강좌는 여기에서 끝을 내도록 하겠습니다. 함수에 관한 강좌는 여기서 막을 내리게 됩니다. 사실, 아직까지도 C 언어를 배우면서 정말로 무언가 할 수 있는 실용적인 프로그램을 만들지 못해서 안타깝습니다. 그래서 이번에 생각해보기로 여러 재미있는 과제들을 내보도록 하죠.

### 생각해보기

#### 문제 1

사용자로 부터 5 명의 학생의 수학, 국어, 영어 점수를 입력 받아서 평균이 가장 높은 사람 부터 평균이 가장 낮은 사람까지 정렬되어 출력하도록 하세요. 특히, 평균을 기준으로 평균 이상인 사람 옆에는 '합격', 아닌 사람은 '불합격' 을 출력하게 해보세요 (난이도 : 中上).

#### 문제 2

유클리도 호제법을 이용해서 `N` 개의 수들의 최대공약수를 구하는 함수를 만들어보세요. 유클리드 호제법이 무엇인지 모르신다면, 인터넷 검색을 활용하는 것을 추천합니다. (댓글을 달아도 돼요) (난이도 : 中上)

#### 문제 3

자기 자신을 호출하는 함수를 이용해서 1 부터 특정한 수까지의 곱을 구하는 프로그램을 만들어보세요. (난이도 : 下)

#### 문제 4

계산기를 만들어보세요. 사용자가 1 을 누르면 +, 2 를 누르면 - 와 같은 방식으로 해서 만들면 됩니다. 물론 이전의 계산 결과는 계속 누적되어야 하고, 지우기 기능도 있어야 합니다. (물론 하나의 함수에 구현하는 것이 아니라 여러개의 함수로 분할해서 만들어야겠죠?)  (난이도 : 中)

#### 문제 5

`N` 진법에서 `M` 진법으로 변환하는 프로그램을 만들어보세요. (난이도 : 中)

#### 문제 6

에라토스테네스의 체를 이용해서 1 부터 `N` 까지의 소수를 구하는 프로그램을 만들어보세요. (난이도 : 中)

#### 문제 7

1000 자리의 수들의 덧셈, 뺄셈, 곱셈, 나눗셈을 수행하는 프로그램을 만들어보세요. 나눗셈의 경우 소수 부분을 잘라버리세요. 물론, 소수 부도 1000 자리로 구현해도 됩니다. 1000 자리 수들의 연산 수행 시간은 1 초 미만이여야 합니다. (난이도 : 上)

##@ chewing-c-end
Link :  27
2009-12-19 14:03
----------------
title : 씹어먹는 C 언어 - <13 - 2. 마술 상자 함수 2 (function)>
cat_title : 13 - 2. 마술 상자 함수 2 (function)
next_page : 28
publish_date : 2009-12-19 14:03
--------------


이번 강좌에서는

* 포인터로 받는 인자

* 함수의 원형

* 배열을 인자로 받기

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분. 이전에 함수에 대해선 잘 이해하셨는지요? 그리고, 마지막에 던진 의미 심장한(?) 질문에는 답을 구하셨나요? 우리는 이전 12 강에서 포인터에 대해서 다루어왔습니다. 그 때 동안 늘 머리속에 맴돌았던 생각은 "도대체 이거 어따가 써먹는거야?" 였죠. 하지만, 이번 강좌에서 그 질문에 대한 해답을 찾을 수 있기 바랍니다.

일단, 간단히 이전에 포인터에 대해서 배웠던 내용을 리뷰 하자면

포인터는 특정한 변수의 메모리 상의 주소값을 저장하는 변수로, `int` 형 변수의 주소값을 저장하면 `int*, char` 이면 `char*` 형태로 선언된다. 또한 `*` 단항 연산자를 이용하여, 자신이 가리키는 변수를 지칭할 수 있으며 `&` 연산자를 이용하여 특정한 변수의 주소값을 알아낼 수 있다.

만일 위 내용중에 한 마디라도 이해가 안되는 부분이 있다면 [12 강 포인터 강좌](http://itguru.tistory.com/23)를 다시 읽어 보시기를 강력하게 권합니다. 그렇지 않다면 아래의 내용을 계속 읽어가도록 하죠. 우리는 지난 강좌에서 다음과 같이 단순한 형태로는 다른 함수에서 정의된 변수의 값을 바꿀 수 없다고 했습니다.

```cpp-formatted
/* 이상한 짓 */
#include <stdio.h>
int change_val(int i) {
  i = 3;
  return 0;
}
int main() {
  int i = 0;

  printf("호출 이전 i 의 값 : %d \n", i);
  change_val(i);
  printf("호출 이후 i 의 값 : %d \n", i);

  return 0;
}
```


왜 `main` 함수 안에서 정의된 `i` 의 값이 바뀌지 않는지는 잘 아시겠지만 그래도 한 번 확인해봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F17797D264B2784B213E5BE)

`i` 의 값이 전혀 바뀌지 않았음을 알 수 있습니다. 그 이유는 함수 `change_val` 을 호출 할 때, `change_val` 함수 안에서 정의된 변수 `i` 는 `main` 함수의 `i` 의 값을 전달 받은 후에, `change_val` 함수 안에서 정의된 변수 `i` 의 값을 3 으로 변경하게 됩니다. 여기서 중요한 점은 'main 함수의 `i` 가 아닌 `change_val` 함수 안에서 정의된 변수 `i` 의 값이 3 으로 변경' 된다는 것이지요. 결론적으로 `main` 함수의 `i` 의 값에는 아무런 영향도 미치지 못하고 위와 같은 현상이 벌어지는 것입니다.

위 과정을 그림으로 표현하면 아래와 같습니다.


![main 에서 int i 를 정의하였다. 이제 change_val 을 호출하면 chagne_val 자체의 int i 로 i 의 값이 전달 된다. 이제, change_val 의 i 의 값을 3 으로 변경한다. 물론 main 의 i 와는 다른 변수 이기 때문에 return 후 다시 main 에서 i 의 값을 확인하면 그대로 0 이다.](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1101E7024B2787A13420C3)

하지만, 여러분은 지난 3 개의 강좌를 통해 포인터에 대해 귀가 아플 만큼 들어 보았을 것입니다. 그리고, 여기에서 그 아이디어를 적극적으로 활용하고자 합니다. 이전의 방법을 통해서 다른 함수에 정의된 변수들의 값을 변경할 때 직면했던 문제는 바로 각 함수는 다른 함수의 변수들에 대해 아는 것이 아무것도 없다는 것이였습니다. 즉 `A` 라는 함수에서 `i` 라는 변수를 이용한다면 컴파일러는 이 변수 `i` 가 오직 `A` 함수에서만 정의되었다고 생각하지 다른 함수에서 정의되었는지는 상관하지 않다는 것입니다.

그렇지만 궁여지책으로 유일하게 가능했던 것은 인자를 이용해서 다른 함수에 정의된 변수들의 '값' 을 전달하는 것이였습니다. 하지만 그렇게 해도 여전히 불가능해 보였습니다.

```cpp-formatted
/* 드디어 써먹는 포인터 */
#include <stdio.h>
int change_val(int *pi) {
  printf("----- chage_val 함수 안에서 -----\n");
  printf("pi 의 값 : %d \n", pi);
  printf("pi 가 가리키는 것의 값 : %d \n", *pi);

  *pi = 3;

  printf("----- change_val 함수 끝~~ -----\n");
  return 0;
}
int main() {
  int i = 0;

  printf("i 변수의 주소값 : %d \n", &i);
  printf("호출 이전 i 의 값 : %d \n", i);
  change_val(&i);
  printf("호출 이후 i 의 값 : %d \n", i);

  return 0;
}
```


  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1811EC054B278ADA18779C)

여러분의 출력결과와 다를 수 있습니다.

헉! 눈으로 보고도 믿기지 않으십니까? 호출 이후의 `i` 의 값이 0 에서 3 으로 바뀌었습니다~~ 이게 무슨일 입니까? 이건 우리가 여태까지 꼭 하고야 말겠던 바로 그 작업 아닙니까. 바로 다른 함수에서 정의된 변수의 값을 바꾸는 것 말이죠. 그런데, 위 코드를 조금씩 뜯어 들여보다 보면 방법은 매우 간단하다는 것을 알 수 있습니다. 물론, 이 강의를 보고 계시는 일부 똑똑한 독자들은 이미 짐작 했을 것이지만요.

```cpp-formatted
int change_val(int *pi)
```


일단, 함수의 정의부분을 살펴보자면 `int` 형의 변수를 가리키는 `pi` 라는 이름의 포인터로 인자를 받고 있습니다. 그리고 `main` 함수에서 이 함수를 어떻게 호출했는지 보면

```cpp-formatted
change_val(&i);
```

즉, 인자에 `main` 함수에서 정의된 `i` 라는 변수의 '주소값' 을 인자로 전달하고 있습니다. 따라서  `change_val` 함수를 호출하였을 때 `pi` 에는 `i` 의 주소값이 들어가게 됩니다. 즉, `pi` 는 `i` 를 가리키게 됩니다.

```cpp-formatted
{
  printf("----- chage_val 함수 안에서 -----\n");
  printf("pi 의 값 : %d \n", pi);
  printf("pi 가 가리키는 것의 값 : %d \n", *pi);

  *pi = 3;

  printf("----- change_val 함수 끝~~ -----\n");
  return 0;
}
```

`pi` 가 `i` 의 주소값을 가지고 있으므로 `pi` 를 출력했을 때 그 값은 `i` 의 주소값과 같을 수 밖에 없습니다. 이는 두 번째 `printf` 문장에서 확인할 수 있습니다. 또한 그 아래 `*pi` 를 통해서 `i` 를 간접적으로 접근할 수 있습니다. 왜냐하면 `*` 라는 단항 연산자의 의미가 '내가 가지는 주소값에 해당하는 변수를 의미해라' 이기 때문에 `*pi` 는 `pi` 가 가리키고 있는 변수인 `i` 를 의미할 수 있게 됩니다. 즉, `pi` 를 통해서 굳게 떨어져 있던 `main` 과 `change_val` 함수의 세계 사이에 다리가 놓이게 되는 것이지요.

간혹 `pi` 가 `main` 함수에서 정의된 것이라고 착각하는 분들이 있는데, `pi` 역시 `change_val` 함수 내에서 정의된 변수 입니다.

또한 `*pi = 3` 을 통해 'pi 가 가리키고 있는 변수' 의 값을 3 으로 변경할 수 있습니다. 여기서 `pi` 가 `i` 를 가리키므로 `i` 의 값을 3 으로 변경할 수 있겠네요. 따라서,

```cpp-formatted
printf("호출 이후 i 의 값 : %d \n", i);
```

에는 `i` 의 값이 성공적으로 변경되어 3 이 출력되는 것입니다. 위 과정을 그림으로 나타내면 아래와 같습니다.


![main 함수에 변수 i 가 있다. change_val 에 i 의 주소값을 전달한다. change_val 은 포인터 pi 에 전달 받은 i 의 주소값이 들어가 있다. 이제, pi 가 가리키는 것의 값을 3 으로 바꾸면, pi 가 가리키는 것이 main 의 변수 i 였으므로 실제로 return 후 확인해 보면 main 의 변수 i 의 값이 바뀐다.](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1836411A4B279039965794)

```cpp-formatted
/* 두 변수의 값을 교환하는 함수 */
#include <stdio.h>
int swap(int a, int b) {
  int temp = a;

  a = b;
  b = temp;

  return 0;
}
int main() {
  int i, j;

  i = 3;
  j = 5;

  printf("SWAP 이전 : i : %d, j : %d \n", i, j);

  swap(i, j);  // swap 함수 호출~~

  printf("SWAP 이후 : i : %d, j : %d \n", i, j);

  return 0;
}
```

  성공적으로 컴파일 했으면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1155830F4B2791D864F629)

흠. 일단 우리가 원하던 결과가 나오지 않았습니다. 소스 상단의 주석에서도 볼 수 있듯이 `swap` 함수는 두 변수의 값을 교환해 주는 함수 입니다. 우리가 원하던 것은 `SWAP` 이후에  `i` 에는 5 가 `j` 에는 3 이 들어 있는 것인데 전혀 바뀌지 않았습니다. 이에 대해 이야기 하기 전에 소스 코드에서 보이는 새로운 것들에 대해 이야기 해봅시다.

```cpp-formatted
int swap(int a, int b)
```

`swap` 함수의 정의를 보면 직관적으로 인자가 2 개나 있다는 것을 알 수 있습니다. 맞습니다. 이 `swap` 함수는 호출시 2 개의 인자를 전달해주어야 합니다. 물론 인자가 더 늘어난다면 반점(,) 을 이용해서 계속 늘려나가면 됩니다. 예를 들어서

```cpp-formatted
int this_function_has_many_argumenets(int a, char b, int* k, long d, double c,
                                      int aa, char bb, int* kk, double cc)
```

  와 같이요. 아무튼, `swap` 함수를 살펴 보면

```cpp-formatted
int swap(int a, int b) {
  int temp = a;

  a = b;
  b = temp;

  return 0;
}
```

로 두 개의 `int` 형 인자를 받아 들이고 있습니다. 이 때, 내부를 보면 `temp` 라는 변수에 `a` 의 값을 저장합니다. 그리고 변수 `a` 에 변수 `b` 의 값을 넣습니다. 이제, 변수 `b` 에 `a` 의 값을 넣어야 하는데, 현재 변수 `a` 에는 `b` 의 값이 이미 들어가 있으므로 이전에 저장하였던 `a` 의 값인 `temp` 변수의 값을 `b` 에 넣으면 됩니다. 일단, 내용상으로는 전혀 하자가 없어 보입니다.

```cpp-formatted
printf("SWAP 이전 : i : %d, j : %d \n", i, j);

swap(i, j);  // swap 함수 호출~~

printf("SWAP 이후 : i : %d, j : %d \n", i, j);
```

그런데, 말이죠. `main` 함수에서 `i,j` 의 값을 바꾸려고 `swap` 함수를 호출하였더니 전혀 뒤바뀌지 않은 채로 출력되었습니다. 도대체 왜 그런가요? 물론, 여러분은 다 알고 있겠지요. `swap` 함수의 변수 `a,b` 가 모두 `swap` 함수 내부에서 선언된 변수들이란 것입니다. 다시말해 변수 `a` 와 `b` 는 `i` 와 `j` 와 어떠한 연관도 없습니다. 다만, `a` 와 `b` 의 초기값이 `i, j` 와 동일하였다는 것만 빼고요.

이는 마치 아래의 작업을 한 것과 같습니다.

```info
    int i, j;
    int temp, a, b;
    /* 함수를 호출하여 함수의 인자를 전달하는 부분 */
    a = i;
    b = j;
    /* 함수 몸체의 내용을 실행 */
    temp = a;
    a = b;
    b = temp;
```

그러니 `i` 나 `j` 의 값이 바뀔리 만무하죠. 아무튼, 위 함수가 호출되는 과정을 그림으로 표현하면 아래와 같습니다.


![main 에서 int i,j 를 정의하며 swap 에 넣으면 swap 의 int a,b 는 각각 swap 내의 변수들 이므로, swap 내에서 아무리 a,b 를 바꿔보았자 main 의 i,j 는 바꾸지 않는다. 결국 역시 포인터를 이용해야 한다.](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1358AE044B28794034405F)

  그렇다면 어떻게 해야 할까요? 다 알고 있겠죠? 포인터를 이용합시다~~

```cpp-formatted
/* 올바른 swap 함수 */
#include <stdio.h>
int swap(int *a, int *b) {
  int temp = *a;

  *a = *b;
  *b = temp;

  return 0;
}
int main() {
  int i, j;

  i = 3;
  j = 5;

  printf("SWAP 이전 : i : %d, j : %d \n", i, j);

  swap(&i, &j);

  printf("SWAP 이후 : i : %d, j : %d \n", i, j);

  return 0;
}
```

  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F181E71014B2879A8A8E568)

오오오.. 드디어 우리가 원하던 것이 이루어졌습니다. 바로 `i` 와 `j` 의 값이 서로 뒤바뀐(swap) 것이지요. 아.. 정말 기쁩니다. 그런데, 이전에 이야기 하였던 내용을 잘 숙지하였더라면 위 함수가 왜 제대로 호출하는지 쉽게 알 수 있습니다.

```cpp-formatted
int swap(int *a, int *b) {
  int temp = *a;

  *a = *b;
  *b = temp;

  return 0;
}
```

먼저 `swap` 함수를 살펴 봅시다. 이는 `int` 형을 가리키는 포인터 변수를 인자로 가지고 있습니다. 일단, `swap` 함수 내에서 두 변수를 교환하는 과정은 위와 동일하니 이에 대해서는 이야기 하지 않도록 하겠습니다. 이 때, `main` 함수에서는 `swap` 함수를 아래와 같이 호출합니다.

```cpp-formatted
printf("SWAP 이전 : i : %d, j : %d \n", i, j);

swap(&i, &j);  // 호출

printf("SWAP 이후 : i : %d, j : %d \n", i, j);
```

바로 `a` 와 `b` 에 `i` 와 `j` 의 주소값을 전달하여 `a` 와 `b` 로 하여금 `i` 와 `j` 를 가리키게 만든 것입니다. 따라서, `swap` 함수 내부에서는 `a` 와 `b` 의 값을 교환하는 것이 아니라 `a` 와 `b` 가 가리키는 두 변수의 값을 교환했으므로 `(*a, *b)` 결과적으로 `i` 와 `j` 의 값이 바뀌게 된 것입니다. 어때요, 간단하지요?

  결론적으로 정리하자면

```warning
어떠한 함수가 특정한 타입의 변수/배열의 값을 바꾸려면 함수의 인자는 반드시 그 타입을 가리키는 포인터를 이용해야 한다!
```

포인터를 인자로 받은 함수에 대해선 지속적으로 이야기 할 것이므로 지금 막상 이해가 잘 안된다고 해도 큰 걱정할 필요는 없습니다.



###  함수의 원형

우리가 여태까지 사용하였던 함수들은 모두 `main` 함수 위에서 정의되고 있었습니다. 그러면, 그 정의를 `main` 함수 아래에서 한다면 어떻게 될까요? 사실, 대부분의 사람들의 경우 `main` 함수를 제일 위에 놓고 나머지 함수들은 `main` 함수 뒤에 정의하게 됩니다. 아무튼, 위의 코드를 살짝 바꿔보면 아래와 같습니다.

```cpp-formatted
/* 될까? */
#include <stdio.h>
int main() {
  int i, j;
  i = 3;
  j = 5;
  printf("SWAP 이전 : i : %d, j : %d \n", i, j);
  swap(&i, &j);
  printf("SWAP 이후 : i : %d, j : %d \n", i, j);

  return 0;
}
int swap(int *a, int *b) {
  int temp = *a;

  *a = *b;
  *b = temp;

  return 0;
}
```

  컴파일 하게 되면 아래와 같은 경고 창을 볼 수 있습니다.

```warning
warning C4013: 'swap'이(가) 정의되지 않았습니다. extern은 int형을 반환하는 것으로 간주합니다.
```

  흠, 일단은 무시하고 실행해 보도록 하죠.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F193957054B28F5AA356F43)

어랏, 잘만 됩니다. 그렇다면 아무런 문제가 없는 것일까요? 사실, 함수를 적절히 잘 이용하기만 하면 큰 문제는 발생하지 않습니다. 그런데 말이죠. 사람도 역시 사람인지라, 프로그래밍 하다가 실수로 인자의 개수를 부족하게 쓰거나, 올바르지 않는 타입의 변수 (예를 들어 인자가 `int*` 인데, `int` 변수를 썼다든지) 를 사용하는 수가 발생하게 됩니다. 더군다나, 우리의 예제에서는 함수가 겨우 한 개 밖에 없었지만 실제 프로그래밍 시에는 수십개의 함수를 이용하기 때문이죠. 그렇다면, 여러분이 완벽한 인간이 아니라는 가정 하에 인자 하나를 누락시켜 봅시다.

위 코드의 함수 호출 부분을

```cpp-formatted
`swap(&i,` &j);
```

에서

```cpp-formatted
swap(&i);
```

로 변경해봅시다.

 컴파일 하면 여전히 위와 동일한 경고가 나오는데 특별히 내가 인자를 누락 했다는 말은 하지 않습니다. 그리고, 실행해보면


![오류!!](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F2058CD244B28F6B3757FDA)

  허걱! 컴파일시 아무런 오류 메세지도 없었는데 실행해 보면 위와 같이 덜컹 오류가 나타납니다. 이런 해괴한 일이 아닐 수 없군요. 게다가, 컴파일러는 내가 인자를 어디서 인자를 누락했는지 조차 표시해주지 않기 때문에 오류를 찾기 힘들어 질 수 밖에 없습니다. 물론, 우리의 예제는 짧기 때문에 찾기 쉽지만 진짜 같은 프로그램을 제작하면 코드가 보통 수천~수만 줄에 달한다는 것만을 기억하세요.

이번에는 `swap` 함수 호출 부분을 `swap(&i, j);` 로 변경해보세요.


![오류!!](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F11259D264B28F73D04A618)

뜨아아. 역시 이번에도 동일한 형태의 프로그램 오류가 컴파일시 오류 하나 없었는데도 불구하고 나타났습니다. 이 역시 포인터 전달 해야 되는데, 그냥 정수값을 전달해서 포인터 `b` 가 메모리의 올바르지 않은 공간에 접근하여 발생한 일입니다. 참으로 곤욕스러운 일이 아닐 수 없습니다. 우리가 아무리 대단하다고 해도 실수를 할 수 있는 법인데, 컴파일러는 이러한 실수를 하나도 잡아내지 못하고 있습니다.

그러나, 우리의 C 언어가 이를 용납할 수 있나요? C 언어에서는 멋진 해결책이 있습니다. 바로, 함수의 **원형(prototype)** 를 이용하는 것입니다.

```cpp-formatted
/* 함수의 원형 */
#include <stdio.h>
int swap(int *a, int *b);  // 이 것이 바로 함수의 원형
int main() {
  int i, j;
  i = 3;
  j = 5;
  printf("SWAP 이전 : i : %d, j : %d \n", i, j);
  swap(&i, &j);
  printf("SWAP 이후 : i : %d, j : %d \n", i, j);

  return 0;
}
int swap(int *a, int *b) {
  int temp = *a;

  *a = *b;
  *b = temp;

  return 0;
}
```

  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1450EB274B28F80D374EDF)

오, 역시 잘 출력됩니다. 이번에는 컴파일시 경고나 오류의 흔적 조차 찾아볼 수 없었습니다.

```cpp-formatted
#include <stdio.h>
int swap(int *a, int *b);  // 이것이 바로 함수의 원형
int main() {
  int i, j;
  i = 3;
  j = 5;
  // ... (생략)
```

소스 코드의 제일 윗부분을 보면 위와 같이 한 줄이 추가된 것을 볼 수 있습니다. 이는 바로 '함수의 원형' 이라 부르는 것입니다. 이는 사실 함수의 정의 부분을 한 번 더 써준 것 뿐입니다 (주의할 점은 함수의 원형에는 정의와는 달리 뒤에 ; 를 붙인 다는 것입니다). 그런데, 이 한줄이 컴파일러에게 다음과 같은 사실을 알려줍니다.

  "야, 이 소스코드에 이러 이러한 함수가 정의되어 있으니까 잘 살펴봐"

다시말해, 컴파일러에게 이 소스코드에 사용되는 함수에 대한 정보를 제공하는 것입니다. 다시 말해 실제 프로그램에는 전혀 반영되지 않는 정보지요. 그렇지만, 우리가 앞서 하였던 실수들을 하지 않도록 도와줍니다. 만일, 위와 같이 함수의 원형을 삽입한 상태에서 인자를 `&i` 하나로 지워 봅시다. 즉, `swap(&i, &j)` 를 `swap(&i);` 로 변경해봅시다.

  그럼 컴파일 시 아래와 같은 오류를 만나게 됩니다.

```warning
 error C2198: 'swap' : 호출에 매개 변수가 너무 적습니다.
```

와우! 우리가 앞서 함수의 원형을 집어 넣지 않았을 때 에는 인자(매개 변수)를 하나 줄여도 아무말 하지 않던 컴파일러가 원형을 삽입하고 나니 위와 같이 정확한 위치에 내가 어딜 잘못했는지 잡아냅니다. 이것이 가능한 이유가 바로 컴파일러에게 내가 무슨 무슨 함수를 이용할 것인지 함수의 원형을 통해 이야기 하였기 때문입니다. 내가, `int swap(int *a, int *b)` 라는 함수가 있다는 것을 원형을 이용해 알려주었기 때문에 컴파일러는 우리가 `swap` 함수를 사용하면 꼭 2 개의 인자를 이용한다는 사실을 알게 되어 내가 인자를 하나만 적었을 때 틀렸다고 알려 준 것입니다.

그렇다면 `swap(&i, &j)` 를 `swap(&i, j)` 로 바꿔보면 어떻게 될까요?

```warning
warning C4047: '함수' : 'int *'의 간접 참조 수준이 'int'과(와) 다릅니다.
warning C4024: 'swap' : 형식 및 실제 매개 변수 2의 형식이 서로 다릅니다.
```

실질적인 오류는 발생하지 않았지만 일단, 내가 잘못하였다는 것을 알려줍니다. 컴파일러는 역시 원형을 통해 두 번째 매개 변수의 타입이 무엇인지 알고 있기에 그냥 `int` 를 사용하면 함수의 두번째 매개변수와 내가 인자에 전달하는 변수의 형과 다르다는 사실을 알려 줍니다. 다만, 여기서 아까와 같이 오류가 출력되지 않는 이유는 `int*` 도 사실 `int` 형 데이터 이기 때문에 `j` 가 `(int *)` 로 캐스팅 되어 전달되므로, 아까와 같은 강한 오류 메세지는 출력되지 않습니다. 그러나, 여전히 프로그래머의 잘못을 지적하고 있습니다.

이러한 연유에서, 함수의 원형을 집어넣는 일은 여러분들이 '반드시' 하셔야 되는 일입니다. 물론, `main` 함수 위에 함수를 정의하면 상관 없지만 사실 `99.9%` 의 프로그래머들은 함수를 `main` 함수의 뒤에 정의하고 원형을 앞에 추가하는 것을 선호하니 여러분들도 트렌드를 따르시기 바랍니다.



###  배열을 인자로 받기

이번에는 배열을 인자로 받아 들이는 함수에 대해서 생각해봅시다. 이번 예제에서 우리가 만들게 된 함수는 바로, 배열을 인자로 받아서 그 배열의 각 원소의 값을 1 씩 증가시키는 함수 입니다.

```cpp-formatted
#include <stdio.h>

int add_number(int *parr);
int main() {
  int arr[3];
  int i;

  /* 사용자로 부터 3 개의 원소를 입력 받는다. */
  for (i = 0; i < 3; i++) {
    scanf("%d", &arr[i]);
  }

  add_number(arr);

  printf("배열의 각 원소 : %d, %d, %d", arr[0], arr[1], arr[2]);

  return 0;
}
int add_number(int *parr) {
  int i;
  for (i = 0; i < 3; i++) {
    parr[i]++;
  }
  return 0;
}
```

  성공적으로 컴파일 했으면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F143DB51F4B29C0FE38D124)

음, 역시 함수가 잘 작동하는 군요. 우리가 `10, 11, 15` 를 입력했을 때, 함수를 통해서 각 원소가 1 씩 증가하여 `11, 12, 16` 이 되었습니다. 일단, `add_number` 함수 부터 살펴 보도록 하죠.

```cpp-formatted
int add_number(int *parr)
```

우리가, 앞서 말한 내용에 따르면 '특정한 타입의 값을 변경하는 함수를 제작하려면, 반드시 그 타입을 가리키는 포인터를 인자로 가져야 한다' 라고 했습니다. 그렇다면, 우리가 `arr` 이라는 배열을 가리키는 포인터가 바로 `add_number` 의 인자로 와야 하는데, 우리가 `12 - 3` 강에서 배운 내용에 따르면 `int arr[3]` 와 같은 일차원 배열을 가리키는 포인터는 바로 `int*` 형이라 했습니다. (잘 모르겠다면 [여기를 눌러서 강의](http://itguru.tistory.com/25)를 다시 보시기 바랍니다)

따라서, `add_number(int *parr)` 이라 하면 `arr` 을 가리키도록 인자를 받을 수 있습니다. 함수를 호출 할 때 아래와 같이 하였습니다.

```cpp-formatted
add_number(arr);
```

그런데, 우리가 이전에 배운 바에 따르면 `arr` 은 배열의 시작 주소 값을 가지고 있다고 하였습니다. 즉, `arr = &arr[0]` 인 것이지요. 따라서, `parr` 에는 `arr` 배열의 시작 주소, 즉 배열 `arr` 을 가리키게 됩니다.

```cpp-formatted
{
  int i;
  for (i = 0; i < 3; i++) {
    parr[i]++;
  }
  return 0;
}
```

마지막으로 함수의 몸체를 살펴봅시다. `parr[i]` 를 통해 `parr` 이 가리키는 배열의 `(i + 1)` 번째 원소에 접근할 수 있습니다 (`arr[1]` 이 배열의 두 번째 원소 이므로). 따라서, `parr[i]++` 을 통해서 배열의 각 원소들의 크기를 모두 1 씩 증가시키게 됩니다. 사실, 위 함수가 어떻게 돌아가는지 잘 이해하기 위해서는 포인터와 배열에 대한 거의 완벽한 이해를 필요로 합니다. 만약 그러지 않는다면 모래사장에 빌딩 짓는 것처럼, C 언어에 대한 개념을 완전히 잊어버릴 수 있으니 모른 다면 꼭 뒤로 가기를 하여 복습을 하시기 바랍니다.

```cpp-formatted
/* 입력 받은 배열의 10 개의 원소들 중 최대값을 출력 */
#include <stdio.h>
/* max_number : 인자로 전달받은 크기 10 인 배열로 부터 최대값을 구하는 함수 */
int max_number(int *parr);
int main() {
  int arr[10];
  int i;

  /* 사용자로 부터 원소를 입력 받는다. */
  for (i = 0; i < 10; i++) {
    scanf("%d", &arr[i]);
  }

  printf("입력한 배열 중 가장 큰 수 : %d \n", max_number(arr));
  return 0;
}
int max_number(int *parr) {
  int i;
  int max = parr[0];

  for (i = 1; i < 10; i++) {
    if (parr[i] > max) {
      max = parr[i];
    }
  }

  return max;
}
```

  성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F141500234B29C0F0734344)

이번 예제는 사용자들로 부터 정수 10 개를 입력 받아서, 그 수들 중 가장 큰 수를 뽑아내는 프로그램 입니다. 먼저 `max_number` 함수 부터 살펴봅시다.

```cpp-formatted
int max_number(int *parr) {
  int i;
  int max = parr[0];

  for (i = 1; i < 10; i++) {
    if (parr[i] > max) {
      max = parr[i];
    }
  }

  return max;
}
```


음.. 일단, 소스 코드를 해석하는데에는 큰 어려움이 없을 것 같네요. 일단 처음 `max` 에 `parr` 이 가리키는 배열의 `[0],` 즉 첫번째 원소의 값을 넣었습니다. 그리고 아래 `for` 문에서 만약 `parr[i]` 가 `max` 보다 크면 `max` 의 값을 `parr[i]` 로 대체하고 있군요. 결과적으로 `i` 값이 9 까지 되었을 때에는 `max` 에 `parr` 중 가장 큰 원소의 값이 들어가게 됩니다. 만일, `max` 보다 더 큰 원소가 `parr` 에 있다면 `max` 의 값은 그 큰 원소의 값으로 바뀌었기 때문에 모순이지요.

  결과적으로 우리가 입력한 10 개의 원소들 중 가장 큰 원소가 출력됩니다.

###  함수 사용 연습하기


사실, 아직까지 함수가 왜 이리 중요한 것인지 감이 잘 오지 않는 분들이 있을 것입니다. 그래서, 그러하신 분들을 위해 함수의 중요성을 절실히 느낄 수 있는 예제를 준비하였습니다.

  다음의 두 소스 코드를 비교해 보면서 어떤 것이 나은지 생각해보세요

```cpp-formatted
/* 함수를 이용하지 않은 버전 */
#include <stdio.h>
int main() {
  char input;

  scanf("%c", &input);

  if (48 <= input && input <= 57) {
    printf("%c 는 숫자 입니다 \n", input);
  } else {
    printf("%c 는 숫자가 아닙니다 \n", input);
  }

  return 0;
}
```


```cpp-formatted
/* 함수를 이용한 버전 */
#include <stdio.h>
int isdigit(char c);  // c 가 숫자인지 아닌지 판별하는 함수
int main() {
  char input;

  scanf("%c", &input);

  if (isdigit(input)) {
    printf("%c 는 숫자 입니다 \n", input);
  } else {
    printf("%c 는 숫자가 아닙니다 \n", input);
  }

  return 0;
}
int isdigit(char c) {
  if (48 <= c && c <= 57) {
    return 1;
  } else
    return 0;
}
```

 일단, 첫번째 소스의 경우 길이가 짧습니다. 다만 이해하기가 힘듧니다.

```cpp-formatted
if (48 <= input && input <= 57) {
}
```

`printf` 문이 없다고 했을 때 위 코드가 `input` 이 숫자인지 아닌지 판별하는지 쉽게 구분이 가나요? 이는 특별히 주석을 넣지 않는 한 매우 어렵습니다. 사실, 숫자의 경우 아스키 코드의 값이 48 에서 57 이기 때문에 위 코드를 사용하였는데 아스키 코드표를 외우고 다니지 않는 한 이해하기 상당히 어렵습니다.

  그렇다면 함수를 이용한 버전을 살펴 봅시다.

```cpp-formatted
if (isdigit(input)) {
}
```

일단 `isdigit` 라는 이름만 보고도 이 함수는 `input` 이 숫자 인지 아닌지 (is digit? ) 판별하는 함수 임을 알 수 있습니다. 물론, `isdigit` 함수 내부에도 첫번째 소스와 동일한 과정이 진행되지만 이 함수가 무슨 작업을 하는지 알기 때문에 소스를 이해하기 훨씬 쉬워집니다. 뿐만 아니라, 어떠한 문자가 숫자인지 반복해서 확인하는 경우에도 함수를 이용하면 편히 사용할 수 있습니다.

  아직까지도 왜 함수를 써야 하는지 모르겠다고 해서 큰 문제는 아닙니다. 나중에 가면 자연스럽게 깨닫게 될 것입니다. 그럼, 이번 강의는 여기까지에서 줄이겠습니다.

### 생각 해보기

#### 문제 1

위 10 개의 원소들 중 최대값 구하는 함수를 이용하여, 10 개의 원소를 입력 받고 그 원소를 큰 순으로 출력하는 함수를 만들어보세요. (난이도 : 中)

#### 문제 1

2 차원 배열의 각 원소에 1 을 더하는 함수의 인자는 어떤 모양일까요? (난이도 : 中下 2 차원 배열의 각 원소에 1 을 더하는 함수의 인자는 어떤 모양일까요? (난이도 : 中下)

##@ chewing-c-end
Link :  26
2009-12-14 01:44
----------------
title : 씹어먹는 C 언어 - <13 - 1. 마술 상자 함수(function)>
cat_title : 13 - 1. 마술 상자 함수(function)
next_page : 27
publish_date : 2009-12-14 01:44
--------------


이번 강좌에서는

* 함수의 필요성

* 함수의 의미, 함수의 인자, 함수의 리턴값, 함수 내부에서 선언된 변수

* `main` 함수


![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분. 이 강좌를 읽고 있을 여러분은 포인터의 고지를 정복하고 온 위대한 전사(?) 들 입니다. 이제, 앞으로 다룰 내용은 C 언어에서 중요하면서도 쉬운 부분 이니 큰 부담 없이 편히 읽으시면 합니다. 또한, 앞에서 배운 포인터를 이제 본격적으로 활용하는 단계에 접어들기 때문에 혹여라도 잊은 것이 있는지 없는지 매일 한 번씩 다시 정독하시면 좋습니다. 또는, 다른 C 언어 강좌로 한 번 더 공부해 보세요. 다른 방식으로 공부하다 보면 이해가 더 잘될 수 도 있습니다.

  저는 제 강좌에서 여러분이 최소한 초등학교 4 학년 정도의 수학을 이수하셨다면 아래와 같은 문제를 본 기억이 어렴풋이나마 있을 것 입니다.


![이 상자는 들어간 값에 4 를 더한 게 튀어나온다. 36 을 집어넣으면 뭐가 튀어나올까요!! ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1141EB214B0E9494796F6B)

음.. 아래 물음표에서 어떤 값이 출력될까요? 아마, 여러분 대부분은 '40' 이라고 짐작하실 것입니다. 맞습니다. 40 입니다. 위 마술 상자는 입력 받은 값에 4 를 더해서 출력하는 상자 입니다. 만일 우리가 36 이 아니라 10 을 집어넣었다면 14 가 나왔을 것이지요.

수학에서 함수는 마술 상자와 비슷합니다. 특정한 값을 입력 받아, 이 값을 가지고 상자 내부에서 지지고 볶고 해서 결과를 내보낸 마술 상자 처럼, 수학에서는 특별한 값 `x` 를 입력 받아 지지고 볶은 뒤(유식한 말로 연산을 취하여)에 결과를 출력하는 것을 함수 라고 합니다. (참고적으로, 수학에서 보통 입력값은 `x`, 출력값은 `y` 라고 하니, 아래에선 아무런 이야기 없이 사용하도록 하겠습니다.)

수학에서 마술 상자를 글로 표현하기 조금 껄끄러우니 보통 다음의 표현을 사용합니다.


$$y = f(x)$$

이는, 'x 라는 값을 f 라는 마술 상자 (함수) 를 통과시켰더니 y 라는 값이 되었다' 라는 의미와 일맥 상통합니다. 위의 마술 상자의 경우 입력값에 4 를 더한 값을 반환하였습니다. 그렇다면, 위의 마술 상자는 아래와 같은 식으로 나타낼 수 있습니다.

$$f(x) = x + 4 $$

예를 들어 x 에 36 이 들어간다면 f(x) 의 값, 즉 y 의 값은 36 + 4 인 40 이 됩니다. 따라서, 40 이 출력된다는 사실을 볼 수 있습니다. 그렇다면, 아래의 예를 보고 어떠한 값이 출력되는지 맞추어 보세요.

$$f(x) = x^3 + 2x, f(x) = ? $$

$$g(x) = x^2 - 3x + 4, g(5) = ?$$

(이례적으로 답을 올리자면 f(3) = 33, g(5) = 14)

간혹 제 블로그를 방문하는 분들 중에는 초등학생인 분들이 있기에, 함수를 전혀 들어보지 못한 분들이 있을 까봐 짤막하게 함수에 대해 설명하였습니다. C 언어의 함수도 비슷한 개념으로 사용됩니다.



###  함수의 시작

우리가 프로그래밍을 하면서 여러가지 작업들을 반복적으로 해야되는 경우가 종종 있습니다. 예를 들어서 변수 `a` 와 `b` 중 최대값을 구하는 것을 생각해봅시다. 우리가 이를 프로그래밍 시에 필요로 하게 된다면 다음과 같이 해야 될 것입니다.

```cpp-formatted
int max;
if (a >= b) {
  max = a;
} else {
  max = b;
}
```

뭐, 위 코드는 아주 아주 쉬운 코드 이니 설명은 하지 않겠습니다. 그런데, 실제로 프로그래밍을 하다 보면 어떠한 두 변수의 최대값을 구하는 경우가 자주 생긴다는 것입니다. 현재 까지 배운 바로는 이러한 상황에서는 코드 복사 붙여넣기를 통해 소스를 채워나가면 된다고 생각했습니다. 자, 그렇다면 이러한 방법이 합리적인 것일까요?

만일 최대값을 구하는 것이 프로그램에서 100 번 정도 필요하다면 그 때 마다 위 코드를 복사해서 변수 이름만 살짝 바꿔주면 됩니다. 하지만, 소스가 얼마나 지저분해질까요? 소스가 수천줄이 넘어가면 위 코드가 무슨 작업을 하는지 눈에 팍 들어오기 힘듧니다.

그렇다면 여러분은 이렇게 생각해 볼 수 있습니다.

> "최대값을 출력하는 함수를 만들어버리자!!"


응? 도대체 위 말이 무슨뜻인감.. 아마도 여러분은 갈피를 잡기 힘들 것입니다. 하지만 이렇게 생각하면 편합니다. **아까 위에서 설명한 마술 상자 처럼 우리가 만들게 될 마술상자는 두 개의 값이 입력된다면 큰 놈을 출력하는 것이야!**

오오. 괜찮은 아이디어 아닌가요. 우리는 그 긴 코드(사실 그렇게 긴 것은 아니지만;;) 를 매번 쓰는 대신에 두 값을 입력받아서 큰 것을 출력하는 마술 상자 (함수) 를 제작하여, 최대값을 구하는 것이 필요할 때 마다 그 마술 상자에 두 변수를 넣어 버리면 되지 않습니까? 그러면 우리는 그 마술 상자가 뱉어내는 값을 받아 먹기만 하면 되는 것이니까요.

  자, 그럼 마술 상자를 만들어봅시다~

일단, 최대값을 구하는 함수를 만들어 보기 전에 아주 아주 간단한 함수를 먼저 만들어보겠습니다.

```cpp-formatted
#include <stdio.h>
/* 보통 C 언어에서, 좋은 함수의 이름은 그 함수가
무슨 작업을 하는지 명확히 하는 것이다. 수학에서는
f(x), g(x) 로 막 정하지만, C 언어에서는 그 함수가 하는
작업을 설명해주는 이름을 정하는 것이 좋다. */
int print_hello() {
  printf("Hello!! \n");
  return 0;
}
int main() {
  printf("함수를 불러보자 : ");
  print_hello();

  printf("또 부를까? ");
  print_hello();
  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F117326164B1283DAAA1E35)

  음.. 일단 우리가 여태까지 보아왔던 것과 매우 다른 모습입니다. 하지만 걱정하지 마세요. 금세 이해하게 될 것이니까요.

```cpp-formatted
int print_hello() {
  // 잠시 생략
}
```

일단, 함수의 **정의(definition)** 부분을 살펴 봅시다. 위와 같이 `int print_hello()` 라고 써 있는 부분을 함수의 '정의' 부분이라 부릅니다. 우리는 함수의 정의 부분에서 3 가지 사실을 알 수 있는데, 일단은 2 가지만 먼저 설명하고 나머지 하나는 아래에서 설명하겠습니다.

먼저, 우리에게 친근한 키워드가 하나 있습니다. 바로 `int !` 우리는 여태까지 `int` 를 변수나 배열을 정의하는데만 사용하였습니다. 그런데, `int` 가 놀랍게도 함수를 정의하는데도 사용되고 있습니다. 여기서의 `int` 는 다음과 같은 사실을 알려줍니다. '이 함수는 `int` 형의 정보를 반환한단다~'. 반환? 그렇다면 반환은 또 뭐야.

우리가 앞서, 마술 상자를 이야기 하였을 때, 우리가 36 을 마술 상자에 넣는다면, 4 를 더해서 40 을 출력한다고 하였습니다. 이 때, 우리는 '출력된다' 라는 사실을 함수에서는 '반환한다' 라고 이야기 합니다. 영어로는 `return` 이라고 하지요.

```cpp-formatted
int print_hello() {
  printf("Hello!! \n");
  return 0;
}
```

위 함수 정의 부분에서, 아래에서 두번째 줄에 `return 0;` 라고 써있는 부분을 볼 수 있습니다. 이 함수는 0 을 반환한다는 뜻이군요. 즉, 우리가 위와 같은 마술 상자를 이용한다면 언제나 0 이 출력됩니다. 이 때, 함수의 반환형이 `int` 이므로, 0 은 `int` 의 형태로 저장되어 나갑니다.

여기서 `int` 의 형태로 저장된다는 말의 의미는 0 이라는 데이터가 메모리 상의 4 바이트를 차지하여 반환된다는 뜻이지요. (통상적으로 정수를 반환하는 함수들은 모두 `int` 를 사용합니다. )

함수의 정의 부분에서 알 수 있는 두 번째 사실은 바로 함수의 이름 입니다. 대충 짐작이 가듯이, 위 함수의 이름은 `print_hello` 입니다. 끝에 붙는 `()` 는 함수의 이름에 포함되는 것이 아닙니다. 끝에 붙는 괄호 두 개는 이것이 함수라는 사실을 의미합니다. 만일 우리가 끝에 `()` 를 붙이지 않는다면 `int print_hello` 라는 문장은 단순히 끝에 `;` 를 제대로 붙이지 않았구나 라고 해석되어 오류를 출력하게 됩니다. 꼭 `()` 를 붙여주세요~

주석에서도 잘 설명 하였듯이 좋은 함수 이름의 조건은 함수가 무슨 일을 하는지에 대해서 잘 설명하는 것 입니다. 만일 우리가 함수를 `int asdfasd()` 라고 만들었다면 우리가 `asdfasd` 라는 함수를 보고 무슨 일을 하는지 잘 알 수 없습니다.

하지만 우리의 예제 처럼 `print_hello` 라고 하게 된다면 이 함수가 대략 'hello 를 출력하는구나' 라는 사실을 알 수 있겠지요. 다만, 함수의 이름이 너무 길어지면 함수를 사용시 너무 불편하므로 20 자가 넘어가게 하지는 맙시다. 또한, 함수의 이름 역시 변수의 이름 조건과 동일하므로 기억나지 않는 분들은 [3강 변수가 뭐지?](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-3-%EB%B3%80%EC%88%98%EA%B0%80-%EB%AD%90%EC%A7%80) 의 맨 마지막 부분을 보세요.

```cpp-formatted
int print_hello() {
  printf("Hello!! \n");
  return 0;
}
```

함수의 정의부분은 그만 살펴보고, 이제 함수가 무슨 일을 하는지 알 수 있는 부분을 살펴 봅시다. 이 부분은 보통 함수의 **몸체(body)** 라고 부릅니다. 이번 예제 함수의 몸체는 설명을 안해도 잘 알 수 있습니다. 이 함수는 `printf("Hello!! \n");` 을 실행한 후, 0 을 반환한다 이지요?

```cpp-formatted
printf("함수를 불러보자 : ");
print_hello();

printf("또 부를까? ");
print_hello();
```

마지막으로 실제로 함수를 호출하는 부분을 살펴 봅시다. 함수를 불러내는 방법(보통 **호출한다(call)** 라는 표현을 사용하므로 앞으로 호출한다고 표현하겠습니다) 은 단순히 함수의 이름을 써주시기만 하면 됩니다. 물론 그 뒤에 `()` 도 붙여주어야 겠지요.

다시 말하지만 `()` 는 함수의 이름에 포함되는 것이 아닙니다. 하지만, `()` 를 써줌으로써 컴파일러에게 '내가 지금 쓴 것이 함수 이니라~' 라는 사실을 말해주게 되는 것이지요. 만일 함수를 호출한답시고 `print_hello;` 라고 쓴다면 컴파일러는 '어딘가에 `print_hello` 라는 변수에 접근하였네' 라고 생각하는데, `print_hello` 라는 변수가 없으므로 오류를 출력하게 됩니다.

함수를 호출하면 프로그램은 함수의 내용을 실행하게 됩니다. 그리고 다시, 원래 실행되려는 부분으로 돌아오게 되죠. 위의 경우, "함수를 불러보자" 가 출력된 후 `print_hello()` 를 통해 함수를 호출하였습니다. 그러면 프로그램은 `print_hello()` 라는 함수로 넘어가서, 이 함수의 내용을 다 실행한 뒤에 다시 원래 있던 곳으로 돌아와 넘어가게 됩니다.

이와 같은 현상은 실생활에서도 볼 수 있습니다. 밥을 먹고 있다가 '엄마가 부르신다' 라는 함수가 호출되면 엄마한테로 달려갑니다. 그리고 '엄마가 부르신다' 라는 함수가 종료되면 다시 밥 먹던 식탁으로 와서 밥을 먹게 되지요. 이 때, 함수의 종료는 두 가지 형태로 있을 수 있습니다. 하나는 반환이 되어 종료를 하게 되는 것이고 다른 하나는 함수의 끝 부분 까지 실행하여 종료되는 것입니다. 함수는 반환을 하여 종료되는 것이 안전합니다. 한 가지 중요한 사실은 `return` 을 실행하면 함수는 무조건 종료되어 함수를 호출하였던 부분을 돌아간다는 점입니다.

```cpp-formatted
/* 함수의 리턴 */
#include <stdio.h>
int return_func() {
  printf("난 실행된다 \n");
  return 0;
  printf("난 안돼 ㅠㅠ \n");
}
int main() {
  return_func();
  return 0;
}
```

  성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F134FA80D4B128A726B8DF9)

  물론 앞에서 이야기 하였듯이 짐작은 하고 있으셨겠지만 확실히 보여드리기 위해 예제를 작성하였습니다.

```cpp-formatted
int return_func()
```

연습 삼아 위 부분이 무슨 의미인지 다시 한 번 살펴봅시다. 일단, `int` 를 보아 이 함수는 `int` 형을 리턴한다는 의미이고, `return_func` 을 보아서 이 함수의 이름이 `return_func` 라는 사실을 알 수 있습니다.

```cpp-formatted
{
  printf("난 실행된다 \n");
  return 0;
  printf("난 안돼 ㅠㅠ \n");
}
```

다음은 함수의 몸체 입니다. 앞에서 이야기 하였듯이 `return` 이 실행되면 프로그램은 바로 함수를 호출하였던 부분으로 넘어가 버려 그 다음에 오는 모든 것들(위 예제에선 `printf("난 안돼 ㅠㅠ \n");`) 이 실행되지 않게 됩니다.

이와 같은 현상도 실생활에서 찾아 볼 수 있습니다 :) 늘 컴퓨터 게임만 하는 아이가 있습니다. 그는 24 시간 컴퓨터 게임만 합니다. 이를 도저히 참지 못한 엄마는 '공부하기' 라는 함수를 만들었습니다. 엄마가 '공부하기' 함수를 호출하였더니 (놀랍게도) 이 아이는 공부하기 함수의 내용을 실행합니다.

공부하기 함수에는 'C 언어 공부하기', '숙제하기' 등등의 작업들이 있었는데, 공교롭게도 엄마가 실수로 'C 언어 공부하기' 와 '숙제하기' 사이에 '공부 끝' 이라는 `return` 문장을 집어 넣은 것입니다! 결과적으로 이 아이는 C 언어 공부하기를 다 실행하자 마자, '공부 끝' 이 실행되어 (함수의 `return`) 결국 원 상태로 돌아가 다시 컴퓨터 게임을 하기 시작하였습니다.

```cpp-formatted
/* 반환값 */
#include <stdio.h>
int ret() { return 1000; }
int main() {
  int a = ret();
  printf("ret() 함수의 반환값 : %d \n", a);

  return 0;
}
```

  성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F1118BF0D4B24FD913D5281)

  마지막으로 한 번더, 함수의 정의 부분을 분석해봅시다.

```cpp-formatted
int ret()
```

아마 이쯤 되면 여러분은 위 것만 보고도 이 함수는 이름이 `ret` 이고, `int` 형을 반환한다 라는 사실을 알 수 있을 것 입니다.

그리고 `ret` 함수의 몸체를 살펴 보자면 상당히 간단하다라는 것을 알 수 있습니다.

```cpp-formatted
{ return 1000; }
```

  그리고 위 코드는 "이 함수를 호출하면 1000 을 리턴한다" 정도 되겠지요.

```cpp-formatted
int main() {
  int a = ret();
  printf("ret() 함수의 반환값 : %d \n", a);

  return 0;
}
```

위는 `ret()` 함수를 호출하여 그 값을 `a` 에 대입하는 문장 입니다. 그런데 `ret()` 가 가지는 값이 있나요? 물론, `ret()` 는 함수이기 때문에 위와 같이 이용하면 안될것 같습니다만, `ret()` 를 코드에 쓰게 된다면 이 말은 "`ret()` 함수의 반환값" 라는 의미를 가집게 됩니다. 즉, 컴퓨터가 위 코드를 실행한다면 `a` 에는 `ret` 함수의 반환값인 1000 이라는 값이 들어가게 됩니다.

  아무튼 아래의 유명한 격언을 기억하시기 바랍니다.

> 호랑이는 죽어서 가죽을 남기고, 함수는 죽어서 리턴값을 남긴다!


###  메인(main) 함수

아마 꼼꼼하신 여러분들은 이미 `int main()` 이란 부분도 `main` 이라는 함수를 정의하고 있다는 사실을 눈치 채고 있을 것입니다. 맞습니다. 여러분은 `main` 이라는 이름의 함수를 정의하고 있는 것이였습니다. 그런데 왜 하필이면 `main` 일까요?

왜냐하면 프로그램을 실행할 때 컴퓨터가 `main` 함수 부터 찾기 때문입니다 (물론 모든 경우가 그런 것은 아니고 적어도 우리가 앞으로 만들게 될 C 프로그램들의 경우). 즉, 컴퓨터는 프로그램을 실행할 때 프로그램의 `main` 함수를 호출함으로써 시작합니다. 만일 `main` 함수가 없다면 컴퓨터는 프로그램의 어디서 부터 실행할 지 모르게 되어 오류가 나게 되죠.

  보통 메인 함수를 아래와 같은 형태로 정의합니다.

```cpp-formatted
int main()
```

위에서 배운 내용을 살짝 활용하면 "이 함수는 리턴형이 `int` 이고 이름은 `main` 이네!" 정도 알 수 있겠지요. 그런데, 메인 함수가 리턴을 하면 누가 받을까요? 메인 함수가 프로그램 맨 처음에 실행되는 함수라면, 맨 마지막으로 종료되는 함수도 메인 함수 이기 때문에 리턴값을 받을 수 있는 함수가 없을 듯 합니다.

사실, 그렇지 않습니다. 메인 함수가 리턴하는 데이터는 바로 운영체제가 받아들입니다. 운영체제. 즉 여러분이 아마도 쓰고 계실 Windows XP 나 Linux 에서 받는 다는 이야기 이지요. \sidenote{이 강좌는 2009 년에 나왔습니다.} 보통 메인 함수가 정상적으로 종료되면 0 을 리턴하고, 비정상적으로 종료되면 1 을 리턴한다고 규정되어 있습니다. 우리가 여태까지 만들어왔던 모든 메인 함수들은 정상적으로 종료되므로 마지막에 0 을 리턴하였죠. 사실, 1 을 리턴한다고 해서 큰 문제는 없습니다. 이 정보를 활용하는 경우는 매우 드물기 때문이죠.

  아무튼, 여기서 알아야 할 사실은 "`main` 도 함수다!" 정도만 알아 두셨으면 합니다.


이번에는 맨 위에서 구상하였던 마술 상자 ( 4 를 더한값을 출력하는..) 를 제작해보기로 하였습니다. 일단 여러분은 아래와 같이 구현할 수 있지 않을까 라는 것을 머리속에 떠올릴 것입니다.

```cpp-formatted
/* 마술 상자 */
#include <stdio.h>
int magicbox() {
  i += 4;
  return 0;
}
int main() {
  int i;
  printf("마술 상자에 집어넣을 값 : ");
  scanf("%d", &i);

  magicbox();
  printf("마술 상자를 지나면 : %d \n", i);
  return 0;
}
```

  컴파일 하면 아래와 같이 달콤한 오류를 볼 수 있습니다.

```warning
error C2065: 'i' : 선언되지 않은 식별자입니다.
```

아니, 왜? 이런 오류가 뜨는 것이지.. 분명히 우리는 `main` 함수 내에서 `i` 라는 이름의 `int` 형 변수를 선언하였고 다른 함수(여기선 `magicbox`) 에서 사용할 수 있어야 되는 것 아닌가요? 하지만 안타깝게도 아닙니다. 사실, 이 마술상자는 우리가 생각했던 것 보다도 훨씬 멋진 개념입니다.

어떠한 함수를 호출할 때, 호출된 함수는 함수를 호출한 놈에 대해서 어떠한 것도 알고 있지 않습니다. 즉, 내가 `magicbox` 라는 함수를 호출하였을 때, 이 `magicbox` 는 내가 얘를 호출하였는지, 다른 애가 (즉, 다른 코드를 말하는 것이겠죠;;) 얘를 호출하였는지 '전혀 알 수 없다' 라는 것입니다.

```cpp-formatted
int magicbox() {
  i += 4;
  return 0;
}
```

따라서 이 함수는 `i` 라는 변수에 대해서 아무런 정보도 가지지 않고 있습니다. 왜냐하면 이 함수를 호출한 것이 무엇인지에 대한 정보가 하나도 없기 때문이죠. 결과적으로 `main` 함수에서 정의된 `i` 라는 변수는 `magicbox` 의 입장에서 본다면 듣도 보도 못한 것이 되는 것입니다. 결과적으로 위에서 보았던 오류와 같이 `i` 라는 변수가 선언되어있지 않다는 오류를 내게 됩니다.

  아직도 위 코드가 왜 작동이 되지 않는지 이해가 되지 않으신 분들은 아래의 옛날 이야기(?) 를 보시면 됩니다.

옛날 옛날 이집트 시대에 어떤 부유한 귀족이 있었습니다. 이 귀족은 하루에 10000 달러씩 장사를 해서 벌었습니다. 그런데 공교롭게도 수학을 매우매우 못했죠. 따라서, 이 귀족은 노예를 한 명 사서, 이 노예에게 자신의 현재 재산에 10000 을 더해서 알려 달라고 하였습니다. 그리고 시간이 흘러 10 시간 뒤, 귀족의 일과가 끝났습니다. 이제, 그는 오늘 자신의 재산 현황을 파악하기 위해서 노예를 호출했습니다.

"야 말해"

  그런데 노예는 아무 말도 하지 못했습니다.

"야 말하라고, 내 재산에 10000 을 더해서 말하라니까"

역시 아무말도 없었습니다. 왜일까요? 그야, 당연히 노예는 귀족의 재산에 대한 정보가 없었기 때문입니다. 귀족이 방금 노예를 호출함으로써 한 일은, "자신의 재산 `+= 10000`" 이였습니다. 그런데, '자신의 재산' 이란 변수는 노예의 머리에서 정의된 것이 아니므로 알 노릇이 없습니다.

그렇다면, 이제 아무 쓸모 없게된 불쌍한 노예를 악랄한 귀족이 죽이게 내버려 두어야 하나요? 물론, 그리하면 안되겠죠. 일단, 여기서 문제점을 해결하기 위해선 노예가 "현재 귀족의 재산" 이라는 데이터만 머리에 넣고 있으면 됩니다. (노예가 계산을 충분히 잘한다는 가정 하에..) 이 말을, C 언어 적으로 이야기 하면 노예라는 함수에 "주인의 현재 재산" 이라는 변수를 정의하고 이 변수에 "자신(주인)의 재산" 의 값을 넣은 뒤에, "주인의 현재 재산+=10000" 을 계산한 후, "주인의 현재 재산" 을 반환(입으로 말함) 하면 되는 것입니다.

  이제, 문제는 노예 머리속에 "주인의 현재 재산" 이라는 변수에 "자신(주인) 의 재산" 값을 어떻게 넣느냐가 문제 입니다. 바로 아래에서 보도록 하죠.



###  함수의 인자


```cpp-formatted
#include <stdio.h>
int slave(int master_money) {
  master_money += 10000;
  return master_money;
}
int main() {
  int my_money = 100000;
  printf("2009.12.12 재산 : $%d \n", slave(my_money));

  return 0;
}
```

  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1454C70F4B23AD6B37FD26)



  일단, 함수의 정의 부분이 바뀐 것을 볼 수 있습니다.

```cpp-formatted
int slave(int master_money)
```

`slave` 가 함수 임을 알려주는 소괄호 안에 `int master_money` 가 써 있군요. 이는 다음과 같은 의미를 가집니다.

"나를 호출하는 코드로 부터 어떤 값을 `mater_money` 라는 `int` 형 변수에 인자(혹은 매개변수라고도 부름)로 받아들이겠다!"

허걱.. 정말 뭔소린지 알 수 없군요. 먼저 '인자' 가 무엇인지 살펴 보도록 합시다. 아까 전에 우리는 노예의 머리속에 '현재 주인이 가지고 있는 재산' 이라는 값을 어떻게 입력해야 할지가 문제라고 하였습니다. 그런데, `slave` 함수와 `main` 함수는 전혀 별개의 함수 이기 때문에 `slave` 함수는 `main` 함수 안의 변수를 사용할 수 없을 뿐더러 `main` 함수에서도 `slave` 함수의 변수들이 무엇인지 전혀 알 길이 없습니다.

하지만, **인자(argument, 혹은 매개변수(parameter) 라고 부른다)** 를 이용하면 이러한 일을 가능하게 합니다. 일단, 인자는 직관적으로 봐도 알 수 있듯이 `slave` 함수 내에 선언이 되어 있는 변수 입니다. 이 때, 인자는 함수 정의할 때의 소괄호 안에 나타나게 되죠. 위의 경우 `slave` 함수는 `int` 형의 `master_money` 라는 변수를 인자로 가지고 있습니다. 이제, 이 함수를 어떠한 함수에서 호출을 한다고 합시다. 그렇다면, 이 함수를 호출 할 때, 인자에 적당한 값을 넣어 주어야 합니다. 마치 아래와 같이요.

```cpp-formatted
slave(500);
```

이 말은 "`slave` 함수를 호출할 때, `slave` 함수 안에서 정의된 `master_money` 라는 변수에 500 이라는값을 전달하겠다!" 라는 의미가 되겠지요.따라서, `slave` 함수 내부에 정의된 `master_money` 라는 변수에는 500 이라는 값이 들어가게 됩니다. 그렇다면 아래는 어떨까요?

```cpp-formatted
slave(my_money);
```

이 것도 마찬가지 입니다. 이렇게 이용한다면 "`slave` 함수를 호출할 때, `slave` 함수 안에서 정의된 `master_money` 라는 변수에 `my_money` 의값을 전달하겠다!" 가 되겠지요. 만일 `my_money` 에 10000 이 있었더라면 `slave` 함수를 호출 시에 `master_money` 에는 10000 이 들어가게 됩니다. 결론적으로 말하자면 함수의 인자는 '함수를 호출한 것과, 함수를 서로 연결해 주는 통신 수단' 이라고 말할 수 있습니다. 이러한 연유에서 수학적인 용어로 틀린 표현 이지만 C 에선 '매개 변수' 라고 부릅니다.

그렇다면, 위의 예제를 한 번 살펴볼까요?

```cpp-formatted
int main() {
  int my_money = 100000;
  printf("2009.12.12 재산 : $%d \n", slave(my_money));

  return 0;
}
```

일단, `slave` 함수를 호출하는 **호출자(caller)** 의 코드를 살펴봅시다. `printf` 에서, 맨 뒤에 `%d` 에 들어갈 값으로 `slave(my_money)` 가 반환 하는 값을 넣었습니다. `slave(my_money)` 가 반환하는 값을 먼저 넣기 위해선 `slave` 함수를 호출해야 하는데 이 때 `my_money` 의 값이 `slave` 함수의 인자로 전달이 됩니다. 그러면 `slave` 함수는 아래의 코드를 실행하겠지요.

```cpp-formatted
{
  master_money += 10000;
  return master_money;
}
```

즉, `master_money` 에 10000 을 더한 후, 그 값을 반환하게 됩니다. 따라서, 100000 에 10000 이 더해진 110000 이 출력되겠지요.

이번에는 과연 성공적으로 컴파일 될지 의문이 드는 예제를 한 번 만들어 보았습니다.

```cpp-formatted
/* 될까용 */
#include <stdio.h>
int slave(int my_money) {
  my_money += 10000;
  return my_money;
}
int main() {
  int my_money = 100000;
  printf("2009.12.12 재산 : $%d \n", slave(my_money));
  printf("my_money : %d", my_money);

  return 0;
}
```

  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F146AC4104B25042409AF0B)

  아마도, 앞의 내용을 열심히 배우신 분들은 위 코드가 정상적으로 실행될 것이라는 것을 알고 계셨겠죠? 하지만, 그렇지 못한 분들을 위해 설명 하자면

```cpp-formatted
int slave(int my_money) {
  my_money += 10000;
  return my_money;
}
```

위 `slave` 함수는 `my_money` 를 인자로 받고 있습니다. 여기서 중요한 점은 `my_money` 가 `slave` 의 변수라는 것입니다. 그렇다면 `slave` 함수를 호출하는 부분을 볼까요.

```cpp-formatted
int main() {
  int my_money = 100000;
  printf("2009.12.12 재산 : $%d \n", slave(my_money));
  printf("my_money : %d", my_money);

  return 0;
}
```

(참고적으로 편의를 위해 `main` 함수 내부에서 선언된`my_money`는 파란색으로, `slave` 함수 내부에서 선언된`my_money`는 붉은색으로 표기하였습니다)

음, `slave` 함수를 호출할 때 `main` 함수 내부에서 선언된`my_money`의 값을 `slave` 함수의 변수인`my_money` 로 전달하고 있습니다. 즉, 각 함수 내부에서 선언된 `my_money` 들은 **서로 다른 변수** 이고, 메모리 상의 **다른 위치**를 점유하고 있습니다.

즉, 우리가 보기에 두 변수는 똑같은 것으로 보여도 적어도 컴퓨터가 보기에는 두 변수는 서로 다른 것이라는 것이지요. 두 번째로 주목할 점은 **값**이 전달된다는 것입니다. 이는 아까 제가 위에서 부터 누누히 강조해 온 점이기도 한데, `slave` 함수를 호출할 때 `slave` 함수의`my_money` 인자에는 값이 전달됩니다. 즉, `main` 함수의`my_money`의 100000 이라는 값이 `slave` 함수의 `my_money` 라는 인자에 저장되어 들어갑니다.

따라서, `slave` 함수에서 `my_money`의 값을 아무리 지지고 볶아도 `main` 함수의`my_money`변수에는 전혀 영향을 주지 않는다는 것이지요. 왜냐하면 `slave` 함수의`my_money` 변수는 단지 "`main` 함수의 `my_money` 와 같은 값을 가진 채로 초기화된 메모리 상의 또다른 변수" 이기 때문이지요. 이건 마치

```info
int a = b;
b++;
```

이라고 했는데 `a` 의 값이 `b` 와 같이 1 증가함을 바라는 것과 같습니다. 아무튼, 결과적으로 `main` 함수에서 두 번째 `printf` 문에서 `main` 함수의 `my_money` 의 값을 출력했을 때 에는 전혀 변하지 않은 100000 이 출력됩니다.

그렇다면 우리가 다른 함수의 변수의 값을 수정하고자 하는 함수를 만들고 싶다면 어떻게 해야 될까요? 우리가 앞에서 배운 내용을 생각해보면 "각 함수의 세계는 너무나 배타적이여서 각 함수는 서로에 무슨 변수가 있는지 모른다. 사실 (정확히 말하자면 각 함수의 형태(리턴형, 함수의 이름, 인자들의 형(type)) 빼고는) 서로에 대해 아는 것이 완전히 없다."

그럼, 정말로 우리는 다른 함수에서 정의된 변수의 값을 수정하는 함수는 결코 작성할 수 없는 것일까요?

답은 아니오 입니다. 놀랍게도포인터를 이용하면 됩니다(드디어 포인터가 쓸모 있어지나요?).일단, 이것까지 이야기 하면 강좌가 너무 길어지므로 오늘은 이쯤에서 끝내도록 하고 '어떻게 포인터로 가능할까' 에 대해서 다음 강좌가 나올 때 까지 생각해봅세요.

### 생각해보기

#### 문제 1

이 강좌 최상단에서 이야기 했던 마술 상자를 함수로 제작해보세요 (난이도 : 못한다면 강좌를 다시 읽어보아야 할 것입니다)

#### 문제 2

어느날 귀족이 돈벌이가 시원치 않아져서 이전에는 일정하게 10000 달러씩 챙겼지만 이제 일정치 않은 수입을 얻게 되었습니다. 여러분은 `slave` 함수를 인자를 2 개를 가져서, 하나는 현재 귀족의 재산, 다른 하나는 오늘 귀족의 수입을 인자로 전달받는 새로운 함수를 만들어 보세요 (난이도 : 下)

#### 문제 3

1 부터 `n` 까지의 합을 구하는 함수를 작성해보세요. 수학적인 공식을 써도 되지만 `for` 문으로 작성하는 것이 연습 하는데에는 도움이 될듯 합니다. (난이도 : 下 1 부터 `n` 까지의 합을 구하는 함수를 작성해보세요. 수학적인 공식을 써도 되지만 `for` 문으로 작성하는 것이 연습 하는데에는 도움이 될듯 합니다. (난이도 : 下)

#### 문제 4

`N` 값을 입력 받아서 1 부터 `N` 까지의 소수의 개수를 출력하는 함수를 제작해보세요. (난이도 : 下)

#### 문제 5

특정한 수 `N` 을 입력받아서 `N` 을 소인수분해한 결과가 출력되게 해보세요 (난이도 : 中)

예) `factorize(10);` 출력결과 : 2 × 5

    `factorize(180);` 출력결과  : 2 × 2 × 3 × 3 × 5

#### 문제 6

`int function(int *arg)` 와 같은 함수가 무엇을 뜻하는지 생각해보세요

##@ chewing-c-end
Link :  25
2009-11-26 00:32
----------------
title : 씹어먹는 C 언어 - <12 - 3. 포인터는 영희이다! (포인터)>
cat_title : 12 - 3. 포인터는 영희이다! (포인터)
next_page : 26
publish_date : 2009-11-26 00:32
--------------


이번 강좌에서는

* `1` 차원 배열을 가리키는 포인 1 차원 배열을 가리키는 포인터

* `2` 차원 배열을 가리키는 포인터 (배열 포인터 2 차원 배열을 가리키는 포인터 (배열 포인터)

* 포인터 배열

* 더블 포인터 (**)

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분~! 이전 강좌는 잘 보시고 계시는지요? 아마도 이번 강좌가 최대의 난관일 듯 하네요. 이번 강좌를 잘 이해하냐, 이해 못하냐에 따라서 C 언어가 쉽다/어렵다가 완전히 좌우됩니다. 그러니 지금 졸린 사람들은 잠을 자고 쌩쌩할 때 오시길 바랍니다. (아마도 이 부분이 C 언어에서 가장 어려울 부분이 될 듯 하네요.. 저도 최대한 쉽게 설명하기 위해 노력하겠습니다^^)

  잠깐 지난 시간에 배웠던 것을 머리속으로 상기시켜봅시다. 일단,

* 배열은 포인터와 밀접한 관련이 있다

* 1 차원 배열의 이름은 첫 번째 원소를 가리킨다. 즉, `int arr[3];` 이라는 배열이 있다면 `arr` 와 `&arr[0]` 은 같다. 그런데, `arr[0]` 이 `int` 형이므로 `arr` 은 `int*`  형 이다. (왜냐하면 `int` 형을 가리키는 포인터는 `int*` 이니까 1 차원 배열의 이름은 첫 번째 원소를 가리킨다.
즉, `int arr[3];` 이라는 배열이 있다면 `arr` 와 `&arr[0]` 은 같다. 그런데, `arr[0]` 이 `int` 형이므로 `arr` 은 `int*`  형 이다. (왜냐하면 `int` 형을 가리키는 포인터는 `int*` 이니까)

이 두 가지 사실을 머리속에 잘 들어 있겠지요. 만일 위 두 문장을 읽으면서 조금이라도 의구심이 드는 사람은 바로 뒤로가기를 눌러서 이전 강좌를 보시기 바랍니다.



###  1 차원 배열 가리키기


일단, 강의의 시작은 간단한 것으로 해보겠습니다. 이전해도 말했듯이 (벌써 몇 번째 반복하고 있는지는 모르겠지만 그 만큼 중요하니까) `int arr[10];` 이라는 배열을 만든다면 `arr` 이 `arr[0]` 을 가리킨다고 했습니다. 그렇다면 다른 `int*` 포인터가 이 배열을 가리킬 수 있지 않을까요? 한 번 프로그램을 짜봅시다.

```cpp-formatted
#include <stdio.h>
int main() {
  int arr[3] = {1, 2, 3};
  int *parr;

  parr = arr;
  /* parr = &arr[0]; 도 동일하다! */

  printf("arr[1] : %d \n", arr[1]);
  printf("parr[1] : %d \n", parr[1]);
  return 0;
}
```

성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1436CE234B01106EBFC31E)

 일단, 중점적으로 볼 부분은 아래와 같습니다.

```cpp-formatted
parr = arr;
```

바로 `arr` 에 저장되어 있는 값을 `parr` 에 대입하는 부분이지요. 앞에서 말했듯이 `arr` 은 `int` 를 가리키는 포인터 입니다. 이 때, `arr` 에 저장된 값, 즉 배열의 첫 번째 원소의 주소를 `parr` 에 대입하고 있습니다. 다시 말해 위 문장은 주석에도 잘 나와 있듯이 아래와 같은 문장이 됩니다.

```cpp-formatted
parr = &arr[0]
```

따라서, `parr` 을 통해서 `arr` 을 이용했을 때와 동일하게 배열의 원소에 마음껏 접근할 수 있게 되는 것이 됩니다. 위 모습을 한 번 그림으로 나타내보면 (아마도 여러분들은 지금 수준이라면 머리속으로 다 그릴 수 있어야 할 것입니다)


![arr[0 은 arr 과 parr 모두가 가리키게 됩니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F194C49214B01139B70E9DA)
참고적으로 한 방의 크기는 그림의 단순화를 위해 4 바이트로 하였습니다.
```cpp-formatted
/* 포인터 이용하기 */
#include <stdio.h>
int main() {
  int arr[10] = {100, 98, 97, 95, 89, 76, 92, 96, 100, 99};

  int* parr = arr;
  int sum = 0;

  while (parr - arr <= 9) {
    sum += (*parr);
    parr++;
  }

  printf("내 시험 점수 평균 : %d \n", sum / 10);
  return 0;
}
```

  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F200B06044B0D44AD6D6FAD)

  일단, 포인터를 이용한 간단한 예제를 다루어보겠습니다.

```cpp-formatted
int* parr = arr;
```

먼저, `int` 형 1 차원 배열을 가리킬 수 있는 `int*` 포인터를 정의하였습니다. 그리고, 이 `parr` 은 배열 `arr` 을 가리키게 됩니다.

```cpp-formatted
while (parr - arr <= 9) {
  sum += (*parr);
  parr++;
}
```

그 다음 `while` 문을 살펴봅시다. `while` 문을 오래전에 배워서 기억이 안난다면 다시 뒤로 돌아가세요! 이 `while` 문은 `parr - arr` 이 9 이하일 동안 돌아가게 됩니다. `sum` 에 `parr` 이 가리키는 원소의 값을 더했습니다. `+=` 연산자의 의미는 아시죠? `sum +=` (*parr); 문장은 `sum = sum + *parr` 와 같다는 것 알고 계시지요?

```cpp-formatted
parr++;
```

`parr` 을 1 증가시켰습니다. 이전 강좌에서도 이야기 하였지만 포인터 연산에서 1 증가시킨다면, `parr` 에 저장된 주소값에 1 이 더해지는 것이 아니라 `1 *` (포인터가 가리키는 타입의 크기) 가 더해진다는 것이지요. 즉, `int` 형 포인터 이므로 4 가 더해지므로, 결과적으로 배열의 그 다음 원소를 가리킬 수 있게 됩니다. 암튼, 위 작업을 반복하면 `arr` 배열의 모든 원소들의 합을 구하게 됩니다. `while` 문에서 9 이하일 동안만 반복하는 이유는, `parr - arr >= 10` 이 된다면 `parr[10` 이상의 값] 을 접근하게 되므로 오류를 뿜게 됩니다.

여기서 궁금한 것이 없나요? 우리가 왜 굳이 `parr` 을 따로 선언하였을까요? 우리는 `arr` 이 `arr[0]` 을 가리킨다는 사실을 알고 있으므로 `arr` 을 증가시켜서 `*(arr)` 으로 접근해도 되지 않을까요? 한 번, `arr` 의 값을 변경할 수 있는지 없는지 살펴봅시다.

```cpp-formatted
/* 배열명 */
#include <stdio.h>
int main() {
  int arr[10] = {100, 98, 97, 95, 89, 76, 92, 96, 100, 99};

  arr++;  // 오류!! 배열 이름은 const
  return 0;
}
```


  컴파일 해보면

```warning
error C2105: '++'에 l-value가 필요합니다.
```

와 같은 오류를 만나게 됩니다. 이 말은 `arr` 이 상수이므로 연산할 수 없다는 말이 됩니다. 배열이름이 상수라고요? 맞습니다. 물론 `*arr =` 10; 과 같이 `arr[0]` 의 값은 바꿀 수 있지만 `arr++` 와 같은 연산(즉, `arr` 이 다른 것을 가리키는 것)은 허용되지 않는 것을 보아서 `const` 키워드가 어느쪽에 붙은 포인터인지 짐작할 수 있을 것 입니다. 즉, 배열의 이름은

```info
  (뭐시기 뭐시기) *const (배열 이름)
```

과 같은 형태임을 알 수 있습니다. 결과적으로 배열의 이름은 죽어다 깨어나도 언제나 배열의 첫번째 원소를 가리키게 됩니다. 배열의 이름이 결코 다른 값들을 가리킬 수 없도록 C 에서 제한을 두는 이유는, 제 생각에 프로그래머가 실수로 배열의 이름이 가리키는 값을 잘못 바꿔서 배열을 '아무도 가리키지 않는 메모리 상의 미아'가 됨을 막으려고 한 것이 아닐까요?



###  포인터의 포인터


똑똑한 분들이라면 이러한 것들에 대해서도 생각해 보신 적이 있을 것입니다. 물론, 안하셔도 상관 없고요.. 저의 경우 포인터 처음 배울 때 그것 마저 이해하기도 힘들어서 한참 버벅거렸습니다 :) 아무튼. 지금 머리속으로 예상하시는 대로 포인터의 포인터는 다음과 같이 정의합니다.

```cpp-formatted
int **p;
```

위는 '`int` 를 가리키는 포인터를 가리키는 포인터' 라고 할 수 있습니다. 쉽게 머리에 와닿지 않죠? 당연합니다. 이전 강좌의 내용도 어려워 죽겠는데 위 내용까지 머리속에 쑤셔 넣으려면 얼마나 힘들겠어요? 그래서, 한 번 예제를 봅시다.

```cpp-formatted
/* 포인터의 포인터 */
#include <stdio.h>
int main() {
  int a;
  int *pa;
  int **ppa;

  pa = &a;
  ppa = &pa;

  a = 3;

  printf("a : %d // *pa : %d // **ppa : %d \n", a, *pa, **ppa);
  printf("&a : %d // pa : %d // *ppa : %d \n", &a, pa, *ppa);
  printf("&pa : %d // ppa : %d \n", &pa, ppa);

  return 0;
}
```

성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1607F7224AFEB33C8FEA44)
여러분의 결과는 약간 다를 수 있습니다. 다만, 같은 행에 있는 값들이 모두 같음을 주목하세요


일단 위에 보시다 싶이 같은 행에 있는 값들은 모두 같습니다. 사실, 위 예제는 그리 어려운 것이 아닙니다. 포인터에 제대로 이해만 했다면 말이죠. 일단 `ppa` 는 `int*` 를 가리키는 포인터 이기 때문에

```cpp-formatted
ppa = &pa;
```

와 같이 이전의 포인터에서 했던 것 처럼 똑같이 해주면 됩니다. `ppa` 에는 `pa` 의 주소값이 들어가게 되죠.

```cpp-formatted
printf("&pa : %d // ppa : %d \n", &pa, ppa);
```

따라서 우리는 위의 문장이 같은 값을 출력함을 알 수 있습니다. 위의 실행한 결과를 보아도 둘다 1636564 를 출력했잖아요.

```cpp-formatted
printf("&a : %d // pa : %d // *ppa : %d \n", &a, pa, *ppa);
```

그리고 이제 아래에서 두 번째 문장을 봐 봅시다. `pa` 가 `a` 를 가리키고 있으므로 `pa` 에는 `a` 의 주소값이 들어갑니다. 따라서, `&a` 와 `pa` 는 같은 값이 되겠지요. 그러면 `*ppa` 는 어떨까요? `ppa` 가 `pa` 를 가리키고 있으므로 `*ppa` 를 하면 `pa` 를 지칭하는 것이 됩니다. 따라서 역시 `pa` 의 값, 즉 `&a` 의 값이 출력되게 됩니다.

```cpp-formatted
printf("a : %d // *pa : %d // **ppa : %d \n", a, *pa, **ppa);
```

마지막으로 위의 문장을 살펴 봅시다. `pa` 가 `a` 를 가리키고 있으므로 `*pa` 를 하면 `a` 를 지칭하는 것이 되어 `a` 의 값이 출력됩니다. 그렇다면 `**ppa` 는 어떨까요? 이를 다시 써 보면 `*(*ppa)` 가 되는데, `*ppa` 는 `pa` 를 지칭하는 것이기 때문에 `*pa` 가 되서, 결국 `a` 를 지칭하는 것이 됩니다. 따라서, 역시 `a` 의 값이 출력되겠지요. 어때요? 간단하죠?

위 관계를 그림으로 그리면 다음과 같습니다.


![a 의 주소값을 pa 가, pa 의 주소값을 ppa 가 가지고 있습니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F161550244AFEB8B93D7FD2)



###  2 차원 배열의 `[]` 연산자

2 차원 배열의 `[]` 연산자에 대해선 제가 지난번 강좌에서 '생각 해보기' 문제로 내었던 것 같은데, 생각해보셨는지요? 일단 이전의 기억을 더듬에서 다음과 같은 배열이 컴퓨터 메모리 상에 어떻게 표현되는지 생각 해보도록 합시다.

```cpp-formatted
int a[2][3];
```

물론, 이 배열은 2 차원 배열이므로 평면위에 표시된다고 생각할 수 도 있지만, 컴퓨터 메모리 구조는 1 차원 적이기 때문에 1 차원으로 바꿔서 생각해봅시다. 되었나요? 그렇다면, 제가 그림을 보여드리죠.

![a 는 a[0 을 가리키며, a[0 은 a[0[0 을 가리킵니다. a[1 은 a[1[0 을 가리킵니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1358091D4AFF6236726DC3)
실제로 프로그램을 짜서 실행해 보면 메모리 상에 위와 같이 나타남을 알 수 있습니다. 한 번 해보세요~
  일단, 위 그림에서 왼쪽에 메모리 상의 배열의 모습이 표현된 것은 여러분이 쉽게 이해하실 수 있스리라 믿습니다. 다만, 제가 설명해야 할 부분은 오른쪽에 큼지막하게 화살표로 가리키고 있는 부분이지요. 먼저 아래의 예제를 봅시다.

```cpp-formatted
/* 정말로? */
#include <stdio.h>
int main() {
  int arr[2][3];

  printf("arr[0] : %p \n", arr[0]);
  printf("&arr[0][0] : %p \n", &arr[0][0]);

  printf("arr[1] : %p \n", arr[1]);
  printf("&arr[1][0] : %p \n", &arr[1][0]);

  return 0;
}
```

성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F157473054B001795ACC9C7)
표현된 주소값은 여러분과 다를 수 있습니다.

`arr[0]` 에 저장되어 있는 값이 `arr[0][0]` 의 주소값과 같고, `arr[1]` 에 저장되어 있는 값이 `arr[1][0]` 의 주소값과 같습니다. 이것을 통해 알 수 있는 사실은..? 아마도 다 알겠지만, `arr[0]` 은 `arr[0][0]` 을 가리키는 포인터 이고, `arr[1]` 은 `arr[1][0]` 을 가리키는 포인터라는 뜻이 되겠지요. 이 때, `arr[0][0]` 의 형이 `int` 이므로 `arr[0]` 은 `int*` 형이 되겠고, 마찬가지로 `arr[1]` 도 `int*` 형이 되겠지요.

```cpp-formatted
/* a? */
#include <stdio.h>
int main() {
  int arr[2][3];

  printf("&arr[0] : %p \n", &arr[0]);
  printf("arr : %p \n", arr);

  return 0;
}
```

성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F124BE80F4B01072C8ED626)
출력 결과가 여러분의 출력결과와 다를 수 있지만 값이 같음을 주목하세요

이번에는 `arr[0]` 의 주소값과 `arr` 에 저장된 값이 같군요.. 근데요, 이러한 결과는 어디서 본 것 같지 않으세요? 

맞아요. 실제로 우리가 만들었던 1 차원 `int` 배열에서도 배열의 이름이 배열의 첫 번째 원소를 가리키고 있었습니다. 그런데 위 2차원 배열의 경우에도 `arr` 이 `arr[0]` 을 가리키고 있으므로 동일하다고 볼 수 있습니다. 그렇다면, `arr[0]` 이 `int*` 형 이므로 `arr[0]` 을 가리키는 `arr` 은 `int**` 형 일까요?  아마 여러분 머리속엔 지금 이러한 생각이 떠오를 것입니다.

"당연하지.. 그걸 말이라 묻냐? 니가 위에서 설명했잖아. `int*` 를 가리키는 포인터는 `int**` 이라고 "

  그런데 생각을 해보세요. 그렇게 당연하다면 제가 질문을 했겠습니까? (^^) 답변은 "아니오" 입니다.

아마 여러분은 '내가 위에서 뭘 배웠지?' 라는 생각이 들면서 혼돈에 빠질 것입니다. 당연하지요.. 제가 이야기를 안한 부분이니까요. 저도 처음에 이 부분을 배웠을 땐 이전까지 배웠던 사실이 쓰나미 처럼 밀려나가고 머리속에 하애지는 현상을 겪었습니다. 아무튼.. 왜 그런지 설명해보죠.



###  포인터의 형(type) 을 결정짓는 두 가지 요소


먼저 포인터의 형을 결정하는 두 가지 요소에 대해 이야기 하기 전에, 위에서 배열의 이름이 왜 `int**` 형이 될 수 없는지에 대해 먼저 이야기 해봅시다. 만일 `int**` 형이 될 수 있다면 맨 위에서 했던 것 처럼 `int**` 포인터가 배열의 이름을 가리킨다면 배열의 원소에 자유롭게 접근할 수 있어야만 할 것입니다.

```cpp-formatted
/* 과연 될까? */
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int **parr;

  parr = arr;

  printf("arr[1][1] : %d \n", arr[1][1]);
  printf("parr[1][1] : %d \n", parr[1][1]);

  return 0;
}
```

  그런데 컴파일 시에 아래와 같은 경고가 기분을 나쁘게 하네요.

```warning
 warning C4047: '=' : 'int **'의 간접 참조 수준이 'int (*)[3]'과(와) 다릅니다.
```

  아무튼, 무시하고 실행해봅시다.




![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F150B40264B0BA3124C7215)

헉! 예전에 보았던 친근한 오류가 뜹니다. 무슨 뜻일까요? 예전에 배열에 대해 공부하였을 때 (11-1 강) '초기화 되지 않은 값' 에 대해서 이야기한 적이 있었을 것입니다. 이 때, `int arr[3];` 이라 했는데 `arr[10] = 2;` 와 같이 허가되지 않은 공간에 접근하기만 해도 위와 같은 오류가 발생한다고 했습니다.

위 예제의 경우도 마찬가지 입니다. `parr[1][1]` 에서 이상한 메모리 공간의 값에 접근하였기에 발생한 일이지요. 그렇다면 왜? 왜? 이상한 공간에 접근하였을까요?

먼저, 일차원 배열에서 배열의 형과, 시작 주소값을 안다고 칠 때, `n` 번째 원소의 시작 주소값을 알아내는 공식을 생각해봅시다. 만일 이 배열의 형을 `int` 로 가정하고, 시작 주소를 `x` 라고 할 때, (참고적으로 다 아시겠지만 `int` 는 4 바이트 `n` 번째 원소에 접근한다면 (`x + 4 * (n - 1)` 로 나타낼 수 있죠)


와 같이 나타낼 수 있습니다. 왜냐구요? 아마, 여러분들이 스스로 생각해보세요 :)

이번에는 이차원 배열을 나타내봅시다. 이 이차원 배열이 `int arr[a][b];` 라고 선언되었다면 (여기서 `a` 와 `b` 는 당연히 정수겠죠) 아래와 같이 2차원 평면에 놓여 있다고 생각할 수 있습니다.

![arr[0[0, arr[0[1 .... arr[a-1[b-1 까지 쭈르륵 나열된 모습](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1547A2204B0BA8833543A1)
참고적으로 행은 '가로' 이고, 열은 '세로' 입니다.
  메모리는 선형(1차원) 이므로 절대로 위와 같이 배열될 일은 없겠지요. 위 이차원 배열을 메모리에 나타내기 위해서는 각 행 부터 읽어주면 됩니다. 즉, 위 배열은 아래와 같이 메모리에 배열됩니다.


![물론 메모리 상에서는 실제로 선형으로 존재한다는 것 아시죠!](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1445F9204B0BABC63D97B6)
사실 위에서도 비슷한 그림이 나오지만 또 그린 이유는 머리에 완전히 박아 두라는 의미 입니다.  즉, `arr[0][0]` 부터 `arr[0][1] .... arr[a-1][b-1]` 순으로 저장되게 되지요. 그렇다면 위 배열의 시작주소를 `x` 라 하고, `int` 형 배열이고, `arr[c][d]` 라는 원소에 접근한다고 칩시다. 그렇다면 이 원소의 주소값은 어떻게 계산될까요?

일단, 위 원소는 `(c+1)` 번째 행의 `(d+1)` 번째 열에 위치해 있다고 생각할 수 있습니다. (예를 들어서 `arr[0][2]` 는 1 번째 행의 3 번째 열에 위치해 있다) 그러면, 먼저 `(c+1)` 행의 시작 주소를 계산해봅시다. 간단히 생각해보아도 `x + c * b * 4` 라는 사실을 알 수 있습니다. 왜냐하면 4 를 곱해준 것은 `int` 이기 때문이고, `(c+1)` 행 앞에 `c` 개의 행들이 있는데, 각 행들의 길이가 `b` 이기 때문이죠.

그리고 이 원소가 `(d+1)` 번째에 있다는 사실을 적용하면 (`(c+1)` 행 시작주소) `+ d * 4` 라고 계산될 수 있습니다. 결과적으로 (`x + 4 * b * *c + 4 * d`가 됩니다)


가 됩니다. 참고적으로 이야기 하자면, 수학에서 곱하기 기호가 매우 자주 등장하므로 생각하는 경향이 있는데, 저도 매번 곱하기 기호를 쓰기 불편하므로 생략하도록 하겠습니다. 위 식은 아래의 식과 동일합니다. (`x + 4bc + 4d` 로 간추립니다)

주목할 점은 식에 `b` 가 들어간다는 것입니다. (1 차원 배열에서는 배열의 크기에 관한 정보가 없어도 배열의 원소에 접근할 수 있었는데 말이 1 차원 배열에서는 배열의 크기에 관한 정보가 없어도 배열의 원소에 접근할 수 있었는데 말이죠)

다시 말해, 처음 배열 `arr[a][b]` 를 정의했을 때의 `b` 가 원소의 주소값을 계산하기 위해 필요하다는 것입니다. 우리는 이전의 예제에서 `int**` 로 배열의 이름을 나타낼 수 있다고 생각하였습니다. 하지만 이렇게 선언된 `parr` 으로 컴퓨터가 `parr[1][1]` 원소를 참조하려고 하면 컴퓨터는 `b` 값을 알 수 없기 때문에 제대로된 연산을 수행할 수 없게됩니다.

따라서, 이차원 배열을 가리키는 포인터는 반드시 `b` 값에 대한 정보를 포함하고 있어야 합니다.

결론적으로 포인터 형을 결정하는 것은 다음 두 가지로 요약할 수 있습니다.

1. 가리키는 것에 대한 정보 (예를 들어, `int*` 이면 `int` 를 가리킨다, `char**` 이면 `char*` 을 가리킨다 등등)
2. 1 증가시 커지는 크기 (2 차원 배열에서는 `b * (형의 크기)` 를 의미한다 1 증가시 커지는 크기 (2 차원 배열에서는 `b * (형의 크기)` 를 의미한다)

여기서 1 증가시 커지는 크기가 2 차원 배열에서는 `b * (형의 크기)` 를 의미하는지 궁금한 사람들이 있을 것입니다. 한 번 해봅시다.

```cpp-formatted
/* 1 증가하면 ? */
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};

  printf("arr : %p , arr + 1 : %p \n", arr, arr + 1);

  return 0;
}
```

  성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F142601254B0BD75502819F)

16 진수의 연산과 친숙하지 않더라도 `0x2CF7D8 - 0x2CF7CC` (참고로 예전에도 이야기 했듯이 제 강좌에서 16 진수로 나타내었다는 사실을 명시하기 위해 앞에 `0x` 를 붙인다고 했습니다.) 를 계산해 보면 `0xC` 가 나옵니다. `0xC ,` 즉 십진수로 12 입니다. 근데, 위 배열의 `b` 값은 3 이고 `int` 의 크기는 4 바이트 이므로, `3 * 4 = 12` 가 딱 맞게 되는 것이지요.

왜 그럴까요? 사실, 그 이유는 단순합니다. 거의 맨 위의 그림을 보면 이차원 배열에서 `a` 가 `a[0]` 을 가리키고 있는 그림을 볼 수 있습니다. 만일 1 차원 배열 `b[3]` 이 있을 때 `b + 1` 을 하면 `b[1]` 을 가리키잖아요? 2 차원 배열도 동일하게 `a` 가 1 증가하면 `a[1]` 을 가리키게 됩니다. 다시 말해 두 번째 행의 시작 주소값을 가리키는 포인터를 가리키게 된다는 것이지요.

```cpp-formatted
/* 드디어! 배우는 배열의 포인터 */
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int(*parr)[3];  // 괄호를 꼭 붙이세요

  parr = arr;  // parr 이 arr 을 가리키게 한다.

  printf("parr[1][2] : %d , arr[1][2] : %d \n", parr[1][2], arr[1][2]);

  return 0;
}
```

  성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F203B851E4B0BDA9D453538)

드디어, 2 차원 배열을 가리키는 포인터에 대해 이야기 하겠습니다. 1 차원 배열을 가리키는 포인터는 간단합니다. (아마 아시겠죠?) 그런데, 2 차원 배열을 가리키는 포인터는 배열의 크기에 관한 정보가 있어야 한다고 했습니다. 2 차원 배열을 가리키는 포인터는 아래와 같이 써주면 됩니다.

```info
  (배열의 형) ( *(포인터 이름) )[2 차원 배열의 열 개수] ;
```

이렇게 포인터를 정의하였을 때 앞서 이야기한 포인터의 조건을 잘 만족하는지 보도록 합시다. 일단, (배열의 형) 을 통해서 원소의 크기에 대한 정보를 알 수 있습니다. 즉, 가리키는 것에 대한 정보를 알 수 있게 됩니다. (조건 1 만족). 또한, `[2` 차원 배열의 열 개수] 를 통해서 1 증가시 커지는 크기도 알게 됩니다. 바로 배열의 형 크기 - 예를 들어 `int` 는 `4, char` 은 `1 * (2 차원 배열의 열 개수)` 만큼 커지게 됩니다.

```cpp-formatted
int (*parr)[3];
```

위와 같이 정의한 포인터 `parr` 을 해석해 보면, `int` 형 이차원 배열을 가리키는데, 그 배열의 열의 개수가 3 개 이군요! 라는 사실을 알 수 있습니다 (정확히 말하면, `int*` 를 가리키는데, 1 증가시 3 이 커진다 라는 의미입니다)

  주의할 점은 괄호로 꼭 묶어주어야 한다는 것입니다. 만일 괄호로 묶지 않는다면 다른 결과가 나오니 주의하세요.

```cpp-formatted
/* 배열 포인터 */
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int brr[10][3];
  int crr[2][5];

  int(*parr)[3];

  parr = arr;  // O.K
  parr = brr;  // O.K
  parr = crr;  // 오류!!!!

  return 0;
}
```

  앞서, 2 차원 배열에서 원소의 주소값을 계산하는 식을 기억하시는지요? 

$$ x + 4bc + 4d $$

여기서 보아야 할 점은 `a` 의 값이 필요 없다는 것입니다. 다시말해, `b` 값만 알고 있다면 `a` 값과 무관하게 원소에 접근할 수 있다는 것이지요. 위 예제에서도 보시다 싶이, `parr` 이 `arr[2][3]` 과 `brr[10][3]` 을 가리킬 수 있습니다.

왜냐하면 `b` 값, 즉 열의 개수가 동일한 이차원 배열이기 때문이죠. 반면에 `carr` 은 `arr` 과 `b` 값, 즉 3 과 5 가 다르기 때문에 `parr` 에 `crr` 을 대입하면 오류가 생깁니다. 만일 `crr` 을 `parr` 에 대입했다고 쳐도, 컴퓨터는 `parr` 을 이용하여 `carr` 을 참조할 때, 열의 개수가 3 인 배열로 생각하기 때문에 이상한 결과가 나타납니다.



###  포인터 배열

포인터 배열, 말그대로 '포인터들의 배열' 입니다. 위에서 설명한 배열 포인터는 '배열을 가리키는 포인터' 였죠. 두 용어가 상당히 헷갈리는데, 그냥 '언제나 진짜는 뒷부분' 이라고 생각하시면 됩니다. 즉, 포인터 배열은 정말로 배열이고, 배열 포인터는 정말로 포인터 였죠.

```cpp-formatted
/* 포인터배열*/
#include <stdio.h>
int main() {
  int *arr[3];
  int a = 1, b = 2, c = 3;
  arr[0] = &a;
  arr[1] = &b;
  arr[2] = &c;

  printf("a : %d, *arr[0] : %d \n", a, *arr[0]);
  printf("b : %d, *arr[1] : %d \n", b, *arr[1]);
  printf("b : %d, *arr[2] : %d \n", c, *arr[2]);

  printf("&a : %d, arr[0] : %d \n", &a, arr[0]);
  return 0;
}
```

  성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F175932204B0D4005339EDE)
마지막 출력결과는 여러분과 상이할 수 있으나 두 값이 같음을 주목하세요
  일단, `arr` 배열의 정의 부분을 봐봅시다.

```cpp-formatted
int *arr[3];
```

  위 정의가 마음에 와닿나요? 사실, 저는 처음에 배울 때 별로 와닿지 않았습니다. 사실, 이전에도 말했듯이 위 정의는 아래의 정의와 동일합니다.

```cpp-formatted
int* arr[3];
```

이제, 이해가 되시는지요? 우리가 배열의 형을 `int, char` 등등으로 하듯이, 배열의 형을 역시 `int*` 으로도 할 수 있습니다. 다시말해, 배열의 각각의 원소는 '`int` 를 가리키는 포인터' 형으로 선언된 것입니다. 따라서, `int` 배열에서 각각의 원소를 `int` 형 변수로 취급했던 것처럼 `int*` 배열에서 각각의 원소를 포인터로 취급할 수 있습니다. 마치, 아래처럼 말이지요.

```cpp-formatted
arr[0] = &a;
arr[1] = &b;
arr[2] = &c;
```

  각각의 원소는 각각 `int` 형 변수 `a,b,c` 를 가리키게 됩니다.이를 그림으로 표현하면 아래와 같습니다.


![arr[0 에는 a 의 주소값, arr[1 에는 b 의 주소값, arr[2 에는 c 의 주소값](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F121495024B0D491240D174)

`arr[0]` 에는 변수 `a` 의 주소가, `arr[1]` 에는 변수 `b` 의 주소, `arr[2]` 에는 변수 `c` 의 주소가 각각 들어가게 됩니다. 이는 마지막 `printf` 문장에서도 출력된 결과로 확인 할 수 있습니다.

사실, 포인터 배열에 관한 내용은 짧게 끝냈습니다. 하지만, C 언어에서 상당히 중요하게 다루어지는 개념입니다. 아직 여러분이 그 부분에 대해 이야기할 단계가 되지 않았다고 보아, 기본적인 개념만 알려 드린 것입니다. 꼭 잊지 마시길 바랍니다.

자. 이제 배열을 향한 대장정이 끝이 났습니다. 여기까지 부담없이 이해하셨다면 여러분은 C 언어의 성지를 넘게 된 것입니다! 사실, 여러분은 이 포인터를 무려 3 강의를 연달아 들으면서 '도대체 이걸 왜하냐?' 라는 생각이 머리속에 끝없이 멤돌았을 것입니다. 물론, 앞에서도 이야기 했지만 포인터는 다음 단계에서 배울 내용에 필수적인 존재입니다. 사실, 지금은 아무짝에도 쓸모 없는 것 같지만...

여기까지 스크롤을 내리면서도 마음 한 구석에 응어리가 있는 분들은 과감하게 포인터 강좌를 처음부터 읽어 보세요. 저의 경우 포인터만 책 수십권을 찾아보고 인터넷에서 수십개의 자료를 찾아가며 익혔습니다. 그래도 궁금한 내용들은 꼬오옥 댓글을 달아주세요. 저는 정말 아무리 이상하고 괴상한 질문도 환영하니.. 꼭 궁금한 내용을 물어봐주세요 :)

### 생각 해 볼 문제

#### 문제 1

3 차원 배열의, 배열이름과 동일한 포인터는 어떻게 정의될 것인가? (난이도 : 中 3 차원 배열의, 배열이름과 동일한 포인터는 어떻게 정의될 것인가? (난이도 : 中)
(참조 :  2 차원 배열에선 `int (*arr)[4];` 와 같은 꼴이었다)

#### 문제 2

포인터 간의 형변환은 무엇을 의미하는가? 그리고, C 언어에서 포인터 간의 형변환이 위험한 것인가? (난이도 : 中)
(참고적으로, 포인터간의 형 변환은 아직 이야기 한 적이 없으나 한 번 시도는 해보세요)

##@ chewing-c-end
Link :  24
2009-11-14 12:32
----------------
title : 씹어먹는 C 언어 - <12 - 2. 포인터는 영희이다! (포인터)>
cat_title : 12 - 2. 포인터는 영희이다! (포인터)
next_page : 25
publish_date : 2009-11-14 12:32
--------------


이번 강좌에서는
* 상수 포인터(`const int*, int* const`)
* 포인터의 덧셈, 뺄셈
* 배열과 포인터와의 관계
* `[]` 연산자
 
![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분! 지난 시간에 포인터의 기본 중의 기본이라 할 수 있는 것 들에 배워보았습니다. 다시 정리해 보자면 포인터는 특정한 데이터의 메모리 상의 (시작) 주소값을 보관하는 변수 입니다.

제가 C 언어를 배우면서 포인터를 배울 때 가장 많이 든 생각은

"근데 말야. 이거왜 배워?"

이였습니다. 맞아요. 여러분들도 위와 같은 생각이 머리속에 끊임없이 맴돌 것 입니다. `int a;` 와 `int *p;` 가 있을 때 `p` 가 `a` 를 가리킨다고 하면 `a = 3;` 이라 하지 `*p = 3;` 과 같이 귀찮게 할 필요가 없잖아요. 하지만 나중에 가면 알겠지만포인터는 C 언어에서 정말로 중요한 역할을 담당하게 될 것입니다. 포인터의 중요한 역할에 대해 지금 이야기 하는 것은 무리라고 생각합니다. 일단, 포인터가 뭔지만 알아 놓고 이걸 도대체 왜 배우는지에 대해선 나중에 이야기 하도록 합시다.

###  상수 포인터

이전에 11 - 1 강에서 상수에 대해 잠깐 언급한 것이 기억이 나시나요? 그 때 저는 어떠한 데이터를 상수로 만들기 위해 그 앞에 `const` 키워드를 붙여주면 된다고 했습니다. 예를 들어서

```cpp-formatted
const int a = 3;
```

과 같이 값이 3 인 `int` 변수 `a` 를 상수로 정의할 수 있습니다. `const` 는 단순히 말해서 '이 데이터의 내용은 절대로 바뀔 수 없다' 라는 의미의 키워드 입니다. 따라서, 위 문장의 의미는 '이 `int` 변수 `a` 의 값은 절대로 바뀌면 안된다!!!' 가 됩니다. 위와 같이 정의한 상수 `a` 를 아래 문장에

```cpp-formatted
a = 4;
```

와 같이 하려고 해도 컴파일 시에 오류가 발생하게 됩니다. 왜냐하면 `a` 는 상수로 선언이 되어 있으므로 값이 절대로 변경될 수 없기 때문이죠. 심지어 '값이 변경될 가능성이 있는 문장' 조차 허용되지 않습니다. 예를 들어

```cpp-formatted
a = 3;
```

이라고 한다면, `a` 의 값은 이미 3 이므로 `a` 의 값은 바뀌지 않습니다. 그런데 왠일? 컴파일 해보면 오류가 출력됩니다. 왜냐하면 위 문장은 `a` 의 값이 바뀔 '가능성' 이 있기 때문이죠. 즉, 컴파일러는 `a` 에 무슨 값이 들어가 있는지 신경 쓰지 않습니다. 그냥 무조건 가능성이 있다면 오류를 출력합니다.

여러분은 도대체 왜 상수를 사용하는지 의문을 가질 것 입니다. 하지만 상수는 프로그래밍 상에서 프로그래머들의 실수를 줄여주고, 실수를 했다고 해도 실수를 잡아내는데 중요한 역할을 하고 있습니다. 예를 들어 아래와 같은 문장을 봅시다.

```cpp-formatted
const double PI = 3.141592;
```

즉 `double` 형 변수 `PI` 를 `3.141592` 라는 값을 가지게 선언하였습니다. 왜 이렇게 해도 되냐면 실제로 `PI` 값은 절대로 바뀌지 않는 상수 이기 때문이죠. 따라서, 프로그래머가 밤에 졸면서 코딩을 하다가 아래와 같이

```cpp-formatted
PI = 10;
```

`PI` 의 값을 문장을 집어 넣었다고 해도 컴파일 시 오류가 발생하여 프로그래머는 이를 고칠 수 있게 됩니다. 반면에 `PI` 를 그냥 `double` 형 변수로 선언했다고 해봅시다.

```cpp-formatted
double PI = 3.141592;
```

그렇다면 프로그래머가 아래와 같은 코드를 잠결에 집어 넣었다면

```cpp-formatted
PI = 10;
```

컴파일러는 이를 오류로 처리하지 않습니다. 이는 엄청나게 큰일이 아닐 수 없죠. 만일 고객들에게 원의 넓이를 계산하는 프로그램을 만들어 주었는데 잘못해서 이상한 값이 나오면 어떻겠습니까? 물론 위와 같이 간단한 오류는 잡아내기 쉽지만 프로그램이 커지만 커질 수록 위와 같은 오류를 잡아내는 것은 여간 힘든 일이 아닙니다. 따라서, 우리는 '절대로 바뀌지 않을 것 같은 값에는 무조건 `const` 키워드를 붙여주는 습관' 을 기르는 것이 중요합니다.

아무튼. 이번에는 포인터에도 `const` 를 붙일 수 있는지 생각해 봅시다.

```cpp-formatted
/* 상수 포인터? */
#include <stdio.h>
int main() {
  int a;
  int b;
  const int* pa = &a;

  *pa = 3;  // 올바르지 않은 문장
  pa = &b;  // 올바른 문장
  return 0;
}
```

컴파일 해보면 오류가 발생합니다.

```warning
error C2166: l-value가 const 개체를 지정합니다.
```

일단, 위 오류가 왜 발생하였는지에 대해 이야기 하기 앞서서 아래 문장이 무슨 의미를 가지는지 살펴 봅시다.

```cpp-formatted
const int* pa =
  &a;  // int* pa 와 같이 정의해도 int *pa 와 같다는 사실은 다 알고 있죠?
```

여러분은 위 문장을 보면 다음과 같은 생각이 떠오를 것입니다. "저 포인터는 `const int` 형을 가리키는 포인터인데, 어떻게 `int` 형 변수 `a` 의 주소값이 대입 될 수 있지? 그러면 안되는 거 아니야?". 하지만, 제가 앞에서 누누히 강조해 왔듯이 `const` 라는 키워드는 **이 데이터의 값은 절대로 바뀌면 안된다** 라고 일러주는 키워드라고 하였습니다.

다시 말해, `const int a` 라는 변수는 그냥 `int` 형 변수 `a` 인데 값이 절대로 바뀌면 안되는 변수일 뿐입니다. 따라서, `const int a` 변수도 그냥 `int` 형이라 말할 수 있습니다. (다만 '변'수가 아닐 뿐)

따라서 `const int*` 의 의미는 `const int` 형 변수를 가리킨다는 것이 아닙니다. `int` 형 변수를 가리키는데 '그 값을 절대로 바꾸지 말라' 라는 의미이죠. 즉, `pa` 는 어떠한 `int` 형 변수를 가리키고 있습니다. 그런데 `const` 가 붙었으므로 `pa` 가가리키는 변수의 값은 절대로 바뀌면 안되게 됩니다.

여기서 '`pa` 가' 라는 부분을 강조한 이유는 `a` 자체는 변수 이므로 값이 자유롭게 변경될 수 있기 때문입니다. 하지만 `pa` 를 통해서 `a` 를 간접적으로 가리킬 때 에는 컴퓨터가 '아, 내가 `const` 인 변수를 가리키고 있구나' 로 생각하기 때문에(`const int*` 로 포인터를 정의하였으므로) 값을 바꿀 수 없게 됩니다.

  결과적으로 아래의 문장은 오류를 출력합니다.

```info
  *pa = 3; // 올바르지 않은 문장
```

물론 `a = 3;` 과 같은 문장은 오류를 출려하지 않습니다. 앞에서도 말했듯이 변수 `a` 자체는 `const` 가 아니기 때문이죠.

```cpp-formatted
pa = &b;  // 올바른 문장
```

그렇다면 위 문장은 옳은 문장 입니다. 왜 일까요? (아마 당연하다고 생각하면 여러분은 훌륭한 학생들 입니다) 이는 아래 예제와 함께 설명하도록 하겠습니다.

```cpp-formatted
/* 상수 포인터? */
#include <stdio.h>
int main() {
  int a;
  int b;
  int* const pa = &a;

  *pa = 3;  // 올바른 문장
  pa = &b;  // 올바르지 않은 문장

  return 0;
}
```

역시 컴파일 해보면

```warning
 error C2166: l-value가 const 개체를 지정합니다.
```

앞서 보았던 오류와 동일한 오류가 뜹니다. 그런데 위치가 다릅니다. 앞에서는 위 문장에서 오류가 발생했는데 이번엔 아래에서 발생합니다. 일단, 포인터의 정의 부분 부터 이야기 해봅시다.

```cpp-formatted
int* const pa = &a;
```

차근차근 봐 보면, 우리는 `int*` 를 가리키는 `pa` 라는 포인터를 정의하였습니다. 그런데 이번에는 `const` 키워드가 `int*` 앞에 있는 것이 아니라 `int*` 와 `pa` 사이에 놓이고 있습니다. 뭐지? 하지만 이 것은 `const` 키워드의 의미를 그대로 생각해 보면 간단합니다. `pa` 의 값이 바뀐 안된다는 것이지요.

그런데 제일 처음에 포인터를 배울 때 강조했듯이, 포인터에는 가리키는 데이터의 주소값, 즉 위 경우 `a` 의 주소값이 `pa` 저장되는 것이지요. 따라서, 이 `pa` 가 `const` 라는 의미는 `pa` 의 값이 절대로 바뀔 수 없다는 것인데, `pa` 는 포인터가 가리키는 변수의 주소값이 들어 있으므로 결과적으로 `pa` 가 처음에 가리키는 것 (a) 말고 다른 것은 절대로 건드릴 수 없다는 것 입니다.

```info
    pa = &b; // 올바르지 않은 문장
```

결론적으로 위 문장은 오류를 뿜게 됩니다. 왜냐하면 `pa` 가 다른 변수를 가리키기 때문이죠 (즉 `pa` 에 저장된 주소값을 바꾸므로) 반면에 위의 예제에서 오류가 났던 문장은 올바르게 돌아갑니다.

```cpp-formatted
*pa = 3;  // 올바른 문장
```

왜냐하면 `pa` 가 가리키는 값을 바꾸면 안된다는 말은 안했기 때문이죠. (그냥 `int*`)

한 번 위에 나와있던 것을 모두 합쳐 보면

```cpp-formatted
/* 상수 포인터? */
#include <stdio.h>
int main() {
  int a;
  int b;
  const int* const pa = &a;

  *pa = 3;  // 올바르지 않은 문장
  pa = &b;  // 올바르지 않은 문장

  return 0;
}
```

와 같이 되겠지요. 어때요? 쉽죠?



###  포인터의 덧셈

이번에는 포인터의 덧셈과 뺄셈에 대해서 다루어 보도록 하겠습니다. 앞에서도 강조하였지만 지금 하는 작업들이 무의미해 보이고 쓸모 없어 보이지만 나중에 정말로 중요하게 다루어 집니다. 조금만 힘내세요 (아마도 C 언어에서 가장 재미 없는 부분일듯.)

```cpp-formatted
/* 포인터의 덧셈 */
#include <stdio.h>
int main() {
  int a;
  int* pa;
  pa = &a;

  printf("pa 의 값 : %p \n", pa);
  printf("(pa + 1) 의 값 : %p \n", pa + 1);

  return 0;
}
```

성공적으로 컴파일 해보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2070331E4AFBD5CC1E3BA4)
여러분의 출력 결과는 위에 나온 결과와 다를 수 있습니다. 다만, 두 수의 차이는 4 일 것입니다.
  아마 여러분은 출력된 결과를 보면서 깜짝 놀랐을 것입니다. 우리는 분명히

```cpp-formatted
printf("(pa + 1) 의 값 : %p \n", pa + 1);
```

에서 `pa + 1` 의 값을 출력하라고 명시하였습니다. 제가 앞에서도 이야기 하였듯이 `pa` 에는 자신이 가리키는 변수의 주소값이 들어갑니다. 따라서, `pa + 1` 을 하면 1244812 에 1 이 더해진 1244813 가 아니라, 4 가 더해진 1244816 이 출력되었습니다. 이게 도대체 무슨 일입니까? `1244812 + 1 = 1244816` 이라고요?

위 해괴한 계산 결과를 해결하기 앞서, 우리는 포인터의 형이 `int*` 라는 것을 알 수 있었습니다. 그런데, `int` 가 4 바이트 이니까.... 설마?

일단, 위 추측을 확인해보기 위해 int  포인터 말고도 크기가 다른 `char` 이다 `double` 등에 대해서도 해봅시다.

```cpp-formatted
/* 과연? */
#include <stdio.h>
int main() {
  int a;
  char b;
  double c;
  int* pa = &a;
  char* pb = &b;
  double* pc = &c;

  printf("pa 의 값 : %p \n", pa);
  printf("(pa + 1) 의 값 : %p \n", pa + 1);
  printf("pb 의 값 : %p \n", pb);
  printf("(pb + 1) 의 값 : %p \n", pb + 1);
  printf("pc 의 값 : %p \n", pc);
  printf("(pc + 1) 의 값 : %p \n", pc + 1);

  return 0;
}
```

성공적으로 컴파일 후 실행해 보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1201521B4AFBD7BE1B72CC)
여러분의 출력 결과는 위에 나온 결과와 다를 수 있습니다.

우왕.  우리의 예상과 정확하게 맞아 떨어졌습니다. `pb` 의 경우 1 이 더해졌고, `pc` 의 경우 8 이 더해졌습니다. 그런데, `char` 은 1 바이트, `double` 은 8 바이트 이므로 모두 우리가 예상한 결과와 일치합니다. 놀랍군요. 하지만 머리 한 켠에는 또다른 의문이 남습니다. 왜 하라는 대로 안하고 포인터가 가리키는 형의 크기 만큼 더할까요. 사실 이에 대한 해답은 뒤에 나옵니다.

훌륭한 학생이라면 여러가지 모험을 해볼 것 입니다. 예를 들어 '포인터의 뺄셈은 허용되는지, 포인터 끼리 더해도 되는지 등등..' 말이죠. 우리도 한 번 궁금증을 해결해 봅시다.

일단 직관적으로 포인터의 뺄셈은 허용될 것 같습니다. 왜냐하면 뺄셈은 본질적으로 덧셈과 다를 바 없기 때문이죠. (1 - 1 = 1 + (-1)) 아무튼 해 보면 덧셈과 유사한 결과가 나타납니다.

```cpp-formatted
/* 포인터 뺄셈 */
#include <stdio.h>
int main() {
  int a;
  int* pa = &a;

  printf("pa 의 값 : %p \n", pa);
  printf("(pa - 1) 의 값 : %p \n", pa - 1);

  return 0;
}
```

성공적으로 컴파일 후 실행 해보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1416491A4AFBD968037E07)
여러분의 출력 결과는 위에 나온 결과와 다를 수 있습니다.
  역시 우리의 예상대로 4 가 빼졌습니다.

```cpp-formatted
/* 포인터끼리의 덧셈 */
#include <stdio.h>
int main() {
  int a;
  int *pa = &a;
  int b;
  int *pb = &b;
  int *pc = pa + pb;

  return 0;
}
```

아마 컴파일 해보면 아래와 같은 오류를 만날 수 있습니다.

```warning
error C2110: '+' : 두 포인터를 더할 수 없습니다.
```

왜 C 에서는 두 포인터끼리의 덧셈을 허용하지 않는 것일까요? 사실, 포인터끼리의 덧셈은 아무런 의미가 없을 뿐더러 필요 하지도 않습니다. 두 변수의 메모리 주소를 더해서 나오는 값은 이전에 포인터들이 가리키던 두 개의 변수와 아무런 관련이 없는 메모리 속의 임의의 지점 입니다. 아무런 의미가 없는 프로그램 상에 상관없는 지점을 말이죠. 무언가, 설명이 불충분한 느낌이 들지만 아무튼 포인터 끼리의 덧셈은 아무런 의미가 없기 때문에 C 언어에선 수행할 수 없습니다. 그렇다면, 포인터에 정수를 더하는 것은 왜 되는 것일까요. 아까도 말했듯이 이에 대해선 아래에서 설명해드리겠습니다.

그런데 한 가지 놀라운 점은 포인터끼리의 뺄셈은 가능하다는 것입니다. 왜 그런지에 대한 설명은 나중에 합시다.

```cpp-formatted
/* 포인터의 대입 */
#include <stdio.h>
int main() {
  int a;
  int* pa = &a;
  int* pb;

  *pa = 3;
  pb = pa;

  printf("pa 가 가리키고 있는 것 : %d \n", *pa);
  printf("pb 가 가리키고 있는 것 : %d \n", *pb);

  return 0;
}
```

성공적으로 컴파일 해보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F1818381A4AFBDBD9037769)

와 같이 나옵니다. 뭐 당연한 일이지요.

```cpp-formatted
pb = pa;
```

부분에서 `pa` 에 저장되어 있는 값 (즉, `pa` 가 가리키고 있는 변수의 주소값) 을 `pb` 에 대입하였습니다. 따라서 `pb` 도 `pa` 가 가리키던 것의 주소값을 가지게 되는 것이지요. 결과적으로 `pb` 와 `pa` 모두 `a` 를 가리키게 됩니다. 주의해야 될 점은 `pa` 와 `pb` 가 형이 같아야 한다는 점 입니다. 다시 말해 `pa` 가 `int*` 면 `pb` 도 `int*` 여야 합니다. 만일 형이 다르다면 형변환을 해주어야 하는데 이에 대한 이야기는 나중에 합시다.



###  배열과 포인터


```warning
  아마 이 단원을 읽다 보면 쇼크를 받을 지도 모르므로 심장이 약하신 분들은 의사와 함께 하십시오.(참고로 저의 경우 많이 놀라서 잠을 잘 못잤습니다)

```

제가 C 언어를 배우면서 가장 감탄하고도 쇼킹했던 부분이 바로 여기였습니다. 물론, 모든 사람들이 그다지 놀라워 하는 것은 아니지만 저한테는 신선한 충격이였습니다. 아마 이 단원을 배운다면 앞서 '포인터의 연산은 왜 이따구로 하는 거야!' 에 대한 답안을 찾을 수 있을 것 입니다.

이전 강좌에서 (11 강) 저는 여러분에게 배열에 대해 이야기 했었습니다. 그 때, 배열은 '변수가 여러개 모인 것으로 생각할 수 있다' 라고 이야기 했었지요. 그런데 말이죠. 또다른 놀라운 특징이 있습니다. 바로 배열들의 각 원소는 메모리 상에 연속되게 놓인 다는 점입니다. 뭐, 놀랍지 않다면 말고요. 어쨋든,

```cpp-formatted
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```

  이라는 배열을 정의한다면 메모리 상에서 다음과 같이 나타납니다.


![10 개의 방이 있고 각 방에 1 부터 10 까지 들어가 있습니다. 물론 각 방의 주소값은 다 있죠](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F152460454D5FA71108EA6F)


즉, 위와 같이 메모리 상에 연속된 형태로 나타난다는 점이지요. 한 개의 원소는 `int` 형 변수이기 때문에 4 바이트를 차지하게 됩니다. 물론, 위 사실을 믿지 못하시는 분들은 아래와 같이 컴퓨터를 통해 직접 확인해 볼 수 있습니다.

```cpp-formatted
/* 배열의 존재 상태? */
#include <stdio.h>
int main() {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int i;

  for (i = 0; i < 10; i++) {
    printf("arr[%d] 의 주소값 : %x \n", i, &arr[i]);
  }
  return 0;
}
```

  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1639F7274AFD1D74023A3F)

 와 같이 나타납니다. 여러분의 결과와 주소값은 약간 다를 수 있지만, 어쨋든 4 씩 증가하면 된 것입니다.

아마 여기쯤 왔다면 여러분의 머리를 스쳐지나가는 생각이 들 것입니다! 아! 포인터로도 배열의 원소에 쉽게 접근이 가능하겠구나! (이 생각이 떠오르지 않는 사람은 아마 이 글을 다시 처음부터 읽으셔야 합니다.) 배열의 시작 부분을 가리키는 포인터를 정의한 뒤에 포인터에 1 을 더하면 그 다음 원소를 가리키겠군! 그리고 2 를 더한 그 다음 다음 원소를 가리킨다!!

위와 같은 일이 가능한 이유는 포인터는 자신이 가리키는 데이타의 '형' 의 크기를 곱한 만큼 덧셈을 수행하기 때문이죠. 즉 `p` 라는 포인터가 `int` a; 를 가리킨다면 `p + 1` 을 할 때 `p` 의 주소값에 사실은 `1*4` 가 더해지고, `p + 3` 을 하면 `p` 의 주소값에 `3*4` 인 12 가 더해진다는 것입니다.

한 번 이 아이디어를 적용시켜서 배열의 원소를 가리키는 포인터를 만들어봅시다.

```cpp-formatted
/* 과연? */
#include <stdio.h>
int main() {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int* parr;
  int i;
  parr = &arr[0];

  for (i = 0; i < 10; i++) {
    printf("arr[%d] 의 주소값 : %p ", i, &arr[i]);
    printf("(parr + %d) 의 값 : %p ", i, (parr + i));

    if (&arr[i] == (parr + i)) {
      /* 만일 (parr + i) 가 성공적으로 arr[i] 를 가리킨다면 */
      printf(" --> 일치 \n");
    } else {
      printf("--> 불일치\n");
    }
  }
  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F143FB70D4AFD20946EB9D0)

 정확히 모두 일치가 나옵니다. 위 소스코드가 이해가 안되는 분들이 있을 까봐 살짝 설명을 드리기는 하겠습니다.

```cpp-formatted
parr = &arr[0];
```

`parr` 이라는 `int` 형을 가리키는 포인터는 `arr[0]` 이라는 `int` 형 변수를 가리킵니다. (배열의 각 원소는 하나의 변수로 생각할 수 있다는 사실은 까먹지 않았죠?)

```cpp-formatted
printf("arr[%d] 의 주소값 : %p ", i, &arr[i]);
printf("(parr + %d) 의 값 : %p ", i, (parr + i));
```

이제, `arr[i]` 의 주소값과 `(parr + i)` 의 값을 출력해봅니다. 만일 `parr + i` 의 값이 `arr[i]` 의 주소값과 같다면 하단의 `if-else` 에서 일치가 출력되고 다르다면 불일치가 출력되게 됩니다. 그런데, 이미 예상하고 있던 바이지만 `parr` 이 `int` 형이므로 `+ i` 를 하면 주소값에는 사실상 `4*i` 가 더해지게 되는 것이지요. 이 때 `arr[i]` 의 주소값도 `i` 가 하나씩 커질 때 마다 4 씩 증가하므로 (`int` 형 배열이므로) 결과적으로 모든 결과가 일치하게 되는 것 입니다.

이렇게 포인터에 정수를 더하는 것 만으로도 배열의 각 원소를 가리킬 수 있습니다. 그렇다면 `*` 를 이용하여 원소들과 똑같은 역할을 할 수 있게 되겠군요. 마치 아래 예제 처럼 말이지요.

```cpp-formatted
/* 우왕 */
#include <stdio.h>
int main() {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int* parr;

  parr = &arr[0];

  printf("arr[3] = %d , *(parr + 3) = %d \n", arr[3], *(parr + 3));
  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F195AB3284AFD2335290679)

  와 같이 동일하게 접근할 수 있게 됩니다.

즉 `parr + 3` 을 수행하면, `arr[3]` 의 주소값이 되고, 거기에 `*` 를 붙여주면 `*` 의 연산자의 역할이 '그 주소값에 해당하는 데이터를 의미해라!' 라는 뜻이므로 `*(parr + 3)` 은 `arr[3]` 과 동일하게 된다는 것입니다. 어때요? 놀랍지요. 포인터의 덧셈이 왜 그렇게 수행되는지 속 시원하게 해결되는 것 같나요?



###  배열의 이름의 비밀

아마 여러분들 중 대다수는 배열을 처음 배울 때 다음과 같은 실수를 하신 경험이 있을 것 입니다. (나만 그런가?)

```info
#include <stdio.h>
int main() {
    int arr[3]={1,2,3};
    printf("%d", arr);
}
```

그러곤 1 도, 2 도, 3 도, 아닌 이상한 값이 나오는 것을 보고 당황하셨겠죠.. 그런데, 놀랍게도 그 때 출력되는 값은 아래와 같습니다.

```cpp-formatted
#include <stdio.h>
int main() {
  int arr[3] = {1, 2, 3};

  printf("arr 의 정체 : %p \n", arr);
  printf("arr[0] 의 주소값 : %p \n", &arr[0]);

  return 0;
}
```


성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F162074184AFD528647BF6B)

와 같이 나옵니다. 와우~ 놀랍게도 `arr` 과 `arr[0]` 의 주소값이 동일합니다.

따라서 배열에서 배열의 이름은 배열의 시작 주소값을 지칭하고 있다는 사실을 알 수 있습니다. 다시 말해, 배열의 이름은 배열의 시작 주소를 가리키는 포인터라고 생각할 수 있겠군요. 그렇다면 다음과 같은 연산이 가능할까요?

```cpp-formatted
/* 될까? */
#include <stdio.h>
int main() {
  int arr[2] = {1, 2};
  int brr[2] = {3, 4};

  arr = brr;  // 안됨

  return 0;
}
```

  컴파일 해보면 아래와 같은 오류가 뜹니다.

```warning
error C2106: '=' : 왼쪽 피연산자는 l-value이어야 합니다.
```

`arr` 을 다른 배열을 가리키게 주소값을 바꿀 수 없다는 뜻이군요... 여러분들은 왜 그래야만 하는지 이해가 가나요? 사실 `arr` 은 포인터 상수 형태로 되어 있습니다. 이 경우에는 `int* const` 꼴의 포인터가 되지요. 사실 이러한 이유는 컴퓨터 메모리의 구조와 밀접한 관련이 있지만 여기서는 그 이야기는 하지 않도록 하겠습니다.

###  [] 연산자의 역할

여러분들 중에서 많은 분들은 `[]` 가 연산자였다는 사실을 보고 깜짝 놀랐을 것 입니다. 그런데, 제가 사실 오래 전에 암묵적으로 알려 주었었죠.. 다음 그림은 4 강에서 연산 순위에 대해 이야기 하였을 때 가져왔던 그림입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F110BAC254AFD485D293EC3)
`www.winapi.com` 에서 가져온 자료 입니다.

위의 표에서 아는 연산자가 별로 없다고 걱정하지는 마세요!우리는 앞으로 C 언어를 공부하면서 위의 거의 모든 연산자들을 다 배울 것 입니다. 표 최상단을 보면 `[ ]` 라 생긴 것이 보일 것 입니다. 아무튼.. `[]` 도 연산자였습니다. 우리는 막연히 배열을 처음에 배우면서 "아, 배열의 `n` 번째 원소를 지정하려면 `[n-1]` 이라고 해야 되는 구나!" 라고 생각하였는데 `[ ]` 도 `+ , -` 와 같은 특정한 역할을 하는 연산자였던 것입니다.

그런데, 우리는 앞서 포인터와 배열의 놀라운 관계를 배웠기 때문에 `[ ]` 연산자의 역할을 대충 짐작할 수 있습니다.

```cpp-formatted
/* [] 연산자 */
#include <stdio.h>
int main() {
  int arr[5] = {1, 2, 3, 4, 5};

  printf("a[3] : %d \n", arr[3]);
  printf("*(a+3) : %d \n", *(arr + 3));
  return 0;
}
```

 성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F147786034AFE0DAB5D0053)

음... 이미 앞에서 다룬 내용을 모두 이해했더라면 위 정도쯤은 쉽게 이해할 수 있을 것입니다. 사실 컴퓨터는 C 에서 `[]` 라는 연산자가 쓰이면 자동적으로 위 처럼 포인터 형태로 바꾸어서 처리하게 됩니다. 즉, 우리가 `arr[3]` 이라 사용한 것은 사실 `*(arr + 3)` 으로 바뀌어서 처리가 된다는 뜻이지요.

  따라서 다음과 같이 신기한 연산도 가능합니다.

```cpp-formatted
/* 신기한 [] 사용 */
#include <stdio.h>
int main() {
  int arr[5] = {1, 2, 3, 4, 5};

  printf("3[arr] : %d \n", 3 [arr]);
  printf("*(3+a) : %d \n", *(arr + 3));
  return 0;
}
```

  성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F12363D234AFE10DA5943D8)

`3[arr]` 은 무언가 조금 '깨는' 표현 입니다. 사실 이렇게 사용한다면 가독성도 떨어지고 한 번에 이해도 되지 않기에 99.9999% 의 프로그래머들은 `arr[3]` 으로 사용할 것입니다. 하지만, 앞에서도 `[]` 는 연산자로 `3[arr]` 을 `*(3+arr)` 로 바꿔주기 때문에 `arr[3]` 과 동일한 결과를 출력할 수 있게 되지요.


###  포인터의 정의

앞에서 말하기를 `int` 를 가리키는 포인터를 정의하기 위해 다음의 두 문장을 모두 사용할 수 있다고 했습니다.

```cpp-formatted
int* p;
int* p;
```

그런데 말이죠. 제 강좌 말도 다른 곳에서 C 언어를 공부했던 사람들이라면 아래와 같은 형식을 훨씬 많이 쓴다는 사실을 알 수 있었을 것입니다.

```cpp-formatted
int *p;
```

왜 일까요? 우리가 `int` 형 변수를 여러개 한 번에 선언하려 했을 때 `int a,b,c,d;` 라 하잖아요. 포인터 변수를 여러개 선언 하려면 아래와 같이 해야 합니다.

```cpp-formatted
int *p, *q, *r;
```

  물론

```cpp-formatted
int *p, *q, *r;
```

  게 해도 됩니다. 다만,

```cpp-formatted
int* p;
```

  꼴로 한다면 다음과 같이 실수 할 확률이 매우 커지게 됩니다. 왜냐하면 아래와 같이 한다면

```cpp-formatted
int *p, q, r;
```

`p` 만 `int` 를 가리키는 포인터 이고, `q, r` 은 평범한 `int` 형 변수가 됩니다. 따라서, 앞으로 저는 제 강좌에서 모든 포인터들은

```cpp-formatted
int *p;
```

꼴로 선언 하도록 하겠습니다.

### 생각해 볼 문제

#### 문제 1

`int arr[3][3];` 과 같은 배열은 내부적으로 어떻게 처리되는지 생각해보세요 (난이도 : 中)

#### 문제 2

`int* arr[3];` 과 같은 배열이 가지는 의미는 무엇일까요? (난이도 : 中)

##@ chewing-c-end

Link :  18
2009-11-14 11:42
----------------
title : 씹어먹는 C 언어 - <11 - 1. C 언어의 아파트 (배열), 상수>
cat_title : 11 - 1. C 언어의 아파트 (배열), 상수
next_page : 20
publish_date : 2009-11-14 11:42
--------------


이번 장에서 배울 내용은

* 배열(Array) 이란 무엇인가? , 배열에 대한 기초적 이해
* 상수는 무엇인가?

입니다.

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요, 여러분. 지난 강의에 내 주었던 마지막 문제는 모두 푸셨나요? 저는 기본적으로 자신이 내준 문제는 스스로 무슨 수를 써서라도 풀어야 한다라는 것이 원칙이지만, 댓글로 한에서 답안을 공개할 수 있으니 여러분의 답안을 댓글로 남겨주시면 고맙겠습니다. 댓글이 저를 귀찮게 한다는 생각 말고요, 과감하게 댓글을 남겨 주세요. 저는 오히려 여러분의 댓글을 기다리고 있는 사람입니다.

얼마전에 Psi 는 친구로 부터 프로그램을 하나 짜 달라는 요청을 받았습니다. 친절한 Psi 는 그 친구의 요청을 흔퀘히 승낙했죠. 그런데, 그 친구가 요청한 프로그램은 그다지 평범한 프로그램이 아니였습니다. 그 친구의 반에 30 명의 학생들이 있는데 각 학생들의 성적들을 입력받아서 평균 보다 낮은 사람들의 번호 옆에 '불합격', 평균 이상의 사람들에게 '합격' 이라는 메세지 까지 출력하는 프로그램을 말입니다.

  그래서 Psi 는 생각하였습니다.

'30 명의 학생들의 점수를 입력 받아서 평균 까지는 구할 수 있겠는데 말야. 각 학생의 점수들을 보관하기 위한 변수들이 필요하단 말이야. 학생이 4 명 이라면 편하겠지만 30 명이라면.. `a1, a2, a3, a4, a5, ..... a30` 까지 각 변수의 값들을 언제 다 입력 받지? 젠장할! 이거 완전히 '캐' 노가다 아닌가.

아무튼, 프로그래밍을 하다가 위와 같이 여러 개의 값을 동시해 보관할 필요성이 생기게 되었습니다. 이전의 경우 여러개의 값을 보관할 경우에, 그 개수 만큼의 변수가 필요했었지요. 하지만 위 경우 처럼 이용해야 할 변수의 개수가 매우 많아지게 되면 어떨 까요? 만약 전국의 학생수에 해당하는 프로그램을 작성하려면 10만개 이상의 변수들이 필요하게 됩니다. 이는, 프로그래머가 아무리 'Ctrl+C, Ctrl+V' 신공이 뛰어나다고 해도 불가능한 일이겠지요.

따라서, C 언어에 '배열(Array)' 이라는 것이 등장하게 되었습니다. 배열은, 간단히 말하자면 변수들의 집합이라고 말할 수 있습니다. 예를 들어서 `int` 형 배열의 경우, `int` 형 변수들이 메모리 상에 여러개 할당 되어 있는 것이지요.



###  배열의 기초


```cpp-formatted
/* 배열 기초 */
#include <stdio.h>
int main() {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  printf("Array 3 번째 원소 : %d \n ", arr[2]);
  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F173F961F4ABA00345AFD9B)

 와 같이 나오게 됩니다.

일단 여러분은 새로운 것들이 나왔기 때문에 당황하는 분들이 계실 수 도 있습니다. 또한, 여태까지 배운 것들도 이해하기 힘든데 이제 더욱 어려운 것이 나타났구나! 라고 생각하시는 분들도 계실 것입니다. 하지만, '불행이도' 여러분이 배우실 것들은 정말 쉬운 내용 들입니다. 그런 걱정 하시지 말고 차분히 읽어 보시면 됩니다.

앞서, 배열에 대해 잠깐 소개를 하였는데 배열은 말그대로 '특정한 형(Type) 의 변수들의 집합' 입니다. 변수를 정의할 때 에는

```info
(변수의 형) (변수의 이름);
```

  과 같이 정의했는데 배열은 그와 비슷하게도



```info
(배열의 형) (배열의 이름)[원소 개수];
```

  와 같이 해주면 됩니다. 위의 경우

```cpp-formatted
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```

와 같이 해주었으므로, *`int` 형의 10 개의 원소를 가지는 배열 `arr`!* 이라고 생각하시면 됩니다. 다시말해, 이 배열은 10 개의 `int` 형 변수들을 보관 할 수 있게 됩니다. 만약 `char arr[10]` 이라 한다면 각 원소들이 모두 `char` 형으로 선언 됩니다. 또한 위와 같이 중괄호로 감싸 주었을 때, 배열의 각각의 원소에는 중괄호 속의 각 값들이 순차적으로 들어가게 됩니다. 배열의 첫 번째 원소에는 `1,` 두 번째 원소에는 `2, ... 10` 번째 원소에는 10 이 들어가게 됩니다.

그런데, 막연하게 배열을 정의해 놓고 보니 배열의 각각의 원소들에 접근하는 방법을 알려주지 않았군요. 사실 이는 간단합니다. 배열의 `n` 번째 원소의 접근하기 위해서는 `arr[n-1]` 와 같이 써 주시면 됩니다. 즉, 대괄호[] 안에 접근하고자 하는 원소의 (번째수 `- 1)` 을 써주면 되죠. 예를 들어서

```cpp-formatted
printf("Array 3 번째 원소 : %d \n ", arr[2]);
```

  이라고 하면 배열의 3 번째 원소인 3 를 출력하게 됩니다. 많은 사람이 헷갈리는 부분인데, `arr[2]` 라고 하게되면 배열의 2 번째 원소인 2 를 출력하게 될 줄이라고 생각하지만 사실 3 번째 원소가 출력되게 됩니다. 즉, `arr[0]` 은 배열의 첫 번째 원소인 1 이 출력되고 `arr[9]` 는 배열의 10 번째 원소인 10 이 출력되게 됩니다.

 만일 `arr[10]` 을 출력하려 한다면 무엇을 출력하게 될 까요? 한 번 해보세요. 아마도 아래와 같은 달콤한 애러 메세지를 볼 수 있게 될 것입니다.


![무지막지한 애러가 뜹니다!!](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1456860E4ABA0273294E93)

  이는 배열의 존재하지도 않는 10 번째 원소를 참조하였기에 메모리 오류가 발생했다는 것 입니다. 사실, "배열의 10 번째 원소는 존재하지도 않으니, 우리가 참조한다면 0 과 같은 값들을 나타내면 되는데, 왜 위와 같이 껄렁한 오류 메세지를 출력하는 것인가?' 라고 생각할 것입니다. 그러기 위해선, 컴퓨터 상에 배열이라는 것이 어떻게 나타나게 되는이 알아야 합니다.



###  메모리 상에서의 배열

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F167AEA0F4ABA04DB7B5741)

이미 [3강](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-3-%EB%B3%80%EC%88%98%EA%B0%80-%EB%AD%90%EC%A7%80)에서도 다루었는데, 이 강의에서 저는 컴퓨터 메모리(RAM) 을 '직사각형 방이 쭉 나열되어 있는 형태' 로 표현하기로 했습니다. 사실 이는 다른 책들에서도 많이 이렇게 표현하므로 알아 두시는 것이 좋습니다. 이전 강의에서는 한 방의 크기가 1 바이트 였으므로 `int` 형의 경우 4 바이트를 차지하므로 배열의 한 원소를 표현하기 위해서는 4 칸을 차지해야 할 것입니다. 하지만, 각 4 개의 방을 모두 그리는 것이 힘들어서 메모리 한 칸을 그냥 4 바이트라고 합시다. 이 때, 위 배열 `arr` 의 경우 원소의 개수가 10 개 이므로 10 칸의 방을 차지하게 됩니다. (아쉽게도 그림 상에서는 모두 표현하지 못했으나 '…' 로 표현해 여러분의 상상력을 자극하고 있습니다 ㅎㅎ)

그런데, 메모리에 위 배열 하나만이 저장되어 있는 것일까요? 물론 아닙니다. 이 프로그램을 실행하는데 조차 수천개의 변수들의 메모리 상에 적재되어 이리저리 사라지고 저장되고 있습니다. 따라서 위 그림을 좀더 사실적으로 그리자면 아래와 같습니다.

![직사각형 방 안에 1 과 10 이 연속적으로 쭉 각 방에 들어가 있습니다.](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F1321760F4ABA074B56A3A4)

즉, `arr[0]` 의 앞과 `arr[9]` 뒤에는 아무것도 없는 것이 아니라 다른 변수의 값들이 저장되고 있다는 사실 입니다. (물론 중간의 … … 에서는 `arr[1]` 부터 `arr[8]` 까지 '연속적' 으로 놓여있습니다.)  따라서, 훌륭한 운영체제라면 초짜 프로그래머가 다른 변수의 값들을 침범하는 것을 막기 위해 허락되지 않는 접근이 감지된다면 위와 같이 `Run-Time` 오류를 발생시키는 것이 정석입니다. 생각해 보세요. 당신이 스타를 하는데 미네랄이 갑자기 1000 에서 4 로 줄어든다면 기분이 어떻겠습니까?


###  배열 가지고 놀기


  이제 본격적으로 배열을 가지고 놀아 보기로 합시다.



```cpp-formatted
/* 배열 출력하기 */ #include <stdio.h> int main() {
  int arr[10] = {2, 10, 30, 21, 34, 23, 53, 21, 9, 1};
  int i;
  for (i = 0; i < 10; i++) {
    printf("배열의 %d 번째 원소 : %d \n", i + 1, arr[i]);
  }
  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F166860204ABA0BDD38FEDD)

  아마, 여태까지 배운 내용을 잘 숙지하셨다면 위 소스를 어려움 없이 이해 하셨을 것이라고 생각합니다.

```cpp-formatted
int arr[10] = {2, 10, 30, 21, 34, 23, 53, 21, 9, 1};
```

일단, 배열의 정의 부분. `arr` 라는 원소를 10 개 가지는 `int` 형 배열을 선언한다라는 뜻이지요. 이 때, 각 원소의 값들은 중괄호 속에 있는 값들이 순차적으로 들어가므로 `2, 10, 30 ~ 9, 1` 까지 들어가게 됩니다.

```cpp-formatted
for (i = 0; i < 10; i++) {
  printf("배열의 %d 번째 원소 : %d \n", i + 1, arr[i]);
}
```

 이제, 배열의 원소들의 값들을 출력하는 부분 입니다. 잘 아시다싶이, `for` 문은 `i = 0` 부터 9 까지 1 씩 증가하면서 대입하는데 각 경우의 배열의 `i` 번째 원소를 출력하게 되므로 위 처럼 배열의 원소들의 값들이 출력되게 됩니다. 다시 한 번 기억하세요! 배열의 `n` 번째 원소를 참조하려면 `arr[n-1]` 로 입력해야 합니다!! `arr[n]` 이 '절대로' 아닙니다!

  여기서 우리는 배열의 장점을 알 수 있습니다. 위 프로그램을 배열 없이 작성한다고 생각해보세요. 우리는 10 개의 서로 다른 변수를 만들어서 각각을 출력하는 작업을 해야 했을 것 입니다. 아래 (더러운) 코드는 위 예제와 동일한 내용을 10 개의 변수를 잡아서 직접 출력한 것을 보여 줍니다.

```cpp-formatted
/* 더러운 코드 */
#include <stdio.h>
int main() {
  int a, b, c, d, e, f, g, h, i, j;
  a = 2;
  b = 10;
  c = 30;
  d = 21;
  e = 34;
  f = 23;
  g = 53;
  h = 21;
  i = 9;
  j = 1;

  printf("1 째 값 : %d \n", a);
  printf("2 째 값 : %d \n", b);
  printf("3 째 값 : %d \n", c);
  printf("4 째 값 : %d \n", d);
  printf("5 째 값 : %d \n", e);
  printf("6 째 값 : %d \n", f);
  printf("7 째 값 : %d \n", g);
  printf("8 째 값 : %d \n", h);
  printf("9 째 값 : %d \n", i);
  printf("10 째 값 : %d \n", j);

  return 0;
}
```

만일 여기에서 10 개의 변수의 값을 각각 입력받는 부분이라도 추가하라면 마우스라도 움켜 쥐고 울 것입니다. 하지만 배열을 이용하면 간단히 끝내 버릴 수 있습니다. 아래 예제 처럼 말이지요.

```cpp-formatted
/* 평균 구하기*/
#include <stdio.h>
int main() {
  int arr[5];  // 성적을 저장하는 배열
  int i, ave = 0;

  for (i = 0; i < 5; i++)  // 학생들의 성적을 입력받는 부분
  {
    printf("%d 번째 학생의 성적은? ", i + 1);
    scanf("%d", &arr[i]);
  }
  for (i = 0; i < 5; i++)  // 전체 학생 성적의 합을 구하는 부분
  {
    ave = ave + arr[i];
  }

  printf("전체 학생의 평균은 : %d \n",
         ave / 5);  // 평균이므로 5 로 나누어 준다.

  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F152576134ABA28307657D6)

사실, 위 평균 구하는 프로그램은 앞에서도 한 번 만들어 보았는데 이번에는 배열을 이용하여 프로그램을 만들어 보았습니다. 이전보다 오히려 더 복잡해진 느낌이지만, 학생 개개인의 성적을 변수로 보관하기 때문에 더 많은 작업들을 할 수 있게 되죠.

```cpp-formatted
for (i = 0; i < 5; i++)  // 학생들의 성적을 입력받는 부분
{
  printf("%d 번째 학생의 성적은? ", i + 1);
  scanf("%d", &arr[i]);
}
```

  위 소스에서 학생들의 성적을 입력받는 부분 입니다. 별다른 특징이 없습니다. 이전에 `scanf` 에서 &(변수명) 형태로 값을 입력 받았는데 배열도 마찬가지로 같습니다. (이 부분에 대해서는 나중에 좀 더 자세히 다루도록 하지요. 왜 `&(arr[i])` 로 안해도 상관이 없는지...) 배열도, `&arr[i]` 로 쓰면 `arr` 배열의 (i+1) 번째 원소에 입력을 받게 됩니다. 이 때, `arr` 이 `int` 형 배열이기에 각 원소도 모두 `int` 형 이므로 `%d` 를 사용하게 되지요.

```cpp-formatted
for (i = 0; i < 5; i++)  // 전체 학생 성적의 합을 구하는 부분
{
  ave = ave + arr[i];
}
```

 이제 `ave` 에 배열의 각 원소들의 합을 구하는 부분 입니다. 배열도 변수의 모음이기에, 각 원소들은 모두 변수처럼 사용 가능합니다. 물론 배열의 각 원소들끼리의 연산도 가능합니다. 예를 들어서

```info
 ave[4] =  ave[3] + ave[2] * i + ave[1]/i;
```

  와 같이 해도 `ave[4]` 는 정확한 값이 들어가게 되지요. 마지막으로

```cpp-formatted
printf("전체 학생의 평균은 : %d \n", ave / 5);
```

  라 하면 전체 학생들의 평균을 구할 수 있게 됩니다.

  자, 그렇다면 아까 위의 친구가 부탁했던 프로그램을 만들 수 있는 수준까지 도달할 수 있겠습니다. 한 번 여러분이 짜보고 제가 만든 소스코드와 비교해 보는 것도 좋은 방법 인 것 같습니다. (참고로 저는 학생을 30 명으로 하면 처음에 데이터 입력하기가 너무 힘들어서 그냥 10 명으로 했으니 여러분은 마음대로 하시기 바랍니다.)

```cpp-formatted
소스 보기
  /* 친구의 부탁 */ #include<stdio.h> int
  main() {
  int arr[10];
  ;
  int i, ave = 0;
  for (i = 0; i < 10; i++) {
    printf("%d 번째 학생의 성적은? ", i + 1);
    scanf("%d", &arr[i]);
  }
  for (i = 0; i < 10; i++) {
    ave = ave + arr[i];
  }
  ave = ave / 10;
  printf("전체 학생의 평균은 : %d \n", ave);
  for (i = 0; i < 10; i++) {
    printf("학생 %d : ", i + 1);
    if (arr[i] >= ave)
      printf("합격 \n");
    else
      printf("불합격 \n");
  }
  return 0;
}
```

성공적으로 컴파일 하였다면 아래와 같은 화면을 볼 수 있을 것입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F130B131B4ABA2CB0625A29)

유후! 어때요. 잘 출력되는 지요.

```cpp-formatted
for (i = 0; i < 10; i++) {
  printf("학생 %d : ", i + 1);
  if (arr[i] >= ave)
    printf("합격 \n");
  else
    printf("불합격 \n");
}
```

사실, 위 소스는 앞에서 보았던 우리의 평균 구하는 소스에 약간 더해서 만든 것 이므로 위 부분만 살펴 보면 되겠습니다. `i` 가 0 부터 9 까지 가면서 배열의 각 원소들을 `ave` 와 비교하고 있습니다. 만약, `ave` 이상이라면 합격, 그렇지 않다면 불합격을 출력하게 말이지요. 솔직히 이 정도 수준의 프로그램 소스는 이제 더이상 설명해 줄 필요가 없어진 것 같습니다. (저만 그런가요? 만약 그렇지 않다면 이전의 강의들을 다시 한 번 정독하기를 강력하게 권합니다)



###  소수 찾는 프로그램


이번에는 배열을 활용한 프로그램을 하나 더 살펴 보겠습니다. 이번 프로그램은 '배열' 을 활용한 소수 찾는 프로그램 입니다. **소수(prime number)**는 1 과 자신을 제외한 약수가 하나도 없는 수를 일컫습니다.

예를 들어, 2 와 3 은 소수 이지만 4 는 2 가 약수 이므로 소수가 아니지요. 또한 1 도 소수가 아닙니다. 아무튼, 소수를 찾는데 배열을 활용한다는 것은 이전에 찾은 소수들을 배열에 저장하여, 어떠한 수가 소수인지 판별하기 위해 그 수 이하의 소수들로 나누어 본다는 뜻입니다.

만일, 그 수 이하의 모든 소수들로 나누었는데 나누어 떨어지는 것이 없다면 그 수는 소수가 됩니다.또한, 짝수 소수는 2 가 유일하므로 홀수들에 대해서만 계산하도록 합니다 . 또한, 짝수 소수는 2 가 유일하므로 홀수들에 대해서만 계산하도록 합니다.

 이러한 아이디어를 바탕으로 프로그램을 짜 보겠습니다. 여러분은 아래 제가 구현한 코드를 보지 말고 한 번 스스로 해보시기 바랍니다. 참고로 저의 프로그램은 소수를 1000 개 만 찾습니다.

```cpp-formatted

/* 소수 프로그램 */
#include <stdio.h>
int main() {
  /* 우리가 소수인지 판별하고 있는 수 */
  int guess = 5; /* 소수의 배열 */
  int prime[1000]; /*    현재까지 찾은 (소수의 개수 - 1)    아래 두 개의 소수를
                      미리 찾았으므로    초기값은 1 이 된다.    */
  int index = 1; /* for 문 변수 */
  int i;         /* 소수인지 판별위해 쓰이는 변수*/
  int ok;        /* 처음 두 소수는 특별한 경우로 친다 */
  prime[0] = 2;
  prime[1] = 3;
  for (;;) {
    ok = 0;
    for (i = 0; i <= index; i++) {
      if (guess % prime[i] != 0) {
        ok++;
      } else {
        break;
      }
    }
    if (ok == (index + 1)) {
      index++;
      prime[index] = guess;
      printf("소수 : %d \n", prime[index]);
      if (index == 999) break;
    }
    guess += 2;
  }
  return 0;
}
```



성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F1123480E4AFE16256DBA49)

와 같이 소수가 쭉 나오는 것을 볼 수 있습니다. 일단 위 소스코드의 핵심적인 부분만 설명해 보도록 하겠습니다.

```cpp-formatted
for (i = 0; i <= index; i++) {
  if (guess % prime[i] != 0) {
    ok++;
  } else {
    break;
  }
}
```

위 부분은 `guess` 이하의 모든 소수들로 나누어 보고 있는 작업 입니다. `index` 는 `(배열에 저장된 소수의 개수 - 1)` 인데 `prime[i]` 로 접근하고 있으므로 배열의 모든 소수들로 나누어 보게 됩니다. 

만일 `guess` 가 `prime[i]` 로 나누어 떨어지지 않는다면 `ok` 를 1 증가 시킵니다. 그리고 나누어 떨어진다면 소수가 아니므로 바로 `break` 되서 루프를 빠져 나가게 됩니다. 만일 `ok` 가 `prime` 배열에 저장된 소수의 개수, 즉 `(index + 1)`과 같다면 자기 자신 미만의 모든 소수들로도 안 나누어 떨어진다는 뜻이 되므로 소수가 됩니다.

이 때, 주의해야 할 점은 한 개의 수를 검사할 때 마다 `ok` 가 0 으로 리셋되어야 합니다. 그렇지 않다면 정확한 결과를 얻을 수 없겠죠?

```cpp-formatted
if (ok == (index + 1)) {
  index++;
  prime[index] = guess;
  printf("소수 : %d \n", prime[index]);
  if (index == 999) break;
}
```

따라서, 위와 같이 `index` 를 하나 더 증가시킨 후 `prime[index]` 에 `guess` 를 추가 시켜 줍니다. 만일 `index` 가 999 가 된다면 배열이 꽉 찼단 뜻이 되므로 `break` 를 해서 `for(;;)` 를 빠져 나가게 됩니다. 어때요? 배열을 이용하여 정말 많은 일을 할 수 있지요?



###  배열의 중요한 특징

  만약 똑똑한 사람이라면 다음과 같이 생각할 수 있을 것 입니다.

  "처음에 배열의 원소의 수를 숫자로 지정하지 않고 변수로 지정해도 될까? 예를 들어 `arr[i]` 라던지 말이야. 그렇게 된다면 위 프로그램에서 반의 총 학생 수를 입력 받아서 딱 필요한 데이터만 집어 넣으면 되잖아?"

 그렇다면, 그의 아이디어를 빌려서 프로그램을 만들어 봅시다.

```cpp-formatted
/* 과연 될까? */
#include <stdio.h>
int main() {
  int total;
  printf("전체 학생수 : ");
  scanf("%d", &total);
  int arr[total];
  int i, ave = 0;

  for (i = 0; i < total; i++) {
    printf("%d 번째 학생의 성적은? ", i + 1);
    scanf("%d", &arr[i]);
  }
  for (i = 0; i < total; i++) {
    ave = ave + arr[i];
  }

  ave = ave / total;
  printf("전체 학생의 평균은 : %d \n", ave);

  for (i = 0; i < total; i++) {
    printf("학생 %d : ", i + 1);
    if (arr[i] >= ave)
      printf("합격 \n");
    else
      printf("불합격 \n");
  }

  return 0;
}
```

  만약 컴파일 한다면 아래에 수많은 오류가 쏟아져 나오는 것을 볼 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F12553F0C4ABA2FE43E64ED)

왜 오류가 나올까? 라고 고민한다면 [3강](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-3-%EB%B3%80%EC%88%98%EA%B0%80-%EB%AD%90%EC%A7%80) 맨 아래 부분을 다시 보시길 바랍니다. \sidenote{2018년 현재, 더이상 변수를 최상단에 선언하지 않아도 됩니다. 아마 오류가 발생하지 않을 것입니다.}

왜냐하면 변수는 무조건 최상단에 선언되야 되기 때문입니다! 위와 같이 배열 `arr` 과 변수 `i, ave` 가 변수 선언문이 아닌 다른 문장 다음에 나타났으므로 C 컴파일러는 무조건 오류로 처리하게 됩니다. (물론 C++ 에서는 가능합니다)

아아. 애초에 사람이 입력하는 대로 배열의 크기를 임의로 정할 수 는 없는 것이였군요. 그렇다면, 그냥 변수 크기 지정시 특정한 값이 들어있는 변수가 가능한지 살펴 봅시다.

```cpp-formatted
/* 설마 이것도? */
#include <stdio.h>
int main() {
  int total = 3;
  int arr[total];
  int i, ave = 0;

  for (i = 0; i < total; i++) {
    printf("%d 번째 학생의 성적은? ", i + 1);
    scanf("%d", &arr[i]);
  }
  for (i = 0; i < total; i++) {
    ave = ave + arr[i];
  }

  ave = ave / total;
  printf("전체 학생의 평균은 : %d \n", ave);

  for (i = 0; i < total; i++) {
    printf("학생 %d : ", i + 1);
    if (arr[i] >= ave)
      printf("합격 \n");
    else
      printf("불합격 \n");
  }

  return 0;
}
```

  과연 성공할까요?


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F207CED0C4ABA314D017E44)

  아아. 역시 우리의 기대를 처절하게 저버리고 오류를 내뿜는 컴파일러.

이는 C 언어에 처음에 배열의 크기를 변수를 통해 정의할 수 없게 규정하고 있기 때문입니다. (사실, '동적 할당' 이라는 방법으로 억지로 해서 정의할 수 있으나 이 부분에 대한 이야기는 나중에 다루도록 합시다.) 왜냐하면 처음에 컴파일러가 배열을 처리할 대 메모리 상에 공간을 잡아야 하는데 이 때, 잡아야 되는 공간의 크기가 반드시 상수로 주어져야 하기 때문입니다. 지금 수준에서 깊게 설명하는 것은 너무 무리인 것 같으니 그냥 '배열의 크기는 변수로 지정할 수 없다' 정도로 넘어가도록 합시다.



###  상수 (Constant)

상수는 변수의 정반대로 처음 정의시 그 값이 바로 주어지고, 그 값이 영원히 바뀌지 않습니다.

```cpp-formatted
/* 상수 */
#include <stdio.h>
int main() {
  const int a = 3;

  printf("%d", a);
  return 0;
}
```

  만약 성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F185FBD154ABA3C4C611986)

  와 같이 나오게 됩니다. 상수는 아래와 같이 정의합니다.

```info
  const (상수의 형) (상수 이름) = (상수의 값);
```

  위 소스의 경우, `a` 라는 이름의 `int` 형 상수이고 그 값은 3 이라는 것을 나타내고 있습니다.

```cpp-formatted
const int a = 3;
```

상수라고 해서 꼭 특별한 것이 있는 것은 아닙니다. 단지, 처음에 한 번 저장된 값은 '절대로' 변하지 않는 다는 점일 뿐이지요. 그렇기 때문에 처음 상수를 정의시 값을 정의해 주지 않는다면

```cpp-formatted
#include <stdio.h>
int main() {
  const int a;

  printf("%d", a);
  return 0;
}
```

와 같이 컴파일시 아래와 같이 나타나게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F18365B194ABA3CF133CD49)

상수는 또한 그 특성 답게 그 값 자체를 바꿀 수 없습니다. 예를 들어서

```cpp-formatted
#include <stdio.h>
int main() {
  const int a = 2;

  a = a + 3;
  printf("%d", a);
  return 0;
}
```

  를 한다면,


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F11435E174ABA3D786ED89C)

  와 같은 오류가 발생하게 됩니다. 즉, 상수는 어떠한 짓으로도 값을 변경할 수 없는 불멸의 데이터 입니다. 이러한 특성 때문에 여러분은 아마 '배열의 크기를 상수로 지정할 수 는 없을까?' 라는 생각을 하게 됩니다. 하지만, 아래와 같은 코드를 보면 이러한 생각이 깨지게 되죠.

```cpp-formatted
#include <stdio.h>
int main() {
  int b = 3;
  const int a = b;
  char c[a];
  return 0;
}
```

즉, 이는 상수 `a` 로 배열의 크기가 할당이 가능하게 된다면 다시 말해 변수 `b` 의 크기로 배열의 크기를 지정할 수 있다는 말이 되기 때문에 이전에 '변수로 배열의 크기를 지정할 수 없다' 라는 사실에 모순 됩니다.

컴퓨터 프로그래밍을 하다 보면 상수를 사용할 일이 꽤나 많습니다. 예를 들어서 계산기 프로그램을 만들 때 에는 `Pi` 의 값을 상수로 지정해 놓게 된다면 변수로 지정할 때 보다 훨씬 안전해지게 됩니다. 왜냐하면 변수로 `Pi` 의 값을 지정했을 때, 프로그래머가 코딩상의 실수로 그 값을 바꾼다면 찾아낼 도리가 없지만, 상수로 지정시에 그 값을 실수로 바꾸도록 코딩을 해도 애초에 컴파일러가 오류를 뿜기 때문에 오류를 미연에 방지할 수 있습니다.



### 초기화 되지 않은 값

우리가 변수의 값을 초기화 하지 않는다면 그 변수는 무슨 값을 가질 까? 라는 생각을 한 분들이 많을 것 같습니다. 0 을가질까요? 아닙니다. 0 도 값 이지 않습니까? 0 을 가진다면 0 이라는 값을 가진다는 것 이지요? 그렇다면 한 번 해보지요.값이 대입되지 않은 변수의 값을 출력해보는 프로그램을 짜보면 아래와 같습니다.

```cpp-formatted
#include <stdio.h>
int main() {
  int arr;

  printf("니 값은 모니 : %d", arr);
  return 0;
}
```

컴파일 해보면 아래와 같은 경고를 볼 수 있습니다.

```warning
warning C4700: 초기화되지 않은 'arr' 지역 변수를 사용했습니다.
```

아마, 심상치 않지만 그래도 오류가 없으니 실행은 해볼 수 있겠군요. 아마  실행해 보면 아래와 같은 모습을 보실 수 있을 것 입니다.


![무지막지한 오류가!!](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F207CCB194AF44121121269)

  아니 이럴수가! 변수 `arr` 의 값을 보기위해 값을 출력하려고 했더니만, 런타임 오류(프로그램 실행 중에 발생하는 오류)가발생하군요. 운영체제는 초기화 되지 않은 변수에 대한 접근 자체를 불허하고 있습니다. 이 때문에 우리는 이 변수에 들어있는 값을영영 보지 못하게 됩니다.

```cpp-formatted
/* 초기화 되지 않은 값 */
#include <stdio.h>
int main() {
  int arr[3];
  arr[0] = 1;
  printf("니 값은 모니 : %d", arr[1]);  // arr[0] 이 아닌 arr[1] 을 출력

  return 0;
}
```

  이번에는 배열의 경우를 살펴 봅시다. 상콤한 기분으로 컴파일을 했으나,

```warning
warning C4700: 초기화되지 않은 'arr' 지역 변수를 사용했습니다.
```

와 같은 경고가 발생합니다. 심지어 앞 예제에서 발생했던 경고와 번호(C7400)와 동일하군요. 불안감에 사로잡혀 실행해보면.. 아니나 다를까 아래와 같은 오류 메세지 창을 보게 됩니다.


![또 오류!!!](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1636490D4AF444254CDCC5)

  역시, `arr[1]` 의 값은 정의되어 있지 않기 때문에 이 값을 출력할 생각은 꿈도 꾸지 말라는 것이라는 것이죠. 참으로 야속한 컴퓨터 입니다.

```cpp-formatted
/* 초기화 되지 않은 값 */
#include <stdio.h>
int main() {
  int arr[3] = {1};
  printf("니 값은 모니 : %d", arr[1]);

  return 0;
}
```


이번에는 마지막으로 거의 자포자기 한 심정으로 위 소스를 컴파일 해 봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1108570F4AF4455E71AD75)

오잉! 경고도, 오류도 나타나지 않습니다. 더군다나, 0 이라는 값이 출력되었습니다! 놀랍군요. 우리는 위 문장에서 `arr[1]` 에 0 을 집어 넣는 다는 말은 한 번이라도 하지 않았습니다. 사실 여러분은 위와 같이 배열을 정의한데에 놀랄 수도 있습니다. 배열의 원소는 3 개나 있는데 값은 오직 1 개 밖에 없기 때문이죠. 하지만 여러분들은 위 문장이 다음과 같은 역할을 한다는 것은 직감적으로 알 수 있습니다.

```info
int arr[3];
arr[0] = 1;
```

물론 맞는 말 입니다. `printf` 부분을 `arr[0]` 출력으로 바꾸어 보면 여러분이 생각했던 대로 1 이 출력됩니다. 하지만, `arr[1]` 이 도대체 왜 오류가 나지 않는 것일까요? 아까전에  `int arr[3]; arr[0] = 1;` 방법으로 해서 끔찍한 오류가 발생되는 것을 여러분이 두 눈으로 톡톡히 보셨지 않습니까? 그 이유는

```cpp-formatted
int arr[3] = {1};
```

와 같이 정의한다면 컴파일러가 내부적으로 아래와 같이 생각하기 때문입니다.

```cpp-formatted
int arr[3] = {1, 0, 0};
```

따라서, 자동적으로 우리가 특별히 초기화 하지 않은 원소들에는 0 이 들어가게 됩니다.

그렇다면

```cpp-formatted
int arr2[5] = {1, 2, 3};
```

은 어떻게 될까요? 역시, 해보면

```cpp-formatted
int arr2[5] = {1, 2, 3, 0, 0}
```

과 같이 한 것과 똑같이 됩니다.

이상으로, 배열에 대한 첫 번째 강의를 마치도록 하겠습니다. 아직 여러분은 배열에 대해 모든것을 다 알고 계신 것은 아닙니다. 다음 강의에서는 더욱 놀라운 배열의 기능을 알아 보도록 합시다.

### 생각해 볼 문제

#### 문제 1

위 입력받는 학생들의 성적을 높은 순으로 정렬하는 프로그램을 만들어 보세요.

#### 문제 2

입력받은 학생들의 성적을 막대 그래프로 나타내는 프로그램을 만들어 보세요.

##@ chewing-c-end
Link :  23
2009-11-09 16:10
----------------
title : 씹어먹는 C 언어 - <12 - 1. 포인터는 영희이다! (포인터)>
cat_title : 12 - 1. 포인터는 영희이다! (포인터)
next_page : 24
publish_date : 2009-11-09 16:10
--------------


이번 강좌에서는

* 포인터에 대한 완벽한 이해

* `*, &` 단항 연산자의 의미


![씹어먹는 C 언어](/img/ChewingClogo.png)

우왕~ 안녕하세요 여러분. 아마 C 언어를 배웠거나 배우고 있는 사람들은 포인터에 대해 익히 들어 보셨을 것 입니다. 이해하기 힘들기로 악명 높은 그 포인터를 말이죠. 하지만, 저와 함께 한다면 큰 무리 없이 배우 실 수 있을 것이라 생각됩니다.


###  포인터를 이해하기 앞서


앞서 3 강에서 이야기 하였지만 모든 데이터들은 메모리 상에 특정한 공간에 저장 되어 있습니다. 우리는 앞으로 편의를 위해, 메모리의 특정한 공간을 '방' 이라고 하겠습니다. 즉, 각 방에는 데이터들이 들어가게 되는 것 입니다. 보통 사람들은 한 방의 크기를 1 바이트 라고 생각합니다. 우리가 만약 `int` 형 변수를 정의한다면 4 바이트 이므로 메모리 상의 4 칸을 차지하게 됩니다. 그런데 말이죠. 프로그램 작동 시 컴퓨터는 각 방에 있는 데이터를 필요로 하게 됩니다. 따라서, 서로 구분하기 위해 각 방에 고유의 **주소(address)** 를 붙여 주었습니다. 우리가 아파트에서 각 집들을 호수로 구분하는 것 처럼 말입니다. 예를 들어 우리가 아래와 같은 `int` 변수 `a` 를 정의하였다면 특정한 방에 아래 그림 처럼 변수 `a` 가 정의됩니다.

```cpp-formatted
int a = 123;  // 메모리 4 칸을 차지하게 한다.
```

![메모리에 123 이란 수가 있고 이 수는 메모리에 0x152839 (앞에 0x 는 이 수가 16 진수로 표시되었다는 것을 의미해요 에 위치](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1369D1164AF9739C0ED550)


이 때, `0x152839` 는 제가 아무렇게나 정한 이 방의 시작 주소 입니다. 참고로, `0x` 가 뭐냐고 물어보는 사람들이 있을 텐데, 이전 강좌에서도 이야기 하였지만 16 진수라고 표시한 것 입니다. 즉, 16 진수로 `152839` (10 진수로 1386553) 라는 위치에서 부터 4 바이트의 공간을 차지하며 123 이라는 값이 저장되어 있게 하라는 뜻이지요.

그렇다면 아래와 같은 문장은 어떻게 수행 될까요?

```cpp-formatted
a = 10;
```

사실 컴파일러는 위 문장을 아래와 같이 바꿔주게 됩니다.

메모리 `0x152839` 위치에서 부터 4 바이트의 공간에 있는 데이터를 10 으로 바꾸어라!

결과적으로, 컴퓨터 내부에서는 올바르게 수행되겠지요.

참고적으로 말하는 이야기 이지만 현재 (아마 이 블로그에 접속하는 사람들 중 99% 이상이) 많은 사람들은 32 비트 운영체제를 사용하고 있습니다. \sidenote{참고로 강좌가 처음 제작된 년도가 2009년 입니다. 지금 (2018년 이후) 이 글을 보시는 분들은 아마 대부분 64 비트 운영체제를 사용하고 있을 것입니다.} 이 32 비트에서 작동되는 컴퓨터들은 모두 주소값의 크기가 32 비트 (즉, 4 바이트.. 까먹었다면 2 - 3 강 참조) 로 나타내집니다. 즉 주소값이 `0x00000000 ~ 0xFFFFFFFF` 까지의 값을 가진다는 것이지요.

어랏! 조금 똑똑하신 분들이라면 32 비트로 사용할 수 있는 주소값의 가지수는 2 의 32 승 바이트, 즉 RAM 은 최대 4 GB 까지 밖에 사용할 수 없다는 사실을 알 수 있습니다. 맞습니다. 이 때문에 32 비트 운영체제에서는 RAM 의 최대 크기가 4 GB 로 제한되지요(즉, 돈을 많이 들여서 RAM 을 10GB 로 만들어도 컴퓨터는 4 GB 까지 밖에 인식하지 못합니다. 어찌 이렇게 슬플수가..)

여기까지는 상당히 직관적이고 단순해서 이해하기 쉬웠을 것 입니다. 그런데 C 를 만든 사람은 아주 유용하면서도 골때리는 것을 하나 새롭게 만들었습니다. 바로 '포인터(pointer)' 입니다. 영어를 잘하는 분들은 이미 아시겠지만 '포인터' 라는 단어의 뜻이 '가리키는 것(가르켜지는 대상체를 말하는 것이 아닙니다)' 이란 의미를 가지고 있습니다.

사실, 포인터는 우리가 앞에서 보았던 `int` 나 `char` 변수들과 다른 것이 전혀 아닙니다. 포인터도 '변수' 입니다. `int` 형 변수가 정수 데이터, `float` 형 변수가 실수 데이터를 보관했던 것 처럼, 포인터도 특정한 데이터를 보관하는 '변수' 입니다. 그렇다면 포인터는 무엇을 보관하고 있을 까요?

바로, 특정한 데이터가 저장된 주소값을 보관하는 변수 입니다. 여기서 강조할 부분은 '주소값' 이라는 것 이지요. 여기서 그냥 머리에 박아 넣어 버립시다. 이전에 다른 책들에서 배운 내용을 싹 다 잊어 버리고 그냥 망치로 때려 넣듯이 박아버려요. 포인터에는 특정한 데이터가 저장된 주소값을 보관하는 변수 라고 말이지요. 크게 외치세요. '주소값!!!!!'

암튼, 뇌가 완전히 세뇌되었다고 생각하면 다음 단계로 넘어가도록 하겠습니다. 아직도 이상한 잡념이 머리에 남아 있다면 크게 숨을 호흡하시고 주소값이라고 10 번만 외쳐 보세요..

자. 되었습니다. 이제 포인터의 세계로 출발해 봅시다. 뿅


###  포인터

다시 한 번 정리하자면

```info
"포인터" : 메모리 상에 위치한 특정한 데이터의(시작)주소값을 보관하는 변수!
```

우리가 변수를 정의할 때 `int` 나 `char` 처럼 여러가지 **형(type)** 들이 있었습니다. 그런데 놀랍게도 포인터에서도 형이 있습니다. 이 말은 포인터가 메모리 상의 `int` 형 데이타의 주소값을 저장하는 포인터와, `char` 형 데이터의 주소값을 저장하는 포인터가 서로 다르다는 말입니다. 응?? 여러분의 머리속에는 아래와 같은 생각이 번개 처럼 스쳐 지나갈 것입니다.

"야 이 Psi 같은 놈아. 아까 포인터는 주소값을 저장하는 거래며. 근데 우리가 쓰는 컴퓨터에선 주소값이 무조건 32 비트, 즉 4 바이트래며!! 그러면 포인터의 크기는 다 똑같은것 아냐? 근데 왜 포인터가 형(type)을 가지는 건데!! 아아아아악"

휴우우. 진정좀 하시고. 여러분 말이 백번 맞습니다 - 단, 현재 까지 배운 내용을 가지고 생각하자면 말이지요. 포인터를 아주 조금만 배우면 왜 포인터에 형(type) 이 필요한지 알게 될 것입니다.

C 언어에서 포인터는 다음과 같이 정의할 수 있습니다 C 언어에서 포인터는 다음과 같이 정의할 수 있습니다.

```info
(포인터에 주소값이 저장되는 데이터의 형) *(포인터의 이름);
```

혹은 아래와 같이 정의할 수 도 있습니다.

```info
(포인터에 주소값이 저장되는 데이터의 형)* (포인터의 이름);
```

예를 들어 `p` 라는 포인터가 `int` 데이터를 가리키고 싶다고 하면

```cpp-formatted
int* p;  // 라고 하거나
int* p;  // 로 하면 된다
```

라 하면 올바르게 됩니다. 즉 위 포인터 `p` 는 `int` 형 데이터의 주소값을 저장하는 변수가 되는 것 입니다. 와우!



###  & 연산자


그런데 말입니다. 아직도 2% 부족합니다. 포인터를 정의하였으면 값을 집어 넣어야 하는데, 도대체 우리가 데이터의 주소값을 어떻게 아냐는 말입니까? 하지만, 여러분의 이러한 욕구를 충족시키는 연산자가 C 에 (당연히) 있습니다. 바로 `&` 연산자 이지요.

그런데, 아마 복습을 철저하게 잘하신 분들은 당황할 수 도 있습니다. 왜냐하면 `&` 가 `AND` 연산자이기 때문입니다. (4 강 참조) 그런데, `&` 연산자는 두 개의 피연산자를 필요로 했습니다. 즉,

```info
a & b; //o.k
a & // NOT ok
```

와 같이 언제나 2 개가 필요 하다는 것이지요. 그런데, 여기에서 소개할 `&` 연산자는 오직 피연산자가 1 개인 연산자 입니다. (이러한 연산자를 **단항(unary)** 연산자라 합니다) 즉, 위의 `AND` 연산자와 완전히 다르 다는 것이지요. 이는 데이터의 주소값을 불러 옵니다. 사용은 그냥 아래와 같은 꼴로 사용해 주면 됩니다.

```info
& (주소값을 계산할 데이터)
```

백설(說)이 불여일행(行). 한 번 프로그램을 짜 봅시다.

```cpp-formatted
/* & 연산자 */
#include <stdio.h>
int main() {
  int a;
  a = 2;

  printf("%p \n", &a);
  return 0;
}
```

성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F18569B154AF9782C8C0B93)

와 같이 나옵니다. 참고로, 여러분의 컴퓨터에 따라 결과가 다르게 나올 수 도 있습니다. 사실, 저와 정말 인연 이상의 무언가가 있지 않는 이상 전혀 다르게 나올 것 입니다. 더 놀라운 것은 실행할 때 마다 결과가 달라질 것입니다.

2 번째 실행한 것

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F20697E1C4AF9796F57FC1C)

위와 같이 나오는 이유는 나중에 설명하겠지만 주목할 것은 '값' 이 출력되었다는 것 입니다.

```cpp-formatted
printf("%x \n", &a);
```

위 문장에서 `&a` 의 값을 16 진수 형태 (`%p`) 로 출력하라고 명령하였습니다. 근데요. 눈치가 있는 사람이라면 금방 알겠지만 위에서 출력된 결과는 4 바이트(16 진수로 8 자리)가 아닙니다! (여러분의 컴퓨터는 다를 수 있습니다.) 하지만 저는 32 비트 운영체제를 사용하고 있습니다. 

그렇다면 뭐가 문제인가요? 사실, 문제는 없습니다. 단순히 앞의 0 이 잘린 것 이지요. 주소값은 언제나 4 바이트 크기, 즉 16 진수로 8 자리 인데 앞에 0 이 잘려서 출력이 안된 것일 뿐입니다. 따라서 변수 `a` 의 주소는 아마도 `0x001EF8D4` 가 될 것입니다. \sidenote{아마 지금(2018년 이후) 강좌를 보고 계시는 분들은 앞에서도 말했듯이 64 비트 시스템을 사용하고 계실 가능성이 높기 때문에, 4 바이트가 아니라 8 바이트 숫자가 출력될 것입니다.}

아무튼 위 결과를 보면, 적어도 제 컴퓨터 상에선 `int` 변수 `a` 는 메모리 상에서 `0x001EF8D4` 를 시작으로 4 바이트의 공간을 차지하고 있었다는 사실을 알 수 있습니다.

자, 이제 `&` 연산자를 사용하여 특정한 데이터의 메모리 상의 주소값을 알 수 있다는 사실을 알았으니 배고픈 포인터에게 값을 넣어 봅시다.

```cpp-formatted
/* 포인터의 시작 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;

  printf("포인터 p 에 들어 있는 값 : %p \n", p);
  printf("int 변수 a 가 저장된 주소 : %p \n", &a);

  return 0;
}
```

실행해 보면 많은 이들이 예상했던 것 처럼....


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1432D2044AF97AEE4FCF59)

똑같이 나옵니다. 어찌 보면 당연한 일입니다.

```cpp-formatted
p = &a;
```

에서 포인터 `p` 에 `a` 의 주소를 대입하였기 때문이죠. 참고로, 한 번 정의된 변수의 주소값은 바뀌지 않습니다. 따라서 아래 `printf` 에서 포인터 `p` 에 저장된 값과 변수 `a` 의 주소값이 동일하게 나오게 됩니다. 어때요. 쉽죠?



###  * 표

이제, 드디어 포인터의 핵심에 다다랐습니다. 현재 까지 우리가 배운 바로는 "포인터는 특정한 데이터의 주소값을 보관한다. 이 때 포인터는 주소값을 보관하는 데이터의 형에 `*` 를 붙임으로써 정의되고, `&` 연산자로 특정한 데이터의 메모리 상의 주소값을 알아올 수 있다" 까지 알고 있습니다. 참고로 아래에서 설명하는 `*` 는 앞서 포인터를 정의할 때 사용하였던 `*` 와 다른 의미를 지닌 다는 사실을 알고 있으세요.

앞서 `&` 연산자가 `2%` 부족한 부분을 채워준다고 했지만 안타깝게도 1% 가 남았습니다. 하지만 `*` 연산자가 이 1% 를 채워질 것 입니다.... 잠깐만. `*` 연산자?? 어디서 많이 들어본 것 같네요.. 맞아요. `*` 연산자도 `&` 처럼 피연산자를 2 개 가질 때 에는 곱셈 연산자로 사용됩니다. 즉

```info
a * b; // a 와 b 를 곱한다.
a *; // Not OK
```

하지만 이 연산자는 위 `&` 처럼 1 개의 피연산자를 가지는 단항 연산자 입니다. `*` 연산자는 쉽게 풀이하자면

```info
 "나(포인터)를 나에게 저장된 주소값에 위치한 데이터라고 생각해!"
```

라는 의미의 연산자 입니다. 한 번 아래 예제를 봅시다.

```cpp-formatted
/* * 연산자의 이용 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;
  a = 2;

  printf("a 의 값 : %d \n", a);
  printf("*p 의 값 : %d \n", *p);

  return 0;
}
```

성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F182446264AF97F1DB59C09)

가 됩니다.

```cpp-formatted
int *p;
int a;
```

일단 `int` 데이터를 가리키는 포인터 `p` 와 `int` 변수 `a` 를 각각 정의하였습니다. 평범한 문장 이지요.

```cpp-formatted
p = &a;
a = 2;
```

그리고 포인터 `p` 에 `a` 의 주소를 집어 넣었습니다. 그리고 `a` 에 2 를 대입하였습니다.

```cpp-formatted
printf("a 의 값 : %d \n", a);
printf("*p 의 값 : %d \n", *p);
```

일단 위의 문장은 단순 합니다. `a` 의 값을 출력하란 말이지요. 당연하게도 2 가 출력됩니다. 그런데, 아래에서 `*p` 의 값을 출력하라고 했습니다. `*` 의 의미는 앞서, "나를 나에 저장된 주소값에 해당하는 데이터로 생각하시오!" 로 하게 하는 연산자라고 하였습니다. 즉, `*p` 를 통해 "`p` 에 저장된 주소(변수 `a` 의 주소)에 해당하는 데이타, 즉 변수 `a`" 를 의미할 수 있게 되었습니다. 다시 말해 `*p` 와 변수 `a` 는 정확히 동일합니다. 즉, 위 두 문장은 아래 두 문장과 10000% 일치합니다.

```cpp-formatted
printf("a 의 값 : %d \n", a);
printf("*p 의 값 : %d \n", a);
```

마지막으로 `*` 와 관련된 예제 하나를 더 살펴 봅시다.

```cpp-formatted
/* * 연산자 */
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;
  *p = 3;

  printf("a 의 값 : %d \n", a);
  printf("*p 의 값 : %d \n", *p);

  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F16095C244AF980DA835149)

아마 많은 여러분들이 예상했던 결과 이길 바랍니다^^

```cpp-formatted
p = &a;
*p = 3;
```

위에서도 마찬가지로 `p` 에 변수 `a` 의 주소를 집어 넣었습니다. 그리고 `*p` 를 통해 "나에 저장된 주소(변수 `a` 의 주소)에 해당하는 데이터(변수 `a)` 로 생각하시오" 를 의미하여 `*p = 3` 은 `a = 3` 과 동일한 의미를 지니게 되었습니다. 어때요. 간단하지요? 이로써 여러분은 포인터의 50% 이상을 이해하신 것 입니다~~! 짝짝짝짝

자. 그럼 '포인터' 라는 말 자체의 의미를 생각해 봅시다. `int` 변수 `a` 와 포인터 `p` 의 메모리 상의 모습을 그리면 아래와 같습니다.


![포인터 p 도, a 도 메모리 상에 각각 존재합니다만, 그 위치에는 a 의 경우 3 이 있지만 p 의 경우 a 의 주소값이 있습니다.](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1618DD264AFA7A915E2A59)

참고로 주소값은 제가 임의로 정한 것 입니다.

즉, 포인터  `p` 는 `*` 를 통해 `a` 를 의미 할 수 (가리 킬 수) 있게 되었지요. 흔히 많은 책들은 포인터 `p` 가 변수 `a` 를 가리키고 있다 라고 말합니다. 사실 저는 이 말이 여러분에게 어렵게 다가올 까봐 여태까지 하고 있지 않았지만 아무튼, 포인터 `p` 에 어떤 변수 `a` 의 주소값이 저장되어 있다면 '포인터 `p` 는 변수 `a` 를 가리킨다' 라고 말합니다. 참고적으로 말하지만 포인터 또한 엄연한 변수 이기 때문에 특정한 메모리 공간을 차지합니다. 따라서 위 그림과 같이 포인터도 자기 자신만의 주소를 가지고 있지요.

이제 여러분들은 포인터에 왜 '형(type)' 이 필요한지 이야기 할 수 있는 단계가 되었습니다. (아마 여러분들 중 반 수 이상은 이미 짐작하고 계실 것 입니다.) 다시 말해 '형' 이 없다는 것은 포인터가 자신이 가리키고 있는 대상에 대해 어떠한 정보도 가지지 않아도 된다는 것 입니다. 여기서 포인터를 선언하기 위해 `pointer` 라는 저 만의 키워드를 이용했다고 합시다. (실제로 이런게 사용되는 것이 아닙니다;;;)

```cpp-formatted
int a;
pointer *p;
p = &a;
*p = 4;
```

자. 위 명령이 올바른 결과를 출력할까요? 포인터 `p` 에는 명백히 변수 `a` 의 '시작 주소' 가 들어 있습니다. '시작 주소' 란 말입니다. 즉, `*p` 라고 했을 때 포인터 `p` 에는 자신이 가리키는 대상의 시작 주소가 있지만 대상의 크기에 대한 정보가 없습니다. 헉! 컴퓨터는 `*p` 라고 했을 때 메모리에서 0x12345678 로 부터 (`&a` 가 0x12345678 이라 가정합시다) 몇 개의 바이트를 더 읽어 들어서 값을 변경해야 할 지 모른다는 말입니다. 결국 포인터는 쓸모 없게 됩니다.

하지만, 우리가 여태까지 해왔던 것 처럼

```cpp-formatted
int a;
int *p;
p = &a;
*p = 4;
```

라고 한다면 어떨 까요? 컴퓨터는 `0x12345678` 로 부터 포인터 `p` 가 `int *` 라는 사실을 보고 "아하. 이 포인터는 `int` 데이터를 가리키는 구나!" 라고 알게 되어 정확히 4 바이트를 읽어 들어 값을 바꾸게 됩니다. 따라서 정확한 값이 출력될 수 있겠지요.

여러분이 현재 까지 배운 내용에 대해 완벽하게 이해를 하고 있다면 아래와 같은 궁금증이 생길 것 입니다.

"야. 그런데 말야. 주소값은 무조건 4 바이트 잖아? 그러면 `int` *p; 처럼 귀찮게 `*` 을 붙이지 말고 `int` p; 라고 한다음에 `p = &a;` 라고 해도 상관 없는거 아니야? 그지? 그지? 그지?

훌륭한 생각입니다. 한 번 해봅시다.

```cpp-formatted
/* 될까? */
#include <stdio.h>
int main() {
  int p;
  int a;

  p = &a;
  a = 3;

  printf("*p 의 값? : %d \n", *p);

  return 0;
}
```

안타깝게도 `printf` 부분에서 아래와 같은 오류가 출력됩니다.

```warning
error C2100: 간접 참조가 잘못되었습니다.
```

사실, 우리가 현재 까지 배운 내용을 바탕으로 이해해 보자면 위에서 왜 오류가 발생하는지 이해하기 힘듦니다. 그냥 단순히 `*` 연산자는 포인터들에게만 적용된다는 사실만을 알아 두시면 감사하겠습니다.

```cpp-formatted
/* 포인터도 변수이다 */
#include <stdio.h>
int main() {
  int a;
  int b;
  int *p;

  p = &a;
  *p = 2;
  p = &b;
  *p = 4;

  printf("a : %d \n", a);
  printf("b : %d \n", b);
  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F160EB5154AF989F736E020)


```cpp-formatted
p = &a;
*p = 2;
p = &b;
*p = 4;
```

사실, 이런 예제까지 굳이 보여주어야 하나 하는 생각이 들었지만 그래도 혹시나 하는 마음에 했습니다. 앞에서도 말했듯이 포인터는 '변수' 입니다. 즉, 포인터에 들어간 주소값이 바뀔 수 있다는 것이지요. 위와 같이 처음에 `a` 를 가리켰다가, (즉 `p` 에 변수 `a` 의 주소값이 들어갔다가) 나중에 `b` 를 가리킬 수 (즉 `p` 에 변수 `b` 의 주소값이 들어감) 있다는 것 이지요. 뭐 특별히 중요한 예제는 아니였습니다만. 나중에 상수 포인터, 포인터 상수에 대해 이야기 하면서 다시 다루어 보도록 하겠습니다.

마지막으로, 강의를 마치며 여러분에게 포인터에 대해 완벽히 뇌리에 꽂힐 만한 동화를 들려드리겠습니다.

옛날 옛날에 대략 2 년 전에 (뭐.. 전 여러분과 옛날의 정의가 다릅니다ㅋ) 변철수, 변수철, 포영희라는 세 명의 사람이 OO 아파트에 살고 있었습니다.

```info
int chul, sue;
int *young;
```

그런데 말이죠. 포영희는 변철수를 너무나 좋아한 나머지 자기 집 대문 앞에 큰 글씨로 "우리집에 오는 것들은 모두 철수네 주세요" 라고 써 놓고 철수네 주소를 적어 놓았습니다

```info
young = &chul;

```

어느날 택배 아저씨가 영희네 집에 물건을 배달하러 왔다가 영희의 메세지를 보고 철수네에 가져다 주게 됩니다.

```info
*young = 3; // 사실 chul = 3 과 동일하다!
```

영희에 짝사랑이 계속 되다가 어느날 영희는 철수 보다 더 미남인 수철이를 보게 됩니다. 결국 영희는 마음이 변심하고 수철이를 좋아하기로 했죠. 영희는 자기 대문 앞에 있던 메세지를 떼 버리고 "우리집에 오는 것은 모두 수철이네 주세요." 라 쓰고 수철이네 주소를 적었습니다.

```info
young = &sue;
```

며칠이 지나 택배 아저씨는 물건을 배달하러 영희네에 왔다가 메세지를 보고 이번엔 수철이네에 가져다 줍니다.

```info
*young = 4; // 사실 sue = 4 와 동일하다
```

이렇게 순수한 사랑이 OO 아파트에서 모락 모락 피어났습니다..... 끝

```info
return 0; // 종료를 나타내는 것인데, 아직 몰라도 되요. (정확히 말하면 리턴...)

```

### 생각해 볼 문제

#### 문제 1

`*` 와 `&` 연산자의 역할이 무엇인지 말해보세요 (난이도 : 下)

#### 문제 2

`int **a;` 와 같은 이중 포인터(double-pointer) 에 대해 생각해 보세요 (난이도 : 中上)


##@ chewing-c-end
Link :  20
2009-10-29 10:45
----------------
title : 씹어먹는 C 언어 - <11 - 2. C 언어의 아파트2 (고차원의 배열)>
cat_title : 11 - 2. C 언어의 아파트2 (고차원의 배열)
next_page : 23
publish_date : 2009-10-29 10:45
--------------


이번 강좌에서는

* 2 차원 배열을 파악한다 2 차원 배열을 파악한다.
* 2 차원 배열이 메모리 상에 어떻게 나타나는지 파악한다 2 차원 배열이 메모리 상에 어떻게 나타나는지 파악한다.
* 3 차 이상의 고차원 배열을 파악한다 3 차 이상의 고차원 배열을 파악한다.

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요, 여러분. Psi 입니다. 아마 이쯤 되면 여태까지 공부하셨던 사람들 중 일부는 '아, 내 머리는 컴퓨터 언어를 배우기에 최적화 되어 있지 않나 보다' 하고 포기하는 사람들과 '오오... 내 맘대로 프로그램을 만들고 주물럭 주물럭 거릴 수 있는 것이 신기한데??' 하는 두 가지 부류의 사람들로 나뉘게 됩니다. 사실, 여기 까지 온 것 만으로도 정말 대단하다고 말 할 수 있습니다. 왜냐하면 인터넷을 통해 무언가 짬짬히 보아서 공부해 나가는 것은 쉬운 일이 아니기 때문이죠. 여러 게임의 유혹도 있고, 내가 이걸 배우는 시간에 채팅이나 하면 좋을 것을.. 와 같은 생각도 들기 때문이죠.

하지만, 저는 여러분이 조금만 더 힘을 내어 이러한 유혹을 이겨내고C 언어의 성 C 언어의 성지에 도달하시기 바랍니다. 사실 배열과 앞으로 나오는 포인터 부분만 넘어간다면 더이상 어려울 부분이 없기 때문이죠. 그 부분이 넘어가 C 언어 성지에 도달하게 되면, 윈도우 `API` 를 공부하여 실감나는 `2D` 게임도 만들고, `Direct X` 나 `OpenGL` 등을 공부해서 `3D` 게임 까지. 뿐만 아니라 소켓 프로그래밍을 공부한다면 친구들과 채팅할 수 있는 프로그램도 만들 수 있고 게임 서버들도 만들 수 있습니다.


그 뿐만이 아닙니다. 시스템 프로그래밍을 공부하면 후킹과 같은 방법을 통해 게임 핵도 만들고 (딱히 좋은 예는 아니지만, 유혹이 가지 않습니까? ㅎㅎㅎ), 리버스 엔지니어링을 공부해 크랙이나 키젠도 만들어 보고, 순위 조작도 해 볼 수 있습니다. 게다가 어셈블리어와 함께 공부한다면 운영체제 까지 정말 무궁무진한 세상이 열리는 것 입니다. 뿐만 아니라 더욱 놀라운 사실은 대부분의 전자 제품은 C 언어로 프로그램되어 있으므로 이를 조작하여 전기 밥솥에서 "굿모닝' 이라 던지 세탁기에서 비프음으로 '나비야~ 나비야~' 가 나올 수 도 있습니다.

C 언어를 배움으로써 얻을 수 있는 위 많은 것들을 쉽게 포기하실 것 입니까? 물론, 나가실 분은 조용히 뒤로가기를 누르셔도 상관 없습니다. 다만, 이 순간의 클릭이 당신의 앞날을 좌우 할 지도 모른다는 사실을 잊지 마세요. 그리고 참, 이전 내용이 기억이 나지 않는다고 머리를 쥐어 뜯지 마세요. 그냥 이전 강좌를 다시 보면 됩니다. 이전 강좌의 내용이 잘 기억이 나지 않는 것은 '지극히 정상' 이니 다시 한 번 읽어 보므로써 기억을 강화시키도록 하세요~~

암튼, 잡담을 끝내고 본론으로 들어가도록 합시다. 이전 강좌에서 배열은 변수 들의 모임이라고 했습니다. 이 때 `arr` 이라는 배열의 `i` 번째 원소를 참조 하기 위해선 `arr[i]` 라고 써야 한다는 것도 알았습니다. 그런데 똑똑한 사람이라면 이 아이디어를 확장해서 다음과 같은 생각을 할 수 도 있을 것 입니다.

```info
"배열의 배열을 만들면 어떨까? "
```

정말로 놀라운 생각 입니다. 일단 여기서 우리는 '배열의 배열'의 의미를 좀 더 명확하게 해야 겠습니다. 'int 형의 배열' 이란 말은 '배열의 각 원소가 `int` 형 변수 인 것!' 입니다.

그렇다면 'int 형의 배열의 배열' 이란 말은 무엇일까요? 이 말은, '배열의 각 원소가 `int` 형의 배열 인 것' 을 말합니다. C 언어 에서 이러한 형태의 배열을 정의하기 위해선 아래와 같이 하면 써주면 됩니다.

```cpp-formatted
(배열의 형) (배열의 이름)[?][?]; //위 경우 (배열의 형) 부분에 `int` 가 오면 된다.? 에는 임의의 수
```

이전에는 `(배열의 이름)[?]` 였지만 2 차원 배열은 옆에 `[?]` 하나가 더 붙었지요.
먼저 배열의 배열이 무엇인지 확실하게 알기 위해서 다음과 같은 배열을 정의해 봅시다.

```cpp-formatted
int arr[3][2];
```

앞에서 말했듯이 위 배열은 '배열의 각 원소 3 개가 원소를 2 개 가지는 `int` 형의 배열이고 이름은 `arr` 이다.' 을 의미 합니다. 따라서,


![배열을 원소로 하는 배열을 생각하면 됩니다. 즉, 원소가 두 개인 배열을 원소로 하여, 이 원소를 3 개 가진 배열이 바로 arr[3[2 에 해당하는 이차원 배열 입니다.  ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F197646024AE8E7E3483008)

가 됩니다.

즉, `arr[0]` 이라 하면 `int` 형의 원소를 2 개 가지는 배열을 말하는 것이며 그 배열의 원소는 각각 `arr[0][0], arr[0][1]` 이 되겠지요.

일차원 배열과 이차원 배열을 한 눈에 비교하자면 아래와 같습니다.


![arr[3 은 그냥 아파트에 집이 3개, arr[3[2 는 집이 3 개 인데, 각 집에 방이 2개 ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2075D8024AE8EB2657AF92)

어때요, 간단하죠? 따라서, `arr[m][n];` 과 같이 배열을 선언한다면 (`m` 과 `n` 은 임의의 정수값), `m * n` 개의 변수를 가지는 배열을 선언한 것이 됩니다.

그렇다면, 2 차원 배열을 가지고 무슨 짓을 할 수 있을 까요? 사실, 여러분도 이미 예상한 바 있지만 오히려 일차원 배열에 비해 활용도가 훨씬 높아지게 됩니다. 예를 들면, 33 명의 학생에 대해 국어, 수학, 영어, 과학 점수를 보관하는 배열을 만든다 (이전의 배열 하나만 이용해선 한 과목의 점수 밖에 보관할 수 없었죠) 도서 입출 관리 프로그램에서 개개의 도서에 대해서 이 도서를 빌려간 날짜, 반납한 날짜 등을 보관하는 배열을 만든다 등등이 있습니다.

아! 그런데 아직 왜 이러한 배열을 '2차원' 배열이라고 말하는지 이야기 하지 않았군요. 사실, 메모리에는 모든 배열이 일차원 배열과 다름없이 들어갑니다. 그런데, 아래 예제를 보고 나면 왜 '2차원' 배열이라 이야기 하는지 감이 확 올 것 입니다.

```cpp-formatted
/* 2 차원 배열 */
#include <stdio.h>
int main() {
  int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

  printf("arr 배열의 2 행 3 열의 수를 출력 : %d \n", arr[1][2]);
  printf("arr 배열의 1 행 2 열의 수를 출력 : %d \n", arr[0][1]);
  return 0;
}
```

성공적으로 컴파일 하였으면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F16594A174AD1ED6834A8B7)

와 같이 나옵니다. 처음에 2 차원 배열을 정의 할 때 부터 확 와닿는 느낌이 듭니다. 왜냐하면 정말로 2 차원 상에 배열된 배열이라고 생각할 수 있고, 배열의 선언 자체가 2 차원 적으로 정의 되었기 때문이죠

```cpp-formatted
int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
```

위에서 2 차원 배열을 정의 하였습니다. 그런데 사실 아래와 같이 모두 한 줄에

```cpp-formatted
int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
```

다 써도 큰 문제는 없지만 보기 좋기 위해 위와 같이 나열한 것 입니다.왜냐하면 2 차원 배열을 아래와 같은 모습으로 존재한다고 상상 할 수 있기 때문이죠.

![3 곱하기 3 정사각형에 위에서 부터 차례로 arr[0[0, arr[0[1, arr[0[2 가 쭉 써있는 것을 생각해보세요](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1940B00D4AD1EFB1226E92)

마치 우리가 배열을 정의했던 것 처럼 이차원 상에 배열이 있다고 생각해서 그려볼 수 있습니다. 이 때, `arr[x][y]` 라고 한다면 `x` 는 몇 번째 줄에 있는지, `y` 는 몇 번째 열에 있는지를 나타냅니다. 예를 들어서 `arr[0][1]` 은 0 번째 줄, 1 번째 열에 있으므로 2 가 되겠지요. 결과적으로 말하자면 '일차원 배열은 한 개의 값(x)으로 원소에 접근하는 것이고, 이차원 배열은 두 개의 값(x,y)으로원소에 접근하는 것이다!' 라고 생각할 수 있게 됩니다.

한가지 눈 여겨 볼 점은 `arr` 이 '배열의 배열' 이라는 것이 맞다는 것 입니다. 왜냐하면 `arr[0]` 을 하나의 배열의 이름이라고 생각해 보면 3 개의 원소 `arr[0][0], arr[0][1], arr[0][2]` 를 가진다고 볼 수 있다는 것 이지요. 마찬가지로 `arr[1], arr[2]` 도 하나의 배열이라고 생각할 수 있습니다. 그런데 `arr` 이 배열이므로 우리는 2 차원 배열을 '배열의 배열' 이라고 볼 수 있지요.

기존의 배열과 마찬가지로 `arr[3]` 이라 하면 `arr[0] ~ arr[2]` 까지 사용 가능했듯이 `arr[3][3]` 이라 하면 `arr[0][0] ~ arr[0][2],``arr[1][0] ~ arr[1][2], arr[2][0] ~ arr[2][2]` 까지 사용 가능 합니다.

그런데 한 가지 지적해야 할 부분은 컴퓨터 메모리 상에선 절대로 이차원 적으로 만들어 지지 않는 다는 것 입니다. 사실, 컴퓨터 메모리 상에선 2차원 이라는 것이 존재할 수 가 없습니다. 단지 선형으로 된 데이터들의 나열일 뿐이지요. 위 배열의 경우 컴퓨터 메모리 상에 다음과 같이 존재합니다.

![arr[0[0, arr[0[1, arr[0[2, arr[1[0, arr[1[1, arr[1[2, arr[1[3, arr[2[0, arr[2[1, arr[2[2 순으로 메모리 상에 선형으로 배열됩니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1126170B4AD1F29F014AC7)

하지만 우리가 이렇게 메모리 상에 선형으로 배열되어 있음에도 불구하고 '이차원 배열' 이라고 부르는 이유는 위 처럼 메모리 상에 2 차원으로 배열되어 있다고 생각하면 정말로 간편하기 때문 입니다. 예를 들어서 `arr[2][1]` 은 메모리 상에서 배열의 시작 부분 (`arr[0][0]`) 에서 부터 `3*2 + 1 = 7` 번째에 있는 값 이라고 생각해야 되지만 사실 이 데이터를 2 차원 상에 배열해 놓고 2 행, 1 열의 값 이라고 생각하면 훨씬 편하기 때문입니다. (물론 컴퓨터는 전자의 경우로 계산하게 됩니다)

```cpp-formatted
/* 학생 점수 입력 받기 */
#include <stdio.h>
int main() {
  int score[3][2];
  int i, j;

  for (i = 0; i < 3; i++)  // 총 3 명의 학생의 데이터를 받는다
  {
    for (j = 0; j < 2; j++) {
      if (j == 0) {
        printf("%d 번째 학생의 국어 점수 : ", i + 1);
        scanf("%d", &score[i][j]);
      } else if (j == 1) {
        printf("%d 번째 학생의 수학 점수 : ", i + 1);
        scanf("%d", &score[i][j]);
      }
    }
  }

  for (i = 0; i < 3; i++) {
    printf("%d 번째 학생의 국어 점수 : %d, 수학 점수 : %d \n", i + 1,
           score[i][0], score[i][1]);
  }

  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F192C582B4AD1F53B33B033)

와 같이 됩니다. 사실 작동 원리는 간단 합니다.

```cpp-formatted
int score[3][2];
```

일단 위 구문을 통해 3 행, 2 열의 크기를 가지는 2 차원 배열 `score` 을 선언 하였습니다. 사실 우리가 프로그래밍 하고자 하는 목표에 따라 해석해 보면 '3 명의 학생의 2 과목의 데이터를 보관하는 `score 2` 차원 배열' 이라고 볼 수 도 있습니다. 이를 그림으로 나타내면


![학생 1 의 국어 점수는 score[0[0, 수학 점수는 score[0[1, 학생 2 의 국어 점수는 score[1[0, 수학은 score[1[1 등등](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F15758C294AD1F69944F937)
  꼴로 보면 됩니다.

```cpp-formatted
for (i = 0; i < 3; i++)  // 총 3 명의 학생의 데이터를 받는다
{
  for (j = 0; j < 2; j++) {
    if (j == 0) {
      printf("%d 번째 학생의 국어 점수 : ", i + 1);
      scanf("%d", &score[i][j]);
    } else if (j == 1) {
      printf("%d 번째 학생의 수학 점수 : ", i + 1);
      scanf("%d", &score[i][j]);
    }
  }
}
```

이제 `for` 문을 통해서 3 명의 학생의 데이터를 입력 받게 됩니다. 일단 오래간만에 두 개의 `for` 문이 같이 돌아가는데 어떠한 형식으로 작동되는 지는 알고 있겠지요? `i = 0` 일 때, `j = 0 ~ 1, i = 1` 일 때, `j = 0 ~ 1, i = 2` 일 때, `j = 0 ~ 1` 로 돌아가게 됩니다. 즉 위 부분을 통해 2 차원 `score` 배열의 값을 집어 넣게 되는 것 이지요.

```cpp-formatted
if (j == 0) {
  printf("%d 번째 학생의 국어 점수 : ", i + 1);
  scanf("%d", &score[i][j]);
} else if (j == 1) {
  printf("%d 번째 학생의 수학 점수 : ", i + 1);
  scanf("%d", &score[i][j]);
}
```

위 `for` 문 안의 위 부분을 살펴 보면 `j` 가 0 이면 국어점수를 입력해라, `j` 가 1 이면 수학 점수를 입력해라 라고 물어 보는 것이 달라 집니다.

마지막으로

```cpp-formatted
for (i = 0; i < 3; i++) {
  printf("%d 번째 학생의 국어 점수 : %d, 수학 점수 : %d \n", i + 1, score[i][0],
         score[i][1]);
}
```

를 통해 입력 받은 값을 깔끔하게 보여주게 됩니다.



### 2 차원 배열 정의하기

앞선 예제에서

```cpp-formatted
int arr[2][3] = {1, 2, 3, 4, 5, 6};
```

와 같이 2 차원 배열을 선언하였습니다. 그런데, 프로그래밍시 줄 수를 절약하고 싶은 사람들은 아래와 같이 해도 큰 문제는 없습니다.

```cpp-formatted
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
```

위 처럼 정의하는 것은 우리가 앞서 써 왔던 방법과 전혀 차이가 없으니 그냥 알아 두시면 됩니다. 여러분들 께서 원하는 방법으로 정의하시면 됩니다.

참고로, 이전 강의에서 이야기를 하지 않았는데, 다음과 같이 배열을 정의할 수 도 있습니다.

```cpp-formatted
int arr[] = {1, 2, 3, 4};
```

음... 무언가 이상하다는 느낌이 드나요? 사실, 알고보면 단순합니다. 위와 같이 정의할 수 있는 이유는 컴파일러가 원소의 개수를 정확하게 알기 때문입니다. 컴파일러는 우리가 배열을 정의한 것을 보고 '아, 이 사람이 원소를 4 개 가지는 `int` 배열을 정의하였구나!' 라고 알아서 대괄호 안에 자동적으로 4 를 집어 넣어서 생각하게 됩니다. 따라서 위와 같이 정의하나

```cpp-formatted
int arr[4] = {1, 2, 3, 4};
```

로 정의하나 같은 말이 되겠지요.
하지만 아래와 같이 정의하는 것은 안됩니다.

```cpp-formatted
int arr[];
```

이 것은 왜 안될까요? 아마, 이전 강의를 잘 보신 분들게서는 단박에 알아 차릴 수 있을 것 입니다. 그 이유는 '배열의 크기는 임의로 정해지지 않기 때문입니다. 즉, 위와 같이 배열을 정의한다면 컴파일러는 우리가 어떠한 크기의 배열을 정의하고 싶은지 모릅니다. 따라서 아래와 같은 오류를 내뿜게 됩니다.

```warning
 error C2133: 'arr' : 알 수 없는 크기입니다.
```

이 아이디어를 2 차원 배열에도 그대로 적용 시킬 수 있습니다.
일단, 아래와 같은 2 차원 배열의 정의를 살펴 보도록 합시다.

```cpp-formatted
int arr[][3] = {{4, 5, 6}, {7, 8, 9}};
```

위 정의를 보면 여러분은 비어있는 대괄호 안에 무슨 값이 들어갈지 맞출 수 있을 것입니다. 무엇이냐고요? 바로 2 이지요. 왜냐하면 `{4,5,6}` 를 가지는 `arr[3]` 배열 하나와, `{7,8,9}` 를 가지는 또다른 `arr[3]` 배열을 정의하여 총 2 개의 `arr[3]` 배열을 정의하였기에, `int arr[2][3]` 이 되어야 하는 것이지요.

그렇다면 아래와 같은 문장이 유효한지 살펴보세요.

```cpp-formatted
int arr[][2] = {{1, 2}, {3, 4}, {5, 6}, {7}};
```

어! 이상하네요. 마지막에 그냥 `{7}` 이라고 되어 있잖아요? 아마 여러분들 중 대다수는 이 것을 보고 위 문장이 틀렸고 성공적으로 컴파일 되지 않으리라 생각할 것입니다. 하지만, 위 2 차원 배열은 배열 정의시 `arr[][2]` 라고 하였기 때문에 무조건 원소가 2 인 1 차원 배열들이 생기게 됩니다. 즉, 7 이 속한 1 차원 배열에는 원소가 한 개인 것이 아니라 마치 `arr[3] = {1}` 고 해도 상관 없는 것 처럼 8 이 들어갈 자리를 비워놓게 되지요. 따라서, 위 문장은 틀린 것이 아닙니다. 그렇다면 아래 문장을 봐보세요.

```cpp-formatted
int arr[2][] = {{4, 5, 6}, {7, 8, 9}};
```

과연 될까요? 아마 여러분들 중 대다수는 될 것이라 생각하고 있을 것 입니다. 하지만 놀랍게도 컴파일해보면

```warning
error C2087: 'arr' : 첨자가 없습니다.
error C2078: 이니셜라이저가 너무 많습니다.
```

와 같은 오류들을 만나게 됩니다. 도대체 이게 뭔가요? 앞에선 하나가 모잘라도 잘만 컴파일 되던데 말이죠. 사실 곰곰히 생각해 보면 컴파일러가 이러한 오류를 내는 것은 당연하게 됩니다. 이는 임의의 크기를 가진 1 차원 배열 2 개를 가지는 2 차원 배열을 생성하라는 말 입니다. 다시 말해, '임의의 크기를 가진 1 차원 배열' 을 생성하겠다는 것이지요. 당연히 오류가 발생하게 됩니다. 배열의 크기는 임의의 크기가 결코 될 수 없기 때문이죠.

아마 여러분은 위 정의가 '저건 임의의 크기를 가진 배열을 생성하라는 것이 아니라, 크기가 3 인 1 차원 배열 두 개를 생성하라는 것이잖아요!' 라고 말할 것 입니다. 하지만, 그렇지 않습니다. 우리는 `int arr[2][] = {{4,5,6},{7,8,9}};` 를 다음과 같은 의미로 사용하였습니다.

```cpp-formatted
int arr[2][3] = {{4, 5, 6}, {7, 8, 9}};
```

하지만 어떤 괴상한 사람들의 경우 다음과 같이 생각하고 썼을 수 도 있겠지요.

```cpp-formatted
int arr[2][4] = {{4, 5, 6}, {7, 8, 9}};
```

처음에 "저게 왜 되지..." 라는 생각이 들기도 하지만 알고 보면 당연하다는 사실을 알 수 있습니다. 이는 단지 `int arr[][2] = {{1,2},{3,4},{5,6},{7}};`  의 경우와 동일한 것이지요. 즉, 크기가 4 인 1 차원 배열 2 개를 정의하였는데 각각 원소 3 개 씩만 정의하고 나머지는 0 으로 처리하게 된 것입니다. 결론적으로 이것도 맞고 저것도 맞기 때문에 컴파일러는 위와 같이 알 수 없다는 오류를 뿜게 됩니다 . 결론적으로 이것도 맞고 저것도 맞기 때문에 컴파일러는 위와 같이 알 수 없다는 오류를 뿜게 됩니다.


###  3 차원, 그 이후 차원의 배열들


2 차원 배열을 잘 이해하였다면 3 차원 배열을 이해하는 것은 그리 어려운 것이 아니라 생각됩니다. 사실, 보통의 프로그래밍에서 3 차원 배열을 쓰는 경우는 그렇게 많지 않습니다. (물론 제가 만들어본 프로그램들에 한해서...) 그렇지만 쓸 수 도 있기에 간단하게 집고 넘어가기만 합시다.

3 차원의 배열의 정의는 2 차원 배열과 거의 동일합니다. (그 이후의 차원들도 마찬가지)

```cpp-formatted
(배열의 형)(배열의 이름)[x][y][z];  // 여기서 x,y,z 는 배열의 크기를 말합니다.
```

이제, 머리속으로 상상의 나래를 펼쳐 봅시다. 제가 그림판으로 3 차원 적인 그림을 그릴 수는 없으므로 여러분의 지능을 믿겠습니다! 일단, 아래의 배열을 머리에 그려 봅시다.

```cpp-formatted
int arr[3][4];
```

이는 가로 길이가 4 이고 세로 길이가 3 인 평면위에 `int` 변수들이 하나씩 놀고 있는 것을 상상하면 됩니다. 그렇다면 이제 아래 배열을 머리에 그려 봅시다.

```cpp-formatted
int brr[2][3][4];
```

아아악! 모르겠다고요? 아니요, 어렵지 않습니다. 위에서 상상한 평면 위에 동일한 평면이 한 층 더 있다고 생각하면 됩니다. 즉, 위에서 생각했던 평면이 2 개의 층으로 생겼다고 하면 됩니다. 어때요, 간단하죠?

하지만, 문제는 4차원 배열 부터 입니다. 뭐 우리는 3 차원 적인 세상에서 살고 있기 때문에 4 차원에 무엇인지 몸에 와닿기는 힘듭니다. (사실, 우리는 3차원 상의 공간에 시간의 축이 더해진 4차원 세상에서 살고 있다고 합니다) 그렇기에 4 차원 배열, 그리고 그 보다 더 놓은 차원의 배열이 무엇인지 머리속으로 그려보기란 고역이 아닐 수 없습니다.

그런데 말이죠. 제가 아까 굵은 글씨로 써 놓았던 것이 기억나시나요?

```info
'일차원 배열은 한 개의 값(x)으로 원소에 접근하는 것이고, 이차원 배열은 두 개의 값(x,y)으로 원소에 접근하는 것이다!'
```

이를 확장해서 생각해 보면 삼차원 배열은 세 개의 값 `(x,y,z)` 을 통해서 원소에 접근하는 것 입니다. 네, 맞아요. 우리가 원소가 몇 번째 층에 있고 (`x`), 그 층에 해당하는 평면에 몇 행(`y`), 그리고 몇 열(`z`) 를 알면 `int` 변수에 정확하게 접근할 수 있지 않습니까?

4 차원도 같습니다. 4 차원 배열은 4 개의 값 `(x,y,z,w)` 을 통해서 원소에 접근할 수 있습니다. 마찬가지로 5 차원은 5 개, `n` 차원은 `n` 개의 값을 통해서 원소에 접근하게 되는 것이지요. 이 아이디어를 적용시키면 어떠한 차원의 배열이 실제 프로그래밍 상에 필요하다고 하더라도 문제 없이 해결할 수 있으리라 생각합니다.

그렇다면 이번 강좌는 여기에서 마치도록 하겠습니다.

### 생각해 보기

#### 문제 1

제 강좌 제목에서 배열이 왜 C 언어의 아파트 인지 설명해 보세요. 즉, '동' 의 개념, '층' 에 개념, '호' 의 개념이 어떠한 배열을 형상화 하고 있는 지도 생각해 보세요. (난이도 : 下)

##@ chewing-c-end
Link :  21
2009-10-12 00:42
----------------
title : 씹어먹는 C 언어 - <2 - 3. 수를 표현하는 방법(기수법)>
cat_title : 2 - 3. 수를 표현하는 방법(기수법)
next_page : 7
publish_date : 2009-10-12 00:42
--------------

* 기수법이 무엇인지 알고 이해한다.
* 이진수, 십진수, 16 진수를 서로 변환한다.
* 컴퓨터 메모리의 단위(비트, 바이트, 워드, 더블 워드) 에 대해 안다.

![씹어먹는 C 언어](/img/ChewingClogo.png)

아마 제 강좌를 읽는 분들 중에선 중학교 수학을 접하지 않는 분들도 있을 수 있기 때문에 이 강좌를 작성하게 되었습니다. 3 강에서 이 부분에 대한 내용을 다루고 있으나 질문이 자주 나오는 것 같아서 이렇게 강좌를 올립니다. 사실 이 부분의 내용은 중학교 수학에서는 모두 다루는 내용이므로 꼭 보셔도 되지 않지만 복습 차원에서 한 번쯤 보아도 좋습니다. 또한, 앞으로 중요하게 쓰일 몇 가지 컴퓨터 용어들을 다루고 있으니 (물론 3 강에서도 나옵니다만...) 한 번 보는 것이 좋겠습니다.

여러분은 '수' 와 '숫자' 의 차이를 알고 계십니까? 아마 많은 사람이 모를 텐데 영어로 하면 '수' 는 Number 이고 '숫자' 는 Digit 라 합니다.

'수' 는 어떠한 물질의 양을 나타내는 단위 입니다. '숫자' 는 이를 기록할 수 있도록 시각화 한 것이지요. 예를 들어서, 사과가 100 개 있다는 사실을 보여주기 위해 사과를 100 개 그려야 되면 상당히 곤란하겠지요. 단순히 '100' 이라는 것만 써서 사과가 100 개 있다는 사실을 알 수 있습니다.

그런데 놀라운 점은 우리가 이러한 `0,1,2,3,4,5,6,7,8,9` 의 숫자들만을 이용하여 수를 표시 할 수 있다는 것이 아닙니다. 우리가 사과 라는 물질을 나타내기 위해 '사과' 라고 쓰지만 사과를 나타내기 위해 꼭 '사과' 라고 써야 하나요? 영어로 'Apple' 이라 쓸 수 도 있고 일본어로 'リンゴ' 라고 쓸 수 있습니다. 수도 마찬가지 입니다. 인간의 손가락이 10개 인지라 수를 10 개의 숫자로 나타내었지만 마음에 안들면 0 과 1 만을 이용할 수 도 있고 100 개의 숫자를 이용할 수 도 있습니다.

이렇게 수를 표현하는 방법을 **기수법(Numeral system)** 이라 합니다.


###  수학적 배경 지식 - 밑과 지수

여기서 소개하는 내용은 중학교 1 학년 재학시 배우게 됩니다만, 제 블로그를 방문하는 분들 중에 초등학생들도 적지 않게 있으리라 생각되어 간단히 짚고 넘어가겠습니다.

수학은 '복잡한 것을 단순히!' 라는 목적 하에 발전해 왔습니다. 이것도 이러한 본분을 충실히 따른 것 입니다. 우리는 곱하기 연산을 자주 사용합니다. 그 때 마다 이를 표현하기 위해 곱하기 기호를 사용해야 합니다. 예를 들어 아래 처럼 2 를 100 번 곱한 수를 생각해 봅시다.

$$2 \times 2 \times 2 \times \cdots \times 2$$

(너무 길어서 약간 생략)

우리는 위 수를 나타내고 싶을 때 마다 위와 같이 2 를 100 번이나 적어야 합니다. 다행이도 수학자들은 위를 단순화 하여 나타내기 위해 아래와 같은 기호를 만들어 냈습니다.

$$2^{100} = 2 \times 2 \times 2 \times \cdots \times 2$$

정말 훌륭한 생각 아닙니까? 단순히 2 를 100 번 곱했다는 사실을 알려주기 위해서 2 위에 작은 글씨로 100 을 적었습니다. 이 때 아래 '2' 를 '밑(base)' 라 부르고 밑 위에 밑을 몇 번 곱할 지 나타낸 수 100을 '지수(exponent)' 라고 부릅니다. 위 숫자의 경우 밑은 2 가 되고 지수는 100 이 되겠지요.

아마 이해가 잘 안되면 아래와 같은 예를 보시면 됩니다.

$$3^5 = 3 \times 3 \times 3 \times 3 \times 3$$

$$7^2 = 7 \times 7 = 49$$

지수에서 가장 중요한 사실은 바로

$$(\text{Number})^0 = 1$$

라는 사실입니다. `Number` 에는 어떠한 수도 들어 갈 수 있습니다. (다만 0 제외) 아마 이 부분에서 의아해 하는 사람들이 많을 것 입니다. "어떻게 숫자를 한 번도 안 곱했더니 1 이 될수가 있냐! 수학자 바보들 아니냐!" 말이지요. 하지만 사실 이 값은 사실 수학자들 사에서 약속 처럼 정의한 값이라 생각하면 됩니다. 만일 이 값을 1 이라 하지 않는다면 여러 지수들에 관련된 중요한 법칙들이 성립 되지 않기 때문이죠. 다시말해 어떤 수의 0 승 한 것이 1 이라 생각하는 것은 다른 법칙들이 만족되기 위해 그렇게 약속한 것이다 정도로 알고 계시면 되겠습니다.


###  십진법, 이진법, 16 진법

현재 아라비아 숫자를 사용하는 우리는 수를 나타내기 위해 10 개의 숫자를 이용하는, 소위 말하는 **십진법(decimal)** 을 이용하고 있습니다. 정확하게 알려진 것은 아니지만 우리가 '10' 에 그토록 관련이 많은 것이 인간이 10 개의 손가락을 가졌기 때문이라 생각합니다. 아무튼, 우리는 '253' 이란 숫자가 나오면 아래와 같이 생각합니다.

$$253 = 2\times 10^2 + 5 \times 10^1 + 3 \times 10^0$$

다시 쓰면,

$$253 = 200 + 50 + 3$$

이 됩니다. 한 가지 주목하실 부분은 바로 한 자리수가 늘어 날 때 마다 그 자리를 나타내는 숫자에 '10' 이 곱해진 다는 것이지요.가장 오른쪽 자리는 1 의 자리, 그 다음 자리는 10 의 자리, 그 다음은 100 의 자리, 그 다음은 1000 의 자리로 말이지요.예를 들어서 253 앞에 7 을 붙인다면

$$7253 = 7\times 10^3 + 2\times 10^2 + 5 \times 10^1 + 3 \times 10^0 = 7000 + 200 + 50 + 3$$

가 됩니다. 이 것이 바로 십진법의 가장 큰 특징이라고 할 수 있습니다. 자리수가 하나 증가할 때 마다 이 자리를 나타내는 숫자에 10 이 곱해지게 되지요. 또한 중요한 특징으론 십진법이 10 개의 숫자를 사용한다는 것 입니다. 0 부터 9 까지 모두 10 개의 숫자를 이용하지요.

이런 아이디어를 적용 시켜서 이진법을 생각해 봅시다. 컴퓨터는 0 과 1 인 두 종류의 숫자 밖에 표현할 수 없습니다. (전기적 신호가 _on_ 이냐 _off_ 냐에 따라 말이지요) 그러면 컴퓨터는 253 을 어떻게 생각할까요? 컴퓨터는 0 과 1 밖에 생각 못하므로 표현할 수 없다구요? 아닙니다. 컴퓨터도 0 과 1 만을 가지고서 모든 수를 표현 할 수 있습니다. 우리가 10 개의 숫자를 가지고 수를 표현하므로 이를 '십진법' 이라 부르지만 컴퓨터는 두 개의 숫자 만으로 수를 표현하므로 '이진법(Binary)' 라 부릅니다.

예를 들어 6 을 이진수로 나타낸다고 합시다. 그렇다면 우리가 십진법에서 사용한 규칙을 그대로 적용하여 사용하면 아래와 같습니다.

$$ 6 = 4 + 2 = 1 \times 2^2 + 1 \times 2^1 + 0 \times 2^0 = 110_2$$

어때요? 규칙이 정확히 동일한가요? 십진법에선 한 자리 늘어날 때 마다 10 이 곱해졌으므로 이진법에선 한 자리 늘어날 때 마다 2 가 곱해집니다. 즉, 가장 오른쪽 자리는 1, 그 다음은 1 에 2 를 곱했으므로 2, 그 다음은 2 에 2를 곱했으므로 4의 자리가 됩니다.

또한 십진법이 0 부터 9 까지의 수를 쓴 만큼 이진법도 0 과 1 만을 사용해야 합니다. 위에 보면 알 수 있듯이 6 을 110 으로 표현하였습니다. 즉, 1 과 0 만을 사용하였습니다.

110 밑에 조그맣게 2 가 표시되어 있는 것이 무엇인지 궁금해 하는 사람들이 있습니다. 이는 '이 수가 이진법으로 표현되어 있습니다' 를 알려주는 기호 입니다. 즉 2 라는 표시가 없다면 이 수가 정말 십진법으로 110을 표현한건지, 아니면 이진법으로 110을 표현한 것인지 알 길이 없기 때문이죠.

이진수가 무엇인지 확실히 감을 잡기 위해 아래의 수들을 보시면 됩니다.

$$23 = 16 + 4 + 2 + 1 = 1 \times 2^4 + 0 \times 2^3 + 1 \times 2^2 + 1\times 2^1 + 1 \times 2^0 = 10111_2$$
$$49 = 32 + 16 + 1 = 1 \times 2^5 + 1 \times 2^4 + 0 \times 2^3 + 0 \times 2^2 + 0\times 2^1 + 1 \times 2^0 = 110001_2$$

그렇다면 이제 이진수를 어떻게 십진수로 바꿀 수 있는지 알아 봅시다. 사실, 위의 내용을 잘 이해하였다면 정말 간단합니다.

아래 그림과 같이 하면 됩니다.

![예컨대 2 진수로 1 0 1 1 0 이 있다고 합시다. 일의 자리 부터 차례대로 변환해 나가면 됩니다. 이 때 각 자리수의 값은 2 의 멱급수 (즉, 2,4,8,16... 로 커져 갑니다. 따라서 1 0 1 1 0 을 일의 자리 부터 보면 0 곱하기 1, 그 다음 자리 1 곱하기 2, 그 다음 자리 1 곱하기 4, 그 다음 자리 0 곱하기 8, 그 다음 자리 1 곱하기 16 응로 보시면 됩니다. 마치, 십진수 123 을 생각할 때 3 곱하기 1, 2 곱하기 10, 1 곱하기 100 으로 한 것과 동일합니다](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F205C510F4B67FFEA029E2D)

    자리수가 하나 올라갈 때 마다 그 자리수의 값이 두 배로 된다는 사실만을 기억하면 됩니다. 하지만 관건은 십진수를 이진수로 어떻게 쉽게 바꾸느냐 입니다. 사실 이는 어렵게 느껴지지만 그 과정은 매우 단순합니다. '2로 나누는 연산' 을 반복해 주면 되지요. 아래 그림을 참조하세요.


![13 을 이진수로 바꿔봅시다. 13 을 2 로 나누면 6 이고 나머지가 1 입니다. 이 1 을 기억하세요!. 그 다음 6 을 나누면 3  이고 나머지가 0 입니다. 이제 3 을 2 로 나누면 1 이고 나머지가 1 입니다. 이제 1 을 2 로 나누면 몫이 0 이고 나머지가 1 이지요. 이제, 나온 나머지들을 거꾸로 셈해보면 1101 이 되죠. 이것이 바로 13 을 2 진수로 변환한 것입니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1554D10F4B67FFEA259019)

··· 의 기호는 나머지를 뜻합니다. 즉, 25 를 2 로 나누면 몫이 12 고 나머지가 1 이 됩니다. 단순히 십진수를 2 로 계산 나누어서 나온 나머지를 몫이 0 이 될 때 까지 구한 다음에 나머지들만 역순으로 재배치 하면 됩니다. 의외로 단순합니다.

(사실 위 방법이 어떻게 정확한 결과를 도출해 내느냐에 대해 설명해야 하지만 사실 세세히 알 필요도 없고 나중에 다 배우므로 생략하도록 하겠습니다.)

하지만, 이진수는 흔히 수가 너무 커지는 경향이 있습니다. 예를 들어 1024 는 십진수로 4 자리 밖에 안되지만 이진수로는 10000000000 이 되어 무려 11 자리나 됩니다. 1 과 0으로 나타내면 (사람들의 입장에서) 읽기 번거럽기 때문에, 이를 손쉽게 표현하기 위해서 프로그래머들은 보통 16진법을 사용하고 있습니다. 16 진법도 여태까지 사용하였던 아이디어를 동일하게 적용하면 됩니다.

그런데 한가지 주목해야하는 사실은 16 진수가 숫자를 16 개나 필요로 한다는 점입니다. 우리가 사용하는 십진법은 숫자가 10 개만 필요하므로 숫자가 10 종류 밖에 없습니다. 따라서 사람들은 16 진수를 위해 필요한 숫자 6개를 알파벳을 이용하여 숫자를 표현하였습니다. 즉 10 에 대응되는 것이 A, 11 에는 B, 12 에는 C, 13 에는 D, 14 에는 E, 15 에는 F 입니다. 16 진수는 **0,1,2,...,9,A,B,C,D,E,F** 를 이용하여 숫자를 표현 합니다.

$$123 = 7 \times 16 + 11 = \text{0x7B}$$

16 진수도 마찬가지로 같은 논리를 적용합니다. 한 자리가 늘어날 때 마다 16 을 곱하면 되는 것이지요. 이 때, `7B` 앞에 붙은 `0x` 는 이 수가 16 진수로 나타나있다는 것을 알려줍니다. 좀 더 이해를 돕기 위해 몇 가지 예를 들겠습니다.

$$19 = 16 + 3 = \text{0x13}$$

$$16782 = 4 \times 16^3 + 1 \times 16^2 + 8 \times 16^1 + 14 \times 16^0 = \text{0x418E}$$

16 진수를 십진수로 바꾸거나 십진수를 16 진수로 바꾸는 일은 앞서 이진수의 경우와 동일합니다. (다만, 2 대신 16 으로 곱하거나 나누어 주어야 한다는 점 말고는) 이는 단순하지만 계산이 지저분 하고 복잡하였죠. 하지만 16 진수를 이진수로, 이진수를 16 진수로 바꾸는 방법은 매우 간단합니다.

먼저 16 진수를 이진수로 바꾸는 방법을 살펴 봅시다. 이는 단순히 16 진수의 각 자리수를 4 자리 (반드시) 이진수로 변환해 주면 됩니다.

![마찬가지로 16 진수로 나타낸 A5 를 봅시다. 16 진수는 숫자가 16 개 필요한데, 우리는 0 부터 9 까지 밖에 없으므로 10, 11, 12, 13, 14, 15 에 해당하는 숫자를 A, B, C, D, E, F 라고 하기로 했습니다. 이제, 16 진수로 표기된 3A 를 십진수로 바꿔봅시다. 일의 자리 부터 보면 A 이므로 10 곱하기 1 이고, 그 다음 자리는 3 이므로 3 곱하기 16 이므로 다 더하면 58 이 되겠지요.  ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2061F8194B70431223D6E3)


 위와 같이 `0x4F38E` 를 2 진수로 변환하면 `1001111001110001110` 가 됩니다. 

마찬가지로 이진수를 16 진수로 바꾸어 주는 것도 간단합니다. 단지 4 자리씩 뒤에서 부터 끊어서 읽으면 되지요. 아래 그림을 보면 알 수 있습니다.

![이진수를 16 진수로 바꾸는 방법은 매우 쉽습니다. 뒤에서 부터 4 자리씩 끊어서 각 4 자리를 16 진수로 바꾸면 되거든요. 예를 들어서 이진수로 1 0 1 1 0 0 0 1 1 0 0  이 있다면 뒤의 4 자리 부터 1 1 0 0 과 1 0 0 0 과 1 0 1 이 되겠지요. 이제 나온 1 1 0 0 을 16 진수로 바꾸면 C 이고, 그 다음 1 0 0 0 은 8 이고, 맨 앞의 1 0 1 은 5 이므로 다 합치면 58C 가 됩니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F173231054B67FFEA07B273)
  음, 이제 어느정도 진법 체계에 통달하셨다고 생각합니다. 컴퓨터 계산기에 진법 변환 기능이 있으므로 혼자서 연습해 보는 것도 좋을 것 같습니다. 그렇다면 이제 컴퓨터 메모리와 이진법과의 상관 관계를 알아 보도록 합시다.



###  컴퓨터 메모리의 단위


컴퓨터에 대해 조금이나마 공부한 사람이라면 컴퓨터에 데이터를 저장하는 공간은 크게 두 부류로 나눌 수 있다고 들었을 것입니다. 컴퓨터를 종료하면 데이터가 날아가는 휘발성 메모리와 컴퓨터를 종료해도 데이터가 날아가지 않는 비휘발성 메모리로 말이지요.

이 때, 휘발성 메모리의 대표적인 주자로 램(RAM, Random Access Memory) 과 비휘발성 메모리의 대표 주자로 롬(ROM, Read Only Memory 흔히 말하는 CD - ROM 이나 DVD - ROM, 아니면 우리 메인보드 Bios 에 박혀있는 롬 등등) 나 하드 디스크 등이 있겠지요.

이 때, 앞으로 저의 강좌에서 주로 '메모리' 라 말하는 것은 휘발성 메모리인 RAM 을 말합니다. RAM 은 하드 디스크나 CD 와는 달리 속도가 매우 빠릅니다. (CD 휭 돌아가는 소리 들어 보셨죠?) 왜냐하면 RAM 의 경우 데이터의 랜덤하게 접근할 수 있는데 하드 디스크나 CD 는 순차적으로 접근 해야 되기 때문이죠. 

쉽게 말해 우리가 아파트 713 호에 사는 철수를 찾는다고 합시다. 철수가 만일 `RAM` 아파트에 산다면 단박에 713 호에 산다는 것을 알 수 있지만 하드 디스크 아파트에 산다면 101 호 부터 모든 주민들 일일히 찾아 713 호 까지 찾아 보아야 한다는 뜻 입니다.

이런 매우 빠른 메모리의 특성 때문에 컴퓨터는 대부분의 데이터들은 메모리에 보관해 놓고 작업을 하게 됩니다. 물론 메모리는 전원이 꺼지면 모두 날아가기 때문에 중요한 데이터들은 틈틈히 하드 디스크에 저장하게 되지요.

컴퓨터의 한 개의 메모리 소자는 0 혹은 1 의 값을 보관할 수 있습니다. 이 이진수 한 자리를 가리켜 비트(Bit) 라고 합니다. 따라서, 1 개의 비트는 0 또는 1 의 값을 보관할 수 있겠지요. 하지만 이는 너무나 작은 양입니다. 보통 우리는 1 보다 훨씬 큰 수들을 다루기 때문이지요. 그래서, 사람들은 이렇게 8 개의 비트를 묶어서 **바이트(Byte)** 라고 부릅니다. 즉, 8 비트는 1 바이트 이지요.

(참고로 4 비트를 특별히 묶어서 니블(nibble) 이라 부릅니다만, 잘 쓰이지는 않습니다)

8 비트로 나타낼 수 있는 수, 다시말해 8 자리 이진수로 나타낼 수 있는 최대의 수는 아래와 같이

$$00000000_2 \sim 11111111_2 = 0 \sim 255 = 0 \sim 0xFF$$

0 부터 255 로 총 256 개의 수를 나타내게 됩니다.

그 다음 단위로 **워드(Word)** 라고 부르는 단위가 있습니다. 컴퓨터에서 연산을 담당하는 CPU 에는 **레지스터(register)** 라는 작은 메모리 공간이 있는데, 이곳에다가 값을 불러다 놓고 연산을 수행하게 됩니다.

예를 들어서 `a + b` 를 하기 위해서는 `a` 와 `b` 의 값을 어디다 적어놓아야지, `a + b` 를 할 수 있는 것처럼, CPU 에서 연산을 수행하기 위해 잠시 써놓는 부분을 레지스터라고 합니다. 

이러한 레지스터의 크기는 컴퓨터 상에서 연산이 실행되는 최소 단위라고 볼 수 있고, 이 크기를 **워드** 라고 부릅니다. 32 비트 컴퓨터 시절에서는 이 1 워드가 32 비트, 즉 4 바이트 였지만, 지금 대다수의 여러분이 사용하는 64 비트 컴퓨터의 경우 1 워드가 64 비트, 즉 8 바이트가 됩니다.
\sidenote{혹시 Windows API 를 공부한 분들이라면, Windows API 에 WORD 와 DWORD 로 정의된 키워드들을 생각하실 수 있습니다. 이 경우 WORD 는 16 비트, DWORD 는 32 비트를 나타냅니다.}

이것으로 여러분이 기수법과 컴퓨터 메모리의 단위에 대해 알아보았습니다. 그럼, 이번 강의는 여기서 마치도록 하죠.

##@ chewing-c-end
Link :  19
2009-09-24 18:24
----------------
title : 씹어먹는 C 언어 - <2 - 2. 주석(Comment)에 대한 이해>
cat_title : 2 - 2. 주석(Comment)에 대한 이해
next_page : 21
publish_date : 2009-09-24 18:24
--------------


이번 강의에서는

* 주석에 대한 확실한 이해

![씹어먹는 C 언어](/img/ChewingClogo.png)

사실, [2 - 1](http://itguru.tistory.com/6)강에서도 다룬 내용이지만 댓글을 통해 질문이 들어 왔기에 정확히 주석이란 놈이 무엇인지 알아 보도록 하겠습니다.

우리가 프로그래밍을 하다 보면 소스 코드가 상당히 길어 지게 됩니다. 우리가 앞서 한 `Hello, World!` 출력 예제는 소스 코드가 겨우 몇 줄에 불과하였지만 실제론 소스 코드의 길이가 수천 줄에서 수만 줄 가까히 됩니다. 예를 들어서 우리가 지금 사용하는 `Windows XP` 의 소스 코드가 몇 줄 정도 될 지 추측해 보세요. 한, 십만줄? 50만 줄? 아닙니다. 정확한 자료는 아니지만 대략 4000만 줄 이상 된다고 합니다.

이런 크기로 프로그램을 작성하다 보면 이 소스 코드가 무엇을 뜻하고 또 무슨 일을 하는지 등의 정보를 소스 코드 내에 나타내야 할 필요성이 있게 됩니다. 즉, 컴파일러가 완전히 무시하고 오직 사람의 편의를 위해서만 존재하는 것이 바로 **주석** 입니다.

종종 지금 코드를 쓰고 있는 시점에서 내용을 내용을 잘 안다고 주석을 생략하는 경우가 있습니다. 하지만 주석 없는 코드를 1 달 뒤에 다시 본다면 분명히 *아니 이게 지금 뭐하는 코드지?* 라고 생각하실 것입니다. 반면에 주석이 잘 작성되어 있는 코드는 몇 년 뒤에서 다시 읽는다 해도 (주석을 잘 달아놨다는 가정 하에) 쉽게 이해할 수 있습니다.

C 언어에서 주석은 두 가지 방법으로 넣을 수 있습니다.

```info
/* 주석이 들어가는 부분 */

// 주석이 들어가는 부분
```

  일단 전자의 경우 `/*` 와 `*/` 로 묶인 내부의 모든 내용들이 주석으로 처리 됩니다. 즉,

```cpp-formatted
/*

이 부분은 내가 아무리 생쇼를 해도 컴파일러가 무시
ㅁㄴㅇ러ㅏㅁ니ㅓㄹ먼리;ㅏㄴㅁ어림나러 무시
ㅁ아ㅓㄹ민럼ㄴㄹ ㅁㄴㅇ럼니러
ㅁㄴ라미너럼나러ㅣㅁ너라ㅣㅓㅇ
printf("Hello, World"); <- 이 것도 당연히 무시
*/
```

 와 같이 난리를 쳐도 `/*` 와 `*/` 로 묶인 부분은 무시됩니다. 아래 예제를 보면 이해가 더욱 잘 될 것입니다.

```cpp-formatted
#include <stdio.h>
int main() {
  /*
  printf("Hello, World!\n");
  printf("Hi, Human \n");
  */
  printf("Hi, Computer \n");

  return 0;
}
```

위와 같은 소스코드를 컴파일 하였을 때,


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F18062C104ABB38E6420A43)

와 같이 `Hi, Computer` 을 출력하는 부분만 남을 것을 볼 수 있습니다. 이는 앞서 말했듯이 `/*` 와 `*/` 로 묶인 부분이 전부다 주석으로 처리되어서 컴파일러가 철저하게 무시하였기 때문 입니다.

반면의 `//` 형태의 주석의 경우 `//` 가 쳐진 줄 만이 주석으로 처리가 됩니다. 즉,

```cpp-formatted
// Hello, World! 를 출력한다.
printf("Hello, World!");
```

로 하면 아래 `printf` 부분 잘 실행됩니다. 하지만 위 주석은 역시 무시됩니다
아래 예제를 보면 확실히 알 수 있습니다.

```cpp-formatted
#include <stdio.h>
int main() {
  // printf("Hello, World!\n");
  printf("Hi, Human \n");
  printf("Hi, Computer \n");

  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F1646CE134ABB39E2743606)

  와 같이 주석으로 감싸진 부분을 제외하고는 나머지 부분이 잘 출력되었음을 알 수 있다.


##@ chewing-c-end
Link :  17
2009-08-15 22:25
----------------
title : 씹어 먹는 C 언어 - <10. 연예인 캐스팅(?) (C 언어에서의 형 변환)>
cat_title: 10. 연예인 캐스팅(?) (C 언어에서의 형 변환)
next_page : 18
publish_date : 2009-08-15 22:25
--------------

* 형 변환(캐스팅)이 무엇인지 안다

* 부동 소수점에 대해 자세히 알아본다.

* 비트, 바이트에 대해 알아본다.

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요, 여러분~~ 이제 드디어 10 번째 강좌에 도달하였습니다. 아마 여태까지 느릿 느릿 진행되는 강좌를 꾸준히 기다리며 읽어와준 여러분들께 감사의 말을 전하고 싶습니다.

아마 잘 알고 있는 내용이지만 C 언어에서 각 변수들에는 고유의 **형(type)** 이 있습니다. 예를 들어서, `int a;` 로 선언된 변수 `a` 의 형은 `int` 형이고, `char b;` 로 선언된 변수 `b` 의 형은 `char` 형 입니다. \sidenote{char 을 어떻게 읽는지는 사람 마다 다른데, 보통 캐릭터 라고 하거나, 그냥 발음 그대로 찰 이라고도 합니다.} 또한 `float c;` 로 선언된 변수 `c` 의 형은 `float` 이고 `double` d; 로 선언된 변수 d의 형은 `double` 이겠죠.

그런데 가끔씩 프로그래밍을 하다 보면 형이 다른 변수 끼리 대입을 하는 연산이 필요로 하게 됩니다. 예를 들어서 `double` 형 변수의 값을 `int` 형 변수에 대입하거나, `float` 형 변수에 `double` 형 변수의 값을 대입하는 것 등등 말이죠.

하지만 안타까운 사실은 형이 다른 변수 끼리의 대입이나 연산들이 모두 불법 이라는 것 입니다. 이건 마치 우리나라에서 달러로 물건을 구매하는 것과 똑같은 것이지요.. 그렇다면 어떻게 해야 할까요?

  일단, 위 조건을 무시한 아래의 예제를 살펴 봅시다.

```cpp-formatted
/* 무시 */
#include <stdio.h>
int main() {
  int a;
  double b;

  b = 2.4;
  a = b;

  printf("%d", a);
  return 0;
}
```

  성공적(?) 으로 컴파일 한다면 아래와 같은 모습을 볼 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F120A6F0B4B67FFE7037144)

어라, 아무런 애러도 없이 결과가 떡 하니 출력되었지만 눈썰미가 좋은 사람들은 `Output` 에 아래와 같은 메세지가 출력되었음을 알 수 있습니다.


![warning C4244: '=' conversion from double to int, possible loss of data](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F1277B5114B67FFE716D114)

  대충 직역해 보면 아래와 같은 의미 입니다.


```warning
경고 C4244 : '=' ": 'double' 로 부터 'int' 로의 형 변환, 데이터의 손실이 예상됨.
```

아마도 우리가 처음 보게 되었을 **컴파일러 경고(Warning) 메세지** 입니다. 똑똑한 컴퓨터는 우리가 `int` 형 변수에 `double` 형 변수의 값을 대입했다고 이야기 하고 있습니다. 또한, 데이터의 손실이 발생하게 된다고 귀띰까지 해주고 있습니다.

실제로, 결과를 확인해보면 데이터 손실이 발생하였음을 알 수 있습니다. 실행 결과를 보게 된다면 분명히 `a` 에 `2.4` 를 대입하였지만 `a` 의 결과는 2 로 나옵니다. (물론 `%d` 를 통해 정수 부분만 출력하게 해서 그렇다고 주장하는 사람들이 있는데 그렇다면 `%f` 로 바꿔서 출력해 보세요. 더 이상한 결과가 나올 것 입니다!)

`int` 형 변수에 (당연하게도, 3, 4 강을 제대로 배운 사람이라면 알겠지만) `double` 형 변수를 대입하면 소수 부분이 잘려서 정수 부분만 들어가게 됩니다. 이는 각 변수들이 메모리 상에 저장되는 특징이 다르기 때문이죠. 왜냐하면 `int` 형 변수는 처음 정의되는 시작 부터 메모리 상에 오직 정수 데이터만 받아 들이도록 설계되기 때문이죠.

  그렇다면 훌륭한 학생이라면 여기서 의문이 생기게 됩니다.

  "도대체 컴퓨터는 실수를 어떻게 표현하는 거야!"



###  컴퓨터가 실수를 표현하는 원리


```warning
  여기서 부터 컴퓨터가 실수를 표현하는 원리에 대해 잠깐 다루겠는데 초보자 분들에게는 적합하지 않는 주제 이므로 읽다가 이해하 안되는 분들은 과감히 뛰어 넘어도 무방합니다. 물론, 한 번쯤 들어 놓으면 나중에 도움이 많이 됩니다.
```

기본적으로 모두가 알고 있듯이 (설마..) 컴퓨터는 이진 - 즉 바이너리(Binary) 시스템으로 설계되어 있습니다. 3 번째 강좌에서 잠깐 이야기 한 것 같은데 이진 이란, 오직 두 가지 숫자인 0 과 1 밖에 사용하지 않는 시스템 입니다. 참으로 불쌍하지 않습니까? 우리는 무려 10 가지의 숫자 (0,1,2,3,4,5,6,7,8,9) 를 사용해 숫자를 표현하는데 컴퓨터는 0 과 1 밖에 사용하지 않기 때문이죠. 컴퓨터가 이렇게 0 과 1 밖에 표현하지 못하는 이유는 컴퓨터는 0 을 전류가 흐르지 않는 상태로, 1 을 전류가 흐르는 상태로 표현하기 때문이죠.

예를 들어서, 3 의 경우 `11, 10` 의 경우 1010 으로 표현됩니다. 이렇게 컴퓨터 상의 1 자리 수를 '비트(bit)' 라고 합니다. 다시 말해 1 비트로 오직 두 가지 숫자 `- 0` 과 1 밖에 표현할 수 없겠지요. 머리가 조금 좋은 사람이라면 컴퓨터 상에서 우리가 '3' 이라고 말하는 숫자가 2 비트를 차지하고 우리가 '15' 라고 말하는 수는 4 비트 (1111) 를 차지함을 알 수 있습니다.

그런데, 우리가 다루는 숫자가 커짐에 따라 컴퓨터에서 차지하는 비트 수가 늘어나게 되죠. 예를 들어서 256 만해도 9 비트 (100000000) 를 차지하게 됩니다. 십진수로는 3 자리 밖에 차지하지 않는데 말이죠. 그래서, 사람들은 편의를 위해서 8 비트를 1 바이트(Byte) 로 부르기로 했습니다. 따라서, 1 바이트로 최대한 표현되는 수는 `0, 1, 2(10), 3(11), 4(100),... 255(11111111)` 까지 256 개의 수를 표현할 수 있게 됩니다.

앞서 3 강에서 말했지만 `int` 형 변수는 4 바이트를 차지한다고 했습니다. 따라서, `int` 형 변수로 최대한 나타낼 수 있는 수는 `0, 1, 2, 3, 4, 5, ...... 21,4748,3647 (11111111111111111111111111111111, 1 이 32 개)` 까지 나타낼 수 있습니다. 하지만, 여기까지는 정수 였습니다. 사실 이렇게 놓고 보면 정수라는 것이 정말 아름답다고 생각하지 않으세요? 컴퓨터로써도 말이지요. 정수는 이진수와 십진수가 정확하게 데이터 손실 없이 계산이 가능합니다. 하지만, 소수(Decimal Number) 은 아니지요.

컴퓨터 상에서 실수를 표현하는 방법은 대표적으로 두 가지를 들 수 있는데 한 가지가 **고정 소수점(Fixed Point)** 방식이고 다른 한 가지는 **부동 소수점(Floating Point)** 방식 입니다. 그런데 여러분이 사용하시는 대부분의 컴퓨터는 '부동 소수점' 방식을 채택하고 있는데 그 이유가 매우 큰 수를 표현 할 수 있기 때문이죠. (참고로 부동 소수점 방식을 통해 수를 표현하는 방법은 국제전기전자기술자협회(IEEE) 에서 1985년에 **IEEE-754** 라는 이름으로 규격화 하였습니다.)

보통 우리가 수를 표현하는 방법은 아래와 같습니다.

$$123, 1234.123, -234$$


그런데, 지수를 이용해서 똑같이 표현할 수 있습니다.

$$1.23 \times 10^2, 1.234123 \times 10^{-2}, -2.34 \times 10^2$$

제가 중학교 때 위 사실을 배웠을 때 에는 '저게 뭐에 쓸모 있는거지?' 라고 생각 되었지만, 사실 위는 컴퓨터 상에서 실수를 표현하는 아주 중요한 기법 입니다. 컴퓨터 상에서 소수를 다음과 같이 표현합니다. 

$$ f \times b^e$$

이 때, `f` 는 가수, `b` 는 밑, `e` 는 지수 입니다. 위 123 의 경우 `f` 는 `1.23, b` 는 `10, e` 는 2 가 되겠군요. 컴퓨터 상에서는 이진체계를 이용하기 때문에 `b = 2` 가 됩니다. 물론 `f` 도 이진법으로 쓰여있는 수 이겠죠. 물론 컴퓨터는 `f, e` 의 값만 메모리에 저장하게 됩니다. 굳이 `b` 를 메모리에 저장할 필요가 없는 이유는 컴퓨터 자체게 2 진 체계를 쓰기 때문에 따로 저장할 필요가 없게 되죠. 사실 여기서 1 비트를 더 쓰게 되는데 이는 부호를 나타내는 비트 입니다. 대부분 이 비트의 값이 0 이면 양수이고, 1 이면 음수가 됩니다.

아래 그림은 `IEEE 754` 에서 정의한 부동 소수점 표현 입니다.

![처음 1 비트는 부호 비트, 그 다음 e 비트 만큼 지수 (1.23 곱하기 10 의 3 승 이라 하면 3 이 지수 부분, 그리고 뒤의 f 비트 만큼 가수(1.23 곱하기 10 의 5 승이라 하면 1.23 이 가수 입니다. float 의 경우 지수 부분이 8 비트, 가수 부분이 23 비트 입니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1142E8024B67FFE861B8C8)


가수(Mantissa) 부분이 `f` 비트를 차지하고, 지수(Exponent) 부분이 `e` 비트, 그리고 맨 앞의 1 비트를 차지하는 부호(Sign) 비트가 있습니다. 우리가 자주 쓰는 `float` 의 경우 (이제, 왜 `float` 이 `float` 인 지 알겠죠?), 가수 부분이 23 비트를 차지하고, 지수 부분이 8비트, 그리고 부호 비트가 1 비트를 차지하여 총 4 바이트를 차지하게 됩니다. 한편 `double` 의 경우 가수 부분이 52 비트고 지수 부분이 11 비트로 무려 8 바이트가 차지하는 거대 자료형 입니다.

이제, 본격적으로 메모리 상에 실수가 어떻게 저장되는지 알아보기 위해 이진법으로 표현된 실수들을 십진법으로 바꾸고, 십진법으로 표현된 실수를 어떻게 이진법으로 바꾸는지 알아야 합니다.

 먼저, 이진법으로 표시된 소수를 한 번 십진법을 바꾸어 보는 연습을 해봅시다.

$$10010.1011_{(2)}$$

아마 이진법이 무엇인지 잘 알고 있는 사람이라면 위 이진소수를 아래와 같은 식으로 바꿀 수 있을 것 입니다. ( 십진법으로 바꾸면 18.6875, 소수점 이하 부분은 2 의 -1 승, -2 승 으로 생각하시면 되요)

$$10010.1011_{(2)} = 2^4 + 2^1 + 2^{-1} + 2^{-3} + 2^{-4} = 18 + 0.5 + 0.125 + 0.0625= 18.6875$$

다시말해 2 진법으로 표시된 소수들도 모두 십진법으로 변환이 가능하다는 것입니다. 그렇다면 십진법 소수도 과연 이진법으로 바꿀 수 있을까요? 이번에는 -118.625를 한 번 이진소수로 바꾸어 봅시다.

$$-118.625 = -1110110_{(2)} - 0.625 = -1110110_{(2)} - 2^{-1} - 2^{-3} = -1110110.101_{(2)}$$


우와, 십진법으로 표시된 숫자들도 이진소수로 바꿀 수 있었군요.
 이제, 마지막으로 위와 같이 이진법으로 바뀐 소수가 어떻게 컴퓨터 메모리에 저장되는지 알아보도록 합시다.

일단, 우리가 컴퓨터 에게 소수를 입력하게 되면 컴퓨터는 이 소수를 이진법으로 바꾸는 과정을 거치게 되는데 이 과정은 위에서 나온 과정과 비슷합니다. 그런데, 문제는 이렇게 십진법으로 표현된 소수를 이진법으로 바꾸는 데 에서 오차가 발생하게 되는데 위 `-118.625` 는 오차 없이 깔끔하게 이진법으로 바뀌었으나 대부분의 소수들은 이진법으로 바뀔 때 오차가 발생합니다.

심지어는 십진법으로 아주 간단하게 나타나는 `0.1` 조차 이진법으로 바꾼다면 아래와 같이 무한 소수가 나타나게 됩니다.

$$0.1 = 2^{-4} + 2^{-5} + 2^{-8} + 2^{-9} + \cdots = 0.001100110011..._{(2)}$$

밑기지 않는 분들은 무한 등비수열의 합을 구하는 방법을 안다면 `0.1` 이 바뀐 무한 이진소수가 참임을 알 수 있습니다.

$$ 0.001100110011..._{(2)} = \frac{\frac{1}{2^{4}}}{1 - \frac{1}{2^{4}}} + \frac{\frac{1}{2^{5}}}{1 - \frac{1}{2^{4}}} = \frac{1}{15} + \frac{1}{30} = \frac{1}{10}$$

컴퓨터는 이렇게 무한히 길게 나타나는 무한 소수들을 모두 메모리에 나타낼 수 없기 때문에 일정 부분만 잘라서 메모리에 보관하게 됩니다. 따라서 오차가 발생하게 됩니다.

이제, 이진 소수로 입력한 실수를 바꾸었다면 부호 비트를 할당하게 됩니다. 앞서, `-118.625` 의 경우 부호 비트에 1 이 할당 됩니다. (음수 이기 때문이죠) 만약 우리가 `118.625` 를 입력하였더라면 부호 비트에 0 이 할당되게 됩니다.

두 번째로 변환된 이진수를 정규화(Normalization) 합니다. 말이 조금 어렵지만 사실을 매우 간단한 작업 입니다. 정규화란, 어떠한 이진수를 `1.xxxx` 꼴로 만드는 것이지요. `-118.625` 의 경우,  이진수 형태인 `1110110.101` 을 `1.110110101` 로 바꾸는 것 입니다.  그렇다면 가수 부분에는 `xxxx` 부분, 즉 110110101 만 저장이 되겠지요.

이 때, 정규화 작업 시 얼마만큼 쉬프트 연산이 일어났는지 계산하여 지수 부분에는 얼마가 와야 되는지 알게 됩니다. 위의 경우 `1110110.101` 을 `1.110110101` 로 바꾸었으므로 쉬프트 연산이 6번 오른쪽으로 일어나게 되어서 지수에는 6 이 오게 됩니다. 만약에, `0.1` 처럼 무한 소수로 표현되는 수들의 경우 반올림을 하게 됩니다. 예를 들어 `0.1 = 0.00011001 10011001 10011001 10011001 10011001 ..` 로 나가는데, `float` 에 대입한다고 하면 `float` 의 가수 부분이 23 비트이므로 24 번째 비트에서 반올림을 하게 됩니다. 따라서, `0.1` 은 컴퓨터 상에 `0.00011001100110011001101` 로 보관 되겠지요.

마지막으로 위에서 계산한 지수에 바이어스(Bias) 처리를 해줍니다. 이 역시 말이 조금 어렵지만 지수에!
$$ 2^{e - 1} - 1 $$

만큼을 더해주는 것 입니다. 이 때, `e` 의 값은 지수 부분의 비트 수로, `float` 형 이면 8 비트 이므로 `127, double` 형이면 11 비트 이므로 1023 을 더하게 됩니다.

왜 계산한 지수에 바이어스 처리를 해주냐면은, 지수가 언제나 양수가 아니기 때문입니다. `-118.625` 의 경우 정규화 시 지수가 `+6` 이였으나 다른 소수들의 경우 - 예를 들어 `0.625` 는 이진수로 `0.101` 인데 정규화 시, 왼쪽으로 쉬프트가 1 번 되므로 지수가 음수(-1) 가 됩니다.

그렇다면, 지수 부분에 음수가 들어갈 경우를 대비하여 지수를 위한 부호 비트를 설정해야 되는 것 아니냐? 라고 물어 볼 수 있습니다. 하지만 컴퓨터 기술자들은 힘들게 부호 비트를 하나 더 설정하느니, 차라리 위 처럼 바이어스 처리를 하여 지수 부분에 무조건 양수만 오게 한 것입니다. 

따라서, 만약 우리가 `float` 형 변수를 이용하게 된다면 위 바이어스 처리를 통해 지수가 -127 부터 127 일 때 까지 처리가 가능하게 되었습니다. 물론 `double` 형 변수를 이용하면 지수가 무려 -1023 ~ 1023 일 때 까지도 처리가 가능하겠지요.

일단 여기서  `-118.625` 를 `float` 형 변수에 대입하였다고 합시다. 그렇다면 `6 + (127) = 133` 이 지수 부분에 들어가게 됩니다. 133 은 이진수로 10000101 이지요. 따라서, `float a = -118.625;` 를 한 변수 `a` 의 메모리 구조를 살펴보면 아래와 같습니다.

![1, 부호 비트. 1 0 0 0 0 1 0 1, 지수 비트 (총 8 비트, 1 1 0 1 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 , 가수 부분 (총 23 비트](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F125365034B67FFE85B3195)

이 때, 훌륭한 학생이라면 의문이 드는 점이 있을 것 입니다. 위에서 `float` 형 변수를 이용하게 되면 지수가 -127 부터 127 까지 처리가 된다고 하였는데, 8 비트로 처리할 수 있는 수의 범위가 `0 ~ 255` 까지 이므로 `-127 ~ 128` 까지 처리가 되야 되는 것 아닌가? 맞다. 하지만 제가 127 까지 된다고 한 이유는 IEEE 에서 아래와 같이 규칙을 정했기 때문입니다.

![0 은 지수부, 가수부 모두 0, 무한대는 지수부는 1 로 꽉차있고 가수부는 모두 0, 등등으로 특별한 경우를 표시합니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F145C7B034B67FFE86C028F)
다시말해, 지수부를 127 까지 밖에 이용을 안하냐면, 여러 특별한 수 들을 표현하기 위해 입니다. 위 표에도 잘 나와 있듯이, 지수부가

$$2^e − 1$$

즉 `float` 의 경우 지수부에 255 가 들어갈 때, (원래 수의 지수가 128 일 때와 동일) 가수부에 0 이 들어가면 이 수가 '무한대' 임을 표현하기 위해입니다. 또한, 위 경우 가수부에 0 이 들어가지 않는다면 `NaN` 을 나타내는데, 이는 0/0, 0/∞, 0/∞, ∞/∞ 와 같은 잘못된 값 들을 표현하기 위함 입니다.

이 때, 표의 세 번째 행에 '비정상 수' 라고 나온 부분이 있는데 비 정상수는 부동 소수점 방식으로 표현될 수 있는 최소의 수 보다도 더 작은 수 들을 비정상 수 라고 부르게 됩니다. `float` 형의 경우 

$$2^{−127}$$

보다 작은 수들을 말하게 됩니다.

아무튼, 부동 소수점에 대한 이야기는 여기서 마치도록 하겠습니다. 사실, 부동 소수점에 관한 이야기는 초보자 한데는 적합하지 않은 것이 사실인데  아무튼, 한 번쯤 들어 놓으면 좋은 주제니까 한 번 해 보았습니다. 이제, 다시 형 변환 이야기로 넘어가도록 하죠.


###  형 변환 (캐스팅)

그렇다면 우리는 경고가 나오지 않게 대입을 할 수 없는가요? 물론 있습니다. 서로의 형을 맞추어 버리면 되죠.

```cpp-formatted
/* 형변환 */
#include <stdio.h>
int main() {
  int a;
  double b;

  b = 2.4;
  a = (int)b;

  printf("%d", a);
}
```

  성공적으로 컴파일 하면 아무리 눈을 굴려보아도 오류 나 경고 따위는 눈을 씼고 찾을 수 없게 됩니다. 그래서, 부푼 마음에 실행을 해 보면...
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F13151B0B4B67FFE858B166)

결과는 아까와 같은 2 입니다...

하지만, 아까와 같은 경고 메세지는 출력이 되지 않았습니다. 왜 일까요? 그 이유는 바로 우리가 강제로 형변환(캐스팅) 을 하였기 때문입니다.

어떠한 변수의 형을 바꿀려면 아래와 같이 하면 됩니다

```info
 (바꾸려는 형) 변수 이름
```

예를 들어, 위의 경우 `double` 로 선언된 `b` 를 `int` 로 바꾸었으므로 `(int)b` 라 하면 됩니다. 이 때, 형을 바꾼다는 것은 영구적으로 바뀌는 것이 아닙니다. 다시 말해 `double` 인 `b` 를 `int` 로 캐스팅 한다고 해도 `b` 가 `int` 인 변수가 되는 것이 아니라 계산식에서 일시적으로 `int` 형 변수로 바꾼 후 생각하라는 것 이죠. 즉,캐스팅을 하고도

```cpp-formatted
printf("%f", b);
```

를 하게 되면 2.4 가 성공적으로 출력됩니다. 위 예제에서 우리는 강제로 형을 변환하였습니다. 따라서 컴파일러는 '아, 이 사람이 마음을 먹고 아예 형이 다른 변수들의 대입을 시도하는 구나' 라고 생각하고 오류 메세지를 출력하지 않게 되는 것 입니다.

```cpp-formatted
/* 두 수의 비율 */
#include <stdio.h>
int main() {
  int a, b;
  float c, d;

  printf("두 숫자 입력 : ");
  scanf("%d %d", &a, &b);

  c = a / b;
  d = (float)a / b;

  printf("두 수의 비율 : %f %f", c, d);

  return 0;
}
```

  성공적으로 컴파일 하면 (경고는 나오지만), 예를 들어 5 와 3 을 입력하였을 때 아래와 같이 나옵니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1207320B4B67FFE814B702)

  와우! 신기하네요. 단지 형변환을 하고 안하고의 차이였지만 두 수의 비율이 하나는 정확하게 나오고 다른 하나는 부정확하게 나오는 군요. 일단, 위 예제에서 관건이 되는 부분은 바로 이 부분입니다.

```cpp-formatted
c = a / b;
d = (float)a / b;
```

`c` 에는 `a` 를 `b` 로 나눈 값이 들어갑니다. `d` 에도 마찬가지인데 한 가지 차이점은 `d` 에서는 `a` 를 `float` 변수로 생각해서 계산하라라고 캐스팅 하였습니다. 이 때, 우리가 주목해야 하는 부분은 바로 `a` 와 `b` 가 정수형 변수라는 것 입니다.

컴퓨터에서 `a/b` 는 2 가지의 의미를 가집니다. 만약 `a` 와 `b` 중 어느 하나가 실수형 변수(float, `double)` 이라면 이는 정말 우리가 하는 나눗셈을 수행하게 됩니다. 다시말해 `5/3 = 1.666666666666666666` 이 되는 것 이죠. 하지만 `a` 와 `b` 가 모두 정수형 변수(`char, int, long`) 라면 컴퓨터는 위와 같은 나눗셈 연산을 수행하지 않고 소위 말하는 '몫' 을 계산하게 됩니다. 따라서 `5/3 = 1` 이 되는 것이지요.

따라서, `(float)a/b` 를 하게 되면 컴퓨터가 `a` 를 실수형 변수로 생각해가 되므로 `a/b` 처럼 몫을 계산하지 않고 정말로 실수형 나눗셈을 수행하게 된다는 것입니다. 따라서 `d` 에는 `1.6666 ...` 이 성공적으로 들어갈 수 있게 됩니다.

어때요? 형변환 하나로 많은 결과가 달라지지 않습니까? 실제로 형변환은 C 언어에서 매우 중요한 부분 중 하나 입니다. 또한 쓰임새도 상당히 많은데, 주로 실수형 변수에서 정수 부분만 추출할 때 사용되기도 합니다.

예를 들어 `double a; int b;` 일 때, `b = (int)a;` 라 하게 되면 변수 `a` 의 정수 부분 데이터만 `b` 로 넘어가게 되죠. 물론 `b = a` 로 해도 컴파일러가 알아서 캐스팅을 해주지만 그렇게 된다면 다른 프로그래머가 보았을 때, 이 것이 실수 인건지, 고의로 한 건지 모르므로 오해의 소지가 있습니다.

마지막으로 여러분에게 재미있는 문제를 내 보도록 하죠. [www.winapi.co.kr](http://www.winapi.co.kr) 이라는 사이트에서 가져온 문제인데, 여러분도 한 번 풀어보세요

### 생각 해보기

#### 문제 1

임의의 실수에서 소수점 이하 두자리수만 추출하여 정수형 변수에 대입하라. 예를들어 사용자로부터 입력받은 실수 `f` 가 12.3456이라면 34만 추출한다. 이때 반올림은 고려하지 않아도 상관없다. `f` 가 달러 단위의 화폐 액수라고할 때 센트 단위만 추출해내는 경우라고 생각하면 된다. 다음 `????` 자리에 적합한 연산식을 작성하는 문제이다.

예를들어 사용자로부터 입력받은 실수 `f` 가 12.3456이라면 34만 추출한다. 이때 반올림은 고려하지 않아도 상관없다. `f` 가 달러 단위의 화폐 액수라고할 때 센트 단위만 추출해내는 경우라고 생각하면 된다. 다음 `????` 자리에 적합한 연산식을 작성하는 문제이다.

```cpp-formatted
printf("실수를 입력하시오 : ");
scanf("%f", &f);
i = ? ? ? ? printf("i=%d\n", i);
```

이 문제의 핵심은 음수이거나 소수점 이하의 자리수가 없는 경우까지 잘 고려하여 항상 잘 동작하는 코드를 만드는것이다.

##@ chewing-c-end
Link :  16
2009-08-15 11:22
----------------
title : 씹어먹는 C 언어 - <9. 만약에... 2탄 (switch 문)>
cat_title: 9. 만약에... 2탄 (switch 문)
next_page : 17
publish_date : 2009-08-15 11:22
--------------

* `switch` 문에 대한 이해, 내부적 처리에 대한 간단한 설명

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분. 그 동안 잘 지내셨는지요? 제가 그 동안 바뻐서 글을 많이 못 올렸으나 일이 잘 해결되어서 이제 더이상 이전처럼 바쁘지 않겠네요. 아무튼, 지금까지 제 강좌를 보시느라 오랫동안 기다려 주신 분들께 정말 감사하다고 생각되고 아직까지도 C 언어를 배우고자 하는 열정이 사그라들지 않은 여러분들은 최고의 C 언어 프로그래머가 될 것이라 믿습니다.

이번 강좌에서는 `if` 문의 친구인 `switch` 문에 대해 배워 보도록 하겠습니다. `switch` 문이 `if` 문의 친구라고 한 이유는 하는 일이 정말로 `if` 문과 비슷하기 때문이죠. 일단, 아래의 초-간단한 강아지 시뮬레이션을 보세요.

```cpp-formatted
/* 마이펫 */
#include <stdio.h>
int main() {
  int input;

  printf("마이펫 \n");
  printf("무엇을 하실 것인지 입력하세요 \n");
  printf("1. 밥주기 \n");
  printf("2. 씻기기 \n");
  printf("3. 재우기 \n");

  scanf("%d", &input);

  if (input == 1) {
    printf("아이 맛있어 \n");
  } else if (input == 2) {
    printf("아이 시원해 \n");
  } else if (input == 3) {
    printf("zzz \n");
  } else {
    printf("무슨 명령인지 못 알아 듣겠어. 왈왈 \n");
  }
  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F166415244A8684E746F97D)

와 같이 3 가지 명령에 대해 반응하고 알 수 없는 명령은 '무슨 명령인지 못 알아 듣겠어. 왈왈' 라고 내보냅니다.

그런데, 만약 강아지가 위 3 가지 명령만 반응하는 것이 아니라 10 가지 명령에 반응하게 하고 싶다고 합시다. 그렇다면 여러분은 아마도 아래와 같이 할 것 입니다. (참고로 아래 '...' 인 부분은 필자가 쓰기 귀찮아서 생략한 부분 입니다.)

```info
   if (...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
    else if(...)
    {
        ...
    }
```

음, 아마도 위 소스코드를 보는 사람이 상당히 불편하게 느낄 것이라고 생각되지 않나요? 물론 보는 이에 따라 다르겠지만 아마 대부분의 사람이 그렇게 생각할 것 입니다. 아마 실제로 사람들과 함께 프로젝트를 진행 할 때 위와 같은 소스를 남발하게 된다면 읽는이도 불편하고 쓰는 사람도 손목이 많이 아플 것 입니다. (물론 `Ctrl + v` 신공이 있기는 하지만...)

따라서, 위와 같이 동일한 변수에 대해 비교문이 반복되는 경우에 아래와 같이 깔끔한 `switch` 문을 적용 시킬 수 있습니다.

```cpp-formatted
/* 업그레이드 버전 */
#include <stdio.h>
int main() {
  int input;

  printf("마이펫 업그레이드\n");
  printf("무엇을 하실 것인지 입력하세요 \n");
  printf("1. 밥주기 \n");
  printf("2. 씻기기 \n");
  printf("3. 재우기 \n");

  scanf("%d", &input);

  switch (input) {
    case 1:
      printf("아이 맛있어 \n");
      break;

    case 2:
      printf("아이 시원해 \n");
      break;

    case 3:
      printf("zzz \n");
      break;

    default:
      printf("무슨 명령인지 못 알아 듣겠어. 왈왈 \n");
      break;
  }

  return 0;
}
```

아마 컴파일 된 결과는 위와 동일하게 나올 것 입니다. 이제, 위 소스 코드에서 가장 중요한 부분인 `switch` 문 부분을 살펴보도록 합시다.

```cpp-formatted
switch (input) {
  case 1:
    printf("아이 맛있어 \n");
    break;

  case 2:
    printf("아이 시원해 \n");
    break;

  case 3:
    printf("zzz \n");
    break;

  default:
    printf("무슨 명령인지 못 알아 듣겠어. 왈왈 \n");
    break;
}
```

`switch` 문의 기본 구조는 아래와 같습니다.

```info
    switch(변수)
    {
    case 값1:
        명령들;
        break;
    case 값2:
        명령들;
        break;
        .. (생략) ..
    }

```

이 때, 변수 부분에는 값1, 값2, ... 들과 비교할 변수가 들어가게 됩니다. 위 예제의 경우 `input` 을 1 과 2 와 3 과 비교해야 했으므로 변수 부분에는 `input` 이 들어가게 됩니다. 이 때 `switch` 문에 사용될 변수로는 반드시 정수 데이터를 보관하는 변수여야 합니다. 다시말해 '변수' 부분에 들어가는 변수들의 타입은 `char, short, int, long` 중의 하나여야 합니다. 만약 `input` 이 `float` 이나 `double` 이라면 컴파일시 오류가 발생되게 됩니다.

`변수 ==  값1` 일 때, 가장 맨 위의 `case` 의 명령이 실행됩니다. 위 예제의 경우 1 이 입력되면 `case 1:` 이 참이 되므로 그 `case` 안의 내용들이 모두 실행됩니다. 이 때 각 명령들을 모두 실행한 후 `break` 를 만나면 `switch` 문을 빠져 나가게 됩니다.

예를 들어서 1 이 입력되었다면 `case 1:` 이 참이므로  `printf("아이 맛있어 \n");`  와 `break;` 가 실행되어 "아이 맛있어" 를 출력하고 `break` 를 통해 `switch` 문을 빠져 나가게 됩니다.

만약 `변수 == 값2` 라면 `case` 값1 은 실행되지 않고 `case` 값2 만 실행되게 됩니다.

또한 주의할 점으로는 '값' 에 위치하는 것들이 무조건 상수 이여야 한다는 것입니다. 만약 '값' 부분에 변수들이 오게된다면 오류가 발생하게 되는데 그 이유는 `switch` 문의 내부적인 처리 방법 때문입니다. (아래쪽 설명 되어 있습니다.)

마지막으로 `switch` 문의 `default` 는 `if` 문의 `else` 와 같은 역할을 합니다. 이도 저도 아닌 것들이 오는 `case` 이죠. 즉 위 예제의 경우 `input` 이 1 도 2 도 3 도 아닐 때 도달하는 경우가 됩니다.

그런데 위 `switch` 문에서 등장한 `break` 는 어디서 많이 본 것 같지 않습니까? 만약 그런 생각이 들었다면 당신은 C 언어 공부를 아주 충실히 하고 있다고 생각 됩니다. (만약 잘 모르겠다면 [여기](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-7-%EB%B1%85%EA%B8%80-%EB%B1%85%EA%B8%80-for-while)를 클릭하세요) break; 문을 실행하면 아래의 모든 `case` 들을 무시하고 `switch` 밖으로 빠져나가기 때문에 밥을 주었는데 강아지가 '아이 맛있어' 라고 할 일은 없게 됩니다.

하지만 만약 여러분이 `break;` 문을 빠뜨리게 되면 위와 같은 상황이 벌어질 수 있습니다.

```cpp-formatted
/* 실패작 */
#include <stdio.h>
int main() {
  int input;

  printf("마이펫 업그레이드\n");
  printf("무엇을 하실 것인지 입력하세요 \n");
  printf("1. 밥주기 \n");
  printf("2. 씻기기 \n");
  printf("3. 재우기 \n");

  scanf("%d", &input);

  switch (input) {
    case 1:
      printf("아이 맛있어 \n");

    case 2:
      printf("아이 시원해 \n");

    case 3:
      printf("zzz \n");

    default:
      printf("무슨 명령인지 못 알아 듣겠어. 왈왈 \n");
  }

  return 0;
}
```

성공적으로 컴파일 한다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F13554E114A8689A11652B4)

와 같이 웃지 않을 수 없는 상황이 벌어집니다. 여러분들이 1 을 입력한다면 `case 1:` 이 실행되어 그 내용들이 모두 실행되지만 `break` 문으로 `switch` 문을 빠져 나가지 못해서 아래 `case` 들 까지 줄줄이 실행되어 위와 같은 꼴을 볼 수 있습니다.

```cpp-formatted
/* 영어 말하기 */
#include <stdio.h>
int main() {
  char input;

  printf("(소문자) 알파벳 읽기\n");
  printf("알파벳 : ");

  scanf("%c", &input);

  switch (input) {
    case 'a':
      printf("에이 \n");
      break;

    case 'b':
      printf("비 \n");
      break;

    case 'c':
      printf("씨 \n");
      break;

    default:
      printf("죄송해요.. 머리가 나빠서 못 읽어요  \n");
      break;
  }

  return 0;
}
```

  성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197F17254A868D363ED3F5)

와 같이 나옵니다.

사실, 여기에 의문이 드는 사람들도 있습니다. '아까 위에서 `switch` 문은 정수 데이터만 처리한다고 했는데 왜 여기서는 문자 데이터도 처리가 되는 것인가?' 그런데, 안타깝게도 이러한 의문이 5 초 이내로 해결되지 않으면 아마 앞에서 배운 내용을 까먹으셨을 것입니다. (그 내용을 보려면 [여기](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-3-%EB%B3%80%EC%88%98%EA%B0%80-%EB%AD%90%EC%A7%80)를 클릭하세요) 왜냐하면 컴퓨터는 문자와 숫자를 구분 못합니다. 컴퓨터는 문자를 모두 숫자로 처리한 뒤, 우리에게 보여줄 때 에만 문자로 보여주는 것이지요. 따라서, 문자 = 정수 라고 생각해도 거의 무방합니다.

이쯤 `switch` 문을 배우고 나면 드는 의문이 하나 있습니다.

"정말로 `switch` 문이 우리에게 필요한가? `if - else` 로 다 해결되는데 왜 귀찮게 `switch` 문을 만들었을까? 차이는 단지 겉으로 얼마나 깔끔한지가 다를 뿐인데... 내부적으로 `switch` 문과 `if-else` 와는 차이가 없나요?"

정말로, 훌륭한 생각이라고 생각합니다. 위 질문에 대한 답변을 정확하게 이해하려면 어셈블리어에 대한 이해가 필요로 합니다.
(참고로 `if` 문과 `switch` 문의 차이에 대한 설명을 자세하게 잘 다루는 곳 : [http://blog.naver.com/kki2406?Redirect=Log&logNo=80041410085](http://blog.naver.com/kki2406?Redirect=Log&logNo=80041410085)` )`

위에 링크 걸은 사이트에 들어가 내용을 모조리 이해한다면 더할 나위 없이 좋겠으나 아마 C 언어를 처음 배우는 사람들의 경우 거의 이해를 못할 것이니 제가 간단하게 설명 드리겠습니다. (만약 아래의 내용을 이해하지 못하더라고 그냥 넘어가세요. 사실 어셈블리어를 배우지 않은 이상 이해하기 힘듭니다)

![switch 문을 이용하여 case 1, case 2 등 쭉 코드를 짠 것입니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1812271B4A8699234673BF)

`switch` 문 이용![if 문과 else if, else 문을 이용하여 코드를 짠 것입니다. 왼쪽의 코드와 동일합니다.](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F201F881B4A869924227727)

위 두 그림은 같은 소스 코드를 `switch` 문과 `if` 문을 이용하여 나타난 것입니다. 사실, 외형적으로 동작하는 것은 차이가 없습니다. 단지 내부적으로 어떻게 처리되냐가 다를 뿐이지요.

일단 `if` 문의 경우 각 경우 마다 값들을 비교 합니다. 위 경우 값을 3 번 비교하겠네요. 왜냐하면 `if` 가 1 번, `else if` 가 2 번이고 `else` 의 경우 값의 비교 없이 자동으로 처리되는 것이므로 총 3 번 비교하게 됩니다. 즉, `if` 문을 이용하면 각 `case` 의 경우 비교하게 되므로 최악의 경우 모든 `case` 에 대해 값을 비교하는 연산 (어셈블리어에서는 `CMP` 연산을 합니다.) 을 시행하게 됩니다.

그런데 `switch` 문은 사뭇 다릅니다. `switch` 의 경우 내부적으로 `jump table` 이라는 것을 생성합니다. 이 때, `jump table` 의 크기는 `case` 의 값들에 따라 달라지는데, 예를 들어서 어떤 `switch` 문의 경우 `case 1: ~ case` 10: 까지 있었다고 합시다. 그렇다면 `jump table` 에는 값들이 0 부터 9 까지 들어가게 됩니다. 여기서 우리는 왜 `case` 값: 할 때, '값' 부분에 변수가 위치하면 안되는지 알게 됩니다. `jump table` 은 프로그램 초기에 작성 되기 때문에 이미 `switch` 문이 실행되기 전에 `jump table` 이 작성되게 됩니다. 따라서, '값' 부분에 변수가 들어가게 되면 `jump table` 에 무엇이 올지 알 수 없으므로 변수를 사용하면 안되는 것입니다.

이 값들은 무엇을 의미하냐면 각 `case` 별로 명령들이 위치한 곳의 주소를 가리키는데 예를 들어서 1 인 지점으로 점프하게 되면 "아이 시원해" 가 나오고 0 인 지점으로 점프하게 되면 "아이 맛있어" 라고 출력하라는 내용의 명령문들이 나옵니다. 이제, 변수의 값에 따라 변수가 3 이라면 `jump table` 의 3 번째 원소를 찾아서 그 값에 해당하는 곳으로 점프하게 됩니다.

(실제로 `switch` 문이 처리되는 과정은 이보다 약간 더 복잡하지만 어셈블리어를 배우지 않은 현재 상황으로써는 최선이라 생각됩니다)

따라서, `switch` 문을 이용하면 `case` 에 따라 `CMP` 연산이 늘어나는 것이 아니라 `jump table` 의 크기만 커질 뿐 성능에 있어서는 전혀 영향을 받지 않게 됩니다.

결론적으로 이야기 하자면 `switch` 문이 효과적으로 처리되기 위해서는 `case` 의 '값' 들의 크기가 그다지 크지 않아야 하고, '값' 들이 순차적으로 정렬되어 있고, 그 '값' 끼리의 차이가 크지 않다면최고로 효율적인 `switch` 문을 이용할 수 있게 됩니다.

###  생각해 보기

#### 문제 1

`switch` 문의 '값' 부분에 왜 정수만 와야 되는지 아십니까?(난이도 : 中上)

#### 문제 2

앞서, `switch` 문이 내부적으로 처리 되는 부분에서 `case 1: ~ case 10:` 일 때 만 생각하였는데, 만약 `case 1:, case 3:, case 4:, case 10:` 과 같이 불규칙 적으로 `switch` 문이 적용된다면 컴퓨터는 `jump table` 를 어떻게 작성할까요 (난이도 : 最上)

##@ chewing-c-end
Link :  14
2009-08-06 21:24
----------------
title : 씹어 먹는 C 언어 - <8. 우분투 리눅스에서 C 프로그래밍 하기>
cat_title: 8. 우분투 리눅스에서 C 프로그래밍 하기
next_page : 16
publish_date : 2009-08-06 21:24
--------------


이번 강좌에서는...

* 우분투
에서 `GCC` 설치

* 기초적인 `VIM` 사용법

* `GCC` 로 컴파일 한 후 실행하기.


![우분투 리눅스의 로고 입니다.](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1721750B4A43B0A903BD87)

안녕하세요, 여러분. 이번 강좌에서는 우분투 리눅스 상에서 C 프로그래밍을 하는 법에 대해서 알아 봅시다. 일단, 우분투 리눅스 상에서 C 프로그래밍을 하는 법을 안다면, 다른 배포판에서도 비슷한 방법으로 따라 할 수 있으므로 도움이 될 것입니다.

일단, C 프로그래밍을 하려면 컴파일러가 있어야 되는데, 아시다 시피 리눅스 상에서는 `Visual Studio` 계열을 사용할 수 없습니다. 왜냐하면 그것들은 모두 `Microsoft` 사의 제품이기 때문이죠. 하지만, 훌륭한 오픈 소스 개발자들이 리눅스 용 컴파일러를 개발하였는데, 그 이름하여 유명한 `GCC (GNU Compiler Collection)` 입니다. 사실, 초기의 `GCC` 는 `GNU C Compiler` 의 약자로, C 언어 컴파일만 지원하였으나, 후에 `Ada, C++, JAVA, Fotran, Objective-C` 와 같은 언어들도 컴파일 할 수 있게 되여 현재의 이름으로 바뀌었습니다.

대부분의 우분투 배포판에는 기본적으로 `GCC` 가 설치되어 있습니다. 터미널을 열어서 `gcc` 를 쳐보세요


![gcc : no input files 라고 화면에 나옵니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F19169B194A43A2E3E4C0F8)

아마, 십중팔구 위 그림과 같이 나올 것입니다. 하지만 간혹 가다 `gcc` 가 설치되어 있지 않아 아래와 같은 결과가 나타나는 사람들도 있습니다.


![화면에 The program 'gcc' can be found in the following packages 가 나오며 apt-get 을 통해 설치하라고 나올 것입니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1839C50D4A43A6E30B04B5)

이럴 때 에는 다음과 같이 입력합니다.


```info
sudo su
```

그리고 비밀번호를 요구하면, 자신이 처음에 설정한 `root` 의 비밀번호를 입력합니다. 만약 자신이 설정한 `root` 의 비밀번호가 무엇인지 모른다면 현재 사용자의 비밀번호를 입력해 보세요. 대부분 현재 사용자의 비밀번호와 `root` 의 비밀번호가 일치 할 것입니다. 만약 입력했다면 아래와 같이


![sudo su 를 입력합니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1761FA254A43A7F2BEA041)

**(사용자 이름)@(컴퓨터이름)** 에서 **root@(컴퓨터이름)** 으로 바뀐 것을 볼 수 있습니다. 이제, 여러분은 아래의 명령어를 입력해서 `gcc` 를 설치하시면 됩니다.

```info
apt-get install gcc
```

입력하면 아래와 같이 나옵니다.


![뭐가뭐가 주르륵 나오게 됩니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F12502E254A43A86315AB7A)

만약 `Y/N` 을 요구한다면 `Y` 를 눌러주시면 되고 저처럼 물어보지 않는다면 그냥 기다리세요. 조금만 기다리다가 위 처럼 다시 명령어 입력을 기다리는 상태가 되었다면 설치가 완료 된 것입니다. 이제, `gcc` 를 쳐보세요. 그렇다면 *gcc: no input files* 가 출력되게 되죠.

이제, 한번 `gcc` 를 통해 C 프로그램을 컴파일 해봅시다. 일단 가장 쉬운 `Hello, World` 를 출력하는 프로그램으로 하기로 하죠. 일단 'vim helloworld.c' 를 입력하여 `helloworld.c` 라는 파일을 만듭니다. (간혹 가다 `vim` 이 설치되지 않은 경우가 종종 있는데 이는 위에서 `gcc` 를 설치했던 방법처럼 `apt-get install vim` 이라 쳐서 `vim` 을 설치하시면 됩니다.)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F121ED6174A43AA8D3490A6)

실행하면 아래 화면을 볼 수 있습니다.


![물결 무늬가 쭉 나와있는 빈 화면이 나옵니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F185BD0214A43AB0A762264)

`vim` 은 우리가 흔히 아는 에디터와 다르게 글을 입력하면 바로 내용이 써지는 것이 아닙니다. 일단,`i`를 눌러서 **입력모드(insert mode)** 에 들어가야 합니다. `i` 를 누른다면 아래에 `INSERT` 라고 뜨게 되죠.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F151CAF164A43AC108A523C)

이제, 드디어 글을 입력할 수 있습니다.  그냥 보통 편집기 처럼 프로그램을 작성하면 됩니다. 한 가지 유의해야 할 점은 `Visual Stdio` 처럼 자동으로 `indentation` 을 해주는 것이 아닙니다. (물론 `vim` 설정파일에서 `autoindent` 로 설정하면 가능하지만 여기서는 짧은 프로그램이므로 손으로 직접 해도 상관 없습니다. 자세한 내용은 다음 사이트를 참조하세요 : [http://kevin0960.tistory.com/entry/VIM-Vi-iMproved-%EC%9D%98-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%AA%A8%EC%9D%8C](http://kevin0960.tistory.com/entry/VIM-Vi-iMproved-%EC%9D%98-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%AA%A8%EC%9D%8C%20))

다 입력한다면 아래와 같은 모습이 됩니다.


![화면에 #include 로 쭉 해서 Hello, World 를 출력하는 소스를 짜세요!](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1543F3194A43AD6968433C)

이제, `Esc` 키를 눌러서 **명령 모드(Command Mode)** 로 들어간 후, :wq 를 입력하세요. 이는 저장(w) 하고 종료(q) 하라는 뜻 입니다. 입력한다면 프로그램을 빠져나가게 되죠.

프로그램을 빠져 나갔다면 이제 `gcc` 를 통해 프로그램을 컴파일 `+` 링크 해야 겠군요.

```info
gcc -o helloworld helloworld.c
```

라고 입력하세요. 여기서 `-o` 는 출력파일의 이름을 지정하는 것입니다. 즉 `-o helloworld` 는 출력파일의 이름을 `helloworld` 로 하라는 뜻이지요. 만약 그냥 `-o` (출력파일 이름) 을 통해 출력파일 이름을 지정하지 않고 그냥 `gcc helloworld.c` 로 하게 되면 출력파일 이름이 `a.out` 으로 만들어 지게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F183F86194A43AE1E757BAE)

위 명령어를 입력 한 후 , 아무 내용이 뜨지 않는다면 애러없이 성공적으로 컴파일 된 것입니다.  이제,

```info
./helloworld
```

를 입력해서 만든 프로그램을 실행시켜 보세요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F17649D224A43AF4176F9B3)

위 처럼 `Hello, World!` 가 출력되었다면 대 성공 입니다. 축하합니다.

참고해서 읽어 볼 만한 자료

`VIM` 설정 및 명령어 모음
 [http://kevin0960.tistory.com/entry/VIM-Vi-iMproved-의-명령어-모음](http://kevin0960.tistory.com/entry/VIM-Vi-iMproved-%EC%9D%98-%EB%AA%85%EB%A0%B9%EC%96%B4-%EB%AA%A8%EC%9D%8C)
 [http://www.linuxconfig.org/Vim_Tutorial](http://www.linuxconfig.org/Vim_Tutorial)
 [http://blog.interlinked.org/tutorials/vim_tutorial.html](http://blog.interlinked.org/tutorials/vim_tutorial.html)

`gcc` 및 `Makefile` 강좌
 [http://wiki.kldp.org/KoreanDoc/html/gcc_and_make/gcc_and_make-2.html](http://wiki.kldp.org/KoreanDoc/html/gcc_and_make/gcc_and_make-2.html)


##@ chewing-c-end
Link :  12
2009-08-06 21:24
----------------
title : 씹어먹는 C 언어 - <7. 뱅글 뱅글 (for, while) >
cat_title : 7. 뱅글 뱅글 (for, while)
next_page : 14
publish_date : 2009-08-06 21:24
--------------


이번 강좌에서는...
* `for` 문 (for statement) 에 대해 이해한다

* `while` 문과 `do - while` 문에 대해 이해한다

* 반복문과 `if` 문을 적당히 잘 이용한다


![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요, 여러분. C 언어 공부는 잘 되가고 있나요? 제 사이트의 강좌 만을 보고도 충분히 C 언에 대한 깊은 학습이 이루어 질 수 있다고 생각하지만 사이트의 강좌 업데이트 속도가 느리니 답답하신 분들도 많을 것 입니다. 그러한 분들은 특별히 C 언어 관련 책을 서점에서 구매하여 읽어보는 것을 추천합니다.

물론 학원을 다녀도 되지만, 시중에 C 언어에 관련한 훌륭한 학습서 (흔히 가장 많이 추천하는 것으로는 열혈강의 C 프로그래밍, A Book On C, Teach Yourself C, 등등) 들이 많이 있으므로 굳이 학원을 다닐 필요가 없을 것이라 생각합니다. 또한 인터넷을 통해서도 C 언어에 관해 많은 정보를 알 수 있으니 이점 유의하시기 바랍니다.

3일전에, Psi 는 친구로 부터 1 부터 100 까지의 합을 구해달라는 요청을 받았습니다. Psi 는 수학자 가우스 처럼 똑똑하지가 못하기에, 등차수열의 합을 구하는 방법을 알지 못했습니다. 하지만 Psi 는 이 블로그에서 C 언어를 통해 계산하는 법을 알았으므로 이를 이용하기로 하였습니다. 그래서, 그는 다음과 같이 30분 동안 열심히 타이핑 하여 아래와 같은 프로그램을 만들었습니다.

```cpp-formatted
#include <stdio.h>
int main() {
  printf("%d", 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 +
                 16 + 17 + 18 + 19 + 20 + 21 + 22 + 23 + 24 + 25 + 26 + 27 +
                 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38 + 39 +
                 40 + 41 + 42 + 43 + 44 + 45 + 46 + 47 + 48 + 49 + 50 + 51 +
                 52 + 53 + 54 + 55 + 56 + 57 + 58 + 59 + 60 + 61 + 62 + 63 +
                 64 + 65 + 66 + 67 + 68 + 69 + 70 + 71 + 72 + 73 + 74 + 75 +
                 76 + 77 + 78 + 79 + 80 + 81 + 82 + 83 + 84 + 85 + 86 + 87 +
                 88 + 89 + 90 + 91 + 92 + 93 + 94 + 95 + 96 + 97 + 98 + 99 +
                 100);
  return 0;
}
```


  그리고, 무사히 계산 결과인 5050을 구해서 친구에게 알려주었습니다. 그런데, 이게 웬일입니까? 그 친구가 갑자기 1 부터 10000까지의 숫자의 합을 계산해 달라고 요청하는 것 아니겠습니까? 위 1 부터 100 까지 쓰는 것도 힘들어 죽겠는데 10000 까지 라니. Psi 는 눈 앞이 캄캄하였습니다. 적어도, 이 강좌를 보기 전 까지는 말이죠.


###  for 문 (for statement)


여러분은 컴퓨터가 왜 생겨났는지 아십니까? 물론 여러가지 이유가 있겠지만 그 중 제일 중요한 이유는 바로 계산 입니다.최초의 컴퓨터라고 알려진 `ENIAC` (물론 이에 대해 의견이 분분 하지만 가장 일반적으로 최초의 컴퓨터는 `ENIAC` 이나 영국의콜로서스 둘 중 하나이네요) 은 탄도의 발사표를 계산하는 역할을 하였습니다. 그렇다면 두 번째로 중요한 컴퓨터의 존재 이유는 무엇일까요? 바로, 노가다 - 즉 반복 연산 입니다.

예를 들어서, 1 부터 100 까지 곱한다고 칩시다. 인간은 지능이 있으므로 충분한 시간만 주어진다면 이를 수행할 수 있습니다. 단, 엄청난 짜증을 내겠지요. 그리고 '도대체 이런 계산을 내가 왜 하나?' 라는 생각도 들어 계산을 하다 말고도망갈 수 도 있습니다. 하지만 컴퓨터의 경우 그렇지 않습니다. 우리가 어떤 생-노가다 성 일을 시켜도 묵묵히 자기 일만합니다. 아무리 지겨운 연산 이라도 전기 조금 더 달라는 요구, 조금 쉬게 해달라는 요구도 없이 묵묵히 자기 일 만 할뿐이지요. 이 것이 바로 우리가 컴퓨터를 쓰는 두 번째 이유 입니다.

따라서, 이번 강좌에서는 반복문에 대해 중점적으로 알아보도록 하겠습니다. 반복문은 컴퓨터 상에서 상당히 많이 쓰이므로 반드시 이해하시기 바랍니다. 일단, C 언어에서 사용할 수 있는 반복문은 여러 종류가 먼저 있습니다만, 가장 먼저 널리 쓰이는 `for` 문에 대해 알아 보도록 하겠습니다.

```cpp-formatted
#include <stdio.h>
int main() {
  int i;
  for (i = 0; i < 20; i++) {
    printf("숫자 : %d \n", i);
  }

  return 0;
}
```


위 소스를 성공적으로 컴파일 하였다면,


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1266D6234A33D95B9F2C54)

와 같이 나옵니다.
`for` 문은 다음과 같은 기본 구조를 가지고 있습니다.

```info
for(초기식;조건식;증감식)
{
명령1;
명령2;
....
}
```

일단, 각 부분의 역할이 무엇인지 알아 보도록 하죠. 초기식에서는 제어변수가 초기화 됩니다. 이 말은 즉슨, `for` 문은 반복문이고, 반복문은 얼마나 반복을 해야 될 지 알아야 합니다. 만약 반복문이 끊이지 않고 반복한다면 `CPU` 사용률을 100%로 끌어 올려 전력 낭비일 뿐 만이 아니라 코드 뒷 부분이 실행되지 않아 여러 오류들이 발생될 수 있습니다.

따라서, C 언어에서는 반복문이 얼마나 반복해야 할 지를 알기 위해 '제어변수' 라는 것을 도입하였습니다. `for` 문으로 하여금 제어변수가 특정한 조건을 만족할 때 에만 반복을 계속하게 한다는 것입니다. 제어변수의 초기값은 `for` 문의 '초기식' 부분에서 지정 됩니다. 예를 들어서 내가 `i` 를 제어변수로 이용하다면 초기식에 `i = 4;` 가 되면 처음 `i` 의 값을 4 로 한다는 뜻이지요.

이제, `for` 문이 조건식을 봅니다. 조건식은 우리의 제어 변수인 `i` 가 만족해야 될 특정한 조건이 있습니다. 예를들어, `i` 의 값은 언제나 10 미만이라 던지 (`i < 10`), `i` 는 언제나 1 이상 이라던지 (`i >= 1`). `for` 문은 이러한 조건식이 참 일때에만 그 일을 수행합니다. 여기서 '그 일' 은 중괄호 속의 명령들을 실행한다는 뜻이지요.

마지막으로 증감식은 "1 회 실행 시 `i` 의 값을 어떻게 만들어야 되냐? " 가 나타나 있습니다. 예를 들어서 증감식에 `i ++` 이 써 있다면 한 번 실행 할 때 마다, `i` 의 값을 1 증가 시킵니다. 

마찬가지로 증감식 부분에 `i -= 2` 라면 한 번 실행 할 때 마다 2 씩 감소하겠네요.

매번 실행 할 때 마다, `for` 문의 증감식이 실행 되고, 그다음에 조건식을 체크 합니다. 만약에 조건식이 `i < 10` 이였고, `i` 의 값은 9 였다고 칩시다. 또한 증감식이 `i ++` 이였다면, 명령들을 실행 한 후, 증감식이 실행되어 `i` 의 값은 10 이 됩니다. 따라서, 조건식이 거짓이 되어 `for` 문을 빠져 나갑니다.

그렇다면 위의 소스 코드는 어떨까요?

```cpp-formatted
for (i = 0; i < 20; i++) {
  printf("숫자 : %d \n", i);
}
```

우리가 컴퓨터라면, 일단 컴퓨터는 `for` 문을 보고,

"음, `i` 의 값을 0 으로 해야 겠다. (초기식)

`for` 문에 `i < 20` 으로 되어 있으므로 (조건식)

"`i < 20` 이 맞나? 맞네.. 그럼중괄호 속의 내용을 실행해야지."

"숫자 0 출력"

또한, `for` 문에 `i++` 로 되어 있으므로 (증감식)

"이제 `i` 의 값을 1 증가 시켜야 겠다. "

따라서, `i` 의 값은 1 이 된다.


"i 의 값이 20 미만 인가? 어, 맞네. 그러면 한 번 더 실행 해야 겠다. "

"숫자 1 출력"

...... (생략) ......

"이제 `i` 의 값을 1 증가 시켜야 겠다" (증감식)

20 번의 실행 후, `i` 의 값이 마침내 20 이 되었다.

"i 의 값이 20 미만 인가? 어? 아니잖아. (조건식) 그러면 이제 `for` 문을 빠져 나가야지"

하며, 더이상 중괄호 속의 내용을 실행하지 않는다. 즉, "숫자 20" 출력은 되지 않는다.

와우! `for` 문은 의외로 간단 합니다. 단지 알아야 하실 것은 `for` 문은 "특정한 연산을 제어변수가 조건에 맞을 때 만 반복해 주는 것이다." 라고 이해 하시면 되겠습니다.

```cpp-formatted
/* 1 부터 19 까지의 합*/
#include <stdio.h>
int main() {
  int i, sum = 0;
  for (i = 0; i < 20; ++i) {
    sum = sum + i;
  }
  printf("1 부터 19 까지의 합 : %d", sum);

  return 0;
}
```

위 소스를 성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F161BE8274A3527D570F4EE)

와 같이 나옵니다.

만약 위 결과를 믿지 못하는 사람들은 직접 계산기로 더하거나, 등차수열의 합 공식을 이용하여 직접 셈하셔 보시기 바랍니다. 아마, 독자 여러분들의 컴퓨터가 비정상이 아니라면, 아니면 당신의 눈이 잘못되지 않는 한 위 결과는 190 으로 나올 것 입니다.

일단, 위 프로그램의 핵심부분은 아래와 같습니다.

```cpp-formatted
for (i = 0; i < 20; ++i) {
  sum = sum + i;
}
```

`for` 문을 살펴보자면, 위 `for` 문은 총 20 회 실행되며 `i` 는 0 부터 19 까지의 값을 가집니다. 이 때 주목해야 할 부분은 바로

```cpp-formatted
sum = sum + i;
```

이 부분이죠. `sum` 이라는 변수에 `i` 의 값이 계속 더해집니다. 아시다 싶이 여러분은 `sum = sum + i` 라는 식의 뜻이 `0 = i` 라는 괴상한 방정식이 아니라 '=' 를 '대입 연산자' 로 생각하여 '`sum` 이란 변수에 `sum + i` 의 값을 집어 넣는다' 라는 의미가 됩니다. 즉, 위 상태로 `for` 문을 실행하게 되면 `sum` 에 0 부터 19 까지의 값이 더해지게 됩니다.

  위 `for` 문을 보통 수식으로 풀어쓰면 아래와 같이 됩니다.

```info
sum = 0; // 초기 조건
sum = sum + 0;
sum = sum + 1; // sum = 1;
sum = sum + 2; // sum = 3;
sum = sum + 3; // sum = 6;
....
sum = sum + 19; // sum = 190;
```


이 되는 것이지요. 그렇다면 이제 Psi 의 고충을 풀어줄 시간이 왔네요. 1 부터 10000 까지의 합은 어떻게 구할까요? 그야 간단합니다. 단지 조건식만 약간 수정해 주면 됩니다. 한가지 걱정할 부분은 만약 10000 까지의 합이 `int` 자료형의 범위보다 크면 안되는데, 다행히도 크지 않으므로 그냥 계산 하시면 됩니다. 이는 아래와 같습니다.

```cpp-formatted
#include <stdio.h>
int main() {
  int i, sum = 0;
  for (i = 0; i <= 10000; ++i) {
    sum = sum + i;
  }
  printf("1 부터 10000 까지의 합 : %d \n", sum);

  return 0;
}
```

그 결과는


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F14694D204A352F3FBBB98A)

와 같네요. 결국 Psi 는 친구와의 우정을 지킬 수 있었습니다. ㅎㅎ

```cpp-formatted
/* for 문 응용 */
#include <stdio.h>
int main() {
  int i;
  int subject, score;
  double sum_score = 0;

  printf("몇 개의 과목 점수를 입력 받을 것인가요?");
  scanf("%d", &subject);

  printf("\n 각 과목의 점수를 입력해 주세요 \n");
  for (i = 1; i <= subject; i++) {
    printf("과목 %d : ", i);
    scanf("%d", &score);
    sum_score = sum_score + score;
  }

  printf("전체 과목의 평균은 : %.2f \n", sum_score / subject);

  return 0;
}
```

위 소스를 성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2044D40D4A44EF7DC1A1DE)

음, 여러 과목을 입력해 보면서 실제 시험 성적 평균을 내보시기 바랍니다. 아무튼, 위 소스를 살펴 봅시다. 일단, 가장 중요한 부분인 `for` 문 부분 부터 보자면...

```cpp-formatted
for (i = 1; i <= subject; i++) {
  printf("과목 %d : ", i);
  scanf("%d", &score);
  sum_score = sum_score + score;
}
```

`for` 문을 살펴보면 `i` 의 값이 1 에서 `subject` 까지 1 씩 증가하면서 돌아가네요. 이 말은 즉슨,  `for` 문 안의 내용이 `subject` 번 실행된다는 뜻입니다. (즉, `subject` 가 3 이라면, `i` 의 값이 1 부터 3 까지 1 씩 증가하면서 돌아가므로 `1,2,3.` 즉 3 번 `for` 문 속 내용이 실행됩니다)

  이 때,

```cpp-formatted
printf("과목 %d : ", i);
scanf("%d", &score);
```

위 부분에서 각 과목의 점수를 입력받고, 그 입력받은 점수를 `score` 라는 변수에 저장하게 되죠.

```cpp-formatted
sum_score = sum_score + score;
```

그리고, 그 입력받은 `score` 를 `sum_score` 에 더하게 됩니다. 다시말해, `for` 문이 모두 돌아가고 나면 `sum_score` 에는 입력받은 과목들의 점수의 합이 들어가게 됩니다. 따라서,
```cpp-formatted
printf("전체 과목의 평균은 : %.2f \n", sum_score / subject);
```

평균은 총점을 과목 수로 나눈 것이므로 `sum_score / subject` 가 우리가 구하고 싶은 전체 과목 평균이 되겠군요.




###  break 문




```cpp-formatted
/* break! */
#include <stdio.h>
int main() {
  int usranswer;

  printf("컴퓨터가 생각한 숫자를 맞추어 보세요! \n");

  for (;;) {
    scanf("%d", &usranswer);
    if (usranswer == 3) {
      printf("맞추셨군요! \n");
      break;
    } else {
      printf("틀렸어요! \n");
    }
  }

  return 0;
}
```

성공적으로 실행했다면 아래와 같이 나오게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F182522284A4C86A47FDAE5)

`3` 이 입력 될 때 까지 계속 물어보다가 3 을 입력하게 되면 프로그램이 종료됩니다 3 이 입력 될 때 까지 계속 물어보다가 3 을 입력하게 되면 프로그램이 종료됩니다.

```cpp-formatted
for (;;) {
  scanf("%d", &usranswer);
  if (usranswer == 3) {
    printf("맞추셨군요! \n");
    break;
  } else {
    printf("틀렸어요! \n");
  }
}
```

일단, `for` 문을 잠시 살펴 봅시다. 그런데, 한 가지 이상한 점이 있죠? 초기식, 조건식, 증감식이 모두 없습니다! 그렇다면 이 `for` 문은 얼마나 실행 되야 되는 것인가요? 답은, `for` 문의 조건식이 명시되지 않는다면 항상 '참' 이라 인식 되기 때문에 이 `for` 문은 언제나 참이됩니다. 다시 말해, 무한히 중괄호 속의 내용을 실행한다는 것이지요. 그래서, 만약

```cpp-formatted
#include <stdio.h>
int main() {
  for (;;) {
    printf("a");
  }
  return 0;
}
```

와 같은 프로그램을 만든다면, `for` 문이 무한번 실행되므로 (프로그램 자체가 강제적으로 종료되기 전 까지)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F142F65274A4C878BBBF8A1)

와 같이 나오게 됩니다.

```cpp-formatted
scanf("%d", &usranswer);
if (usranswer == 3) {
  printf("맞추셨군요! \n");
  break;
} else {
  printf("틀렸어요! \n");
}
```

아무튼, `scanf` 를 통해 `usranswer` 에 사용자가 입력한 수를 저장합니다. 그리고 `if` 문을 통해 비교하지요. 과연 컴퓨터가 생각한 3 과 같은지... 만약 같다면 '맞추셨군요!' 가 출력이 됩니다. 그리고,프로그램이 종료되죠. 즉, `for` 문을 빠져나갑니다. 그런데, 맞추지 못하면 `for` 문은 계속 돌고 돌게 됩니다. 우리가 맞출 때 까지요. 그렇다면, 위 소스에서 `for` 문을 빠져나가게 하는 부분은 무엇일까요. 아마 짐작했던 대로, `break` 가 `for` 문을 탈출 시킵니다.

`break` 는 `for` 문에 조건식에 상관 없이 실행이 되기만 하면 `for` 문을 그대로 탈출 시켜 버립니다. 이 말은 즉슨 `break` 아래의 어떠한 것들도 실행이 되지 않는 다는 것이지요.

```cpp-formatted
#include <stdio.h>
int main() {
  for (;;) {
    break;
    printf("a");
  }
  return 0;
}
```

따라서, 위와 같은 프로그램을 만들었을 때, `break` 문을 만나자 마자 `for` 문 밖으로 탈출 시키므로 `a` 는 출력이 되지 않고 프로그램은 종료됩니다. 반면에

```cpp-formatted
#include <stdio.h>
int main() {
  for (;;) {
    printf("a");
    break;
  }
  return 0;
}
```

위와 같이 `break` 앞에 printf("a"); 가 있다면 `a` 가 출력이 되고 `for` 문을 빠져나가 종료가 되는 것이지요.

사실, 무한 `for` 문은 생소하기는 해도 많은 곳에서 쓰이고 있습니다. 예를 들어 어떤 게임에서

```info
    for(;;)
    {
        게임;
        if(유저 사망)
        {
            if(게임 다시 안할래요)
                break;
        }

        게임 재시작;
    }

```

와 같이 쓰일 수 있습니다.




###  continue 문




  `continue` 문은 `break` 문과 비슷하지만서도 하는 일은 완전히 다릅니다. `continue` 는 `break` 와는 달리 `for` 문을 빠져 나가지 않고, 그냥 패스 해주는 것입니다. 아래 예제를 봅시다.

```cpp-formatted
/* 5 의 배수를 제외한 숫자 출력 */
#include <stdio.h>
int main() {
  int i;

  for (i = 0; i < 100; i++) {
    if (i % 5 == 0) continue;

    printf("%d ", i);
  }

  return 0;
}
```

성공적으로 실행하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1622651C4A5DF04541B283)

   와 같이 나오게 됩니다. 보시다 싶이, 5 의 배수를 제외한 0 이상, 100 미만의 모든 수들이 출력 되었습니다.


```cpp-formatted
for (i = 0; i < 100; i++) {
  if (i % 5 == 0) continue;

  printf("%d ", i);
}
```

일단, `for` 문을 살펴보면 `i` 가 0 부터 100 미만의 값을 가지게 됩니다. 이 때, `if` 문을 살펴 보면 `i` 를 5로 나눈 나머지 (i % 5) 가 0 일 때 (== 0) `continue` 를 실행함을 볼 수 있습니다. `continue` 는 `break` 문 처럼 아래 모든 내용을 무시한다는 점에서 동일하지만, `break` 문은 루프를 빠져나가는데 반면 `continue` 는 다시 조건 점검부로 점프하게 됩니다. `continue` 는 마치 카드 게임에서 스킵과 같은 역할을 하게 됩니다. (break 문이 카드게임에서 퇴출 되는 것이라면...)

  따라서, `i` 의 값이 5 의 배수인 경우에만 printf("%d", `i)` 가 실행이 되지 않게 되는 것이지요.

문득 `for` 문을 배우면서 이러한 생각은 들지 않았나요? `if` 문 안에 `if` 문을 넣을 수 있는 것 처럼 `for` 문 안에도 `for` 문을 넣을 수 있을까? 네, 물론 넣을 수 있습니다. 아래 예제를 참조하세요.

```cpp-formatted
/* 구구단 */
#include <stdio.h>
단int main() {
  int i, j;

  for (i = 1; i < 10; i++) {
    for (j = 1; j < 10; j++) {
      printf(" %d x %d = %d \n", i, j, i * j);
    }
  }

  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F16564C154A63CF5D290175)



와 같이 근사한 구구단 표가 출력됩니다.

```cpp-formatted
for (i = 1; i < 10; i++) {
  for (j = 1; j < 10; j++) {
    printf(" %d x %d = %d \n", i, j, i * j);
  }
}
```

위 코드에서 구구단 표를 출력하는 부분은 바로 위 부분입니다. `for` 문이 2 개나 사용되어 있는 꼴이지요. 그런데 사실 돌아가는 원리는 간단합니다. 일단, 처음에 `i` 에 1 이 들어 가게 되죠. 그런 다음에

```cpp-formatted
for (j = 1; j < 10; j++) {
  printf(" %d x %d = %d \n", i, j, i * j);
}
```


이 부분이 열심히 실행됩니다. 물론 위 부분이 열심히 실행되는 동안 `i` 의 값은 변하지 않고 (계속 1 로 남는다), `j` 의 값만 1 부터 9 까지 변하여 구구단의 `1 x 1 ~ 1 x 9` 까지 출력하게 되는 것이지요. 위 `for` 문이 끝나면, 다시

```cpp-formatted
for (i = 1; i < 10; i++)
```

이 부분이 실행되어 `i` 의 값이 1 증가합니다. 즉, `i` 는 2가 되는 것이지요. 이제 다시

```cpp-formatted
for (j = 1; j < 10; j++) {
  printf(" %d x %d = %d \n", i, j, i * j);
}
```

가 실행되어 `2 x 1 ~ 2 x 9` 까지 출력되게 됩니다. 마찬가지 방법으로 `i` 의 값이 9 가 될 때 까지 실행한 뒤 `i` 의 값이 10 이 되면 `for` 문을 완전히 빠져 나와 실행이 종료 됩니다.

```cpp-formatted
/* 다음 소스만 보고 무슨 숫자가 출력될 지 맞추어 보세요~~ */
#include <stdio.h>
int main() {
  int i, j;

  for (i = 1; i < 10; i++) {
    for (j = 1; j < i; j++) {
      printf("%d ", j);
    }
  }

  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1333971A4A63D9053A7C73)

가 나오게 됩니다. 아마 위에서 `for` 문에 대해 잘 이해하신 분들은 금방 이해 할 수 있겠지요.

```cpp-formatted
for (i = 1; i < 10; i++) {
  for (j = 1; j < i; j++) {
    printf("%d ", j);
  }
}
```

이 부분에서 `i` 가 1 이면, `j` 가 출력되지 않고, `i` 가 2 가 되면 `j` 가 1 부터 1 까지, `i` 가 3 이 되면 `j` 는 1 부터 2 까지 순차적으로 출력되어 `i` 가 9 일 때, `j` 는 1 부터 8 까지 출력되어 위와 같은 모습을 보이게 됩니다. 어때요? 간단하지요?

아마 이 쯤 하셨다면 `for` 문에 대해 질렸을 것 같으니 `for` 문과 비스므리하면서도 다른 반복문인 `while` 문에 대해 살펴 보도록 해봅시다.

```cpp-formatted
/* while 문 */
#include <stdio.h>
int main() {
  int i = 1, sum = 0;

  while (i <= 100) {
    sum += i;
    i++;
  }

  printf("1 부터 100 까지의 합 : %d \n", sum);

  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F172DC70E4A7ABE672D72D0)

와 같이 1 부터 100 까지 숫자들의 합이 출력됩니다.

`while` 문은 위의 예제에서도 알 수 있듯이 `for` 문과는 달리 구조가 사뭇 단순합니다. `while` 문의 기본 구조는 아래와 같습니다.

```info
    while (조건식)
    {
        명령1;
        명령2;
        ...
    }
```

`for` 문 처럼 '조건식' 에는 이 `while` 문을 계속 돌게 할 조건이 들어갑니다. 예를 들어서 조건식에 `i <= 100` 이 들어간다면 `i` 가 100 이하 일 때 만 조건이 성립하므로 `i` 가 100 이하일 때 까지 `while` 문이 계속 돌아가게 됩니다.

```cpp-formatted
while (i <= 100) {
  sum += i;
  i++;
}
```

위 경우, `i` 의 값이 100 이하 인 지 검사한 다음에 (i <= 100 ), `sum` 에 `i` 를 더하고 (sum += i ), `i` 의 값을 증가한 뒤 (i++ ), 다시 처음으로 돌아가게 됩니다. 이 때, `while` 문의 특징이 바로 시작 부터 조건식을 검사한다는 것입니다. (이는 `for` 문과 동일합니다.)
따라서, 만약 `i < 1` 이 조건식이라면 `while` 문 내부의 내용은 하나도 실행되지 않고 종료되게 됩니다.

```cpp-formatted
#include <stdio.h>
int main() {
  int i = 1, sum = 0;

  do {
    sum += i;

    i++;
  } while (i < 1);

  printf(" sum : %d \n", sum);
  return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F193ED11B4A7AC0CB6CCA3C)

와 같이 나오게 됩니다.

`do - while` 문의 구조는 아래와 같습니다.

```cpp-formatted
do {
  명령1;
  명령2;
  ...
} while (조건식);
```

  `do - while` 문은 사실 `whlie` 문과 같습니다. 그런데, 한 가지 차이게 있는데, 앞서 말했듯이 `while` 문은 명령을 실행하기 전에 조건식이 참 인지 먼저 검사 합니다. 따라서, 조건식이 처음부터 참이 아니라면 `whlie` 문 안의 내용은 결코 실행 될 수 없겠지요. 그런데, `do - while` 은 먼저 명령을 실행 한 뒤에 조건식을 검사합니다. 따라서, 처음부터 조건식이 참이 아니라도 명령을 먼저 실행한 다음 조건식을 검사하기 때문에 최소한 한 번은 실행되게 됩니다.

```cpp-formatted
do {
  sum += i;

  i++;
} while (i < 1);
```


 따라서, 위 경우 `i` 가 1 로 `i < 1` 이 였지만 조건식을 나중에 검사하기 때문에 일단 `sum + = i` ; 와 `i ++` 을 실행 한 다음에 `i < 1` 이 검사되어 `sum` 의 값이 1 이 출력될 수 있었던 것이지요. 어때요, 간단하죠?


  그렇다면 이제 반복문에 대해 대충 감을 잡았을 것으로 기대합니다. 하지만 사실 반복문을 익숙하게 사용할 때 까지 많은 연습이 필요하기 때문에 제가 '숙제' 를 내보도록 할께요. 아마 이 '숙제' 에는 답이 있을 수 도 없을 수 도 있을 뿐더러, 해답을 공개하지도 않을 것 입니다. 단지 스스로 곰곰히 생각해 보며, 정말로 모를 경우... 음, 알 때 까지 고민하세요^^ 그렇다면 여러분을 믿습니다~~ 화이팅!

### 생각 해보기 

#### 문제 1 (난이도 : 中)

`N` 줄인 삼각형을 출력한다. 단, 사용자로 부터 임의의 `N` 을 입력 받는다. 아래는 `N = 3` 일 때의 출력 예시 이다.

```info
  *
 ***
*****
```

####  문제 2 (난이도 : 中上)

  위와 동일한 형태를 취하되, 역 삼각형을 출력한다. 아래는 `N = 3` 일 때의 출력 예시 이다.

```info
*****
 ***
  *
```

#### 문제 3 (난이도 : 下)

  1000 이하의 3 또는 5 의 배수인 자연수들의 합을 구한다.

####  문제 4 (난이도 : 中) 

  1000000 이하의 피보나치 수열 ( `N` 번째 항이 `N - 1` 번째 항과 `N - 2` 번째 항으로 표현되는 수열, 시작은 1,1,2,3,5,8,...) 의 짝수 항들의 합을 구한다

####  문제 5 (난이도 : 下)

  사용자로 부터 `N` 값을 입력 받고 1 부터 `N` 까지의 곱을 출력한다.

####  문제 6 (난이도 : 中)

다음 식을 만족하는 자연수 `a,b,c` 의 개수를 구하여라

```info
  i) a + b + c = 2000
  ii) a ＞ b > c, a,b,c 는 모두 자연수
```

####  문제 7 (난이도 : 中上)

임의의 자연수 `N` 을 입력 받아 `N` 을 소인수 분해 한 결과를 출력하여라. 예를 들어서 `N = 18` 일 경우

`N = 18`
`18 = 2 * 3 * 3`

####  문제 8 (난이도 : 上)

문제 7 에서 만든 프로그램의 속도를 향상 시킬 수 있는 방법은 없을까? 큰 수를 빠르게 소인수분해 할 수 있는 방법들을 찾아 프로그램에 적용시켜 보아라. 예를 들어서 `N` 의 제곱근 이하의 정수들만 처리한다던지, `Lucas- Lehmer` 판정법을 이용해 소수인지 아닌지 판정한다던지 등등..

(참조 : `*` 표가 붙은 문제들은 http://projecteuler.net/index.php?section=problems 에서 가져온 것들)


##@ chewing-c-end
Link :  10
2009-04-28 13:40
----------------
title : 씹어먹는 C 언어 - <6. 만약에...(if 문)>
cat_title : 6. 만약에... (if 문)
next_page : 12
publish_date : 2009-04-28 13:40
--------------


이번 강좌에서는

* `if` 문에 대한 이해 - 관계 연산자, 논리 연산자

* `if- else` 문

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요? 여러분. 이제 저의 강좌도 6강에 이르렀네요. 지난번의 강좌에서 배운 입출력 함수로 여러가지 재미있는 프로그램을 만들었나요? 그러한 프로그램들을 많이 만들 수록 여러분의 실력은 몇 배로 향상된다는 사실을 잊지 마시기 바랍니다. 이번 강좌에는 C 언어에서 매우 중요한 부분인 제어문 - 그 중에서도 조건문이라는 사실을 배우겠습니다.

우리가 자판기에서 음료수를 고를 때 자판기 내부에는 다음과 같은 과정이 수행 됩니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F122CFA1649FDB5F0B88E78)
돈을 넣는다. 지폐인가? 맞다면 액수가 충분한가? 아니면 더 받는다 `....` 이렇게 맞다 아니다 로 갈리게 됩니다. 이러한 것을 조건문 이라고 합니다. 즉 항상 실행되는 것이 아니라 특정한 조건이 맞는 경우에만 실행되는 것이지요

그런데, 위 부분에서 우리가 여태 까지 보지 못했던 특징이 있습니다. 여태까지 우리는 모든 문장들이 순차적으로 실행되어 왔습니다. 예를들어,

```info
.....
printf("안녕\n");
printf("내 이름은 Psi 야 \n");
printf("너의 이름은 뭐니?\n");
....

```

와 같은 문장에서 처음에 **안녕** 이 출력되고 그 다음에 **내 이름은 Psi 야**, 그리고 마지막으로 **너의 이름은 뭐니?** 가 출력이 됩니다. 안녕이 출력이 되지 않거나 너의 이름은 뭐니? 가 출력되지 않는 일은 없죠.

뿐만 아니라, 내 이름은 Psi 야가 안녕 보다 먼저 출력되는 경우도 없습니다. 단지 어떠한 조건에서도 안녕, 내 이름은 Psi 야, 너의 이름은 뭐니? 가 차례대로 출력되는 것이지요.

하지만, 위의 그림을 봅시다. **지폐 인가?** 부분을 보면 만약 Yes 라면 **액수는 충분한가?** 를 실행하고 No 라면 **동전 인가?** 를 실행하게 끔 되어 있습니다. 다시말해 어떠한 경우를 만족한다면 이것을 실행하고, 또 다른 경우라면 이 것을 실행하는 꼴이지요. 이런 것을 '조건문' 이라 합니다. 어떠한 조건에 따라 실행되는 것이 달라지는 것이지요.




### `if` 문 시작하기

  아래 예제를 봅시다.

```cpp-formatted
/* if 문 이란? */
#include <stdio.h>
int main() {
  int i;
  printf("입력하고 싶은 숫자를 입력하세요! : ");
  scanf("%d", &i);

  if (i == 7) {
    printf("당신은 행운의 숫자 7 을 입력했습니다");
  }

  return 0;
}
```

(※ 참고로 위의 소스 코드에서 붉은색 중괄호와 검은색 중괄호를 이용한 까닭은 설명을 쉽게 하기 위한 것이지 소스코드 작성시 실제로 색깔을 바꿔줄 필요는 없습니다)
위 예제를 성공적으로 컴파일 한 후, 7 을 입력하였으면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F19309C0F4A0E4F2A5529BD)

 와 같이 나오게 됩니다. 그런데, 7 이 아닌 다른 수를 입력하였을 때 에는,

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F184FF90D4A0E4F68B2C47B)

 처럼 나오게 됩니다. 일단, 위 소스 코드에는 우리가 여태까지 보지 못했던 것이 있으니 찬찬히 뜯어 보도록 합시다.

```cpp-formatted
if (i == 7) {
  printf("당신은 행운의 숫자 7 을 입력했습니다");
}
```

이는위 소스코드에서 가장 핵심적인 부분입니다. 영어에서 흔히 말할 때 어떨 때, if 라는 단어를 쓰나요. 예를 들어서, *If you are smart enough, please learn C language* (만약 당신이 충분히 똑똑하다면, C 언어를 배워라!) 라는 문장을 보았을 때 **If** 라는 단어는 무슨 역할을 하나요? 아마 영어를 조금이나마 배운 사람들이라면, **if** 는 '만약 `~` ' 이라는 의미를 가진 것임을 바로 알 수 있습니다.

  C 언어에서도 마찬가지 입니다. `if` 는 가정을 나타냅니다. 여기서는 무엇을 가정 하였을까요? 바로 `if` 문 안에 있는 `i == 7` 이 그 가정을 나타냅니다. 즉, '만약 `i` 의 값이 7 이라면' 이라는 뜻이지요. `if` 문은 언제나 괄호 안의 조건이 참 이라면 아래 붉은 색 중괄호 속의 내용을 실행합니다. 거짓이라면 붉은 색 중괄호의 내용을 실행하지 않고 지나치죠.

  따라서, 만약 `i` 의 값이 7 이라면,

```cpp-formatted
printf("당신은 행운의 숫자 7 을 입력했습니다");
```

를 실행 한 후 붉은 색 중괄호 밖으로 빠져 나갑니다. 이제, 붉은 색 중괄호 밖으로 빠져나간 다음 다시 아래로 순차적으로 실행하게 되죠. 즉, 마지막으로 `return 0;` 가 실행됩니다.

그런데, `i` 의 값이 7 이 아니라면, 붉은 색 중괄호 속의 내용은 실행되지 않고 지나쳐 버립니다. 왜냐하면 `if` 문 에서 `i == 7` 이 '거짓' 이 되기 때문이죠. 따라서 붉은 색 중괄호 속의 내용은 실행이 되지 않고 `return 0` 만 실행이 됩니다.

참고적으로 `==` 와 같이 어떠한 두 값 사이의 관계를 나타내 주는 연산자를 **관계 연산자** 라고 부릅니다. 이 때, 관계 연산자의 좌측에 있는 부분을 좌변, 우측에 있는 부분을 우변이라 합니다. (즉, `3 == 2` 와 같은 경우 3 은 좌변, 2 는 우변 이라 부릅니다)

또한, 알아야 될 또 한가지 중요한 것은, 사실 관계 연산자는 어떠한 관계를 연산 한 후에, 참 이면 1 을, 거짓이면 0 을 나타내게 됩니다.

다시 말해, `if` 문은 참, 거짓에 따라서 중괄호 속의 내용을 실행 하느냐, 하지 않느냐 결정하는 것 처럼 보이지만 실제로는, **`if` 문 속의 조건이 0 인가 (거짓), 0 이 아닌가 (참) 에 따라서 실행의 유무를 판별하게 되죠**

따라서, `if (0)` 이라 한다면 그 중괄호 속의 내용은 절대로 실행되지 않고, `if(1)` 이라 한다면 그 중괄호 속의 내용은 `100%` 실행되게 됩니다.

```cpp-formatted
/* 나눗셈 예제 */
#include <stdio.h>
int main() {
  double i, j;
  printf("나누고 싶은 두 정수를 입력하세요 : ");
  scanf("%lf %lf", &i, &j);

  printf("%f 를 %f 로 나눈 결과는 : %f \n", i, j, i / j);

  return 0;
}
```

성공적으로 컴파일 후 10 과 3 을 입력하였다면 아래와 같이 나오게 됩니다

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F17375E274A3145093A6F9A)

 와우! 성공적으로 되었습니다. 그런데 위에서 나온 소스 코드는 우리가 여태까지 바왔던 코드와 다를 바가 없습니다. 여태까지 배운 기능들만 이용해서 만든 것이지요. 하지만 바로 이 부분에서 문제가 대두됩니다.

  컴파일한 프로그램을 다시 실행시켜 1 과 0 을 차례대로 입력해 보세요. 즉, 1 을 0 으로 나누어 보세요.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F124DF5104A0DA54BCA8950)

위에서 보시는 것과 같이 나눈 결과가 `1.#INF00` 이라는 이상한 결과를 내뿜었습니다. 왜 일까요? 왜냐하면 수학에서, (즉 컴퓨터 에서) 어떠한 수를 0 으로 나누는 것은 금지되어 있기 때문이죠. 위 `i` 와 `j` 변수가 `double` 로 선언되어 있어서 망정이지 `i,j` 변수를 `int` 형으로 선언하였다면 프로그램은 애러를 내뿜고 종료 됩니다.

이 문제를 대수롭지 않게 여긴다면 큰 문제입니다. 예를들어서 여러분이 엑셀로 열심히 작업을 하였는데 실수로 어떤 수를 0 으로 나누는 작업을 하였더니 힘들게 작업한 엑셀이 종료되 버려 파일이 날아가 버리면 여러분은 다시는 엑셀을 쓰지 않을 것 입니다. 따라서, 우리는 나누는 수 (제수) 가 0 이 아닌지 확인할 필요성이 있습니다. 즉, 제수가 0 이면 나누지 않고 0 이 아니면 나누는 것이지요.

  따라서 위 프로그램을 아래와 같이 수정합시다.

```cpp-formatted
#include <stdio.h>
int main() {
  double i, j;
  printf("나누고 싶은 두 정수를 입력하세요 : ");
  scanf("%lf %lf", &i, &j);

  if (j == 0) {
    printf("0 으로 나눌 수 없습니다. \n");
    return 0;
  }
  printf("%f 를 %f 로 나눈 결과는 : %f \n", i, j, i / j);

  return 0;
}
```

만약 1 을 0 으로 나누었다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F122D04264A0DA6C8C9FE6A)

 그리고 다시 10 을 3 으로 나누어 보면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F147687144A0DA2E77AA0B9)

 로 위와 같이 정상적으로 나타난다.
 이제, 위 소스코드를 뜯어 보기로 합시다.

```cpp-formatted
{
  printf("0 으로 나눌 수 없습니다. \n");
  return 0;
}
```

만약 `j` 의 값이 0 이라면 중괄호 속의 내용이 실행되며, "0 으로 나눌 수 없습니다" 가 표시되고 프로그램이 종료(return `0)` 됩니다.

반면에, `j` 의 값이 0 이 아니라면 중괄호 속의 내용이 실행되지 않습니다. 즉, 아래의 내용이 실행되게 됩니다.

```cpp-formatted
printf("%f 를 %f 로 나눈 결과는 : %f \n", i, j, i / j);

return 0;
```

이렇듯, `if` 문은 여러 조건에 따른 처리를 위해 사용합니다. 먼저 나왔던 예제는 `i` 의 값이 7 일 때의 처리를 위해 `if` 문을 사용하였고 위의 예제는 `j` 의 값이 0 일 때의 처리를 위해 사용하였습니다.

```cpp-formatted
/* 합격? 불합격? */
#include <stdio.h>
int main() {
  int score;

  printf("당신의 수학점수를 입력하세요! : ");
  scanf("%d", &score);

  if (score >= 90) {
    printf("당신은 합격입니다! \n");
  }

  if (score < 90) {
    printf("당신은 불합격 입니다! \n");
  }

  return 0;
}
```

위 소스를 성공적으로 컴파일하였다면 다음과 같이 나옵니다.
만약 당신의 수학점수로 91 점을 입력하였다면,

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F1440190B4A0FA2AAAD22F1)

 만약 당신의 수학 점수로 80 점을 입력하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F153ECB0B4A0FA2DF949F1D)

 와 같이 나타납니다.

```cpp-formatted
if (score >= 90) {
  printf("당신은 합격입니다! \n");
}

if (score < 90) {
  printf("당신은 불합격 입니다! \n");
}
```

위 소스의 핵심이라 할 수 있는 부분은 위 두 부분입니다.일단, `if(score >= 90)` 이라는 부분부터 살펴 봅시다. 이미 짐작은 했겠지만 `>=` 은 '~ 이상', 즉 '~ 보다 크거나 같다' 를 의미합니다. 따라서, `score` 의 값이 90 보다 '크거나 같으면' `if` 문 안의 내용이 참 (true) 이 되어 중괄호 속의 내용이 실행됩니다.

따라서, 처음에 우리가 91 점을 입력하였을 때 `score >= 90` 이 참이 되어서 

```cpp-formatted
printf("당신은 합격 입니다! \n");
```

가 실행되었습니다. 그런데 여기서 주의해야 할 점은 `score => 90` 이라고 하면 안된다는 것 입니다. 이렇게 쓰면 컴파일러는 인식을 하지 못합니다.

이 부분에서 헷갈리는 사람들은 '크거나 같다' 라는 말 그대로 옮겨 적었다고 생각하세요. `>=` 는 크거나 (>) 같다 (=) 를 합친 것이다!

마찬가지로, 아래 `score < 90` 도 보자면 `score` 가 90 미만일 때 참이다 라는 사실을 나타낸 것임을 알 수 있습니다.

```cpp-formatted
/* 크기 비교하기 */
#include <stdio.h>
int main() {
  int i, j;

  printf("크기를 비교할 두 수를 입력해 주세요 : ");
  scanf("%d %d", &i, &j);

  if (i > j)  // i 가 j 보다 크면
  {
    printf("%d 는 %d 보다 큽니다 \n", i, j);
  }
  if (i < j)  // i 가 j 보다 작으면
  {
    printf("%d 는 %d 보다 작습니다 \n", i, j);
  }
  if (i >= j)  // i 가 j 보다 크거나 같으면
  {
    printf("%d 는 %d 보다 크거나 같습니다 \n", i, j);
  }
  if (i <= j)  // i 가 j 보다 작거나 같으면
  {
    printf("%d 는 %d 보다 작거나 같습니다 \n", i, j);
  }
  if (i == j)  // i 와 j 가 같으면
  {
    printf("%d 는 %d 와(과) 같습니다 \n", i, j);
  }
  if (i != j)  // i 와 j 가 다르면
  {
    printf("%d 는 %d 와(과) 다릅니다 \n", i, j);
  }

  return 0;
}
```

위 내용을 성공적으로 컴파일 후, 10 과 4 를 입력하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1638C70B4A0FA59B8223FF)

와 같이 나타나게 됩니다.

이번 예제에서는 소스의 길이가 약간 깁니다. 하지만 따지고 보면 상당히 간단한 구조로 되어 있음을 알 수 있습니다. 일단 위의 예제에 관계 연산자 들의 역할에 대해 알아봅시다.

```info
>=  : 좌변이 우변보다 같거나 크면 참이 됩니다. ( 6 >= 3 : 참, 6 >= 6 : 참, 6 >= 8 : 거짓)
> : 좌변이 우변보다 크면 참이 됩니다. (6 > 3 : 참, 6 > 6 : 거짓, 6 > 8 : 거짓)
<= : 좌변이 우변보다 작거나 같으면 참이 됩니다.( 6 <= 3 : 거짓, 6 <= 6 : 참, 6 <= 8 : 참)
< : 좌변이 우변보다 작으면 참이 됩니다.( 6 < 3 : 거짓, 6 < 6 : 거짓, 6 < 8 : 참)
== : 좌변과 우변이 같으면 참이 됩니다.( 6 == 3 : 거짓, 6 == 6 : 참, 6 == 8 : 거짓)
!= : 좌변과 우변이 다르면 참이 됩니다. ( 6 != 3 : 참, 6 != 6 : 거짓, 6 != 8 : 참)

```

따라서, 위 관계연산자에 따라 위 프로그램이 실행이 됩니다. 한 번 여러가지 숫자를 집어 넣으면서 확인해 보세요.

마지막으로 `if` 문의 구조에 대해서 간단히 정리해 보자면

```info
if ( 조건)
{
명령
}

```


와 같이 됩니다. 잊지 마세요!



### `if - else` 문 시작하기

```cpp-formatted
#include <stdio.h>
int main() {
  int num;

  printf("아무 숫자나 입력해 보세요 : ");
  scanf("%d", &num);

  if (num == 7) {
    printf("행운의 숫자 7 이군요!\n");
  } else {
    printf("그냥 보통 숫자인 %d 를 입력했군요\n", num);
  }
  return 0;
}
```

만약 성공적으로 컴파일 하였다면 7 을 입력했을 때,

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1871611B4A2D5A84084DBF)

 그리고, 그 외 7 이 아닌 다른 숫자를 입력하였을 때 에는,

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1617B51E4A2D5ABF18155E)

 와 같이 나오게 됩니다.

 자, 이제 위 소스를 뜯어 봅시다.

```cpp-formatted
if (num == 7) {
  printf("행운의 숫자 7 이군요!\n");
}
```

여태 까지 보왔듯이, 이 부분은 그냥 평범한 `if` 문이군요. 하지만 그 다음 부분에 심상치 않은 것이 등장합니다.

```cpp-formatted
else {
  printf("그냥 보통 숫자인 %d 를 입력했군요\n", num);
}
```

이번에는 여태까지 배우지 않은 것인 `else` 라는 것이 등장합니다. 영어를 잘 하시는 분들은 지레 짐작하시고 있었겠지만 `else` 는 '그 외의 `~ ,` 그 밖의 `~` ' 의 뜻으로 사용되는 단어입니다. 

그렇다면 여기서도 그러한 의미를 나타내는 것인가요?

맞습니다. `else` 는 바로 '앞선 `if` 문이 조건을 만족하지 않을 때' 를 나타냅니다. 즉, 앞선 `if` 문이 조건을 만족 안할 때 해야 할 명령을 바로 `else` 문에 써 주는 것이지요. 다시 말해, `else` 문은 떨거지(?) 들을 처리하는 부분입니다.

위의 경우에서도 만약 `num` 의 값이 7 이 아니였다면 `if` 문을 만족 안하게 되는 것입니다. 그러면 자연스럽게 `else` 로 넘어와서 "그냥 보통 숫자인 ... 를 입력했군요" 를 출력하게 되는 것이지요. 하지만, `num` 의 값이 7 이 였다면 `if` 문을 만족하는 것이기 때문에 `else` 는 거들떠 보지도 않고 넘어가게 됩니다.

```cpp-formatted
/* if - else 죽음의 숫자? */
#include <stdio.h>
int main() {
  int num;

  printf("아무 숫자나 입력해 보세요 : ");
  scanf("%d", &num);

  if (num == 7) {
    printf("행운의 숫자 7 이군요!\n");
  } else {
    if (num == 4) {
      printf("죽음의 숫자 4 인가요 ;;; \n");
    } else {
      printf("그냥 평범한 숫자 %d \n", num);
    }
  }
  return 0;
}
```

이번에 성공적으로 컴파일 한 후, 숫자들을 입력해 보면 비슷한 결과가 나오지만 4 를 입력했을 경우 "죽음의 숫자 4 인가요 ;;; " 가 나오게 됩니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F152D780B4A2D5D7312F23E)

  자, 이제 소스를 뜯어 보기로 합시다.

```cpp-formatted
else {
  if (num == 4) {
    printf("죽음의 숫자 4 인가요 ;;; \n");
  } else {
    printf("그냥 평범한 숫자 %d \n", num);
  }
}
```

앞 `if (num==7)` 부분은 이미 설명 했으니 생략하기로 하고, `else` 문의 구조만 뜯어 보기로 합시다. 만약 `num` 의 값이 4 였다고 합시다. 그렇다면, 처음에 만나는 `if` 문에서 `num == 7` 이 거짓이 되므로 `else` 로 넘어가게 됩니다.

그런데, `else` 의 명령을 실행하려고 하는데 보니, 또 `if` 문이 있네요. 이번에는 `if (num == 4)` 가 나타납니다. 하지만 아까와는 달리 `num == 4` 가 참이므로 그 `if` 문의 중괄호 속의 명령, 즉 "죽음의 숫자 4 인가요 ;;;" 가 출력되게 됩니다.

그리고, 앞 예제에서 설명했듯이 `if(num == 4)` 아래의 `else` 는 무시 하게 되고, 끝나게 되는 것이지요.

그렇다면 이제 아이디어를 확장해서 `num` 이 1 부터 10 일 때 까지 특별한 설명을 달기로 합시다. 그러면 아래와 같이 프로그램을 짜야 되겠죠.

```cpp-formatted
/* 쓰레기 코드 */
#include <stdio.h>
int main() {
  int num;

  printf("아무 숫자나 입력해 보세요 : ");
  scanf("%d", &num);

  if (num == 7) {
    printf("행운의 숫자 7 이군요!\n");
  } else {
    if (num == 4) {
      printf("죽음의 숫자 4 인가요 ;;; \n");
    } else {
      if (num == 1) {
        printf("첫 번째 숫자!! \n");
      } else {
        if (num == 2) {
          printf("이 숫자는 바로 두번째 숫자 \n");
        } else {
          ......(생략)......
        }
      }
    }
  }
  return 0;
}
```

정말 믿도 끝도 없이 길어져서 나중에는 중괄호가 너무 많아 헷갈리기도 하고, 보기도 불편하게 됩니다. 하지만, C 언어는 위대한지라, 이 문제를 간단히 해결하였습니다.

```cpp-formatted
/* 새로쓰는 죽음의 숫자 예제 */
#include <stdio.h>
int main() {
  int num;

  printf("아무 숫자나 입력해 보세요 : ");
  scanf("%d", &num);

  if (num == 7) {
    printf("행운의 숫자 7 이군요!\n");
  } else if (num == 4) {
    printf("죽음의 숫자 4 인가요 ;;; \n");
  } else {
    printf("그냥 평범한 숫자 %d \n", num);
  }
  return 0;
}
```

  위 코드를 실행해 보면 앞선 예제와 똑같이 작동합니다. 하지만 코드도 훨씬 보기 편해 졌고 난잡하던 중괄호도 어느 정도 정리가 된 것 같군요. 그렇다면 정말 하는 일이 똑같을 까요? 네, 똑같습니다. 왜냐하면

```info
    if(조건 1)
    {
        명령 1;
    }
    else
    {
        if(조건 2)
        {
            명령 2;
        }
        else
        {
            if(조건 3){
            명령 3;
            }
            else
            {
                ....
            }
        }
    }

```

위와 같은 코드를 단지 아래 처럼 '간단히' 표현한 것이기 때문이죠.

```info

    if(조건 1)
    {
        명령 1;
    }
    else if(조건 2)
    {
        명령 2;
    }
    else if(조건 3)
   {
       명령 3;
   }
   ....
  else {
        명령 ;
    }


```

단지, 보기 편하게 하기 위해 '간략하게' 줄인 꼴과 같다는 것입니다. 마치 `a = a + 10` 을 `a+= 10` 으로 바꾼 것 처럼 말이죠.

```cpp-formatted
/* if 와 if- else if 의 차이*/
#include <stdio.h>
int main() {
  int num;

  printf("아무 숫자나 입력해 보세요 : ");
  scanf("%d", &num);

  if (num == 7) {
    printf("a 행운의 숫자 7 이군요!\n");
  } else if (num == 7) {
    printf("b 행운의 숫자 7 이군요! \n");
  }

  // 비교
  if (num == 7) {
    printf("c 행운의 숫자 7 이군요!\n");
  }
  if (num == 7) {
    printf("d 행운의 숫자 7 이군요! \n");
  }

  return 0;
}
```

성공적으로 컴파일 후, 7 을 입력하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F166A891A4A2D6203231C46)

  와 같이 나오게 됩니다. 여기서 주목해야 할 점은, 출력되는 문장 앞의 알파벳 (a,c,d) 인데 이는 각 문장이 위 프로그램의 어느 부분에서 출력되는 지 알려줍니다.

  우리가 컴퓨터 라고 생각하고 프로그램을 실행해 봅시다. 통상적으로 프로그램은 소스코드의 위에서 부터 아래 방향으로 실행됩니다

```cpp-formatted
if (num == 7) {
  printf("a 행운의 숫자 7 이군요!\n");
} else if (num == 7) {
  printf("b 행운의 숫자 7 이군요! \n");
}
```

컴퓨터가 쭉 프로그램을 읽다가 위 부분에 도달하면

"어! `if` 문이군. `num` 의 값이 7 인지 확인해 볼까?" 라고 확인을 합니다. 그런데, 참 이므로
"오, `if` 문이 참 이군. 그렇다면 중괄호 속의 내용을 실행해야겠다! " 하며 "a 행운의 숫자 7 이군요" 를 출력합니다.

그런데, 그 다음 부분인 `else if(num == 7)` 에서도 마찬가지로 `num` 의 값이 7 이므로 `num == 7` 이 참이 되어서 `else if` 가 참이 되어 "b 행운의 숫자 7 이군요! " 도 출력되어야 할 것 같습니다.  하지만, 결과롤 보아하니 출력이 되지 않았습니다. 왜 일까요?

왜냐하면, 앞에서 누누히 설명했듯이 `else` 문은 전제 조건이 '앞의 `if` 문이 참이 아닐 때' 실행 된다는 사실을 기본으로 깔고 있기 때문이죠. 따라서, 앞의 `if` 문이 참이므로 실행이 될 수 없습니다. 따라서, "b 행운의 숫자 7 이군요! " 도 출력되지 않습니다. 참고적으로 `else` 문은 언제나 `if` 문의 결과에 따라 실행 여부가 결정되므로 언제나 `else` 를 사용하려면 `if` 도 반드시 함께 따라 사용해야 합니다.

  다시 컴퓨터가 쭉 읽다가 아래와 같은 문장을 발견했네요.

```cpp-formatted
if (num == 7) {
  printf("c 행운의 숫자 7 이군요!\n");
}
if (num == 7) {
  printf("d 행운의 숫자 7 이군요! \n");
}
```

"어! `if` 문이군. 그런데 `num` 의 값이 7 이므로 이 `if` 문은 참이야. 중괄호 속의 내용을 실행해야지" 하면서 "c 행운의 숫자 7 이군요!" 가 출력된다. 마찬가지로 아래도

"어! `if` 문이군. 그런데 `num` 의 값이 7 이므로 이 `if` 문은 참이야. 중괄호 속의 내용을 실행해야지" 하면서 "d 행운의 숫자 7 이군요!" 가 출력되는 것입니다.

```cpp-formatted
/* if-else 문 마지막 연습 */
#include <stdio.h>
int main() {
  float ave_score;
  float math, english, science, programming;

  printf("수학, 영어, 과학, 컴퓨터 프로그래밍 점수를 각각 입력해 주세요 ! : ");
  scanf("%f %f %f %f", &math, &english, &science, &programming);

  ave_score =
    (math + english + science + programming) / 4;  // 4 과목의 평균을 구한다.
  printf("당신의 평균 점수는 %f 입니다 \n", ave_score);
  if (ave_score >= 90) {
    printf("당신은 우등생 입니다. ");
  } else if (ave_score >= 30) {
    printf("조금만 노력하세요!. \n");
  } else {
    printf("공부를 발로 합니까? \n");
  }

  return 0;
}
```

만약 성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F205DEA274CFA106127CBFF)

 와 같이 나오게 됩니다. 그 외에도, 다른 값들을 입력하면 다른 결과가 출력됨을 알 수 있습니다.

```cpp-formatted
ave_score = (math + english + science + programming) / 4;
```

  아마, 산술 연산을 까먹으신 분들은 없겠죠? 위 식이 2 초 내로 이해가 되지 않는다면 [ 4 강](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-4-%EA%B3%84%EC%82%B0%ED%95%98%EB%A6%AC)을 다시 공부하시기 바랍니다.  위 식은, 수학, 영어, 과학, 프로그래밍 점수의 평균을 구해서 `ave_score` 라는 변수에 대입하는 식입니다.

```cpp-formatted
if (ave_score >= 90) {
  printf("당신은 우등생 입니다. ");
} else if (ave_score >= 40) {
  printf("조금만 노력하세요!. \n");
} else if (ave_score > 0) {
  printf("공부를 발로 합니까? \n");
} else {
  printf("인생을 포기하셨군요. \n");
}
```

위 프로그램의 핵심 부분(?) 이라 할 수 있는 이 부분을 잘 살펴봅시다. 만약 내 평균 점수가 93 이라면, "당신은 우등생 입니다" 가 출력되게 되죠. 그리고, 아래 `else if` 와 `else` 는 무시하고 종료됩니다.

하지만 평균 점수가 40 이라면, 위의 `if (ave_score >= 90)` 이 거짓이 되어 다음으로 넘어가죠. 즉, `else if (ave_score >= 30)` 을 합니다. 이번에는 참이 되므로, "조금만 노력하세요!" 가 출력이 되고 종료가 됩니다.

또한, 평균점수가 10 점 이라면 위의 `if` 와 `else if` 모두 거짓이지만 `else if(ave_score > 0 )` 은 참이 되어 "공부를 발로 합니까?" 가 출력 됩니다.

마지막으로 평균점수가 0 점 이하 라면, 떨거지 처리(?) 인 `else` 에서 참이 되어서 "인생을 포기하였군요" 가 실행됩니다.

```cpp-formatted
/* 크기 비교 */
#include <stdio.h>
int main() {
  int a;
  printf("아무 숫자나 입력하세요 : ");
  scanf("%d", &a);

  if (a >= 10) {
    if (a < 20) {
      printf(" %d 는 10 이상, 20 미만인 수 입니다. \n", a);
    }
  }
  return 0;
}
```

성공적으로 컴파일 후, 10 이상 20 미만의 수를 입력했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1344B9264A2E8C492559CE)

 와 같이 나오게 된다. 위 소스 코드는 간단하다. 우리가 여태까지 배운 내용 만으로도 충분히 이해 할 수 있는 부분입니다.

```cpp-formatted
if (a >= 10) {
  if (a < 20) {
    printf(" %d 는 10 이상, 20 미만인 수 입니다. \n", a);
  }
}
```

처음에, `a` 의 값이 10 이상이면 참이 되어서 중괄호 속의 내용을 실행하게 되고, 또한 거기서 `a < 20` 이라는 `if` 문을 만나게 되는데 이 것 조차 참이라면 "... 는 10 이상, 20 미만인 수 입니다" 가 출력되는 것입니다.

  그런데, 사실 위 문장은 아래와 같이 간단히 줄여 쓸 수 있습니다.



### 논리 연산자

```cpp-formatted
/* 논리 연산자 */
#include <stdio.h>
int main() {
  int a;
  printf("아무 숫자나 입력하세요 : ");
  scanf("%d", &a);

  if (a >= 10 && a < 20) {
    printf(" %d 는 10 이상, 20 미만인 수 입니다. \n", a);
  }

  return 0;
}
```

위 소스를 그대로 컴파일 해 보면 위와 결과가 똑같이 나옵니다. 그렇다면 '&&' 는 무엇일까요? 그 것은 바로 **논리 곱(AND)** 라고 불리는 논리 연산자 입니다.

앞에서 우리는 `AND` 연산에 대해 배운 적이 있었습니다. (기억이 나지 않는다면 [여기를](http://itguru.tistory.com/8) 클릭). 이 때, `AND` 연산의 특징은 바로 오직 `1 AND 1` 만이 결과가 1 이였고, `1 AND 0` 또는 `0 AND 0` 은 모두 결과가 0 이였습니다.

여기서도 마찬가지 입니다. 위에서도 이야기 했지만 '참' 은 숫자 1 에 대응되고 '거짓' 은 숫자 0 에 대응 됩니다. 따라서, `a >= 10` 이 참이라면 '1' 을 나타내고, 거짓이라면 '0' 을 나타냅니다. 

마찬가지로, `a < 20` 도 참 이라면 '1' 을 나타내고, 거짓이라면 '0' 을 나타냅니다. 만약 `a >= 10` 도 참이고 `a < 20` 도 참 이라면 `1 AND 1` 을 연산하는 것과 같게 되어서 결과가 1, 즉 참이 되어 `if` 문의 중괄호 속의 내용을 실행하게 되죠.

반면에 `a < 10` 라던지 `a >= 20` 이여서 둘 중 하나라도 조건을 만족하지 않게 된다면 `1 AND 0` 이나 `0 AND 1` 을 하는 것과 같게 되어 결과가 `0,` 즉 거짓이 됩니다. 따라서 중괄호 속의 내용은 실행되지 않게 됩니다.

정리하자면, `&&` 는 두 개의 조건식이 모두 '참' 이 되어야 `if` 문 속의 내용을 실행하는 것이 됩니다.

그렇다면 우리가 여태 알고 있었던 `AND` 연산 기호인 `&` 를 쓰지 않고 `&&` 를 쓰는 것일까요? 그 이유는 `&` 하나는, 숫자 사이의 `AND` 연산을 사용 할 때 쓰고 논리 곱 연산자인 `&&` 는 두 개 이상의 조건식 사이에서 사용됩니다.

따라서 `if (a >= 10 & a < 20 )` 이나, `0x10 && 0xAE` 와 같은 연산은 모두 틀린 것이 됩니다.

```cpp-formatted
/* 논리 합 */
#include <stdio.h>
int main() {
  int height, weight;
  printf("당신의 키와 몸무게를 각각 입력해 주세요 : ");
  scanf("%d %d", &height, &weight);

  if (height >= 190 || weight >= 100) {
    printf("당신은 '거구' 입니다. \n");
  }

  return 0;
}
```


성공적으로 실행 후, 키를 190 이상으로 입력했거나 몸무게를 100 이상으로 입력했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F147B6B224A2E9135C13E04)

위와 같이 나오게 되죠.

이번에는 `||` 라는 것이 등장하였습니다. 앞서 `AND` 가 `&&` 였다는 것을 보아, `||` 는 `OR` 를 나타내는 논리 연산자임을 알 수 있습니다.

기억을 되살려 봅시다. `AND` 와 `OR` 의 차이가 뭐였죠? 음.... 아, 기억 나는군요. `AND` 가 두 조건이 모두 참 일 때, 참을 반환한다면, `OR` 은 두 조건이 모두 거짓 일 때 만 거짓을 반환합니다. 다시말해 `(참) || (거짓) == (참)` 이 된다는 것이지요.

```cpp-formatted
if (height >= 190 || weight >= 100) 
```

그렇다면 위 `if` 문을 살펴 봅시다. `height >= 190` 이 참 이라면, `OR` 연산한 값은 `weight` 의 크기에 관계없이 무조건 참이 되어서 중괄호 속의 내용을 실행 합니다. 또한 `height >= 190` 이 거짓이여도, `weight >= 100` 이 참 이라면 중괄호 속의 내용을 실행하게 되죠.

따라서, `OR` 논리 연산자는 조건식에서 적어도 어느 하나가 참 이라면 무조건 `if` 문의 내용을 실행해 주게 됩니다.

```cpp-formatted
/* 논리 부정 */
#include <stdio.h>
int main() {
  int height, weight;
  printf("당신의 키와 몸무게를 각각 입력해 주세요 : ");
  scanf("%d %d", &height, &weight);

  if (height >= 190 || weight >= 100) {
    printf("당신은 '거구' 입니다. \n");
  }
  if (!(height >= 190 || weight >= 100)) {
    printf("당신은 거구가 아닙니다. \n");
  }

  return 0;
}
```

위 소스를 성공적으로 컴파일 한 후, 180 과 80 을 입력하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F145066114A3131B3C7531E)

 와 같이 나옵니다.

 위 소스에서 관심있게 살펴 보아야 할 부분은 바로 이 부분이죠.

```cpp-formatted
if (!(height >= 190 || weight >= 100)) {
  printf("당신은 거구가 아닙니다. \n");
}
```

(참고로 위의 소스와 다른 점은 `height` 앞에 `!` 가 붙었다는 점 입니다.) 다른 것은 다 똑같은데, 새로 붙은 `!` 가 무슨 역할을 하는 것 같나요?

아마도 예측 하셨겠지만, `!` 는 NOT 을 취해주는 연산자 입니다. 다시 말해, **반전**을 시켜 주는 것이지요. 위 경우, `height >= 190 || weight >= 100` 의 가 **거짓**일 경우에만, 다시 말해서 `height < 190 && weight < 100` 인 경우에만 중괄호 속의 내용이 실행 됩니다. 어때요, 간단하죠?

이것으로 C 언어에서 중요한 부분인 `if` 문에 대해 알아 보았습니다. 이제 마지막으로 할 일은 바로 `if` 문을 가지고 여러가지 프로그램을 만들어 보는 것입니다. 솔직히 말해서, `if` 문 이전까지 배운 내용으로는 그다지 할 것들이 없었습니다.

하지만, 이번 `if` 문을 통해서 컴퓨터에게 '생각(?)' 할 수 있는 능력을 부여 할 수 있게 됩니다. 따라서, 무궁 무진한 것들을 만들어 낼 수 있게 되죠. 뭐, 만들어 볼 것들로 제가 추천하는 것들은 계산기나 성적표라던지, 등등. 아무튼, 힘내세요.

##@ chewing-c-end
Link :  9
2009-04-27 18:09
----------------
title : 씹어먹는 C 언어 - <5. 문자 입력 받기>
cat_title : 5. 문자 입력 받기
next_page : 10
publish_date : 2009-04-27 18:09
--------------


이번 강좌에서는...

* 문자를 저장하는 변수

* `scanf` 의 사용

* 섭씨 → 화씨 환산 프로그램

등을 배우게 됩니다.

![씹어먹는 C 언어](/img/ChewingClogo.png)


지난번 강좌는 잘 이해 되셨는지요? 이번 강좌에서는 제목에서도 볼 수 있듯이 두 가지 내용을 한꺼번에 배우게 됩니다. 바로, 문자를 키보드로 부터 입력을 받는 것이지요. 문자를 입력 받을 수 있다면, 숫자도 당연히 입력 받을 수 있게 됩니다. 즉, 이번 강좌에서는 문자 형식의 변수와 키보드로 부터 입력을 받는 입력에 대해 알아 보도록 하겠습니다.

일단, 컴퓨터에서 문자를 처리하는 방식에 대해 생각해 봅시다. 제가 누누히 말하지만 우리의 컴퓨터는 그다지 똑똑하지 못합니다. 아무리 최신 `Intel CPU` 를 장착해도 컴퓨터는 단지 0 과 1 만을 처리할 뿐이죠.

따라서, 2 와 3 같은 숫자도 처리하지 못하는데 어떻게 a, b 가, 나, 韓 과 같은 수 많은 문자를 처리할 수 있겠습니까? 하지만, 방법이 있습니다. 이러한 문자들을 숫자에 대응시키는 것입니다. 그런데, 숫자에 대응시킨다면 컴퓨터가 이 것이 숫자인지, 아니면 문자인지 어떻게 알까요? 물론 알 방법은 없습니다. 단지 이 숫자를 '문자' 형태로 사용하거나 '숫자' 형태로 사용하는 것이지요.

문자를 저장하는 변수는 앞에서 살짝 본 적이 있습니다. 바로 `char` 이지요. `int` 가 `integer` 의 약자였다면 `char` 은 `character` 의 약자 입니다. 변수가 등장하면 어김없이 등장하는 아래의 표를 살펴 봅시다.


![각 자료형의 데이터 범위를 나타낸 표 입니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1126BC1149F5682ED85700)

보시는 것과 같이 `char` 은 맨 위에 위치해 있으며 크기는 1 바이트 입니다. 또한, 이를 통해 나타낼 수 있는 숫자의 범위를 알려주고 있는데, 이는 -128 부터 127 까지, 256 가지 입니다.

```cpp-formatted
/* 문자를 저장하는 변수  */
#include <stdio.h>
int main() {
  char a;
  a = 'a';

  printf("a 의 값과 들어 있는 문자는? 값 : %d , 문자 : %c \n", a, a);
  return 0;
}
```

위 소스를 성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1162B30F49F569F8AC3654)

  위와 같이 나옵니다. 일단, 소스를 분석해 보겠습니다.

```cpp-formatted
char a;
```

  이 부분은 `char` 형 변수를 선언하는 부분입니다. 기억이 안나시는 분들은 [3강](http://itguru.tistory.com/?page=2)을 참조하세요.

```cpp-formatted
a = 'a';
```


이 부분은 `a` 라는 변수에 문자 `a` 를 대입하고 있습니다. 이 때, 모든 문자들은 모두 작은 따옴표로 묶어 주어야 합니다. 만약 작은 따옴표로 묶지 않고 그냥 썼다면

```cpp-formatted
a = a;
```

C 컴파일러는 이 `a` 가 변수 `a` 라고 착각하여 `a` 라는 변수의 값을 `a` 라는 변수에 대입하는 문장으로 인식하게 되죠. 따라서 `a` 에는 아무런 값이 들어있지 않은 쓰레기 값(NULL) 이 되어 나중에 `a` 라는 문자를 출력해 보았을 때, 이상한 값이 나오게 됩니다.
  
문자를 대입하는 것도 숫자를 대입하는 것과 동일합니다. 대입 연산자를 이용하면 되죠.

```cpp-formatted
printf("a 의 값과 들어 있는 문자는? 값 : %d , 문자 : %c \n", a, a);
```

마지막으로, 위 `printf` 문에 대해 보도록 하겠습니다. 앞에서 말했듯이 컴퓨터는 `a` 가 문자라는 것 자체를 모른다고 했습니다. 단지 우리가 `a` 를 문자로 보느냐 아니면 숫자를 보느냐에 따라 달라진다고 했는데, 이 말 뜻을 위 `printf` 문을 보면 알 수 있습니다.

일단, `%d` 는 `a` 의 값을 숫자 (정수인 10 진수) 라고 출력하라는 뜻입니다. 그 옆의 `%c` 는 아마 예상했겠지만 `a` 의 값을 문자로 출력하라는 뜻이지요. 따라서, `%c` 에는 `a` 에 저장되어 있던 문자 'a ' 가 출력되게 됩니다. 그렇다면 `%d` 에는 무엇이 출력되었을까요? 앞에서 말했지만 컴퓨터는 문자와 숫자를 일대일 대응 시켜서 생각한다고 했습니다. 따라서, `%d` 에 출력되는 숫자가 바로 `a` 에 대응되는 숫자를 가리킵니다.

이 때, 각 문자 마다 대응되는 숫자를 아무렇게나 하는 것이 아니라 일정하게 정해져 있는데 현재 우리가 쓰고 있는 컴퓨터에서는 다음과 같이 정의되어 있습니다.


![ASCII 표라고 부르며 128 개의 데이터에 어떤 문자가 대응되어 있는지 표로 나와 있습니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F16506D0949F56DF8DED1B5)

위 표는 미국 표준 학회(ASA) 에서 정한 **아스키**(ASCII, *American Standard Code for Information Interchange*) 코드로 8 비트 데이타를 이용하여 여러 문자에 번호를 붙인 것 입니다. 아까, `a` 의 숫자 값을 출력하였을 때 97 이 나왔는데 위 표에서 찾아 보면 `a` 의 값이 97 임을 볼 수 있습니다. 이 때, 위 표의 내용이 0 부터 127 까지 밖에 없는 이유는 위 표준을 정할 당시 그 당시 7 비트 만으로 충분하다고 생각했기 때문이죠. 하지만 `IBM` 에서 좀 더 많은 종류의 문자가 필요하게 되자 1 비트를 더 추가 시켜서 확장된 아스키 코드(Extended `ASCII Code)` 를 만들었습니다.

하지만 위 256 개 가지고는 충분하지 못하죠. 왜냐하면 우리 글만 해도 자모음 24 개로 구성되어 있는데, 한 글자당 최대 초성/중성/종성 을 모두 표현해야 합니다. 또한 더욱 심각한 것은 한자와 같은 표의문자의 경우 수만 개가 넘는 한자 데이터들을 가지고 있어야 하는데 이를 256 개 안에 다 표현한다는 것은 불가능하기 때문이죠. 따라서, 컴퓨터가 전세계에 보급되자 좀 더 많은 종류의 문자를 표현해야 한다는 필요성이 대두되었습니다.

결국에는 **유니 코드(Unicode)** 라는 새로운 형식의 문자 체계를 도입하게 됩니다. 유니코드는 한 문자를 2 바이트로 처리하였습니다. 이는, 기존 아스키의 1 바이트 체계 보다 대응할 수 있는 숫자의 양이 2 배가 늘어난 것이 아니라 256 배가 늘어나, 총 65536 가지의 문자를 처리할 수 있게 되었습니다. 유니코드는 이렇게 막강하여 현재까지 대부분의 언어의 문자 체계를 모두 표시하고도 2만 개 가량 더 대응시킬 수 있는 숫자가 남았다고 합니다. 따라서, 한글, 한자 등 영어를 제외한 대부분의 문자는 2 바이트를 차지합니다.


###  scanf 의 도입

```cpp-formatted
/* 섭씨온도를 화씨로 바꾸기  */
#include <stdio.h>
int main() {
  double celsius;  // 섭씨 온도

  printf("섭씨 온도를 화씨 온도로 바꿔주는 프로그램 입니다. \n");
  printf("섭씨 온도를 입력해 주세요 : ");
  scanf("%lf", &celsius);  // 섭씨 온도를 입력 받는다.

  printf("섭씨 %f 도는 화씨로 %f 도 입니다 \n", celsius, 9 * celsius / 5 + 32);

  return 0;
}
```

위 소스를 성공적으로 컴파일 했다면 아래와 같이 나옵니다. 참고로 경고가 1 개 정도 나올 수 있는데, 이는 `scanf` 의 보안 문제 때문입니다. `scanf` 를 `scanf_s` 로 바꾸면 되지만 지금 이 수준에서 보안문제에 크게 신경 쓸 것은 없으므로 그냥 `scanf` 로 하셔도 됩니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F20064E1D49F5AD9E3974E5)

이 때, 원하는 숫자를 쓴 후 엔터를 누른다면 (예 : `100)`

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1950C20949F5AE667BA795)

 위와 같이 섭씨가 화씨 온도로 변경된 값이 출력됩니다. 와우! 드디어 쓸만한 프로그램을 처음으로 만들어 보게 된 것 같군요. 소스 코드를 찬찬히 살펴 보도록 합시다.

```cpp-formatted
double celsius;  // 섭씨 온도
```

일단, `celsius` 라는 `double` 형 변수를 선언하였습니다. 변수의 이름을 종전의 `a , b` 에서 `celsius` 라고 한 이유는 좀 더 이해하기 편하기 때문이죠. 좋은 소스 코드의 조건은 다른 사람이 이해하기 쉬운 소스 코드 이고, 다른 사람이 이해하기 쉬운 소스코드는 기본적으로 변수 이름을 보고도 변수를 한 눈에 파악하기 쉽게 만드는 것입니다.

```cpp-formatted
scanf("%lf", &celsius);  // 섭씨 온도를 입력 받는다.
```

이제, 새로운 것이 등장하였군요. `printf` 에 이어 등장한 `scanf` 군. `printf` 가 화면에 결과를 출력해 주는 함수였다면, `scanf` 는 화면(키보드) 로 부터 결과를 받아들이는 입력 함수 입니다. 이렇게 흔히 `printf` 와 `scanf` 를 가리켜 입출력함수라 하죠. 이 때, `scanf` 함수는 우리가 어떠한 입력을 하기 전까지 계속 기다립니다. 또한, 입력을 할 때 엔터를 눌러야지만 입력으로 처리됩니다.

`scanf` 와  `printf` 는 이름도 비수무리 할 뿐더러, 사용하는 방법도 비슷합니다. `printf` 에서 각 변수를 출력할 포맷(`%d, %f, %c` 등) 을 변수마다 다르게 하는 것처럼 `scanf` 도 각 변수의 타입마다 입력받는 포맷을 달리 해야 합니다.

위 경우 처럼 `double` 형의 변수를 입력 받으려면 `%lf` (소문자 LF 이다, if 가 아니다) 로 해야 합니다. 그런데, `printf` 보다 조금 까다로운 점은 `printf` 는 `double` 이나 `float` 모두 `%f` 로 출력하지만 이에 경우 `float` 은 `%f` 로 무조건 입력 받아야 한다는 점입니다.

마찬가지로 `double` 형 변수도 무조건 `%lf`  로만 입력 받아야 합니다. 그 외에도, `printf` 는 정수형 변수는 모두 `%d` 로 출력 가능했던 반면에 `scanf` 는 각 자료형 마다 포맷이 다 정해져 있습니다. 아래 예제에서 잠시 `scanf` 의 포맷 들에 대해 정리해 보도록 하겠습니다

```cpp-formatted
printf("섭씨 %f 도는 화씨로 %f 도 입니다 \n", celsius, 9 * celsius / 5 + 32);
```

  마지막으로 위 프로그램의 중요한 부분을 살펴보자. 바로 이 부분에서 섭씨와 화씨의 환산 작업이 이루어 진다. 참고로, 화씨와 섭씨의 변환 공식은 아래와 같습니다.

$$C  \cdot \frac{9}{5} + 32 = F$$

따라서, 이 공식을 그대로 C 언어 수식을 바꾼 것이 `9 * celsius / 5 + 32` 인 것입니다. 곱셈과 나눗셈의 우선순위가 높으므로 `9 * celsius / 5` 가 먼저 계산 된 후 32 가 더해지므로 위의 식과  일치합니다. 따라서, 결국 `printf` 의 두번째 `%f` 부분에는 위 계산된 화씨의 값이 들어가게 됩니다.

```cpp-formatted
/* scanf 총 정리  */
#include <stdio.h>
int main() {
  char ch;  // 문자

  short sh;  // 정수
  int i;
  long lo;

  float fl;  // 실수
  double du;

  printf("char 형 변수 입력 : ");
  scanf("%c", &ch);

  printf("short 형 변수 입력 : ");
  scanf("%hd", &sh);
  printf("int 형 변수 입력 : ");
  scanf("%d", &i);
  printf("long 형 변수 입력 : ");
  scanf("%ld", &lo);

  printf("float 형 변수 입력 : ");
  scanf("%f", &fl);
  printf("double 형 변수 입력 : ");
  scanf("%lf", &du);

  printf("char : %c , short : %d , int : %d ", ch, sh, i);
  printf("long : %d , float : %f, double : %f \n", lo, fl, du);
  return 0;
}
```

성공적으로 컴파일 후 (경고가 6 개 정도 나올 수 있는데 무시하세요^^)

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1806421D49F5BFD8C959E0)


```cpp-formatted
printf("char 형 변수 입력 : ");
scanf("%c", &ch);
```

일단, 제일 먼저 문자를 입력 받는 부분을 봅시다. 예전에도 이야기 했지만 한글은 2 바이트를 차지하기 때문에 최대 1 바이트를 차지하는 `char` 형 변수인 `ch` 에 한글을 치면 오류가 납니다. 이와 같이 허용된 메모리 이상에 데이터를 집어넣어 발생하는 오류를 **버퍼 오버플로우(Buffer Overflow)** 라고 하며 보안 상 매우 취약합니다.\sidenote{버퍼 오버플로우를 이용해서 공격자들이 프로그램의 정상적인 코드가 아니라, 자신들이 원하는 코드가 실행될 수 있도록 조종할 수 있습니다.} 뿐만 아니라 근처의 데이터가 손상됨에 따라 큰 문제가 발생하게 될 수 도 있습니다.  따라서, 여러분들은 버퍼 오버플로우가 일어나지 않게 허용된 데이타 이상을 집어넣는지 안집어 넣는지 검사할 필요성이 있습니다.

또한 앞으로 우리가 `char` 형 변수를 선언할 때 에는 '이 사람이 문자를 보관하는 변수를 선언하는 구나' 라고 생각하도록 합시다. 왜냐하면 보통 수 데이타를 보관하는 변수로는 `int` 를 쓰지 `char` 을 잘 쓰지 않을 뿐더러 `char` 이름도 `character` 에서 따왔을 만큼 문자와 무언가 관련이 있기 때문이죠.

```cpp-formatted
printf("short 형 변수 입력 : ");
scanf("%hd", &sh);
printf("int 형 변수 입력 : ");
scanf("%d", &i);
printf("long 형 변수 입력 : ");
scanf("%ld", &lo);
```


이 부분은 여러분들이 무난하게 이해하실 수 있으리라 봅니다. 단지 포맷에 `%hd, %d, %ld` 로 다른 것 뿐이지요. 참고로 `short` 형이나 `long` 형은 아직 다루지는 않았지만 `int` 와 똑같은 계열의 정수형 변수라고 생각하시면 됩니다.

```cpp-formatted
printf("float 형 변수 입력 : ");
scanf("%f", &fl);
printf("double 형 변수 입력 : ");
scanf("%lf", &du);
```

마찬가지로 `float` 형에서는 `%f` 로, `double` 형에서는 `%lf` 로 사용한다는 것을 기억하시기 바랍니다.

이번 강좌는 지난번 강좌보다는 조금 짧습니다. 하지만 이번 강좌를 통해 응용할 수 있는 것들이 무궁 무진해졌습니다. 일단, 기본적으로 연습하실 것은 단위 환산 프로그램을 만들어 보세요! 아니면, 금리와 원금을 입력 받아서 일정 개월 후의 상환할 돈이라 든지 등등... 수 많은 프로그램을 만들 수 있습니다. 지금, 이러한 것들을 만들 수 있는 모든 도구들은 준비되어 있습니다. 이제 여러분이 스스로 창작할 세계가 남아 있을 뿐입니다.

### 생각 해보기

#### 문제 1

앞서 섭씨를 화씨로 바꿀 때 `9 * celsius / 5 + 32` 라고 하였습니다. 만약에 이를 `9 / 5 * celcius + 32` 로 바꾸면 결과가 달라질까요?

##@ chewing-c-end
Link :  8
2009-04-24 01:36
----------------
title : 씹어먹는 C 언어 - <4. 계산하리 >
cat_title : 4. 계산하리
next_page : 9
publish_date : 2009-04-24 01:36
--------------


이번 강의에서는

* 산술 연산자

* 대입 연산자

* 비트 연산자, 쉬프트 연산자



* 변수에 관한 추가적인 내용

* 산술 변환, 우선 순위



등을 배우게 됩니다.


![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분. 지난 강의에서 모두들 변수에 대해 감이 잡혔을 것이라 믿고 강의를 진행하도록 하겠습니다.

최초의 컴퓨터는 무엇을 하기 위해 태어났을까요? 오락용? 영화 시청? (물론 그 때에는 불가능 했을 터이지만). 아닙니다. 최초의 컴퓨터라 일컫어 지는 에니악(ENIAC.. 물론 에니악이 최초의 컴퓨터이냐 아니냐에 관한 논쟁은 길다. 한편에서는 콜로서스라는 주장도 있는데 아무튼) 은 포탄을 어떤 각도로 발사했을 때, 어디에 떨어질 지를 예측하는 기계였습니다. 

물론 지금도 컴퓨터의 가장 중요한 역할은 인간이 할 수 없는 복잡한 수식을 계산하는 것입니다. 다시말해, 컴퓨터는 **빠른 계산**을 위해 태어난 기계인 것입니다.

### 산술 연산자, 대입 연산자

이번 강좌에서는 C 언어에서 컴퓨터에 어떻게 연산 명령을 내리는지 살펴보도록 하겠습니다.

일단, '계산' 이라 하면 머리속에 가장 먼저 떠오르는 것은 사칙연산, 즉 ＋, －, ×, ÷ 을 의미합니다. 보통 코딩 시에 × 와 ÷ 기호를 쓰기 힘들기 때문에, 그 대신 `*` 와 `/` 를 사용합니다. 즉, 8 × 5 는 `8 * 5` 로 표현하고, 10 ÷ 7 은 `10 / 7` 로 표현합니다.

또한, 색다른 연산자로 `%` 가 있는데 이는 나눈 나머지를 의미합니다. 예를들어 `10 % 3` 은 1 이 됩니다. 왜냐하면 10 을 3 으로 나눈 나머지가 1 이기 때문이죠. 이러한 `＋, －, *, /, %` 를 **산술 연산자(Arithmetic Operator)** 라고 합니다.

```cpp-formatted
/* 산술 연산 */
#include <stdio.h>
int main() {
  int a, b;
  a = 10;
  b = 3;
  printf("a + b 는 : %d \n", a + b);
  printf("a - b 는 : %d \n", a - b);
  printf("a * b 는 : %d \n", a * b);
  printf("a / b 는 : %d \n", a / b);
  printf("a %% b 는 : %d \n \n", a % b);

  printf("a / b 는 : %f \n", a / b);  // 해서는 안될 짓
  return 0;
}
```

만약 위 코드를 잘 컴파일 했다면 아래와 같이 나옵니다. (컴파일 하는 방법을 까먹은 사람들은 [1강](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-1-C-%EC%96%B8%EC%96%B4%EA%B0%80-%EB%AD%90%EC%95%BC)을 참조하세요)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1452B11C49F096D5AA2B50)

참고로, 맨 마지막 부분에 나오는 이상한 숫자는 저와 다를 수 있으니 걱정하지 마세요

```cpp-formatted
a = 10;
b = 3;
```

지난 강좌를 잘 이해하셧더라면 위 문장이 무슨 역할을 하는지 쉽게 이해하실 수 있을 것입니다. `a` 라는 변수에 10 을 대입하는 것이고, 두 번째 문장은 `b` 에 3을 대입하는 것입니다. 그렇다면 아래 문장을 살펴보세요.

```cpp-formatted
10 = a;
3 = b;
```

언뜻 보기에 맞는 문장인 것 같습니다. 왜냐하면, 실제 수학을 공부한 사람이라면 `a = 10` 이나 `10 = a` 나 별반 다를 것이 없기 때문이죠. 하지만, C 언어 컴파일러는 '=' 라는 기호를 뒤에서 부터 해석합니다. 즉, `a = 10` 은 '10 을 `a` 에 대입하라' 라는 문장이 되지만, `10 = a` 는' `a` 의 값을 10 에 대입하라' 라는 이상한 문장이 되서 오류가 발생하게 됩니다. 

이렇게 '=' 를 **대입 연산자(Assignment Operator)** 라고 합니다. 왜냐하면 우측의 값을 좌측에 '대입' 하는 것이기 때문이죠.

따라서,

```cpp-formatted
a = 5;
b = 5;
c = 5;
d = 5;
```

라는 문장이나,

```cpp-formatted
a = b = c = d = 5;
```

라는 문장은 완전히 같은 것이 됩니다. 왜냐하면, 앞에서 말했듯이 `=` 는 뒤에서 부터 해석한다고 했으므로, 제일 먼저 `d = 5` 를 해석한 후, 그 다음에 `c = d, b = c, a = b` 로 차례대로 해석해 나가기 때문에 `a = 5; b = 5; c = 5; d = 5;` 라는 문장과 같은 것이지요.

```cpp-formatted
printf("a + b 는 : %d \n", a + b);
printf("a - b 는 : %d \n", a - b);
printf("a * b 는 : %d \n", a* b);
printf("a / b 는 : %d \n", a / b);
printf("a %% b 는 : %d \n \n", a % b);
```

자, 이제 산술 연산자들에 대해 살펴보도록 합시다. 일단, 한 눈에 보게 `a + b, a - b, a * b, a / b` 는 각각 덧셈, 뺄셈, 곱셈, 나눗셈을 하여서 그 값이 `%d` 에 들어가 출력된 것 같습니다. 그런데, `a + b, a - b, a * b` 는 각각 계산 결과가 `13, 7, 30` 이 나온 사실을 쉽게 받아들일 수 있지만, `a / b` 가 왜 3 이 나왔는지는 이해하기 힘듭니다. 왜, `a / b` 가 3 이 되었을까요?

사실, 3 강에서 말했지만 `a` 와 `b` 는 모두 `int` 형으로 선언된 변수 입니다. 즉, `a` 와 `b` 는 오직 '정수' 데이터만 담당합니다. 즉, `a` 와 `b` 는 모두 정수 데이터만 처리하기 때문에 `a` 를 `b` 로 나누면, 즉 10 을 3 으로 나누면 `3.3333...` 이 되겠지만 정수 부분인 3 만 남기게 되는 것 입니다. 따라서, 값은 3 이 출력됩니다.

마지막으로 생소한 `%` 라는 연산자에 대해 살펴봅시다. `+, -, *, /` 연산자는 모두 정수, 실수형 데이터에 대해서 모두 연산이 가능한데, `%` 는 오직 정수형 데이터에서만 연산이 가능합니다. 왜냐하면 `%` 는 나눈 나머지를 표시하는 연산자 이기 때문이죠. `a % b` 는 `a` 를 `b` 로 나눈 나머지를 표시합니다. 즉, `10 % 3 = 1` 이 됩니다.

이 때,

```cpp-formatted
printf("a %% b 는 : %d \n \n", a % b);
```

`%%` 는 `%` 를 '표시'하기 위한 방법입니다. 왜냐하면 `%` 하나로는 `%d , %f` 같이 사용될 수 있기 때문이 표시가 되지 않습니다.

```cpp-formatted
printf("a / b 는 : %f \n", a / b);  // ???
```

위 프로그램을 실행 시켜 보신 분들은 알겠지만, 마지막 문장에서 엄청나게 긴 숫자가 튀어나오게 됩니다. 물론, 그 숫자는 아무런 의미가 없는 숫자 입니다. 이러한 이상한 숫자가 출력된 이유는 바로 정수형 변수를 주고, 마치 실수형 데이터를 출력하라는 것마냥 써놓았기 때문입니다.

 3강 에서 우리는  `%f` 가 오직 실수형 데이터 만을 출력하기 위해 있는 것이라 하였습니다. 그런데, `a / b` 가 `3.3333` 이라고 해서 실수형 데이터가 되는 것이 아니라, `(정수형 변수) (연산) (정수형 변수)` 는 언제나 `(정수)` 이기 때문에 실수형 데이터를 출력하는 `%f` 를 이용하면 이와 같이 이상한 결과나 나오게 됩니다.

그렇다면 아래의 경우 어떻까요?

```cpp-formatted
/* 산술 변환  */
#include <stdio.h>
int main() {
  int a;
  double b;

  a = 10;
  b = 3;
  printf("a / b 는 : %f \n", a / b);
  printf("b / a 는 : %f \n", b / a);
  return 0;
}
```

만약 제대로 컴파일 했다면 아래와 같이 나오게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F191B8E1749F32487F3F3B7)

`a` 는 정수형 변수, `b` 는 실수형 변수 입니다. 그런데, 이들에 대해 연산을 한 후에 결과를 실수형으로 출력하였는데 정상적으로 나왔습니다. 그 것은 왜 일까요? 이는 컴파일러가 '산술 변환' 이라는 과정을 거치기 때문입니다. 즉, 어떠한 자료형이 다른 두 변수를 연산 할 때, 숫자의 범위가 큰 자료형으로 자료형들이 바뀝니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F11757E0E49F3260ADBDEC9)

즉, 위 그림에서도 보듯이 `a` 가 `int` 형 변수이고 `b` 가 `double` 형 변수인데, `double` 이 `int` 에 비해 포함하는 숫자가 더 크므로 큰 쪽으로 산술 변환됩니다. 일단, 정수형 변수와 실수형 변수가 만나면 무조건 실수형 변수쪽으로 상승되는데, 이는 실수형 변수의 수 범위가 `int` 보다 훨씬 넓기 때문입니다. 위와 같은 산술 변환을 통해 애러가 없이 무사히 실행 될 수 있었습니다. 또한 `double` 형태로 산술 변환 되므로 결과도 `double` 형태로 나오기 때문에

```cpp-formatted
printf(" a / b 는 : %d \n", a / b);
```

와 같이 하면 오류가 생기게 됩니다. 왜냐하면 `%d` 는 정수형 값을 출력하는 방식이기 때문이죠.

### 대입 연산자

```cpp-formatted
/* 대입 연산자   */
#include <stdio.h>
int main() {
  int a = 3;
  a = a + 3;
  printf("a 의 값은 : %d \n", a);
  return 0;
}
```

위 결과를 컴파일 하면 아래와 같이 나옵니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1444341149F327F6580EC8)

일단, 변수 선언 부분 부터 살펴 봅시다.

```cpp-formatted
int a = 3;
```

위 문장을 아마 무슨 뜻일지 감이 바로 오실 것입니다. "음... `a` 라는 변수를 선언하고 `a` 변수에 3 의 값을 집어 넣는구나". 맞습니다. 사실 위 문장이나 아래 문장이나 다를 바가 없습니다.

```cpp-formatted
int a;
a = 3;
```

그냥, 타이핑 하기 귀찮아서 짧게 써 놓은 것 뿐입니다.

```cpp-formatted
a = a + 3;
```

그 다음 부분은 대입 연산자와 산술 연산자가 함께 나와 있습니다. 만일, 우리가 방정식에 대해서 공부해 본 사람이라면 다음과 같이 이의를 제기할 수 도 있습니다.

```info
a = a + 3
따라서 양변에서 a 를 빼면
0 = 3 ???
```

물론, 위는 수학적으로 맞지만 C 언어 에서 의미하는 바는 다릅니다. 위에서 말했듯이, `=` 는 등호가 아닙니다. '대입' 연산자 입니다. 무엇을 대입하냐구요? 오른쪽의 값을 왼쪽으로 대입합니다. 즉, `a + 3` 의 값(6) 을 `a` 에 대입합니다. 따라서, `a = 6` 이 되는 것이지요.

이 때, 이와 같이 계산 될 수 있는 이유는 `+` 를 `=` 보다 먼저 연산하기 때문입니다. 즉, `a + 3` 을 먼저 한 후(+), 그 값을 대입(=) 하는 순서를 거치기 때문에 `a` 에 6 이라는 값이 들어갈 수 있게 됩니다. 이러한 것을 **연산자 우선순위** 라고 하는데, 밑에서 조금 있다가 다루어 보도록 하겠습니다.

```cpp-formatted
/* 더하기 1 을 하는 방법  */
#include <stdio.h>
int main() {
  int a = 1, b = 1, c = 1, d = 1;

  a = a + 1;
  printf("a : %d \n", a);
  b += 1;
  printf("b : %d \n", b);
  ++c;
  printf("c : %d \n", c);
  d++;
  printf("d : %d \n", d);

  return 0;
}
```

위 코드를 컴파일 하면 아래와 같이 나옵니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1427821049F32CD7A211BB)

  음, 모두 2 가 되었군요. 사실 위에 나온 4 개의 코드는 더하기 1 을 한다는 점에서 모두 같습니다. 일단, 하나하나 차례대로 살펴봅시다.

```cpp-formatted
a = a + 1;
```

가장, 기초적으로 1 을 더하는 방법입니다. 위 문장은 "a 에 `a` 에 1 을 더한 값을 대입한다." 라는 뜻을 가지고 있죠?

```cpp-formatted
b += 1;
```

이게 뭔가요! 처음 본 연산인 `+=` 입니다. 이러한 연산을 복합 대입연산 이라 하며, `b = b + 1` 과 같습니다. 이렇게 쓰는 이유는 단지, `b = b + 1` 을 쓰기 귀찮아서 간략하게 쓰는 것입니다. 물론, `b = b + 1` 과 `b += 1` 은 엄밀히 말하자면 같은 것은 아니지만 이에 대해서는 나중에 다루어 보도록 하겠습니다(우선 순위에서 약간 차이가 있습니다). 복합 대입 연산은 아래와 같이 여러 가지 형태로 이용될 수 있습니다.

```info
b += x; // b = b + x; 와 같다
b -= x; // b = b - x;와 같다
b *= x; // b = b * x;와 같다
b /= x; // b = b / x;와 같다
```

마지막으로, 비슷하게 생긴 두 부분을 함께 살펴 보도록 하겠습니다.

```cpp-formatted
++c;
d++;
```

위와 같은 연산자(`++`)를 증감 연산자라고 합니다. 둘 다, `c` 와 `d` 를 1 씩 증가시켜 줍니다. 그런데, `++` 의 위치가 다릅니다. 전자의 경우 `++` 이 피연산자(c) 앞에 있지만 후자의 경우 `++` 이 피연산자(d) 뒤에 있습니다.

`++` 이 앞에 있는 것을 **전위형(prefix)**, `++` 이 뒤에 있는 것을 **후위형(postfix)** 라 하는데 이 둘은 똑같이 1 을 더해주만 살짝 다릅니다. 전위형의 경우, 먼저 1 을 더해준 후 결과를 돌려주는데 반해, 후위형의 경우 결과를 돌려준 이후 1 을 더해줍니다. 이 말만 가지고는 이해가 잘 안될테니 아래를 보세요.

```cpp-formatted
/* prefix, postfix  */
#include <stdio.h>
int main() {
  int a = 1;

  printf("++a : %d \n", ++a);

  a = 1;
  printf("a++ : %d \n", a++);
  printf("a : %d \n", a);

  return 0;
}
```

위 소스를 성공적으로 컴파일 했다면 아래와 같이 결과가 나온다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F204C7B1749F3F1494AE9B7)


분명히, 위에서 `++c` 나 `d++` 이나 결과를 출력했을 때 에는 결과가 1 이 잘 더해져서 2 가 나왔는데 여기서는 왜 다르게 나올까요? 앞서 말했듯이 `++ a` 는 먼저 1 을 더한 후 결과를 반환한다고 했고 `a++` 은 먼저 결과를 반환 한 후, 그 후에 1 을 더한 다고 했습니다.

```cpp-formatted
printf("++a : %d \n", ++a);
```

즉, 위의 경우 `a` 에 먼저 1 을 더한 값인 2 를 `printf` 함수에 반환하여 `%d` 에 2 가 들어가게 됩니다. 그런데,

```cpp-formatted
printf("a++ : %d \n", a++);
```

이 경우, 먼저 `a` 의 값을 `printf` 에 반환하며 `%d` 에 1 이란 값이 '먼저' 들어 간 뒤, 1 이 출력된 이후 `a` 에 1 이 더해집니다. 따라서, 다시 `printf` 문으로 `a` 의 값을 출력하였을 때 에는 2 라는 값이 나오게 되는 것입니다. 참고로, 위 4 개의 연산 중에서 가장 빨리 연산되는 것은 `a++` 과 같은 증감 연산입니다 \sidenote{왜냐하면, a = a + 1 의 경우 ADD a  1 로 하지만, a++ 은 INC a 로 좀 더 빨리 계산된다. 자세한 내용은 나중에} 하지만, 요즘의 컴파일러는 최적화가 잘 되어 있어, `a = a + 1` 같은 것은 `a ++` 로 바꾸어 컴파일 해버립니다.

### 비트 연산자

마지막으로 생소한 연산자에 대해 알아보록 하겠습니다. **비트 연산자**라고 부르는 이들은 정말 비트(bit) 를 가지고 연산을 합니다. 비트는 컴퓨터 기억 장치의 최소 단위로 1 비트는 0 과 1 만을 구분합니다. 이진법의 1 자리라 볼 수 있죠. 보통, 8개의 비트(8 bit) 를 묶어서 1 바이트(byte) 라고 하고, 이진법으로 8 자리 수라 볼 수 있죠. 따라서, 1 바이트로 나타낼 수 있는 수의 범위가 0 부터 `11111111b` 로 십진수로 바꾸면 0 부터 255 까지 나타낼 수 있습니다.

비트 연산자에는 `&` (And 연산), `|` (\ 위에 있는 것이다. 영문자 `i` 가 아닌다. `Or` 연산), `^` (XOR 연산), `<<, >>` (쉬프트 연산) `, ~` (반전) 등이 있습니다. 일단, 각 연산자가 어떠한 역할을 하는지 살펴보도록 합시다.

#### `AND` 연산 (&)

`AND` 연산은 아래와 같은 규칙으로 연산된다.

```info
1 & 1 = 1
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0
```

비트 연산은 각 자리를 연산하는데, 예를들어, `1010 & 0011` 의 경우

![각 자리수 별로 일의 자리 부터 연산해 나갑니다. 처음에는 0 과 1, 그 다음에 1 과 1, 그 다음에 0 과 0, 그 다음에 1 과 0 을 AND 연산하게 되면 0010 이라는 결과가 나오지요](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F19089F0F49F472A5C0B43C)

위와 같이 한자리 한자리 각각 `AND` 연산하여, 위에 써 놓은 규칙대로 연산이 됩니다. 만약 두 숫자의 자리수가 맞지 않을 경우 ,예를들어 1111100 과 11 을 `AND` 연산 할 때 에는 11 앞에 0 을 추가하여 자리수를 맞추어 준다. 즉, 1111100 과 0000011 의 연산과 같습니다.

#### `OR` 연산 (|)

```info
1 | 1 = 1
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0

```

`OR` 연산은 `AND` 연산과 대조적이다. 어느 하나만 1 이여도 모두 1 이 되는데, 예를들어 `1101 | 1000` 은 결과가 1101 이 됩니다.

#### `XOR` 연산 (^)

```info
1 ^ 1 = 0
0 ^ 1 = 1
1 ^ 0 = 1
0 ^ 0 = 0
```


`XOR` 연산은 특이하게도 두 수가 달라야지만 1 이 된다. 예를들어, `1100 ^ 1010` 의 경우 결과가 0110 이 됩니다.

#### 반전 연산(~)

반전연산은 간단히 말에 0 을 1 로 1 을 0 으로 바꿔주는 것입니다. 예를들어서 `~ 1100` 을 하면 그 결과는 0011 이 됩니다.

#### `<<` 연산 (쉬프트 연산)

위 연산 기호에서 볼 수 있듯이, 비트를 왼쪽으로 쉬프트(Shift) 시킨다. 예를 들어, 101011 를 1 만큼 쉬프트 시키면 ( 이를 a << 1 이라 나타냅니다)

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1829FB0F49F474DAC07F7D)
  위 처럼 결과가 010110 이 됩니다. 이 때, `<<` 쉬프트 시, 만일 앞에 쉬프트된 숫자가 갈 자리가 없다면, 그 부분은 버려집니다. 또한 뒤에서 새로 채워지는 부분은 앞에서 버려진 숫자가 가는 것이 아니라 무조건 0 으로 채워집니다.

#### `>>` 연산

이는 위와 같은 종류로 이는 `<<` 와 달리 오른쪽으로 쉬프트 해줍니다. 이 때, 오른쪽으로 쉬프트 하되, 그 숫자가 갈 자리가 없다면 그 숫자는 버려집니다. 이 때, 무조건 0 이 채워지는 `<<` 연산과는 달리 앞부분에 맨 왼쪽에 있었던 수가 채워지게 되죠. 예를들어서 `11100010 >> 3 = 11111100` 이 되고, `00011001 >> 3 = 00000011` 이 됩니다.

비트 연산자를 자세히 다룬 이유는 이 부분이 약간 생소하기 때문입니다. 또한, 처음에 비트 연산자를 접할 때, '저런거 뭐에다 쓰지?' 라는 생각이 들기도 합니다. 그런데, 사실 비트 연산은 암호 분야에서 많이 쓰이며 쉬프트 연산도 가끔씩 유용하게 쓰입니다.

```cpp-formatted
/* 비트 연산 */
#include <stdio.h>
int main() {
  int a = 0xAF;  // 10101111
  int b = 0xB5;  // 10110101

  printf("%x \n", a & b);   // a & b = 10100101
  printf("%x \n", a | b);   // a | b =10111111
  printf("%x \n", a ^ b);   // a ^ b = 00011010
  printf("%x \n", ~a);      // ~a = 1....1 01010000
  printf("%x \n", a << 2);  // a << 2 = 1010111100
  printf("%x \n", b >> 3);  // b >> 3 = 00010110

  return 0;
}
```

위를 성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F200CD91E49F47B31C40ACF)

위와 같이 나오게 됩니다. 일단, 첫 세줄은 그럭 저럭 이해가 잘 갑니다. 그런데, 네 번째 줄인 `~ a` 연산에 대해 의문을 품는 사람들이 많습니다.

```cpp-formatted
printf("%x \n", ~a);  // ~a = 1....1 01010000
```

  우리의 기억을 되돌려 [3 강](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-3-%EB%B3%80%EC%88%98%EA%B0%80-%EB%AD%90%EC%A7%80)으로 가 봅시다. 강의 중간쯤에 보면 여러가지 자료형 들에 대한 설명과 함께 작은 표가 있을 텐데 말이죠. 이를 다시 아래에 불러와 봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F16216E0949F47C0DD3A2AC)

`int` 형 변수에 대한 설명을 보니 옆에 **Size** 이라 표시된 것이 있습니다. 이는 `int` 형 변수의 크기를 나타내는데 4 바이트라고 되어 있군요. 맞습니다. `int` 형 변수는 하나의 데이터를 저장하기 위하여 메모리 상의 4 바이트 - 즉 32 비트를 사용합니다. ( 1 byte = 8 bits) 아까, 하나의 비트가 0 과 1 을 나타낸다고 했으므로 (즉 1 개의 비트가 2 진수의 한 자리를 나타내게 되죠), 하나의 `int` 형 변수는 32 자리의 이진수라고 볼 수 있습니다. 예를들어 우리가 `a = 1` 이라 한 것은 실제로 컴퓨터에는 `a = 00000000 00000000 00000000 00000001` 이라 저장되는 것과 같게 되는 거죠.

즉, 우리가 `int a = 0xAF;` 라고 한 것은 `a = 10101111;` 이 맞지만 사실 컴퓨터 메모리 상에서는 `a` 가 `int` 형이기 때문에 `a = 00000000 00000000 00000000 10101111` (`10101111` 앞에 0 이 24 개 있다) 이라 기억하는 것이 됩니다. 따라서, 이 숫자를 반전 시키게 되면
`a = 11111111 11111111 11111111 01010000`, 즉 `0xFFFFFF50` 이 되는 것이지요. 마찬가지로 생각해 보면,

```cpp-formatted
printf("%x \n", a << 2);  // a << 2 = 1010111100
printf("%x \n", b >> 3);  // b >> 3 = 00010110
```

이 두 문장도 사실은 각각 `00000000 00000000 00000000 10101111` 과 `00000000 00000000 00000000 10110101` 을 쉬프트 연산한 것과 같습니다.

따라서 `a` 의 경우 `00000000 00000000 00000000 10101111` 을 왼쪽으로 2 칸 쉬프트 하면 ` 00000000 00000000 00000010 10111100` 이 되어 `0x2BC` 가 됩니다

`b` 의 경우 마치 앞에 1 이 있는 것 같지만 실제로는 `int` 형 데이터에 저장되어 있으므로 4 바이트로, `00000000 00000000 00000000 10110101` 이므로 맨 왼쪽의 비트는 0 입니다. 따라서 쉬프트를 하게 되면 왼쪽에 0 이 채워지면서 `00000000 00000000 00000000 00010110` 이 되어 `0x16` 이 됩니다.

### 복잡한 연산

마지막으로 여러 연산이 중첩된 혼합 연산에 대해 살펴 보도록 합시다. 우리가 연산을 하는데 에도 순서가 있듯이 컴퓨터에도 연산을 하는데 무엇을 먼저 연산을 할 지 우선 순위가 정해져 있을 뿐더러 연산 방향 까지도 정해져 있습니다. 이를 간단히 살펴 보자면 아래와 같습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F205C9C4F501D010E144AA9)


이와 같이 순위가 매겨져 있습니다. 이 때, 눈여겨 보아야 할 점은 괄호들이 제 1 우선 순위에 위치하였다는 점 입니다. 따라서, 어떠한 연산이라도 괄호로 감싸 주게 되면 먼저 실행 됩니다.

마지막으로, 결합 순위에 대해 잠시 다루어 보도록 하겠습니다. 표의 오른쪽을 보면 결합 순위가 나와 있는데, 대부분이 '왼쪽 우선' 이지만 몇 개는 '오른쪽 우선' 입니다. 이 말이 뜻하는 바가 무엇이냐면, 아래와 같은 문장을 수행할 때 계산하는 순위를 이야기 합니다.

```cpp-formatted
a = b + c + d + e;
```

위 표에서 보듯이, 덧셈의 결합 순서가 왼쪽 우선이므로 위 계산과정은 아래의 순서대로 진행됩니다.

```info
b + c 를 계산하고 그 결과를 반환( 그 결과를 C 라 하면)
C + d 를 계산하고 그 결과를 반환( 그 결과를 D 라 하면)
D + e 를 계산하고 그 결과를 반환(그 결과를 E 라 하면)
```

 따라서, 위 식은

```info
a = E
```

 가 되죠. 따라서, `a` 에 `E` 의 값, 즉 `b + c + d + e` 의 값이 들어가게 됩니다.

또한, 위 표에서 몇 안되는 '오른쪽이 우선' 인 대입 연산자(=) 를 살펴봅시다. 만약 대입 연산자가 왼쪽 우선이였다면 아래의 식이 어떻게 계산될 지 생각해 봅시다.

```info
a = b =  c = d = 3;
```

만약 왼쪽 우선이였다면 `a = b; b = c; c = d; d = 3` 의 형식으로 계산되어 `a, b, c` 에는 알 수 없는 값이 들어가겠죠. 하지만 오른쪽이 우선이므로 위 식은 `d = 3, c = d, b = c, a = b` 의 형식으로 계산되어 `a,b,c,d` 의 값이 모두 3 이 될 수 있었습니다.

자, 이제 연산자에 대한 강의가 끝났습니다. 연산자는 C 언어에서 가장 기초적인 부분이라 할 수 있습니다. 마치 수학에서 덧셈, 뺄셈을 가장 처음에 배우는 것 처럼 말이죠. 이번 강좌에서는 특별히 예제를 많이 만들어 보지는 않았지만 여러분 께서 C 언어를 통해 복잡한 수식의 계산을 하거나, 복잡한 수식을 보고 이러한 연산은 이 순서로 연산될 것이다 라고 예측해 보는 것도 우선순위를 이해하는데 도움이 될 것입니다. 보통, 우선순위를 잘못 고려하여 나는 오류들은 찾기가 매우 힘들기 때문에 우선순위를 빠삭하게 잘 이해하는 것이 좋습니다.

##@ chewing-c-end
Link :  7
2009-04-22 23:30
----------------
title : 씹어먹는 C 언어 - <3. 변수가 뭐지? >
cat_title : 3. 변수가 뭐지?
next_page : 8
publish_date : 2009-04-22 23:30
--------------


이번 강좌에서 배우게 될 것은

* 변수란 무엇인가?

* 정수형, 실수형 변수

* 16 진법, 메모리 주소

* 변수 이름 짓기


![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요? 여러분. 잘 지내셨나요. 지난 번에 처음으로 C 코드를 분석한 것은 이해가 잘 되셨나요? 이해가 잘 안되셨다도 괜찮습니다. 점점 C 언어를 배워감에 따라, 기존이 이해가 안 되었던 것들도 언젠가는 '아 이래서 그랬구나' 하는 순간이 오게 됩니다. 이 단계에서 여러분이 취해야 할 자세는 일단 이해가 안되는 것은 일단, **암기** 하고, 포기하지 않는 것이 필요합니다.

### 변수란 무엇인가?

컴퓨터는 많은 내용을 기억 해야 합니다. 정확히 말하면, 컴퓨터의 '메모리' 라는 부분에 전기적인 신호를 써 놓는 것이죠. 컴퓨터가 무엇을 기억해야 되냐고 생각할 수 있지만, 우리가 많이 하는 게임인 스타크레프트만 보아도 일단, 각 유닛의 `HP` 와 마나, 그리고 실시간으로 바뀌는 미네랄과 가스, 뿐만 아니라 유닛의 위치, 유닛의 데미지 등 모든 것을 기억해야지 우리가 게임을 제대로 즐길 수 있게 되겠지요. 만약 컴퓨터가 미네랄의 양을 제대로 기억 못한다면 미네랄이 갑자기 100 에서 0 이 되거나 10 에서 9999 로 바뀌는 참사가 발생합니다.

그렇다면 컴퓨터는 이러한 데이터들을 어떻게 기억할까요? 바로 컴퓨터의 메모리, 즉 `RAM` 이라는 특별한 기억공간에 이를 기록합니다. 보통 우리는 흔히 `RAM` 을 설명할 때 아래 처럼 표시합니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1411621C49EF238BBD31DF)

마치, 각 방에 데이터들이 저장됩니다. 이 때, 컴퓨터는 각 방에 이름을 붙이는데 단순하게 숫자로 이름을 붙입니다. 0 번, 1 번, 2 번, .. 와 같이 말입니다. 우리 대부분이 사용하는 32 비트 `CPU` 에서는 최대 2³² 개(4GB) - 총, 42 억개 달하는 방을 가질 수 있게 되겠지요. 참고로 32 비트 숫자를 매번 쓰는게 매우 힘들기 때문에, 대개 16진법으로 주소값을 나타냅니다. 

예를 들어서, 컴퓨터가 `0x12345678` 부터 `0x1234567B` 부분에 내가 캔 미네랄의 양에 관한 정보를 저장했다고 합시다. (이 한칸에는 1 바이트, 즉 0 부터 127 까지의 수 데이터를 저장할 수 있습니다) 만약 우리가 건물을 지을 때, 내가 가진 미네랄의 양이 충분한 지 확인하기 위해, 내가 캔 미네랄의 양에 관한 정보가 필요합니다. 그런데, 이렇게 미네랄에 관한 정보가 필요로 할 때 마다 이 길고 알아보기 힘든 복잡한 주소를 일일이 써야 한다면 상당히 힘들겠지요.

하지만 다행히도 C 언어에는 '변수' 라는 것이 있어서, 이 모든 작업을 쉽게 할 수 있습니다. 예를들어, 내가 캔 미네랄의 양을 `mineral` 이라는 변수에 저장했다고 합시다. 그렇다면 컴퓨터는 '알아서' 메모리의 어딘가에 `mineral` 의 방을 주고 그 내용을 저장합니다. 예를들어서, 컴퓨터가 이 `mineral` 이라는 변수에게 4 칸의 자리를 할당해 주었다고 합시다. 이는 아래 그림처럼 메모리 상에 표시됩니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F1951971E49EF31AA1E06F1)

이 때, 우리가 미네랄을 더 캐서 8 을 추가해야한다고 봅시다. 만약 이전에 8 을 추가한다면 `0x12345678` 부터 `0x1234567B` 까지의 모든 내용을 불러와서 8 을 더한 후, 다시 집어넣는 작업을 일일이 손으로 써 주어야 되었을 것입니다. 하지만, 이제는 단순히 `mineral = mineral + 8` 과 같이 써 주기만 한다면 `mineral` 에 8 이 더해지는 것이죠. (만약 `mineral = mineral + 8` 이라는 식이 이해가 안되도 그냥 넘어가세요. 이 처럼 간단해 진다는 것을 말해주고 싶었을 뿐입니다)

이와 같이 C 언어에서, 바뀔 수 있는 어떤 값을 보관하는 곳을 변수 라고 합니다. 영어로는 Variable 이라 하는데, 말 그대로 '바뀔 수 있는 것들' 이라는 뜻입니다.

### 변수 선언하기

```cpp-formatted
/* 변수 알아보기 */
#include <stdio.h>
int main() {
  int a;
  a = 10;
  printf("a 의 값은 : %d \n", a);
  return 0;
}
```

  프로젝트를 만들어 위의 내용을 적은 후, 컴파일 해봅시다. 까먹었다면 [1 강](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-1-C-%EC%96%B8%EC%96%B4%EA%B0%80-%EB%AD%90%EC%95%BC)을 참조하세요. 만약 성공적으로 하였다면 아래와 같은 화면을 볼 수 있겠죠.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F1771700D49EF340A2E0A5B)

  일단, 이번에도 역시 생소한 것들이 나왔기 때문에 한 문장씩 차근차근 살펴 봅시다.

```cpp-formatted
int a;
```

음, 이게 무엇일까요? 이전에 `int main()` 에서 보았던 `int` 가 다시 나타났군요.사실 이 문장에 뜻은 `a` 라는 변수를 우리가 쓰겠다고 컴파일러에게 알리는 것입니다. 만약 이러한 문장이 없다면 우리가 `x` 가 뭐고 `y` 가 뭔지 알려주지도 않은 채, 친구에게 `x + y` 가 얼마냐? 하고 물어보는 것과 똑같은 격이 되는 것이지요.

이 때, `a` 앞에 붙은 `int` 라는 것은'int' 형의 데이터를 보관한다는 뜻으로, `int` 형의 변수는 `-2147483648` 에서 부터 `2147483648` 까지의 숫자를 보관 할 수 있게 됩니다. 따라서, 만약 중간의 문장을

```cpp-formatted
a = 10000000000000;
```

와 같이 한다면 아마 `a` 의 값을 출력하였을 때, 이상한 결과가 나오게 됩니다. 왜냐하면 보관할 수 있는 범위를 초과하는 숫자를 보관했기 때문이죠.

그럼 이제, 걱정이 생깁니다. `a` 에 고작 10 밖에 안 넣을 거 면서, 굳이 `2147483647 ~ 2147483647` 까지 표현할 수 있는 `int` 형의 변수를 왜 사용했냐고 물을 수 있습니다. 물론, `int` 형 보다 작은 범위의 숫자 데이터 만을 가지는 형식이 있기는 하지만 (`char` 등등), **보통의 경우 정수 데이터를 보관할 때 `int` 형 변수를 사용합니다.** 

또한, 2147483647 보다 큰 수를 사용하려면 어떻게 해야되냐는 궁금증도 생기지요. 물론 이 보다도 훨씬 큰 숫자를 처리하는 데이터 형식이 있습니다. 아래의 표를 참조하세요.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1165C91B49EF36C6B66009)

http://www.cplusplus.com/doc/tutorial/variables/

세번째 열인 `Range` 를 보시면, `unsigned` 와 `signed` 라고 나뉜 것이 있는데, 보통 `int` 라 하면 `signed int` 를 뜻합니다. 이는 음수/양수 모두 표시할 수 있는 대신에 양수로 표현할 수 있는 범위가 줄어듭니다. 반면에 `unsigned int` 는 양수만을 표현할 수 있는 대신에, 양수로 표현할 수 있는 범위가 두 배로 늘어납니다. 또한 마지막에 보면 `float, double, long double` 이 있는데 이들은 '실수형' 자료형으로 소수(`0.1, 1.4123` 등) 을 표현 할 수 있습니다. 뿐만 아니라 `double` 의 경우,

$$ \pm 2.3 \times 10^{-308} \backsim \pm 1.7 \times 10^{308} $$

의 수들을 표현 할 수 있습니다. (이에 대한 정확한 설명은 후에 다루겠습니다.)

```cpp-formatted
a = 10;
```

위 문장은 무엇을 의미할까요? 언뜻 보기에도 감이 오시겠지만, 변수 `a` 에 10 을 집어넣는 다는 것입니다. 따라서 나중에 `a` 의 값을 출력시 10 이 나올 것입니다. 이와 같은 형태의 문장은 후에, 연산자에 대해 다룰 때 다시 알아보도록 하겠습니다.

```cpp-formatted
printf("a 의 값은 : %d \n", a);
```

마지막으로, 지난번에도 보았던 `printf` 문 입니다. 그런데, 약간 다른 것이 있습니다. `%d` 가 출력되는 부분에 써져 있습니다. 그런데, 프로그램을 실행시켜 보았을 때 `%d` 는 컴퓨터에서 출력되지 않았습니다. 그 대신, `%d` 가 출력될 자리에 무언가 다른 것이 출력되었는데, 바로 `a` 의 값 이였습니다. 즉,`%d` 는 `a` 의 값 (정확히는 처음 "" 다음에 오는 첫 번째 변수) 을 '10 진수' 로 출력하라' 라는 뜻이 됩니다.

또 다른 예제를 봅시다.

```cpp-formatted
/* 변수 알아보기 2*/
#include <stdio.h>
int main() {
  int a;
  a = 127;
  printf("a 의 값은 %d 진수로 %o 입니다. \n", 8, a);
  printf("a 의 값은 %d 진수로 %d 입니다. \n", 10, a);
  printf("a 의 값은 %d 진수로 %x 입니다. \n", 16, a);
  return 0;
}
```

프로그램을 제대로 짰다면 아래와 같은 결과를 볼 수 있을 것입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1542541849EF3CE607CA9E)

일단, 위 코드를 보고 생기는 궁금증은 2 가지 있습니다. `%` 달린게 2 개나 있는데, 이를 어떻게 해야되냐와, `%d` 말고도 `%o` 와 `%x` 는 무엇인가 입니다.

먼저, `printf` 의 작동 원리에 대해 봅시다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F17728A0D49EF3E386AE550)

`printf` 출력시에, 큰 따옴표로 묶인 부분 뒤에 나열된 인자들 (8, a) 가 순서대로 큰 따옴표 안의 `%` 부분으로 들어감을 알 수 있습니다. 따라서 , 예를들면 `printf("%d %d %d %d", a,b,c,d);` 와 같은 문장은 `a, b, c, d` 의 값이 순서대로 출력되겠죠.

이제, `%o`  와 `%x` 는 무엇일까요? 이는 인자의 값(a) 를 출력하는 형식 입니다. 즉, `%o` 는 `a` 의 값을 8 진수로 출력하라라는 뜻이고, `%x` 는 16 진수로 출력하라는 뜻 이죠.

### 실수형 변수

앞서 말했듯이, 실수형에는 `float` 와 `double` 이 있습니다. `double` 의 경우 `int` 형에 비해 덩치가 2 배나 크지만 그 만큼 엄청난 크기의 숫자를 다룰 수 있습니다. 그 대신, 처음 15 개의 숫자들만 정확하고 나머지는 10 의 지수 형태로 표현됩니다. 또한 `float` 과 `double` 의 장점은 소수를 표시할 수 있다는 점인데, 정수형 변수에서 소수를 넣는다면 (예를들어 `int a; a = 1.234;`), 소수 부분은 다 잘린 채, 나중에 `a` 의 값을 표시해 보면 1 이 나올 것 입니다.

```cpp-formatted
/* 변수 알아보기 3*/
#include <stdio.h>
int main() {
  float a = 3.141592f;
  double b = 3.141592;
  printf("a : %f \n", a);
  printf("b : %f \n", b);
  return 0;
}
```

  실행해 본다면 아래와 같이 나오게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F2010B91C49EF4A9B72C776)

   일단, 위 코드를 보면서 궁금한 점이 생기지 않았나요?

```cpp-formatted
float a = 3.141592f;
double b = 3.141592;
```


왜, `float` 형 변수 `a` 를 선언할 때 에는 숫자 뒤에 `f` 를 붙였는데 `double` 형 에서는 `f` 를 안 붙였는 지요. 왜냐하면, 그냥 `f` 를 안 붙이고 `float a = 3.141592` 로 하면 이를 `double` 형으로 인식하여 문제가 생길 수 있습니다. 따라서, `float` 형이라는 것을 확실히 표시해 주기 위해 `f` 를 끝에 붙이는 것입니다.

```cpp-formatted
printf("a : %f \n", a);
printf("b : %f \n", b);
```

이제, 마지막으로 `%d, %o, %x` 도 아닌 `%f` 가 등장하였습니다. 만약, 여기서 `a` 를 `%d` 형식으로 출력하면 어떻게 될까요? 한 번 해보세요. 아마 이상한 숫자가 나오게 될 것입니다. 왜냐하면 `a` 는 지금 정수형 변수가 아니기 때문 입니다. 설사, 우리가 `a = 3f; b = 3;` 라고 해도, 이미 `a` 와 `b` 를 실수형 변수로 선언하였기 때문에 컴퓨터는`a ,b` 를 절대 정수로 보지 않습니다.

따라서, 우리는 실수형 변수를 출력하는 형식인 `%f` 를 사용해야 합니다.

참고로 주의할 사항은 `printf` 에서 `%f` 를 이용해 수를 출력 할 때 다음과 같이 언제나 소수점을 뒤에 붙여 주어야 한다는 점입니다. 예를 들어서

```cpp-formatted
printf("%f", 1);
```

을 하면 화면에 이상한 값 (아마도 0 이 출력될 것입니다) 이 나오지만

```cpp-formatted
printf("%f", 1.0);
```

을 하면 화면에 제대로 `1.0` 이 출력됩니다.

### `printf` 의 또 다른 형식

```cpp-formatted
/* printf 형식 */
#include <stdio.h>
int main() {
  float a = 3.141592f;
  double b = 3.141592;
  int c = 123;
  printf("a : %.2f \n", a);
  printf("c : %5d \n", c);
  printf("b : %6.3f \n", b);
  return 0;
}
```

만약 위 소스를 성공적으로 쳤다면 실행시 아래와 같이 나오게 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1523470E49EF5445F36C7A)

```cpp-formatted
printf("a : %.2f \n", a);
```

이번에는 `%f` 가 아니라 `%.2f` 로 약간 다릅니다. 그렇다면 `.2` 가 뜻 하는 것은 무엇일까요? 대충 짐작했듯이, 무조건 소수점 이하 둘째 자리 까지만 표시하라 란 뜻입니다. 따라서, 위의 경우 `3.141592` 중 `3.14` 까지만 출력되고 나머지는 잘리게 되죠.

여기서 '무조건' 이라는 것은 `%.100f` 로 할 경우에도, `3.141592000000....00` 을 표시해서 무조건 100 개를 출력하게 합니다.

```cpp-formatted
printf("c : %5d \n", c);
```

이번에는 `%d` 가 아닌 `%5d` 입니다. 여기서 `.5` 가 아님을 주의합시다. 이 말은, 숫자의 자리수를 되도록 5 자리로 맞추라는 것입니다. 따라서, 123 을 표시할 때, 5 자리를 맞추어야 하므로 앞에 공백을 남기고 그 뒤에 123 을 표시했습니다.

그런데, 123456 을 표시할 때, `%5d` 조건을 준다면 어떻할까요? 이 때는 그냥 123456 을 다 표시합니다. 앞서 `.?f` 는 `?` 의 수 만큼 무조건 소수점 자리수를 맞추어야 하지만 이 경우는 반드시 지켜야 되는 것은 아닙니다

```cpp-formatted
printf("b : %6.3f \n", b);
```

마지막으로, 위에서 썼던 두 가지 형식을 모두 한꺼번에 적용한 모습입니다. 전체 자리수는 6 자리로 맞추되 반드시 소수점 이하 3 째 자리 까지만 표시한다는 뜻입니다.

### 변수 작명하기

앞서, 보았듯이 변수를 선언하는 것은 어려운 일이 아닙니다. 단지, 아래의 형태로 맞추어 주기만 하면 됩니다.

```cpp-formatted
(변수의 자료형) 변수1, 변수2, .....;
/* 예를 들어 */
int a, b, c, hi;
float d, e, f, bravo;
double g, programming;
long h;
short i;
char j, k, hello, mineral;
```

이 때, 변수 선언시 주의해야 할 점이 있습니다. 만약에 여러분이 오래된 버전의 C 언어 (C89) 를 사용한다면, 변수 선언시 반드시 최상단에 위치해야 합니다. 하지만, 여러분이 지금 사용하고 있는 최신 버전의 C 의 변수 사용하기 전 아무데나 변수를 선언해도 상관 없습니다. 

```cpp-formatted
/* 변수 선언시 주의해야 할 점 */
#include <stdio.h>
int main() {
  int a;
  a = 1;
  printf("a 는 : %d", a);
  int b;  // 괜찮음!
  return 0;
}
```

두 번째로, 사람의 이름을 지을 때, 여러가지를 고려하듯이 변수의 이름에서도 여러가지 조건들이 있습니다. 아래 예제를 보세요.

```cpp-formatted
/* 변수 선언시 주의해야 할 점 */
#include <stdio.h>
int main() {
  int a, A;  // a 와 A 는 각기 다른 변수 입니다.
  int 1hi;
  // (오류) 숫자가 앞에 위치할 수 없습니다.
  int hi123, h123i, h1234324;  // 숫자가 뒤에 위치하면 괜찮습니다.
  int 한글이좋아;
  /*
  (오류)
  변수는 오직 알파벳, 숫자, 그리고 _ (underscore)로만으로 이루어져야 합니다. */
  int space bar;
  /*
  (오류)
  변수의 이름에는 띄어쓰기하면 안됩니다.  그 대신 _ 로 대체하는 것이 읽기
  좋습니다.*/
  int space_bar;  // 이것은 괜찮습니다.
  int enum, long, double, int;
  /* (오류)
     지금 나열한 이름들은 모두 '예약어' 로 C 언어에서 이미 쓰이고 있는
     것들입니다. 따라서 이러한 것들은 쓰면 안됩니다. 이를 구분하는 방법은
     예약어들을 모두 외우거나 '파란색' 으로 표시된 것들은 모두 예약어라 볼 수
     있습니다   */

  return 0;
}
```

  이 안에 모든 내용이 들어 있습니다. 변수의 이름은 반드시

* 숫자가 앞에 위치하면 안됩니다. 그러나 중간이나 뒤는 괜찮습니다.

* 변수명은 오직 영어, 숫자, `_` 로 만 구성되어 있어야 합니다. \sidenote{사실 비주얼 스튜디오와 같은 컴파일러에서는 유니코드(한글 포함)로 변수 이름을 지어도 괜찮지만 관습상 코드는 모두 영어로 작성하는 것이 맞습니다.}

* 변수의 이름에 띄어쓰기가 있으면 안됩니다.

* 변수의 이름이 C 언어 예약어 이면 안됩니다. 보통 예약어를 쓰면 에디터에서 다른 색깔로 표시되어 예약어를 썼는지 안썼는지 알 수 있습니다.

 또한 C 언어는 대소문자를 구분합니다(이를 영어로 case sensitive 하다고 합니다). 따라서, `VARiable` 과 `Variable` 은 다른 변수 입니다. 왠지, 조건이 많아 변수명을 지을 때, 까다로울 것 같지만 그냥 평범하게 짓다보면 예약어와 겹칠일 도 없고, 숫자가 앞에 오는 경우도 별로 없습니다.

자, 이제 우리는 C 언어에서 중요한 부분인 변수에 대해서 알아보았습니다. 현재 우리는 수를 다루는 변수들만 다루었지만, 다음 강좌에서는 변수에 대한 산술 연산과, 문자를 다루는 변수에 대해 알아보도록 하겠습니다.

##@ chewing-c-end
Link :  6
2009-04-17 19:21
----------------
title : 씹어먹는 C 언어 - <2 - 1. C 언어 본격 맛보기>
cat_title : 2 - 1. C 언어가 본격 맛보기
next_page : 19
publish_date : 2009-04-17 19:21
--------------


이번 강좌에서는 아래와 같은 내용을 배우게 됩니다.

* `Hello, World!` 빠삭하게 분석
* 주석(Comment)의 사용


![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분. [저번 강의](http://itguru.tistory.com/entry/%EC%94%B9%EC%96%B4%EB%A8%B9%EB%8A%94-C-%EC%96%B8%EC%96%B4-1-C-%EC%96%B8%EC%96%B4%EA%B0%80-%EB%AD%90%EC%95%BC)에서의 희열을 아직도 느끼시나요? 방금 자신의 손으로 최초의 프로그램 - `Hello, World!` 를 만들었다는 사실을 말이죠. 하지만 자신이 프로그램을 만들었다는 사실을 친구들에게 자랑하기 전에, 그 프로그램이 어떻게 동작하는지 살펴보도록 합시다.

### 도대체 뭔일이 있던거지? 



### Hello, World 프로그램 분석하기

  일단, 여러분이 지난번에 쓰셨던 코드는 다음과 같습니다. 사실, 지난번에는 이 코드가 뭔 내용인가 하면서 쓰셨겠죠. 다만 한 가지 눈치 챘을 법한 부분은 바로 큰 따옴표로 닫혀 있는 부분의 "Hello, World!" 가 프로그램에 출력된다는 점입니다. 한 번 다른 문장으로 바꿔서 과연 그 문장이 출력되는지 확인해보는 것도 좋습니다. 

그렇다면 우리가 작성한 코드가 어떠한 의미를 가지는지 살펴보도록 하겠습니다. 

```cpp-formatted
#include <stdio.h>
int main() {
  printf("Hello, World! \n");
  return 0;
}
```

  일단 위 프로그램의 첫 줄 부터 봅시다.

```cpp-formatted
#include <stdio.h>
```


영어를 잘 하시는 분은 `include` 의 뜻이 '포함하다' 라는 것임을 알 수 있습니다. 그렇다면 위 프로그램은 무엇을 포함하고자 하는 것일까요? 바로 옆의 `stdio.h` 라는 파일을 포함하고자 하는 것입니다. 그렇다면 우리는 왜, `stdio.h` 라는 파일을 이 프로그램에 포함 시켰을 까요? 그 이유는 아래에서 설명하도록 하겠습니다.

  그 다음 부분을 살펴 봅시다.

```cpp-formatted
int main()
```

이번에는 조금 생소한 단어군요. `main` 은 그렇다 쳐도, `int` 는 또 뭘까요? RPG 게임을 많이 하신 분들이라면 지능을 뜻하는 intelligence 의 약자라고 생각하실 수 도 있지만,  사실 이는 **정수** 를 뜻하는` integer` 의 약자입니다. 또한 그 옆의 `main` 은 함수를 말하는 것이죠. 사실 이 문장의 뜻은 '정수 형을 반환하는 메인 함수' 라는 뜻이며,대부분의 C 프로그램은 위 함수로 부터 시작됩니다. 자세한 사실은 나중에 알아봅시다.

```cpp-formatted
{
```

그 다음 문장은 참으로 간단하네요. 중괄호 입니다. 여기서 중괄호는 `main` 함수의 시작을 알리게 됩니다. 즉, 중괄호로 묶인 부분은 '여기는 `main` 함수 꺼야' 라는 것을 나타냅니다. C 언어에서는 `main` 함수 뿐만이 아니라 어떠한 문장도 여는 중괄호가 있다면 반드시 이에 대응되는 닫는 중괄호(`}`)가 와야 합니다. 여기서도 마찬가지로, 마지막 문장에서 닫는 중괄호가 와있네요.

```cpp-formatted
printf("Hello, World! \n");
```

이제, 위 프로그램에서 가장 핵심이라 볼 수 있는 부분인 `printf` 를 살펴 봅시다. `printf` 는 화면에 괄호안의 내용을 출력할 수 있게 해주는 함수 입니다. 위의 경우, 괄호 안에 있는 `Hello, World!` 가 화면에 출력되었습니다.

그런데, 도대체 위 함수가 어떻게 해서 화면에 글자를 출력하는 것일까요? 사실, 화면에 글자를 출력하는 것은 쉬운 일 일 것 같지만, 매우 복잡한 과정을 거치는 것입니다. 왜냐하면, 일단 운영체제에 자신이 화면에 글자를 뿌려야 한다는 메시지를 보내야 하고, 또 운영체제는 하드웨어 (모니터) 에 이를 뿌린다는(출력한다는) 것을 이야기 해 주어야 하기 때문이죠.

하지만 우리가 위 짧은 문장을 화면에 표현하기 위해 위 모든 내용을 작성해야 한다는 것은 상당히 불합리해 보입니다. 따라서 우리는 위 모든 내용을 포함하고 있는 파일을 필요로 하는데, 그 것이 바로 앞서 이야기한 `stdio.h` 입니다. **(studio 가 아닙니다!)**

`stdio` 는 *STandard Input Output header* 의 약자로, **표준 입출력 헤더** 입니다. 이 파일에는 입출력, 즉 화면에 출력하고, 키보드로 부터 입력을 받아들이는 것을 담당하고 있습니다. 물론, 이 파일 하나에 모든 내용이 다 구현 되어 있는 것은 아닙니다. 자세한 내용은 나중에 배우게 됩니다.

그런데, 한 가지 이상한 점이 있습니다. 큰 따옴표 안의 내용이 모두 출력되는데, 왜 마지막의 `\n` 은 출력되지 않은 것일까요? 그렇다면 한 번 여러분들 께서 `\n` 을 지워 보고 다시 프로그램을 실행해 보세요. 아마 다음과 같이 나올 것 입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F207B991A49E9735F64CC19)

지난번 하고 차이점이 보이세요? 분명히 지난 번에는 *Press anykey to continue* 가 한 줄 개행되어 나타났는데 이번에는 연이어 나타났습니다. (윈도우 한글판 사용자의 경우 '아무키나 누르세요' 가 나타날 것입니다)

아하, 알겠습니다. 바로 `\n` 은 키보드 상의 엔터, 즉 개행 문자 였던 것입니다. (참고로 `\` 를 `Escape character` 라고 합니다)

참고적으로 알아야 할 사실은 우리나라 키보드의 경우 `\` 로 나타나지만 외국 대부분의 키보드에는 `\` 대신에 역슬래시(＼) 를 사용합니다. 따라서, 보통 C 언어 서적을 보면 `＼n` 이라 나타난 것이 있는데 이는 `\n` 과 똑같은 것입니다.

마지막으로 중요한 점은, 모든 문장이 끝나는 부분에 세미콜론(;)을 찍어 주어야 된다는 것입니다. 

물론, 함수의 선언 부분 (즉, `int main()` ) 뒤에나 헤더파일 선언 부분 (`#include <stdio.h>`) 뒤에는 `;` 을 붙이면 안되지만, 위와 같이 `printf(.....)` 나, 아래 줄의 `return 0` 와 같은 문장들에게는 꼭 끝에 세미콜론을 붙여아합니다. 만약 붙이지 않는다면 이전 강의에서 보았던 오류들이 나타나게 됩니다.

```cpp-formatted
return 0;
```

영어로 읽어 보면 대충 뜻을 짐작하셨겠지만, 0 을 **반환(return)**한다는 뜻 입니다. 0 을 왜 반환할까요? 그리고 그 것을 반환한다면 '누구' 한테 반환하는 것인가요? 쉽게 말해 운영체제에게로 반환합니다. (정확히 말하면 이 프로그램을 호출한 프로그램) 그런데 왜 하필이면 0 일까요? 1 이면 안되고 왜 2 이면 안되죠.

그렇다면 한 번 1 이나 다른 원하는 숫자를 반환하도록 해보세요. 결과는 똑같습니다. 그런데 왜 굳이 0 을 반환하는 것일까요?

사실은 0 을 반환한다는 것은 컴퓨터에게 *프로그램이 무사히 종료되었음* 을 알리는 것이죠. 반면에 1 을 반환한다면 컴퓨터에게 *프로그램이 무사히 종료되지 않았어요 - 오류가 발생했어요.* 를 알리는 것입니다. 

```cpp-formatted
}
```

마지막으로 이렇게 꼭 중괄호로 닫아주어야지, 그렇지 않을 경우 파일의 끝이 없다는 오류가 발생하게 됩니다. 와우! 이쯤 되면 위 프로그램을 빠삭하게 분석해 보았다고 할 수 있습니다.

### 주석(Comment) 넣기

마지막으로 모든 프로그래밍 언어에 기본으로 있는 기능이자, 그 만큼 중요한 기능인 주석 넣기에 대해 알아봅시다.

주석이라 하면, 코멘트, 즉 **자신의 코드에 대해 설명을 해주는 것**입니다. 아마 위의 대여섯 줄 짜리 코드에 뭐가 설명할 필요가 있겠어? 라고 생각할 수 있지만 실제로 '쓸만한' 프로그램을 만들게 되면 코드의 길이가 수천줄을 넘어가는 것은 예삿일입니다. 물론 그런 파일들이 여러개 모여서 프로그램을 만들게 되는 것이지요.

그렇게 된다면 코멘트 없이는 이 코드가 도대체 무슨 역할을 하는지도 잘 모르고, 남이 쓴 코드가 어떤일을 하고, 어떻게 돌아가는지 이해가 잘 안되는 경우가 많습니다. 더욱 심각한 사실은 자신이 쓴 코드도 못알아 보는 경우가 있다는 것입니다. 이처럼, 이런 기분나쁜 일을 미연에 방지하기 위해 이 코드가 무슨 역할을 하고 어떻게 동작되는지 간단하게 나마 설명해 주는 것이 필요하겠죠. 그런 것을 바로 주석 이라 합니다.

우리가 코드를 이해하기 위해 필요한 것이지, 컴퓨터에는 아무런 도움이 되지 않는 것이므로 컴파일러는 이 주석을 완전히 무시해 버립니다. 마치 우리만이 볼 수 있는 것 처럼 말이죠. 그렇기 때문에 주석에 무슨 짓을 해도 상관이 없습니다.

기본적으로 C 언어 에서는 두 가지 형태의 주석을 지원합니다.

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1728BF0C49EE1719061C9D)

마치 컴파일러가 철저히 무시한다는 것을 반영하기라도 한 것인지, 주석은 초록색으로 표시됩니다. 보통 한 줄에 쓸 수 있는 주석은 `//` 로 나타내고, 주석이 조금 길어저 여러 줄에 걸쳐 표시하려면 `/*` 와 `*/` 를 이용합니다. 한 번, 위 `Hello, World!` 프로그램에 자기 나름대로 주석을 넣어 설명을 해보세요.

##@ chewing-c-end
Link :  5
2009-04-16 00:40
----------------
title : 씹어먹는 C 언어 - <1. C 언어가 뭐야?>
next_page : 6
cat_title : 1. C 언어가 뭐야?
updated_date : 09/12/2018
publish_date : 2009-04-16 00:40
--------------



저의 강의는 미엘리키 님의 C++ 필기 노트를 보고 깊은 감명을 받고 시작한 것입니다.
이번 강좌에서는 다음과 같은 내용을 배우게 됩니다.

* 컴파일러란 무엇인가?
* 개발 툴 (Visual Studio 2008 Express Edition) 설치
* 내 생애 최초의 프로그램

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분! 씹어먹는 C 언어 강좌에 오신 것을 환영합니다.

### 왜 C 언어를 배워야 하는가?

아마도 이 강좌를 보고 있는 여러분들은 분명 누군가에 의해 “너는 C 언어를 배워야만 해!” 해서 들어 오셨을 것입니다. 하지만 많은 경우 도대체 왜 굳이 C 언어를 배워야 하는지 알려주지는 않았을 것입니다. 저 또한 C 언어를 처음 공부한 이유가 누가 배워야 한다고 해서 배운 것이지, 제가 필요성을 느껴서 배운 것도 아닙니다. 

여러분이 프로그래밍을 시작한 계기는 분명 여러가지가 있을 것입니다. 저는 처음 프로그래밍을 배운 계기가 게임을 만들고 싶어서였습니다. 어떤 분들은 멋진 웹사이트를 만들고 싶었을 것이고, 또 어떤 분들은 안드로이드 앱을 만들고 싶어서 였을 것입니다. 그런데 이러한 것들을 하기 위해 굳이 C 언어를 알아야 할까요?

사실 아닙니다. 요즘에 게임을 만드는 가장 핫한 플랫폼인 유니티는 보통 C# 으로 프로그래밍 하고, 웹사이트의 경우 대개 파이썬, PHP, 자바스크립트 등등으로 만듭니다 (여기서 말하는 웹사이트는 백엔드).  또 안드로이드 앱은 자바 (혹은 코틀린), iOS 앱은 스위프트나 Objective-C 로 만듭니다. 여기 어디에도 C 는 쓰지 않습니다. **아마 이러한 것들을 지금 빨리 만들고 싶어서 손이 근질근질 거리시는 분들은 이 부분에서 뒤로가기를 누르셔도 좋습니다.**

그렇다면 왜 사람들은 C 언어를 배우라고 할까요? 도대체 왜 학교에선 다른 언어들 놔두고 C 언어를 가르칠까요? 제가 생각하는 이유는 다음과 같습니다.

* 만약 적당히 잘하는 프로그래머가 목표라면, 굳이 컴퓨터 내부가 어떻게 돌아가는지 몰라도 괜찮습니다. 하지만 좋은 프로그래머가 되려면, **컴퓨터의 내부 원리를 아는 것이 필수적**입니다. 
만약에 C 언어를 배우게 된다면, 컴퓨터 내부 원리를 더 쉽게 이해할 수 있습니다. 

* C 언어를 배운다면, 다른 언어를 더 쉽게 습득할 수 있습니다. 많은 언어들이 C 언어에서 파생되어서 생겨났습니다 (위에서 나열한 C#, Objective-C, 그리고 가장 유명한 C++ 까지 모두 이름에서 알 수 있듯이 C 의 영향을 많이 받은 언어들 입니다.) 따라서 이런 언어들을 배우는데 많은 도움이 됩니다.

* 이미 엄청나게 많은 코드들이 C 언어로 작성되어 있습니다. 따라서, 어느 정도 수준 이상에 도달하게 된다면 C 언어를 결코 피하실 수 없을 것입니다.

* 마지막으로, C 언어는 크기가 매우 작습니다. 즉 배워야 할 내용이 다른 언어에 비해 매우 적습니다! (C 언어의 최고의 교과서라 불리는 *The C Programming Language* 라는 책은 200여 페이지 밖에 되지 않습니다. 반면에 C++ 에서 비슷한 역할을 하는 책인 *The C++ Programming Language* 는 1300페이지가 넘습니다.) 물론, '배워야 할 내용이 적다' 와 '쉽다' 는 차이가 있으니 이 점 알아두시기 바랍니다 :)


이러한 연유에서 저는 여러분들이 C 언어를 배워야 하겠다라고 마음 먹기 매우 잘한 일이라 생각합니다. 특히 C 언어를 배우는데 있어서 제 강좌인 씹어먹은 C 언어를 선택한 것 역시 훌륭한 선택이라 자부합니다.

### 저는 누구인가요?


이 블로그의 주인 Psi 는 누구일까요? 저 역시 C 언어를 배우고 있으며 전문가들 보다도 훨씬 못합니다. 전문적인 강의를 원했던 사람은 여기서 다시 살포시 뒤로가기를 눌러도 됩니다. (아마 `80%` 이상이 누를 것이라 추정) 하지만 제가 유일하게 잘 할 수 있다고 자부하는 것은어려워만 보이던 C 언어의 기초 부분을 최대한 쉽게 설명하는 것입니다.  ( [저에 대한 자세한 프로필은 여기를 참조해주세요](http://itguru.tistory.com/notice/107))

앞으로 저와 함께 C 언어의 세계로 여정을 떠날 사람들은 준비가 되었습니까? 그럼 모두 스크롤을 내려주세요!

### 여정에 필요한 준비물

**C 언어**를 배우기 위해선 다음과 같은 준비물이 필요합니다.

1. 컴퓨터
2. 머리
3. 노오력
4. 컴파일러.

1,2,3 번은 여러분들 께서 충분히 준비할 수 있다고 생각합니다.

그런데 4번, 컴파일러는 뭐지?

### 컴파일러?

컴파일러, 영어로는 `Compiler` 라고 씁니다. 말그대로 컴파일(Compile) 해주는 것(-r) 입니다. 그렇다면 컴파일은 도대체 무엇일까요?

아마 여러분은 컴퓨터는 0 과 1 밖에 모르는 바보(?) 라고 들었을 것입니다. 맞습니다. 컴퓨터의 두뇌라고 할 수 있는 `CPU` 에서는 수 많은 0 과 1 들이 이리저리 돌아다니고 있을 것입니다. 만약에 이런 컴퓨터에 명령을 내리려면 오직 0 과 1 로만 써야겠지요? 010101010111 이런식으로 말입니다.

![에니악 caption=C 언어는 노오력으로 배울 수 있지만, 이건 아마 노오오오오오력이 필요햇을 것입니다!](/img/eniac.jpg)

아마 옛날에는 실제로 전선을 이리저리 연결해가며 비슷한 방식으로 명령을 내렸을 것입니다.

만약 우리가 프로그래밍을 0 과 1 로 만 한다면 얼마나 끔찍할지 생각해보세요. 만약 이런 세상이였다면 프로그래머 연봉이 평균 10억은 되었을 것입니다. 하지만 훌륭한 컴퓨터 과학자들 덕분에, 0 과 1 대신에, 그나마 사람이 알아들을 수 있는 '언어'로 프로그래밍을 할 수 있게 하였습니다. 0 과 1 로 표현되는 명령을, 사람들이 그나마 알아듣기 쉽게 표현하게 말입니다. 예를 들어서 1 + 1 을 하기 위한 명령을 컴퓨터에 내린다면

```info
01011101010101
```

이 되겠지만 컴퓨터 언어를 통해 간단히 

```info
1 + 1
```

이렇게 표현할 수 있을 것입니다. 문제는 컴퓨터가 인간의 언어를 도무지 알아 들을 수 없으니, 컴퓨터가 이해할 수 있는 0..1 들로 바꿔주는 녀석이 필요합니다. 이렇게, 사람들이 사용하는 '프로그래밍 언어'와 컴퓨터가 이해하는 '기계어' 사이 다리 역할을 수행하는 것이 바로 **컴파일러** 입니다. 

좋은 소식은 쉽게 컴파일러들을 구할 수 있다는 점입니다. 유명한 컴파일러로는 무료로 배포되는 `gcc` 와 `clang` 를 들 수 있지만 사용법이 초보자들에게는 약간 복잡합니다. 대신에, 저희는 마이크로소프트에서 무료로 배포하는 `Visual C++ 2017 Community` 를 사용할 것입니다. 

더 좋은 소식은 `Visual Studio Community 2017` 을 다운받으면 아예 위 컴파일러 뿐만이 아니라  사용자들이 프로그래밍 하기 편하게 여러가지 프로그램들이 딸려 옵니다. 땡큐죠!

비주얼 스튜디오 커뮤니티 2017 은

 [https://www.visualstudio.com/vs/community/](https://www.visualstudio.com/vs/community/)

에서 받으실 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2676893E58DC5A6402106D)

위와 같이 사이트에 들어가서 `Download VS Community 2017` 을 누르시면 됩니다. (제가 지금 미국에서 있어서 영어로 뜨지만 아마 한국에 계신 분들은 한국말로 뜰 것입니다 :)



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2763604A58DC5A642C5115)


다운로드 된 실행파일을 실행하면 위와 같이 뜹니다. `Continue` 를 눌러주세요


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2377554B58DC5A652B7F90)



이제 어떠한 것들을 설치할 지 선택할 수 있는데, 일단 여러분은 `C/C++` 을 배우는 것이 목적이므로 화면에 `Desktop development with C++` 만 선택해 주시면 됩니다. 혹시 내가 나중에 C# 이나 기타 등등으로 더 많은 코딩을 하고 싶다 그러시는 분들은 다른 것들을 선택해서 설치해주셔도 상관 없지만, 설치 용량이 엄청 커지게 됩니다. 저거 하나만 선택했는데에도 벌써 `5.61 GB` 네요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F27334D3C58DC5A6531172A)



그럼 이제 알아서 필요한 것들을 다운 받아서 설치하게 됩니다. 인터넷 상황에서 따라서 30분에서 1시간 정도 기다려야 합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F2758FB3858DC67FF0302F0)



설치가 다 되었으면 컴퓨터를 재시작 해야 합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27716B4C58DC67FE24EA96)



뭔가 가입하라고 나오는데 그냥 나중에 한다고 하고 무시하면 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F2313A24658DC67FE212176)





그 다음으로 어떤 테마를 고를지 정하면 됩니다. 저의 경우 그냥 디폴트인 파란색 바탕을 사용하는데, 사람들에 따라서 어두운 테마를 좋아하는 경우도 있습니다 :)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F240BEE3958DC67FE073364)



이제 메인 화면에서 새로운 프로젝트를 만들어봅시다.


간단히 `Ctrl + Shift + N` 을 누르면 새 프로젝트를 만드는 창을 띄울 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2437B54058DC67FE25378A)



다음으로 프로젝트 선택 화면에서 `Win32 Console Application (Win32 콘솔 어플리케이션)` 을 선택합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2729344C58DCF43435069B)



'다음' 을 눌러줍니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2528FF3558DCF4342BD1FB)



빈 프로젝트에 체크해 주시면 프로젝트 생성이 완료됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F2325A94F58DCF4351586CA)



이제 프로젝트에 소스 파일을 추가해야 합니다.


기본적으로 왼쪽에 보시면 솔루션 탐색기에서 소스 파일을 쉽게 추가할 수 있는데, 솔루션 탐색기가 안보인다면, `Ctrl + Alt + L` 을 눌러서 띄울 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F2445D24D58DCF435315473)



이제 C 프로그래밍을 하고 싶다면 이름에 `Hello.c` 라고 적습니다. 그럼 이제 왼쪽에 만들어진 Hello.c 파일을 클릭합니다.


### 내 생애 첫 프로그램

드디어 여러분 인생 첫 프로그램을 만들 시간이 다가왔습니다. 에디터 화면에 다음과 같이 입력합니다.

```cpp-formatted
#include <stdio.h>
int main() {
  printf("Hello, World! \n");
  return 0;
}
```

한 가지 당부 드리고 싶은 말은, 반드시 손으로 직접 입력해 보기 바랍니다. 그냥 `Ctrl - C, Ctrl - V` 하는 것은 시간은 절약되지만 결국 나중에 머리에 남는 것은 없게 됩니다.

이제, 위 내용을 다 입력하였으면 `F7` 를 눌러 주어서, 또는 상단의 빌드 → 솔루션 빌드를 눌러서 컴파일 합니다. 만약 위 내용을 잘 써서 성공적으로 빌드 되었다면 아래 아래와 같은 화면을 보게 될 것입니다.

![컴파일 하는 중입니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1276C30F49E755BB9051F1)

그런데, 간혹 가다 어떤 사람들은 오류가 뜨는 사람들도 있는데, 대표적으로
```warning
error C2143: 구문 오류 : ';'이(가) 'return' 앞에 없습니다
```

라 던지,

```warning
error C2001: 상수에 줄 바꿈 문자가 있습니다.
error C2143: 구문 오류 : ')'이(가) 'return' 앞에 없습니다.
```

와 같은 오류를 보게 되는 사람들이 있습니다.

첫 번째의 경우, `printf("Hello, World! \n")` 다음에 세미 콜론 (`;`) 을 쓰지 않아서 나타나는 경우이고, 두 번째의 오류는 `printf` 안에 큰 따옴표로 제대로 닫지 않았을 경우입니다. 위에서 언급한 오류가 아니더라도, 어디선가 오류가 발생하였따면  십중 팔구 위의 소스 코드를 잘못 쳤기 때문 이므로 다시 한 번 신중히 쳐보거나, 그래도 안되면 복사해 보시기 바랍니다.

이제, 드디어 이렇게 완성된 프로그램을 실행할 시간이 다가왔습니다. `Ctrl + F5` 를 눌러서 프로그램을 실행해 봅시다.

![Hello, World! 가 출력되었습니다. ](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1371751449E85179051D6E)

만세! 현재 저는 영문판 `XP` 를 쓰고 있어서 `Hello, World!` 밑에 `Press any key to continue` 가 나오겠지만(참고로 이 강좌는 2008년에 제작되었습니다) 한글판 사용자 분들은 '아무 키나 누르세요' 가 나올 것입니다. 어쨋든, 위의 `Hello, World!` 가 출력되었으면대 성 공 입니다.

여러분은 지금, 여러분 최초의 프로그램을 만들게 된 것입니다!

다음 강좌에서는, 위 프로그램이 도대체 어떻게 동작하는 것인지에 대해 알아보도록 합시다.

##@ chewing-c-end
Link :  87
2010-07-16 21:23
----------------
title : 씹어먹는 C 언어 - <18 - 1. 파일 뽀개기 (헤더파일과 #include) >
cat_title : 18 - 1. 파일 뽀개기 (헤더파일과 #include)
next_page : 88
publish_date : 2010-07-16 21:23
--------------


이번 강좌에서는

* 모듈화 프로그래밍 (파일 나누기)

* `#include` 전처리기에 대한 이해

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분. 저도 강좌를 쓰는 것이 참으로 오래간만 입니다. 현재 저는 강좌를 모두 모두 모아 하나의 pdf 파일로 만드려고 노력중입니다. 이를 위해 `Latex` 를 사용하고 있는데 한국 `Latex` 커뮤니티 (KTUG) 분들께서 훌륭하게 만들어주신 `kotex` 덕분에 수월하게 파일 제작이 가능합니다. 아무튼 감사하다는 말씀을 드리며 강좌를 시작해 나가보도록 하겠습니다.

현재까지 여러분은 모든 소스 코드를 하나의 소스 파일에서 작성하였습니다. 사실 이는 큰 문제가 아니였습니다. 왜냐하면 우리가 여태 까지 만들었던 프로그램의 총 소스 길이는 그다지 길지 않았고 또 나 혼자 만들기 때문에 하나의 파일에 모조리 작성해도 상관이 없었습니다. 하지만 여러분이 프로그래머가 되어서 회사에서 프로그래밍을 한다면 소스의 길이도 수천~ 수만줄에 이르고, 여러 사람들이 만들기 때문에 파일을 여러개로 나누어야 할 필요성이 있습니다. 물론 파일을 나눌 때 에는 비슷한 작업을 하는 것 끼리 나누는 것이 좋겠죠.

```cpp-formatted
/* 평범한 문장 */
#include <stdio.h>
char compare(char *str1, char *str2);
int main() {
  char str1[20];
  char str2[20];

  scanf("%s", str1);
  scanf("%s", str2);

  if (compare(str1, str2)) {
    printf("%s 와 %s 는 같은 문장 입니다. \n", str1, str2);
  } else {
    printf("%s 와 %s 는 다른 문장 입니다. \n", str1, str2);
  }
  return 0;
}

char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```


성공적으로 컴파일 하였다면



![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F130E31144C40527F9208AF)


와 같이 나옵니다.

만일 같은 두 문장을 사용하였다면 같다는 메세지가 뜨겠지요. 위 소스 코드는 아주아주 쉬운 내용으로 여태까지 내용을 잘 이수하였다면 잘 이해하실 수 있을 것입니다. 다만,

```cpp-formatted
if (compare(str1, str2)) ```


이 부분에서 살짝 갸우뚱 하시는 분들이 있으실 텐데 우리가 만든 `compare` 함수는 두 문자열이 같으면 `1,` 다르면 0 을 리턴합니다. 그런데 `if` 문의 경우 괄호 안의 값이 0 이면 '거짓' 으로, 0 이 아니면 '참' 으로 판단하기 때문에 (이는 이전 강좌에서 이야기 했던 바 입니다. 기억이 안나면 [http://itguru.tistory.com/10](http://itguru.tistory.com/10) 를 보세요) 우리가 원하는 결과를 얻을 수 있었던 것이지요.

그렇다면 이번에는 이 강좌의 주제에 맞게 파일을 분할해봅시다. `compare` 함수는 상당히 다른 일을 하고 있기 때문에 굳이 `main` 함수와 같은 파일에 둘 필요가 없습니다. 따라서 다른 파일에 만들어 보겠습니다.



###  파일 나누기

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F190193344C4053CBBD99BB)
먼저 위의 그림과 같이 오른쪽 파일 목록이 나와 있는 부분에서 '소스 파일' 폴더를 클릭한 후 마우스 오른쪽 클릭을 한 후, '새 항목' 을 위와 같이 누릅니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F172A08344C4053CC2CB431)

그러면 위와 같이 새 항목을 추가할 수 있는 화면이 뜨는데 우리는 'C++ 파일(.cpp)' 을 선택하고, 이름에 `str` 을 적습니다. `str` 을 적은 이유는 우리가 만든 `compare` 함수는 문자열을 처리하므로 이에 맞게 `str` 이라는 이름을 붙여 주었습니다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F160643374C40544BC789F8)
하지만 우리가 하려는 것이 C 언어 이지 C++ 이 아니므로 파일 이름을 `str.c` 로 변경해줍니다. 이는 파일을 클릭한 후 `F2` 를 누르면 파일이름을 변경할 수 있습니다. (또는 마우스 오른쪽 클릭 후 이름 바꾸기를 누른다)


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F112028344C4053CC733B8F)

이제, `test.c` (저의 기존 소스를 보관했던 파일 명 입니다. 여러분의 경우 다를 수 있습니다.) 에 쓰여 있던 기존의 `compare` 함수 소스를 잘라옵니다. 즉, `test.c` 에 있던 `compare` 함수 소스는 사라지고 `str.c` 에 `compare` 함수 소스를 넣는 것입니다.

위 작업이 끝나게 된다면 각 파일에는 다음과 같이 소스가 들어가 있을 것입니다.

```cpp-formatted
/*
test.c
여러분과 파일 이름은 다를 수 있습니다.
*/
#include <stdio.h>
char compare(char *str1, char *str2);
int main() {
  char str1[20];
  char str2[20];

  scanf("%s", str1);
  scanf("%s", str2);

  if (compare(str1, str2)) {
    printf("%s 와 %s 는 같은 문장 입니다. \n", str1, str2);
  } else {
    printf("%s 와 %s 는 다른 문장 입니다. \n", str1, str2);
  }
  return 0;
}
```


```cpp-formatted
/*
str.c
*/

char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F130E31144C40527F9208AF)

아까와 동일한 결과를 얻을 수 있었습니다.

일단 위 프로그램이 어떻게 작동하는지 살펴 봅시다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F13697A0E4C406E8688A9DF)


아마 예전에 배워서 까먹었을 가능성이 있는데 우리가 실행 파일을 만들기 위해서는 먼저 C 코드를 컴퓨터가 이해할 수 있는 언어로 바꿔주는 **컴파일(compile)** 이라는 과정이 진행됩니다. 이는 단일 소스 코드 전체를 어셈블리어 (기계어와 1 : 1 대응이 되어 있음) 로 변환해 줍니다 (이 때, 목적코드라 불리는 확장자가 `.o` 인 파일이 생성됩니다). 이 과정이 끝나게 되면 **링킹(linking)** 이라는 과정이 진행되는데 말그대로 각기 다른 파일에 위치한 소스 코드들을 한데 엮어서 하나의 실행 파일로 만들어지는 과정이라 생각하시면 됩니다.

링킹 과정에서 특정한 소스 파일에 있는 함수들이 어디어디에 있는지 찾는 과정을 거치게 되는데 예를 들어서 `test.c` 의 경우 `compare` 함수가 어디있는지 찾게 됩니다. (눈치가 빠른 독자라면 `printf` 함수 역시 찾아야 함을 알 수 있는데 이에 대한 설명은 나중에 하겠습니다)

우리의 예제의 경우 `compare` 함수는 `str.c` 에 있기 때문에 **링커**(링킹을 해주는 프로그램) 는 'test.c 에서 `compare` 함수를 호출하는 경우 `str.c` 에서 찾아라' 정도로 처리해 주게 됩니다. 덕분에 우리는 `test.c` 에서 `compare` 함수를 호출하더라도 `str.c` 의 `compare` 함수를 이용할 수 있게 되는 것이지요.

만일 `test.c` 에서

```cpp-formatted
char compare(char *str1, char *str2);
```


부분을 지워버리면 어떨까요? 이렇게 된다면 컴파일러는 'main 함수에서 `compare` 함수를 호출하였는데, 도대체 `compare` 함수는 어떻게 생긴 모양이야!' 가 되어 컴파일 시에 오류가 발생하게 됩니다. 물론 링커의 경우도 `compare` 함수의 정확한 모양이 무엇인지 알 수 없으므로 오류가 발생하게 되죠.

따라서 이렇게 언제나 함수의 선언을 명시해 주는 것은 매우 중요한 일입니다.

하지만 `compare` 라는 함수 말고도 `copy` 라는 함수가 `str.c` 에 추가되었습니다. 이 함수는 두 문자열을 복사해주는 역할을 합니다. `copy` 라는 함수를 `test.c` 에서 이용하기 위해선 역시 `copy` 함수의 원형을 써주어야 합니다. 이는 상당히 귀찮은 일이지요. 뿐만 아니라 다른 파일에서도 `compare` 함수와 `copy` 함수를 이용할 수 있는데 이 파일 역시 이 두 함수의 원형을 써주어야 합니다.

이렇게 귀찮은 작업을 막기 위해 C 에서는 아주 놀라운 해결책을 제시하였는데 바로 **헤더파일 (header file)** 을 이용하는 것입니다. 헤더파일은 다음과 같은 방법으로 만들 수 있습니다.



###  헤더 파일

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F160941104C4069157ABB63)
먼저 기존에 `str.c` 파일을 추가했을 때 했던 것 처럼 하되 이번에는 헤더파일 폴더에 파일을 추가해보도록 합시다.


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F206DC2104C4069211A9828)

헤더파일을 추가하는 것이므로 '헤더파일' 을 선택한 후, 이름에 `str` 을 적습니다.



![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1367AB104C40696025CB87)

그리고 헤더파일에는 위와 같이 내용을 기록합니다. 그 후, 각 소스 코드를 다음과 같이 수정해줍니다.

```cpp-formatted
/* test.c */
#include <stdio.h>
#include "str.h"
int main() {
  char str1[20];
  char str2[20];

  scanf("%s", str1);
  scanf("%s", str2);

  if (compare(str1, str2)) {
    printf("%s 와 %s 는 같은 문장 입니다. \n", str1, str2);
  } else {
    printf("%s 와 %s 는 다른 문장 입니다. \n", str1, str2);
  }
  return 0;
}
```




```cpp-formatted
/* str.c */
#include "str.h"

char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```



```cpp-formatted
/* str.h */
char compare(char *str1, char *str2);
```



  성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F15681B1C4C406A05628C04)

역시 위와 같이 잘 작동하고 있음을 알 수 있습니다.

먼저 `test.c` 부터 살펴봅시다.

```cpp-formatted
#include <stdio.h>
#include "str.h"
```

`#include` 와 같은 명령들은 **전처리기(Preprocessor)** 명령이라고 부르는데 이러한 명령들의 특징은 컴파일 이전에 실행된다는 점 입니다.이 명령은 우리가 지칭하는 파일의 내용을 정확히 `100%` 복사해서 붙여 넣는다는 점입니다. 따라서 `#include "str.h"` 라는 명령은 `str.h` 에 있었던 내용, 즉 `char compare(char *str1, char *str2);` 로 컴파일이 시작하기 전에 바뀌어 버립니다.

그렇다면 `#include <stdio.h>` 는 어떨까요? 이 역시 똑같습니다. `stdio.h` 에 써있는 내용들이 정확히 복사되어 컴파일 이전에 코드에 붙어버립니다. 그런데 한 가지 이상한 점은 `stdio.h` 는 `<>` 로 감쌌는데, `str.h` 는 왜 " " 로 감쌌을까요? 그 이유는 단순한데, `< >` 로 감싸는 헤더파일은 컴파일러에서 기본으로 지원하는 헤더파일의 경우이고 " " 로 감싸는 헤더파일은 사용자가 직접 제작한 헤더파일의 경우 입니다.

여러분은 `stdio.h` 에 무엇이 써져 있는지 궁금하지 않으세요? 한 번 제가 그 내용을 올려드리겠습니다. 참고로 [여기](https://code.woboq.org/userspace/glibc/libio/stdio.h.html)에서 전체 코드를 보실 수 있습니다.

```cpp-formatted
#ifndef _STDIO_H
#define _STDIO_H 1
#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION
#include <bits/libc-header-start.h>
__BEGIN_DECLS
#define __need_size_t
#define __need_NULL
#include <stddef.h>
#define __need___va_list
#include <bits/types.h>
#include <bits/types/FILE.h>
#include <bits/types/__FILE.h>
#include <bits/types/__fpos64_t.h>
#include <bits/types/__fpos_t.h>
#include <bits/types/struct_FILE.h>
#include <stdarg.h>
#ifdef __USE_GNU
#include <bits/types/cookie_io_functions_t.h>
#endif
#if defined __USE_XOPEN || defined __USE_XOPEN2K8
#ifdef __GNUC__
#ifndef _VA_LIST_DEFINED
typedef __gnuc_va_list va_list;
#define _VA_LIST_DEFINED
#endif
#else
#include <stdarg.h>
#endif
#endif
#if defined __USE_UNIX98 || defined __USE_XOPEN2K
#ifndef __off_t_defined
#ifndef __USE_FILE_OFFSET64
typedef __off_t off_t;
#else
typedef __off64_t off_t;
#endif
#define __off_t_defined
#endif
#if defined __USE_LARGEFILE64 && !defined __off64_t_defined
typedef __off64_t off64_t;
#define __off64_t_defined
#endif
#endif
#ifdef __USE_XOPEN2K8
#ifndef __ssize_t_defined
typedef __ssize_t ssize_t;
#define __ssize_t_defined
#endif
#endif
/* The type of the second argument to `fgetpos' and `fsetpos'.  */
#ifndef __USE_FILE_OFFSET64
typedef __fpos_t fpos_t;
#else
typedef __fpos64_t fpos_t;
#endif
#ifdef __USE_LARGEFILE64
typedef __fpos64_t fpos64_t;
#endif
/* The possibilities for the third argument to `setvbuf'.  */
#define _IOFBF 0 /* Fully buffered.  */
#define _IOLBF 1 /* Line buffered.  */
#define _IONBF 2 /* No buffering.  */
/* Default buffer size.  */
#define BUFSIZ 8192
/* The value returned by fgetc and similar functions to indicate the
   end of the file.  */
#define EOF (-1)
/* The possibilities for the third argument to `fseek'.
   These values should not be changed.  */
#define SEEK_SET 0 /* Seek from beginning of file.  */
#define SEEK_CUR 1 /* Seek from current position.  */
#define SEEK_END 2 /* Seek from end of file.  */
#ifdef __USE_GNU
#define SEEK_DATA 3 /* Seek to next data.  */
#define SEEK_HOLE 4 /* Seek to next hole.  */
#endif
#if defined __USE_MISC || defined __USE_XOPEN
/* Default path prefix for `tempnam' and `tmpnam'.  */
#define P_tmpdir "/tmp"
#endif
/* Get the values:
   L_tmpnam        How long an array of chars must be to be passed to `tmpnam'.
   TMP_MAX        The minimum number of unique filenames generated by tmpnam
                (and tempnam when it uses tmpnam's name space),
                or tempnam (the two are separate).
   L_ctermid        How long an array to pass to `ctermid'.
   L_cuserid        How long an array to pass to `cuserid'.
   FOPEN_MAX        Minimum number of files that can be open at once.
   FILENAME_MAX        Maximum length of a filename.  */
#include <bits/stdio_lim.h>
/* Standard streams.  */
extern FILE *stdin;  /* Standard input stream.  */
extern FILE *stdout; /* Standard output stream.  */
extern FILE *stderr; /* Standard error output stream.  */
/* C89/C99 say they're macros.  Make them happy.  */
#define stdin stdin
#define stdout stdout
#define stderr stderr
/* ... 너무 길어서 생략 ... */
```


만일 헤더 파일이라는 것이 존재하지 않았더라면 우리는 `printf` 함수를 이용하기 위해서 위 모든 내용은 아니지만 적어도 `printf` 함수의 원형을 써주어야 하는데 이는

```cpp-formatted
_Check_return_opt_ _CRTIMP int __cdecl printf(
  _In_z_ _Printf_format_string_ const char* _Format, ...);
```


로 무지하게 복잡합니다. 아무튼, 이렇게 `printf, scanf` 함수와 같이 매 함수를 쓰기 위해서 위 모든 내용을 쓰는 것 대신에 헤더파일 `include` 하나로 간단하게 해결할 수 있습니다.

보통 헤더파일을 만들 때 에는 그 헤더파일에 있는 함수들이 정의되어 있는 소스 파일의 이름을 따서 짓는 것이 보통입니다. 위 경우 `str.h` 에 선언되어 있는 함수들이 모두 `str.c` 에 정의되어 있으므로 헤더파일의 이름을 `str.h` 로 하였습니다. 또한 한 가지 흥미로운 점은 `str.c` 에서도 `str.h` 를 `include` 하고 있다는 점입니다.

이는 다음과 같은 상황을 방지할 수 있습니다.

```info
/* something.c */
int A()
{
    B();
    return 0;
}
int B()
{
    return 1;
}
```


만일 `something.c` 라는 파일에 위와 같은 소스가 있다고 합시다. 이는 `100%` 오류가 발생됩니다. 왜냐하면 `A()` 함수에서 `B()` 를 호출할 때 `B` 가 무엇인지 뭔지 모르므로 오류가 발생하게 되는 것이지요. (이는 함수 단원에서 공부한 한 바 입니다) 다시 말해 `B()` 를 위에 선언 해주어야 합니다. 아래와 같이요.

```info
/* something.c */
int B();
int A()
{
    B();
    return 0;
}
int B()
{
    return 1;
}
```


하지만 헤더파일을 배웠으니 차라리 이렇게 할 바에는 아래와 같이 하는 것이 훨씬 낫을 것이라는 거죠.

```info
/* something.c */
#include "something.h"
int A()
{
    B();
    return 0;
}
int B()
{
    return 1;
}
```


```info
/* something.h*/

int A();
int B();
```


이와 같은 이유로 `str.c` 에서도 (이 경우 꼭 필요는 없었지만) `str.h` 를 `include` 해준 것입니다.

도서 관리 프로그램 리모델링

그렇다면 이번에는 여태까지 쌓은 지식을 바탕으로 이전에 만들었던 도서 관리 프로그램을 파일을 나누어서 깔끔하게 만들어봅시다.

아래는 기존의 소스 입니다.

```cpp-formatted
#include <stdio.h>
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book);

char compare(char *str1, char *str2);
int borrow_book(int *borrowed);
int return_book(int *borrowed);

int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */

  /* 각각 책, 저자, 출판사를 저장할 배열 생성. 책의 최대 개수는 100 권*/
  char book_name[100][30], auth_name[100][30], publ_name[100][30];
  /* 빌렸는지 상태를 표시 */
  int borrowed[100];

  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");

    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);

    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
      add_book(book_name, auth_name, publ_name, borrowed, &num_total_book);
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
      search_book(book_name, auth_name, publ_name, num_total_book);
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
      borrow_book(borrowed);
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
      return_book(borrowed);
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    }
  }

  return 0;
}
/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);

  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);

  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);

  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;

  return 0;
}
/* 책을 검색하는 함수 */
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];

  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);

  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);

  printf("검색 결과 \n");

  if (user_input == 1) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(book_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 2) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(auth_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 3) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(publ_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  }

  return 0;
}
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
int borrow_book(int *borrowed) {
  /* 사용자로 부터 책번호를 받을 변수*/
  int book_num;

  printf("빌릴 책의 번호를 말해주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &book_num);

  if (borrowed[book_num] == 1) {
    printf("이미 대출된 책입니다! \n");
  } else {
    printf("책이 성공적으로 대출되었습니다. \n");
    borrowed[book_num] = 1;
  }

  return 0;
}
int return_book(int *borrowed) {
  /* 반납할 책의 번호 */
  int num_book;

  printf("반납할 책의 번호를 써주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &num_book);

  if (borrowed[num_book] == 0) {
    printf("이미 반납되어 있는 상태입니다\n");
  } else {
    borrowed[num_book] = 0;
    printf("성공적으로 반납되었습니다\n");
  }

  return 0;
}
```

파일들로 나누기 전에 가장 먼저 고려해야 할 사실은 바로 '어떠한 파일들로 나눌 것인가?’ 입니다. 파일을 나눌 때 가장 먼저 살펴보아야 할 점은 각 파일들을 특정한 역할을 가지도록 나누는 것인데 우리의 프로그램의 경우 다음과 같이 나누면 될 것 같습니다.`main` 함수를 가지는 `test.c ,` 도서 관리 함수들을 가지는 `book_function.c,` 그리고 문자열 관리 함수를 가지는 `str.c` 로 나누면 될 것 같습니다. 따라서 `book_function.h` 와 `str.h` 라는 헤더파일도 가지겠네요.
먼저 가장 단순한 `str.c` 부터 봅시다. `str.c` 에는 `compare` 함수가 들어가면 적당할 것 같습니다.

```cpp-formatted
/* str.c */
#include "str.h"
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }
    str1++;
    str2++;
  }
  if (*str2 == '\0') return 1;
  return 0;
}
```

또한 `str.h` 에는 `compare` 함수의 원형이 선언되어 있죠.

```cpp-formatted
/* str.h */
char compare(char *str1, char *str2);
```



그럼 이제, 책들을 처리하는 함수들을 모아놓은 `book_function.c` 를 살펴봅시다. 단순하게 생각해보면 아래와 같이 하면 될 것 같습니다.

```cpp-formatted
#include "book_function.h"
/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);
  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);

  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);
  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;
  return 0;
} /* 책을 검색하는 함수 */
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];
  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);
  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);
  printf("검색 결과 \n");
  if (user_input == 1) {
    /*
  i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을        사용자가 입력한
  검색어와 비교하고 있다.
  */ for (i = 0; i < num_total_book; i++) {
      if (compare(book_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  } else if (user_input == 2) {
    /*
   i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을        사용자가
   입력한 검색어와 비교하고 있다.
   */
    for (i = 0; i < num_total_book; i++) {
      if (compare(auth_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 3) {
    /*
  i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를        사용자가 입력한
  검색어와 비교하고 있다.
  */
    for (i = 0; i < num_total_book; i++) {
      if (compare(publ_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  }
  return 0;
}
int borrow_book(int *borrowed) {
  /* 사용자로 부터 책번호를 받을 변수*/
  int book_num;
  printf("빌릴 책의 번호를 말해주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &book_num);
  if (borrowed[book_num] == 1) {
    printf("이미 대출된 책입니다! \n");
  } else {
    printf("책이 성공적으로 대출되었습니다. \n");
    borrowed[book_num] = 1;
  }
  return 0;
}
int return_book(int *borrowed) {
  /* 반납할 책의 번호 */
  int num_book;
  printf("반납할 책의 번호를 써주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &num_book);
  if (borrowed[num_book] == 0) {
    printf("이미 반납되어 있는 상태입니다\n");
  } else {
    borrowed[num_book] = 0;
    printf("성공적으로 반납되었습니다\n");
  }
  return 0;
}
```



그런데 이렇게 하게 되면 `100%` 오류가 발생하게 됩니다. 왜냐하면 `add_book` 함수의 경우만 보아도 `printf` 함수와 `scanf` 함수를 사용하고 있기 때문이죠. 이 함수들을 사용하기 위해서는 `stdio.h` 를 꼭 `include` 해주어야 합니다. 뿐만 아니라 `search_book` 함수의 경우 `compare` 함수를 호출하고 있는데 이 때문에 역시 `str.h` 를 `include` 해주어야 합니다. 따라서 올바른 `book_function.c` 의 모습은 아래와 같이 되어야 합니다.

```cpp-formatted
/* book_function.c  */
#include <stdio.h>
#include "book_function.h"
#include "str.h"
/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);

  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);
  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);
  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;
  return 0;
} /* 책을 검색하는 함수 */
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];
  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);
  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);
  printf("검색 결과 \n");
  if (user_input == 1) {
    /*
  i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을        사용자가 입력한
  검색어와 비교하고 있다.
  */
    for (i = 0; i < num_total_book; i++) {
      if (compare(book_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  } else if (user_input == 2) {
    /*
  i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을        사용자가
  입력한 검색어와 비교하고 있다.
  */
    for (i = 0; i < num_total_book; i++) {
      if (compare(auth_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  } else if (user_input == 3) {
    /*
  i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를        사용자가 입력한
  검색어와 비교하고 있다.
  */
    for (i = 0; i < num_total_book; i++) {
      if (compare(publ_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  }
  return 0;
}
int borrow_book(int *borrowed) {
  /* 사용자로 부터 책번호를 받을 변수*/
  int book_num;
  printf("빌릴 책의 번호를 말해주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &book_num);
  if (borrowed[book_num] == 1) {
    printf("이미 대출된 책입니다! \n");
  } else {
    printf("책이 성공적으로 대출되었습니다. \n");
    borrowed[book_num] = 1;
  }
  return 0;
}
int return_book(int *borrowed) {
  /* 반납할 책의 번호 */
  int num_book;
  printf("반납할 책의 번호를 써주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &num_book);
  if (borrowed[num_book] == 0) {
    printf("이미 반납되어 있는 상태입니다\n");
  } else {
    borrowed[num_book] = 0;
    printf("성공적으로 반납되었습니다\n");
  }
  return 0;
}
```



또한 당연하게도 `book_function.h` 의 모습은 아래와 같겠죠.

```cpp-formatted
/* book_function.h */
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book);
int borrow_book(int *borrowed);
int return_book(int *borrowed);
```



이제 마지막으로 `main` 함수가 있는 `test.c` 를 살펴볼 차례 입니다.

`main` 함수에서는 `printf` 와 `scanf` 등과, `book_function` 에 정의되어 있는 함수들을 사용하고 있고 `compare` 함수는 사용하지 않으므로 다음과 같이만 해주면 됩니다.

```cpp-formatted
/* test.c */
#include <stdio.h>
#include "book_function.h"
int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */
  /* 각각 책, 저자, 출판사를 저장할 배열 생성. 책의 최대 개수는 100 권*/
  char book_name[100][30], auth_name[100][30], publ_name[100][30];
  /* 빌렸는지 상태를 표시 */
  int borrowed[100];
  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");
    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);
    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
      add_book(book_name, auth_name, publ_name, borrowed, &num_total_book);
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
      search_book(book_name, auth_name, publ_name, num_total_book);
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
      borrow_book(borrowed);
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
      return_book(borrowed);
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    }
  }
  return 0;
}
```



어때요? 꽤 간단하지요. 이 작업을 한 후 컴파일 후 실행하면 역시나 잘 작동됨을 알 수 있습니다. 이렇게 여러분은 파일을 나누는 방법에 대해서 알게 되었습니다. 이렇게 파일을 나누어서 처리하게 되면 상당히 체계적으로 프로그래밍을 할 수 있는데 이렇게 하는 프로그래밍을 모듈화 프로그래밍 (modular programming) 이라고 합니다. 즉 프로그램의 각 부분 부분을 나누어서 따로 처리 한다는 의미지요.

우리는 여태까지 헤더 파일에는 함수의 선언 밖에 쓰지 않았지만 사실 헤더파일에도 많은 것들이 올 수 있습니다. 이에 대해서는 다음 시간에 알아보도록 합시다.

### 생각해 볼 문제

#### 문제 1

위 도서 관리 프로그램을 구조체를 이용하여 만든 것이 있을 것입니다. ( [http://itguru.tistory.com/60](http://itguru.tistory.com/60) 생각해 볼 문제 참조) 이 역시 위와 같이 파일로 쪼개 보세요.

##@ chewing-c-end
Link :  86
2010-07-10 10:25
----------------
title : C 언어 레퍼런스- strcoll 함수
cat_title :  strcoll
publish_date : 2010-07-10 10:25
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strcoll

```info
#include <string.h> // C++ 에서는 <cstring>

int strcoll ( const char * str1, const char * str2 );
```

`locale` 을 이용하여 두 개의 문자열을 비교한다.

C 형식 문자열인 `str1` 과 `str2` 를 `LC_COLLATE` 에 정의되어 있는 방식에 따라 해석 된 후 비교하게 된다. 이 함수 역시 문자 하나 하나를 일일히 비교하여 두 개의 문자가 다른 것이 나타날 때 까지나 `NULL` 에 도달할 때 까지 비교를 수행한다.



###  인자


`str1`

비교할 C 형식 문자열

`str2`

비교할 C 형식 문자열




###  리턴값




아래와 같은 규칙으로 값을 리턴한다.

두 문자열이 일치하면 0 을 반환한다.

만일 `str1` 과 `str2` 에서 최초로 일치하지 않는 문자의 값이 `str1` 이 더 크다면 0 보다 큰 값을 반환하고 그렇지 않다면 0 보다 작은 값을 반환하게 된다.



###  연관된 함수

*  [strcmp](http://itguru.tistory.com/85)  :  두 문자열을 비교한다.
* `strncmp` :  두 문자열의 일부분을 비교한다.
*  [memcmp](http://itguru.tistory.com/84)  :  두 메모리 블록을 비교한다.
Link :  85
2010-06-25 23:27
----------------
title : C 언어 레퍼런스 - strcmp 함수
cat_title :  strcmp
publish_date : 2010-06-25 23:27
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strcmp

```info
#include <string.h> // C++ 에서는 <cstring>

int strcmp ( const char * str1, const char * str2 );
```


두 개의 문자열을 비교한다.

C 문자열 형식의 `str1` 과 `str2` 를 비교한다.

이 함수는 각 문자열의 첫 번째 문자 부터 비교를 시작한다. 만일 같다면 두 문자가 다를 때 까지나 `NULL` 에 도달할 때 까지 계속 비교를 수행한다.



###  인자

`str1`

비교할 C 형식 문자열

`str2`

비교할 C 형식 문자열



###  리턴값


두 문자열의 관계에 따라 정수값을 리턴한다.

만일 두 문자열이 정확하게 일치한다면 0 을 리턴한다.

일치하지 않을 경우, 일치 하지 않는 첫 번째 문자를 비교해 `str1` 이 `str2` 보다 크다면 0 보다  큰 값을 아니면 0 보다 작은 값을 리턴한다.



###  strcmp 함수의 간단한 구현





```cpp-formatted
/*

다음 소스는
http://www.jbox.dk/sanos/source/lib/string.c.html
에서 가져왔습니다.

*/
int strcmp(const char *s1, const char *s2) {
  int ret = 0;
  while (!(ret = *(unsigned char *)s1 - *(unsigned char *)s2) && *s2)
    ++s1, ++s2;

  if (ret < 0)
    ret = -1;
  else if (ret > 0)
    ret = 1;

  return ret;
}
```



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strcmp/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char szKey[] = "apple";
  char szInput[80];
  do {
    printf("Guess my favourite fruit? ");
    gets(szInput);
  } while (strcmp(szKey, szInput) != 0);

  puts("Correct answer!");
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F193B1B1E4C24BABDAC1454)

###  연관된 함수

*  [strncmp](http://itguru.tistory.com/90)  :  두 문자열의 일부 문자를 비교한다.
*  [memcmp](http://itguru.tistory.com/84)  :  두 메모리 블록을 비교한다.
*  [strrchr](http://itguru.tistory.com/96)  :  문자열에서 특정한 문자가 마지막으로 나타나는 위치를 찾는다.
*  [strspn](http://itguru.tistory.com/97)  :  특정한 문자열이 다른 문자열에서 차지하는 길이를 계산한다.
Link :  84
2010-06-25 19:31
----------------
title : C 언어 레퍼런스 - memcmp 함수
cat_title :  memcmp
publish_date : 2010-06-25 19:31
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ memcmp

```info
#include <string.h> // C++ 에서는 <cstring>

int memcmp ( const void * ptr1, const void * ptr2, size_t num );
```


두 개의 메모리 블록을 비교한다.

`ptr1` 이 가리키는 처음 `num` 바이트의 데이터와 `ptr2` 가 가리키는 처음 `num` 바이트의 데이터를 비교하여 이들이 같다면 0 을 리턴하고 다르다면 0 이 아닌 값을 리턴한다. 이 때 리턴되는 값은 아래를 참고.



###  인자

`ptr1`

메모리 블록을 가리키는 포인터

`ptr2`

메모리 블록을 가리키는 포인터

`num`

비교할 바이트 수



###  리턴값




두 개의 메모리 블록의 관계에 따라 아래와 같이 정수 값을 리턴한다.

* 만일 두 메모리 블록이 정확히 같다면 0 을 리턴한다.
* 만일 두 메모리 블록이 다를 경우, `ptr1` 과 `ptr2` 가 가리키는 메모리 블록에서 앞에서 부터 처음으로 다른 바이트를 살펴 보는데, 그 바이트를 `unsigned char` 로 해석하였을 때, 그 값이 `ptr1` 이 더 크면 0 보다 큰 값을, 아니면 0 보다 작은 값을 리턴한다.



###  실행 예제




```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/memcmp/
에서 가져왔습니다.

참고로 아래의 예제는 단어를 순서대로 배열하는데 요긴하게 이용될 수 있습니다.
(예: 사전)

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str1[256];
  char str2[256];
  int n;
  size_t len1, len2;

  printf("Enter a sentence: ");
  gets(str1);

  printf("Enter another sentence: ");
  gets(str2);

  len1 = strlen(str1);
  len2 = strlen(str2);

  n = memcmp(str1, str2, len1 > len2 ? len1 : len2);

  if (n > 0) {
    printf("'%s' is greater than '%s'.\n", str1, str2);
  } else if (n < 0) {
    printf("'%s' is less than '%s'.\n", str1, str2);
  } else {
    printf("'%s' is the same as '%s'.\n", str1, str2);
  }
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F161811194C24B767A228D0)


위에서 `abcde` 와 `adecd` 를 입력하였을 때, `abcde` 가 `adecd` 보다 작게 나온다. 이는 `memcmp` 가 앞에서 부터 처음으로 다른 바이트 (abcde 의 경우 두 번째인 'b', adecd 에서는 두 번째인 'd' ) 를 비교하는데 'b' 가 'd' 보다 아스키 코드 값이 작으므로 0 보다 작은 값이 리턴된다.



###  연관된 함수

* [memchr](http://itguru.tistory.com/92)  :  메모리 블록에서 특정한 문자를 찾는다.
*  [memcpy](http://itguru.tistory.com/77):  메모리 블록을 복사한다.
*  [memset](http://itguru.tistory.com/104)  :  메모리 블록을 채운다.
*  [strncmp](http://itguru.tistory.com/90)  :  두 개의 문자열의 일부분을 비교한다.
Link :  83
2010-06-19 20:09
----------------
title : 씹어먹는 C 언어 - <17. 변수의 생존 조건 및 데이터 세그먼트의 구조>
cat_title : 17. 변수의 생존 조건 및 데이터 세그먼트의 구조
next_page : 87
publish_date : 2010-06-19 20:09
--------------

이번 강좌에서는

* 지역 변수(local variable), 전역 변수(global variable), 정적 변수(static variable) 에 대해 알아본다.

* 데이터 세그먼트의 구조에 대해 알아본다.

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분.. 드디어 17 번째 강좌 입니다. 총 20 에서 25 강 까지로 예상하고 있는데 이제 앞으로 얼마 남지 않았군요. 구조체까지 완전히 배웠으니 이제 여러분은 정말로 만들어 볼 것이 많을 것 같네요. 이번 강좌는 단순한 내용이므로 딱히 아주 길지는 않을 것 입니다. 아마도 여태까지 배운 개념들을 환기시키는 정도로 사용될 것 같네요.


###  지역 변수


아래의 간단한 소스를 살펴 봅시다.

```cpp-formatted
/* 오류 */
#include <stdio.h>
int function() {
  int a = 3;
  return 0;
}
int main() {
  int a;
  function();
  printf("%d", a);

  return 0;
}
```


  컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1145B3014C1E1E1454D7DA)

와 같은 상콤한 오류를 만나게 됩니다.

이러한 오류는 왜 발생하였을 까요? 아마 제 강좌를 열심히 들었던 분들은 이미 다 알고 계시겠지만,,

그 이유는 바로 `function` 함수의 변수 `a` 와 `main` 함수의 변수 `a` 는 다르기 때문 입니다. 이렇게 각 함수의 내부에서 정의된 변수들을지역 변수 (local variable)이라고 하는데 이 변수들은 메모리 상의 '스택' 에 저장되어 있습니다. 이에 대한 설명은 나중에 하겠습니다. 아무튼 이러한 지역 변수들은 같은 함수 내에서 선언 된 것 끼리 말고는 서로에 접근할 수 없습니다. 물론 C 에서는 이를 해결하기 위해 포인터라는 훌륭한 것이 있지만 아무튼 다른 함수에 선언된 지역 변수 끼리는 서로의 값에 접근을 할 수 없습니다.

또한 이 지역 변수들은 자신이 속한 함수가 종료 될 때 (즉 `return` 을 수행할 때) 파괴 됩니다. 다시말해 메모리 상에서 사라지게 되는 것입니다. 따라서, `main` 함수에서 `function` 을 실행 했다면 처음에 메모리에 3 이란 값을 볼 수 있겠지만 `function` 이 종료된 직후 메모리 에서는 3 이 사라지게 됩니다. 즉 `function` 의 지역변수 `a` 가 사라지게 되는 것이죠.

마찬가지로 `main` 함수의 지역 변수 `a` 역시 `main` 함수가 종료하면 파괴 됩니다.

지역 변수를 쉽게 비유하자면 '하나의 국가(함수) 에 사는 국민(지역 변수)' 라고 생각하면 됩니다. 즉 같은 국가 내에서는 서로 같은 언어로 자유롭게 대화할 수 있지만 우리가 외국인만 만나면 한없이 작아지는 것 처럼 다른 국가 사람들과는 이야기 하기가 힘들다는 것과 비슷합니다.

참고로 배열은 지역 변수 일까요? 맞습니다. 배열은 '지역 변수의 모음' 이라면 보면 적당합니다. 아무튼 배열 역시 지역 변수고 스택에 저장됩니다.


###  전역 변수



```cpp-formatted
/* 전역 변수 */
#include <stdio.h>

int global = 0;

int function() {
  global++;
  return 0;
}
int main() {
  global = 10;
  function();
  printf("%d \n", global);
  return 0;
}
```

  성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F12224E0D4C1E20C882FA32)

이번에는 어느 함수에도 속하지 않는 변수가 등장하였습니다. 이와 같이 함수 '외부' 에 선언되어 있는 변수를 바로 **전역 변수(global `variable)** 이라 합니다. 얘는 정말 이름대로 글로벌 한 녀석인데 아까 지역 변수가 자신이 정의되어 있는 함수 내부에서는 접근할 수 있었더라면 이 변수의 경우 모든 함수에서 접근할 수 있습니다. 마치 몇 개 국어를 자유롭게 구사하는 사람 처럼 말이죠.

먼저 `main` 에서

```cpp-formatted
global = 10;
function();
```


`global` 의 값을 10 으로 한 후 `function` 을 호출했습니다. `function` 에서는 `global` 의 값을 1 더하는데 따라서 다시 `main` 에서 `global` 의 값을 출력 했을 때 에는 11 이 됩니다.

지역 변수의 경우 함수가 종료 될 때 파괴 되었는데, 전역 변수의 경우 프로그램이 시작 할 때 만들어 졌다가 프로그램이 종료 될 때 파괴 됩니다. 전역 변수는 지역 변수와는 달리 메모리의 **데이터 영역(Data segment)**에 할당 됩니다.

한 가지 재미있는 것은 모든 전역 변수들은 정의 시 자동으로 0 으로 초기화 된다는 것입니다.

```cpp-formatted
/* 전역 변수의 초기화 ? */
#include <stdio.h>

int global;
int function() {
  global++;
  return 0;
}
int main() {
  function();
  printf("%d \n", global);
  return 0;
}
```


  성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1351B40F4C1E22A6662374)

위와 같이 1 이 출력됨을 알 수 있습니다. 만일 `global` 이 지역 변수 같았더라면 일단 컴파일 시에 `global` 변수가 초기화 되지 않고 사용되었습니다 라는 경고를 보았을 테고, 설사 실행했다고 해도 맨 위에서 보았던 상콤한 오류 창을 보았을 텐데요.

하지만 컴파일러는 전역 변수의 정의와 동시에 0 으로 초기화 해버립니다.

따라서 위와 같이 1 이 출력되었죠.

```cpp-formatted
/* 함수 호출 횟수 세기*/
#include <stdio.h>

int How_Many_Times_This_Function_Called = 0;
int function() {
  How_Many_Times_This_Function_Called++;
  printf("called : %d \n", How_Many_Times_This_Function_Called);

  return 0;
}
int main() {
  function();
  function();
  function();
  function();
  return 0;
}
```

  성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1602720E4C1E243678DB27)

위 프로그램에서는 `function` 이라는 변수가 몇 번 호출 되는지 알려줍니다. `How_Many_Times_This_Function_Called` 라는 변수는 `function` 함수를 몇 번 이나 호출했는데 카운트 해줍니다. 만일 `How_Many_Times_This_Function_Called` 를 `function` 함수의 지역 변수로 만들었다면 함수 종료 후 파괴 되므로 정보를 보관할 수 없었겠죠.

```cpp-formatted
/* 전역 변수의 문제점 */
#include <stdio.h>

int How_Many_Times_This_Function_Called = 0;
int How_Many_Times_This_Function_Called2 = 0;
int function() {
  How_Many_Times_This_Function_Called++;
  printf("function called : %d \n", How_Many_Times_This_Function_Called);

  return 0;
}
int function2() {
  How_Many_Times_This_Function_Called2++;
  printf("function 2 called : %d \n", How_Many_Times_This_Function_Called2);

  return 0;
}
int main() {
  function();
  function2();
  function();
  function2();
  function2();
  function2();
  function();
  function();
  function2();
  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F16595B1B4C1E24EE998ECD)

이번에는 또 다른 함수 `function2` 의 호출 회수도 세는 변수를 지정하였습니다. 전역 변수는 모든 함수에서 접근할 수 있기 때문에 이를 위해 다른 변수 `How_Many_Times_This_Function_Called2` 를 도입하게 되었습니다. 그렇다면 이렇게 10 개의 함수에 대해 각각 호출 회수를 세기 위해서는 아마도 10 개의 전역 변수가 필요하게 됩니다.

이는 심각한 문제가 아닐 수 있습니다. 전역 변수는 모든 함수에서 접근할 수 있기 때문에 전역 변수에 조금 이라도 문제가 생기면 전체 함수에 영향을 미치게 됩니다. 따라서 전역 변수는 매우 조심 스럽게 사용해야 하는데 이렇게 '위험한' 전역 변수를 수십개 선언 하다 보면 필연적으로 문제가 생기게 마련입니다.

```warning
참고로 대부분의 프로그래머들은 많은 수의 전역 변수를 선언하지 않는 것을 권고합니다.
```


아마도 여러분은 이쯤 부터 "그럼, 함수가 종료되어도 값이 변경되지 않는 지역변수 는 없을까?" 라는 생각을 하게 됩니다. 다행이도 있습니다. 물론 지역 변수는 아니지요. 이를 **정적 변수 (static variable)** 이라 합니다.



###  정적 변수


```cpp-formatted
/* 정적 변수의 활용 */
#include <stdio.h>

int function() {
  static int How_Many_Times_This_Function_Called = 0;

  How_Many_Times_This_Function_Called++;
  printf("function called : %d \n", How_Many_Times_This_Function_Called);

  return 0;
}
int function2() {
  static int How_Many_Times_This_Function_Called = 0;

  How_Many_Times_This_Function_Called++;
  printf("function 2 called : %d \n", How_Many_Times_This_Function_Called);

  return 0;
}
int main() {
  function();
  function2();
  function();
  function2();
  function2();
  function2();
  function();
  function();
  function2();
  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F16595B1B4C1E24EE998ECD)

와 같이 동일하게 작동함을 알 수 있습니다. 정적 변수는 보통 아래와 같이 정의합니다.

```info
static (변수의 타입) (변수의 이름);
```

예를 들면

```cpp-formatted
static struct HUMAN adam;
static char c;
```

와 같이 말이죠.

```cpp-formatted
static int How_Many_Times_This_Function_Called = 0;
```

먼저 `function` 함수 부터 살펴 봅시다. 위와 같이 정적 변수 `How_Many_Times_This_Function_Called` 를 정의하였습니다. 이는 지역 변수와 하는 짓이 비슷해서 다른 어떠한 함수에서도 `How_Many_Times_This_Function_Called` 에 접근할 수 없습니다. 당연하게도 `function2` 에 정의된 `How_Many_Times_This_Function_Called` 와 이름은 같지만 메모리 상에 다른 곳에 존재하는 완전히 다른 것입니다.

정적 변수의 경우 함수가 처음 실행 될 때 정의 됩니다. 즉, 위 문장을 함수를 실행할 때 매번 적용되서 언제나 `How_Many_Times_This_Function_Called` 의 값이 0 이 되는 것이 아닙니다.

정적 변수의 특징은 앞에서도 말했듯이 함수가 종료 되어도 그 값을 계속 유지하고 있다는 점입니다. 따라서

```cpp-formatted
How_Many_Times_This_Function_Called++;
```

를 통해 함수의 호출 횟수를 셀 수 있습니다. 그렇다면 `main` 함수 에서 `How_Many_Times_This_Function_Called` 의 값을 볼 수 있는 방법이 있을까요? 답은 '없습니다' 입니다. 맨 위의 예제에서 지역 변수 `a` 값을 참조 할 수 없었던 것 처럼 `How_Many_Times_This_Function_Called` 는 '함수가 종료 될 때 파괴되지 않는다' 라는 점 빼고는 지역 변수와 하는 짓이 동일합니다.
다만 정적 변수의 경우 전역 변수 처럼 '데이터 영역' 에 저장되고 프로그램이 종료될 때 파괴됩니다. 또한 전역 변수 처럼 정적 변수도 정의시 특별한 값을 지정해 주지 않는 한 0 으로 자동 초기화 됩니다.



###  데이터 세그먼트의 구조





프로그램이 실행 될 때 프로그램은 `RAM` 에 적재 됩니다. 다시 말해 프로그램의 모든 내용이 `RAM` 위로 올라오게 된다는 것이지요. 여기서 '프로그램의 모든 내용' 이라 하면 프로그램의 코드와 프로그램의 데이터를 모두 의미 하는 것입니다. 이렇게 `RAM` 위로 올라오는 프로그램의 내용을 크게 나누어서 **코드 세그먼트(Code Segment)** 와 **데이터 세그먼트(Data Segment)** 로 분류할 수 있습니다.

우리가 중점 적으로 살펴볼 것은 데이터 세그먼트입니다. 일단 아래의 그림을 보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F140309404D2EF2B93B6CF4)

위와 같이 메모리에 배치 되어 있는 것을 알 수 있습니다.

일단 가장 먼저 주목할 부분은 **Read-Only Data** 부분 입니다. 이전에 상수와 리터럴에 대해서 이야기 할 때 등장하였는데 이 부분에 저장되는 데이터들은 값이 절대로 변경될 수 없습니다. 다시 말해 궁극적으로 보호 받는 부분 이죠.

그 다음으로 그 위에 전역 변수와 정적 변수가 거처하는 데이터 영역이 있습니다. 그 위에 바로 **힙(Heap)** 이라는 영역이 있는데 이 부분에 대해서는 나중에 설명하도록 합시다. 힙 맨 위를 보면 **스택(Stack)** 이 있습니다. 스택은 지역 변수가 거처하는 곳입니다. 스택의 특징으로는 지역 변수가 늘어나면 크기가 아래로 증가하다가 지역변수가 파괴되면 다시 스택의 크기는 위로 줄어들게 됩니다. 즉, 스택이 늘어나는 방향은 메모리 주소가 낮아지는 방향(아래 방향) 이라 보시면 됩니다.

```cpp-formatted
/* 메모리의 배치 모습 */

#include <stdio.h>
int global = 3;
int main() {
  int i;
  char *str = "Hello, Baby";
  char arr[20] = "WHATTHEHECK";

  printf("global : %x \n", &global);
  printf("i : %x \n", &i);
  printf("str : %x \n", str);
  printf("arr : %x \n", arr);
}
```

성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F181FA3194C1E30486DBF36)


각 변수들의 주소값을 살펴 보면서 과연 메모리에 정말로 그렇게 배치 되었는지 살펴 봅시다. 일단 저의 결과는 여러분 컴퓨터의 결과와 당연히 차이가 나게 됩니다. 왜냐하면 프로그램 실행 시 그 프로그램이 `RAM` 어디에 위치하게 될 지는 아무도 모르기 때문이죠. 하지만 그 주소값들만 비교 해보도록 합시다.


가장 먼저 `Read Only` 데이터인 `str` 을 봅시다. `str` 에는 “Hello, Baby” 라는 리터럴의 주소값이 들어가 있습니다. 따라서, `str` 의 값을 출력했다면 `Read Only` 데이터의 위치를 대략 알 수 있겠지요. 여기서는 `0x1175a28` 로 나옵니다. 예상 대로 출력된 주소값들 중 가장 작게 나옵니다. 왜냐하면 `RO data` 는 데이터 세그먼트 맨 아래에 위치해 있기 때문이죠.



두 번째로 전역 변수인 `global` 의 주소값을 살펴보면 `str` 보다는 살짝 크지만 다른 것들 보다는 많이 작다는 것을 알 수 있습니다. 이는 `global` 이 전역 변수로 데이터 영역에 위치해 있기 때문이죠. 세 번째로 `i` 를 보자면 지역 변수 이기 때문에 `stack` 에 존재하고 있습니다. `stack` 의 경우 지역 변수를 추가할 수록 메모리 주소가 작아지는 방향으로 추가가 되므로 `i` 보다 나중에 추가 된 `arr` 의 주소값이 더 작습니다. 이들이 데이터 세그먼트에 배치된 모습을 그림으로 그려 본다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F114F551E4C1E3404A1F0AD)




와 같이 됨을 알 수 있습니다. 어때요? 간단 하지요?


### 생각해보기

#### 문제 1

CPU 의 레지스터에 대해 알아보자. `EAX, EBX` 는 무엇인가? 또한 `CS, DS` 에 대해 알아보고 `ESP, EBP 에 대해 알아본다.

 [http://d3s.mff.cuni.cz/~ceres/sch/osy/text/ch03s02s02.php](http://d3s.mff.cuni.cz/%7Eceres/sch/osy/text/ch03s02s02.php)
 [http://www.drpaulcarter.com/pcasm/](http://www.drpaulcarter.com/pcasm/)

특히 위의 두번째 링크에 들어가 `PC Assembly Language` 한국어 판을 읽어보기를 추천합니다.


#### 문제 2

스택에 대한 폭넓은 이해를 위해 아래 글을 보는 것을 추천합니다. (동적 할당 부분 전까지만)
 [http://blog.naver.com/speciallive?Redirect=Log&logNo=98372211](http://blog.naver.com/speciallive?Redirect=Log&logNo=98372211)

##@ chewing-c-end
Link :  71
2010-06-13 23:33
----------------
title : 씹어먹는 C 언어 - <16 - 3. 구조체와 친구들(공용체(union), 열거형(enum))>
cat_title : 16 - 3. 구조체와 친구들(공용체(union), 열거형(enum)
next_page : 83
publish_date : 2010-06-13 23:33
--------------


이번 강좌에서는

* 구조체의 나머지 기능에 대한 이해

* 공용체(union) 에 대한 이해

* 열거형(enum) 에 대한 이해

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분! 또 오래간만 입니다. (저 아직 죽지 않고 살아있어요) 구조체를 향한 강좌도 끝을 향해 달려가고 있습니다. 물론 이번 강좌에서는 구조체만을 다루는 것이 아니라 C 언어에서 사용 비중이 그렇게 크지는 않지만 어쨋든 알기는 알아야 하는 기능들에 대해서 배워볼 차례 입니다. 다시말해, 큰 산들은 다 넘었고 이제 우리 앞에는 조그마한 언덕만이 남아 있을 뿐이라는 것이죠 :)



###  구조체 안의 구조체




```cpp-formatted
/* 구조체 안의 구조체*/
#include <stdio.h>
struct employee {
  int age;
  int salary;
};
struct company {
  struct employee data;
  char name[10];
};
int main() {
  struct company Kim;

  Kim.data.age = 31;
  Kim.data.salary = 3000000;

  printf("Kim's age : %d \n", Kim.data.age);
  printf("Kim's salary : %d$/year \n", Kim.data.salary);

  return 0;
}
```

성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1701851E4BCAB179451724)

먼저 `employee` 구조체를 살펴 봅시다.

```cpp-formatted
struct employee {
  int age;
  int salary;
};
```

위 구조체에는 `int` 형의 `age` 와 `salary` 변수 두 개가 멤버로 되어 있습니다. 다음, `company` 구조체를 살펴보면

```cpp-formatted
struct company {
  struct employee data;
  char name[10];
};
```

와 같이 또다른 구조체 변수를 멤버로 가짐을 볼 수 있습니다. 뭔가 이상하다는 느낌이 들 수 도 있는데, 사실 위와 같이 정의해도 되는 것은 당연한 일입니다. 왜냐하면 제가 이전에도 말했듯이 구조체는 **사용자가 정의한 또다른 형(type)** 이라고 보는 것이기 때문이죠.

구조체 역시 `int` 나 `char` 과 같은 하나의 형 입니다. 우리가 만든 형은 이름이 `struct employee` 라는 것이고, 그 중 `data` 라는 (구조체) 변수를 생성하였죠. 이는 `int a` 와 지극히 똑같은 작업 입니다.

```cpp-formatted
struct company Kim;
```

위와 같이 `company` 구조체를 정의한 뒤, 'struct company' 형의 변수 `Kim` 을 정의하였습니다. 이제, `Kim` 의 멤버들에게 값을 대입해 보아야 겠죠.

```cpp-formatted
Kim.data.age = 31;
```

일단 위 문장을 살펴 봅시다. '.' 연산자의 우선 순위는 왼쪽 부터 이므로 `Kim.data` 가 해석 된 후, `(Kim.data).age` 가 해석이 됩니다. 다시 말해 "`Kim` 의 `data` 멤버의 `age` 멤버" 로 생각 되는 것이지요. 따라서 위와 같이 "Kim 의 `data` 멤버의 `age` 멤버" 에 31 의 값을 넣었습니다. 마찬가지로 `salary` 에 30000 을 넣었습니다.

따라서 위와 같이 출력이 됩니다.


###  구조체를 리턴하는 함수


구조체는 말그대로 여러분이 창조하신 하나의 타입이기 때문에 `int , char` 등이 가능했던 모든 것들을 구조체는 그대로 할 수 있습니다. 역시 구조체 형을 리턴하는 함수도 가능하겠지요.

```cpp-formatted
/* 구조체를 리턴하는 함수 */
#include <stdio.h>
struct AA function(int j);
struct AA {
  int i;
};

int main() {
  struct AA a;

  a = function(10);
  printf("a.i : %d \n", a.i);

  return 0;
}

struct AA function(int j) {
  struct AA A;
  A.i = j;

  return A;
}
```


성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F202E540D4C14C54CAA7088)

먼저 `AA` 라는 구조체를 정의하였습니다. 편의상 멤버는 `int` i  로 하나만 가진다고 합시다.

```cpp-formatted
struct AA {
  int i;
};
```


아래는 "struct AA" 형을 리턴하는 함수 `function` 입니다. 인자로는 `int j` 를 취합니다.

```cpp-formatted
struct AA function(int j) {
  struct AA A;
  A.i = j;

  return A;
}
```

말그래도 `struct AA` 형을 리턴하기 때문에 리턴하는 것 역시 `struct AA` 형의 것이 되야 합니다. 위 함수는 인자로 받는 `j` 값으로 `A` 의 `i` 멤버를 `j` 의 값으로 초기화 한 후 이를 그대로 리턴합니다.

```cpp-formatted
struct AA a;

a = function(10);
```

우리는 `main` 함수에서 `struct AA` 타입의 구조체 변수 `a` 를 정의하였습니다. 그렇다면 `a = function(10);` 을 통해 `function(10)` 이 리턴한 구조체의 대입이 일어나게 됩니다.  `function(10)` 은 '`i` 멤버의 값이 10 인 구조체 변수' 를 리턴하므로 `a` 의 `i` 멤버 값은 10 이 됩니다.



###  구조체 변수의 정의 방법

우리는 여태까지 구조체 변수를 다음과 같이 정의하였습니다.

```info
struct Anomynous Var1, Var2; // "struct Anomynous" 형의 변수 Var1 , Var2 를 정의한다.
```

그런데 구조체 변수를 정의하는 방법 중 아래와 같이 색다른 방법을 소개해 드립니다.

```cpp-formatted
/*

구조체 변수를 정의하는 색다른 방법.
예제를 이렇게 길게 만든 이유는 소스를 읽으면서 구조체와 조금 더 친해지기 바래서
입니다. 소스를 찬찬히 분석해보세요 ^^

*/
#include <stdio.h>
char copy_str(char *dest, char *src);
int Print_Obj_Status(struct obj OBJ);
struct obj {
  char name[20];
  int x, y;
} Ball;

int main() {
  Ball.x = 3;
  Ball.y = 4;
  copy_str(Ball.name, "RED BALL");

  Print_Obj_Status(Ball);

  return 0;
}
int Print_Obj_Status(struct obj OBJ) {
  printf("Location of %s \n", OBJ.name);
  printf("( %d , %d ) \n", OBJ.x, OBJ.y);

  return 0;
}
char copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```

성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F195FEB0C4C14C8D901E478)

```cpp-formatted
struct obj {
  char name[20];
  int x, y;
} Ball;
```

저는 위와 같이 "sturct obj" 라는 구조체를 정의하였고 멤버는 위와 같습니다. 그런데, 맨 아래 `Ball` 은 무엇인가요? 이는 바로 그냥 `sturct obj` 형의 `Ball` 이란 구조체 변수를 정의하라는 뜻입니다. 사실 우리가 `main` 함수 내부에서

```cpp-formatted
struct obj Ball;
```

이라고 써왔든 것과 다를 바가 없습니다. 그냥, 위와 같이 구조체 변수를 정의하는 방법도 있다는 것을 알려 드린 것입니다.

나머지 부분은 여러분이 스스로 분석해 보시기 바랍니다.

```cpp-formatted
/* 멤버를 쉽게 초기화 하기*/
#include <stdio.h>
int Print_Status(struct HUMAN human);
struct HUMAN {
  int age;
  int height;
  int weight;
  int gender;
};

int main() {
  struct HUMAN Adam = {31, 182, 75, 0};
  struct HUMAN Eve = {27, 166, 48, 1};

  Print_Status(Adam);
  Print_Status(Eve);
}

int Print_Status(struct HUMAN human) {
  if (human.gender == 0) {
    printf("MALE \n");
  } else {
    printf("FEMALE \n");
  }

  printf("AGE : %d / Height : %d / Weight : %d \n", human.age, human.height,
         human.weight);

  if (human.gender == 0 && human.height >= 180) {
    printf("HE IS A WINNER!! \n");
  } else if (human.gender == 0 && human.height < 180) {
    printf("HE IS A LOSER!! \n");
  }

  printf("------------------------------------------- \n");

  return 0;
}
```

성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1814FB0C4C14CB0DD0DE6E)

위 예제도 역시 구조체의 잡다한 기능 중 하나를 보여주고 있습니다. 바로 멤버를 초기화 하는 방식 인데요, 우리가 이전까지 멤버를 초기화 해온 방법 보다 더 쉽게 할 수 있습니다.

```cpp-formatted
struct HUMAN {
  int age;
  int height;
  int weight;
  int gender;
};
```

`HUMAN` 구조체는 위와 같이 4 개의 `int` 형 멤버들을 가지고 있습니다.

```cpp-formatted
struct HUMAN Adam = {31, 182, 75, 0};
struct HUMAN Eve = {27, 166, 48, 1};
```

그리고 `main` 내부에서 위와 같이 `Adam` 과 `Eve` 를 정의하였죠. 이 때, `= {}` 를 통해서 중괄호 내부의 정보들이 순차적으로 각 멤버에 대입되게 됩니다. 따라서 `Adam` 의 경우 `age` 에는 31 이, `height` 에는 182 가, `weight` 에는 75, `gender` 에는 0 이 들어가게 되죠.

이전 예제에서 배운 초기화 방식에서는 다음과 같이 해주면 됩니다.

```cpp-formatted
struct HUMAN {
  int age;
  int height;
  int weight;
  int gender;
} Adam = {31, 182, 75, 0}, Eve = {27, 166, 48, 1};
```


어때요? 간단하지요. 그렇다면 이전 예제의

```info
struct obj
{
    char name[20];
    int x,y;
};

```

의 경우 어떻게 하면 될까요? 간단 합니다.

```cpp-formatted
struct obj {
  char name[20];
  int x, y;
} Ball = {"abc", 10, 2};
```

와 같이 하게 되면 `name` 에는 "abc" `, x` 에는 `10, y` 에는 2 가 들어가게 됩니다.

여기서 구조체에 관한 이야기는 끝이 납니다. 아. 정말로 길었던 구조체 강좌였습니다. 아마 3 번의 강좌를 걸쳐서 제가 구조체에 관한 모든 지식들을 전달한 것 같습니다.



###  공용체 (union)


사실 **공용체(union)** 는 그다지 많이 사용하는 기능은 아닙니다만, 그래도 C 언어에서 제공하는 것들 중 하나이니 간단하게 나마 집고 넘어가도록 합시다. 공용체는 구조체와는 달리 메모리를 ‘공유’ 합니다. 이게 도대체 무슨 말인가 하면 아래 그림을 참조해주세요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F1210640D4C14DC693AF455)

위 그림을 보아도 알 수 있듯이 공용체의 각 멤버들의메모리 시작 주소는 모두 동일합니다. 따라서 우리는 위 그림의 `union A` 의 경우 `j` 의 값을 변경함으로 써 `i` 의 값을 변경할 수 있고 마찬가지로 `i` 의 값을 변경함으로써  `j` 의 값을 변경할 수 있게 됩니다. 과연 이 말이 진짜 인지 확인해 보도록 합시다.

```cpp-formatted
/* 공용체 */
#include <stdio.h>
union A {
  int i;
  char j;
};
int main() {
  union A a;
  a.i = 0x12345678;
  printf("%x", a.j);
  return 0;
}
```




성공적으로 컴파일 했다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F1868AA0C4C14DC6A84F982)



음. 과연 우리는 `a` 의 `j` 멤버 값을 전혀 설정해 주지 않았음에도 불구하고 `i` 에 `0x12345678` 을 대입하자 `j` 의 값이 78 로 잘 나왔습니다. 그런데 이상한 점이 듭니다. 왜 78 이 나왔을 까요? `0x12` 가 나와야 되는 것 아닌가요? 분명히 `i` 와 `j` 에 동일한 주소값에 위치해 있고 `i` 가 `0x12345678` 로 메모리 상에 있다면 `j` 는 처음 두 개인 `0x12` 가 되어야 되는 것 아닌가요? 물론, 여러분의 생각은 옳습니다. 하지만 컴퓨터에서는 수를 이렇게 보관하지 않습니다. 적어도 여러분의 컴퓨터에서는요.



###  빅 엔디안 (Big Endian), 리틀 엔디안 (Little Endian)


컴퓨터에서 메모리에 수를 저장할 때, 우리가 생각하는 방법, 즉 낮은 주소값에 상위 비트를 적는 방식을 **빅 엔디안** 방식이라고 합니다. 그리고, 우리가 생각하는 방법의 정반대로 높은 주소값에 상위 비트를 적는 방식을 **리틀 엔디안** 이라고 합니다. 현재 대부분은 `x86` 프로세서는 리틀 엔디안 방식을 사용하고 있고 일부 컴퓨터에서만 빅 엔디안 방식을 사용하고 있습니다. \sidenote{따라서 여러분의 컴퓨터의 경우 99% 모두 리틀 엔디안을 사용하고 계실 것입니다.}

먼저, 빅 엔디안 에서 수를 어떻게 저장하는지 보면
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F15149E0E4C14DC6A3AB3FF)


와 같이 상식적으로 수를 저장하게 됩니다. 하지만 이건 빅 엔디안 방식의 경우이고요, 우리가 대부분 사용하는 프로세서는 리틀 엔디안 방식이므로 리틀 엔디안 방식의 경우를 살펴 보게 되면
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F122BC3054C14DC6B87546A)

와 같이 1 바이트 씩 역으로 보관함을 알 수 있습니다. 따라서 우리가 출력했던 `j` 값은 `0x78` 이 됩니다. 만일 `j` 를 `short` 형을 지정했으면 어떨까요? `0x7856` 이 나올까요? `0x5678` 이 나올까요?

```cpp-formatted
#include <stdio.h>
union A {
  int i;
  short j;
};
int main() {
  union A a;
  a.i = 0x12345678;
  printf("%x", a.j);
  return 0;
}
```




성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F1868700C4C14DC6B7EB212)


로 `0x5678` 이 나오게 됩니다.

이제 다시 머리가 혼란스러워 지기 시작했습니다. 메모리 상에 그대로 살펴 보게 되면 분명히 `j` 에 해당하는 부분은 `0x7856` 으로 출력되야 정상이지만 컴퓨터는 ‘지극히 정상적으로’ `0x5678` 을 출력하였습니다. 도대체 왜 그럴까요. 그 이유는 간단합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1522E70D4C14DC6C02944D)



이번에는 `j` 가 `short` 형 (2 바이트) 이므로 위와 같이 `j` 가 2 바이트를 차지하게 됩니다. 이 때 왜 `j` 의 값을 출력하면 `0x7856` 이 나오지 않고 `0x5678` 이 나올까? 이 문제에 대해 고민하고 있을 여러분을 위해 질문을 하나 던지겠습니다. `i` 의 값을 출력하면 얼마가 나올까요? 당연히 `0x12345678` 이 될것입니다. 왜냐하면 컴퓨터는 자신이 메모리에 수를 ‘리틀 엔디안 방식’ 을 저장하고 있다는 사실을 알고 있기 때문이죠. 따라서 이를 출력할 때에는 적절한 변환을 취해서 `0x12345678` 을 출력할 것입니다.


`j` 의 경우도 마찬가지 입니다. `j` 는 현재 ‘78 56’ 부분을 가리키고 있지만 컴퓨터는 `j` 가 리틀 엔디안 형식으로 이루어 졌다는 것을 알기 때문에 `j` 를 출력할 때에는 적절히 변환하여 `0x5678` 을 출력하게 될 것입니다.


어때요? 간단 하지요?


공용체에 관한 설명은 여기서 끝납니다. 아마도 공용체를 접할 가능성이 100 번 코딩 하다 보면 1 번 나올까 말까 한데 이를 자세히 짚고 넘어가는 것은 큰 의미가 없다고 생각합니다. 사실 공용체에 대해 배운 것 보다는 엔디안에 대해 배운 것이 훨씬 중요하기 때문에 혹여라도 엔디안에 대해 잊는 일은 없길 바랍니다.



###  열거형 (Enum)


프로그래밍을 하다 보면 각 데이터에 수를 대응 시키는 경우가 많습니다. 예를 들어 사람을 처리할 때, 남자에는 0, 여자에는 1 을 대응시켜서 처리하거나 색깔을 나타낼 때도 빨강에는 0, 흰색에는 1 등을 대응 시켜서 나타내게 됩니다. 이렇게 수를 대응 시켜서 처리할 때 에는 아래와 같이 헷갈리는 경우가 발생합니다.

```info
if (human.gender == 0) // 사람의 성별이 0 일 때
```

남자에는 0, 여자에는 1 임을 확실하게 기억하고 있다면 상관이 없겠지만 기억하지 못하게 된다면 성에 대해 무엇을 대응 시켰는지 다시 찾아 보아야 된다는 번거로운 일이 발생합니다. 하지만 아래와 같이

```info
if(human.gender == MALE) // 사람의 성별이 남자 일 때
```

와 같이 한다면 확실히 알아 듣기 쉽겠지요. 하지만 문제는 이를 위해 `MALE` 이라는 상수를 설정해야 되고 이 때문에 메모리가 낭비되게 됩니다. 이는 프로그래머의 입장에서 난감한 일이 아닐 수 없지요. C 에서는 이를 **열거형(Enum)**을 도입해서 말끔하게 해결해줍니다.

```cpp-formatted
/* 열거형의 도입 */
#include <stdio.h>
enum { RED, BLUE, WHITE, BLACK };
int main() {
  int palette = RED;
  switch (palette) {
    case RED:
      printf("palette : RED \n");
      break;
    case BLUE:
      printf("palette : BLUE \n");
      break;

    case WHITE:
      printf("palette : WHITE \n");
      break;
    case BLACK:
      printf("palette : BLACK \n");
      break;
  }
}
```




성공적으로 컴파일 했다면


![](http://)



일단, 열거형을 정의한 부분 부터 살펴 봅시다.


```cpp-formatted
enum { RED, BLUE, WHITE, BLACK };
```


열거형을 나타내기 위해서는 `enum` 을 쓰고 중괄호 안에 각각에 대해 써주면 됩니다. 그렇다면 컴파일러는 열거형에 나타나 있는 각 원소에 0 부터 차례로 정수값을 매겨 주게 됩니다. 즉 `RED = 0, BLUE = 1, .. BLACK = 3` 와 같이 말이지요. 이제 우리는 이를 자유롭게 이용하면 됩니다.


예를 들어

```info
if(palette == 0) // 현재 파레트의 색이 빨강인지 확인한다.
```

로 했던 것을

```info
if(palette == RED) // 현재 파레트의 색이 빨강인지 확인한다.
```

로 하면 됩니다. 사실 위와 의미는 정확히 똑같지만 프로그래머가 읽을 때 에는 큰 차이가 있게 되죠. 위와 같이 한다고 해서 실질적으로 `RED` 라는 변수가 메모리에 정해지는 것은 아닙니다. 컴파일 시에 컴파일러는 `RED` 는 모두 0 로 바꾸고 `BLUE` 는 모두 1 로 바꾸는 등 변환 작업을 하게 됩니다.



```cpp-formatted
/* 열거형 팁 */
#include <stdio.h>
enum { RED = 3, BLUE, WHITE, BLACK };
int main() {
  int palette = BLACK;
  printf("%d \n", palette);
}
```


성공적으로 컴파일 했다면


![](http://)



열거형에서 처음 수를 0 으로 시작하기 싫다면 어떨까요. 단순히 원하는 수로 해주면 됩니다. 예를 들어 위와 같이



```cpp-formatted
enum { RED = 3, BLUE, WHITE, BLACK };
```

으로 한다면 `RED = 3` 부터 해서 `BLUE = 4, WHITE = 5, BLACK = 6` 이 됩니다. 또한,


```cpp-formatted
enum { RED = 3, BLUE, WHITE = 3, BLACK }
```

으로 한다면 수를 지정한 부분 부터 다시 시작 되는 방식으로 `BLUE = 4, BLACK = 4` 가 됩니다.
참고로 열거형 에서는 언제나 ‘정수값’ 이여야만 합니다.


### 생각해볼 문제

#### 문제 1

공용체는 도대체 어디에 써먹을 수 있을까요? 아래 글을 읽어보세요

http://www.go4expert.com/forums/showthread.php?t=15


##@ chewing-c-end
Link :  82
2010-05-23 12:08
----------------
title : C 언어 레퍼런스 - strncat 함수
cat_title :  strncat
publish_date : 2010-05-23 12:08
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strncat

```info
#include <string.h> // C++ 에서는 <cstring>

char * strncat ( char * destination, char * source, size_t num );
```


문자열에 일부 문자들을 덧붙인다.

`source` 의 처음 `num` 개의 문자들을 `destination` 끝에 덧붙인다. 이 때, `destination` 끝에는 자동으로 `NULL` 문자 까지 붙여진다.

만일, `source` 의 문자열의 길이가 `num` 보다 작다면, `source` 의 `NULL` 문자 까지만 붙여진다.



###  인자




`destination`

`destination` 배열을 가리키는 포인터로, C 문자열을 보관하며 (널 문자를 포함한) 합쳐진 문자열이 들어갈 만큼 충분히 크기가 커야만 한다.

`source`

덧붙여질 C 문자열이다.

`num`

`source` 에서 붙일 문자의 (최대) 개수이다.



###  리턴값


`destination` 이 리턴된다.



###  실행 예제


```cpp-formatted
/*

str1 의 "To be " 와 str2 의 "or not to be" 를 합쳐서 str1 에 저장한다
이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strncat/
에서 가져왔습니다.

*/
#include <stdio.h>
#include <string.h>

int main() {
  char str1[20];
  char str2[20];
  strcpy(str1, "To be ");
  strcpy(str2, "or not to be");
  strncat(str1, str2, 6);
  puts(str1);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F201608194C14EF7D2681EB)



###  함수 구현 예


```cpp-formatted
/*

이 소스는
http://www.jbox.dk/sanos/source/lib/string.c.html
에서 가져왔습니다.

*/

char *strncat(char *s1, const char *s2, size_t count) {
  char *start = s1;
  while (*s1++)
    ;
  s1--;
  while (count--) {
    if (!(*s1++ = *s2++)) return start;
  }
  *s1 = '\0';
  return start;
}
```



###  연관된 함수


*  [strcat](http://itguru.tistory.com/81)  :  문자열을 합친다.
*  [strncpy](http://itguru.tistory.com/80)  :  문자열의 일부분을 복사한다.
*  [memcpy](http://itguru.tistory.com/77):  메모리의 일부분을 복사한다.
Link :  81
2010-05-21 12:02
----------------
title : C 언어 레퍼런스 - strcat 함수
cat_title :  strcat
publish_date : 2010-05-21 12:02
--------------


#@ strcat

```info
#include <string.h> // C++ 에서는 <cstring>

char * strcat ( char * destination, const char * source );

```

문자열을 덧붙인다.

`destination` 끝에 `source` 를 더하게 된다. 이 때, `destination` 의 맨 마지막 널 문자는 `source` 의 첫번째 문자가 덮어 씌우게 된다. 그리고, `source` 의 마지막 널 문자가 `destination` 끝에 붙어서 새로운 문자열을 형성하게 된다.

다시말해, `destination = "ab"` 이고, `source="c"` 였다면 `strcat` 후, `destination` 은 "abc" 가 된다.



###  인자




`destination`

`destination` 배열을 가리키는 배열로, C 형식의 문자열을 포함하고 있어야만 하고, 합쳐진 문자열을 포함할 만큼 배열의 크기가 커야 한다.

`source`

`destination` 에 덧붙여질 C 형식 문자열. 이 때, `destination` 과 위치가 겹쳐지면 안된다.



###  리턴값




`destination` 이 리턴된다.



###  실행 예제




```cpp-formatted
/*

str 에 각 문자열들을 덧붙인다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strncat/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str[80];
  strcpy(str, "these ");
  strcat(str, "strings ");
  strcat(str, "are ");
  strcat(str, "concatenated.");
  puts(str);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F135F1E174BF5FA1D265DDE)



###  함수 구현 예




```cpp-formatted
/*아래 코드는http://www.jbox.dk/sanos/source/lib/string.c.html에서
 * 가져왔습니다.*/
char *strcat(char *dst, const char *src) {
  char *cp = dst;
  while (*cp) cp++;
  while (*cp++ = *src++)
    ;
  return dst;
}
```





###  연관된 함수

*  [strcpy](http://itguru.tistory.com/79): 문자열을 복사한다.
*  [memcpy](http://itguru.tistory.com/77)  :  메모리 블록을 복사한다.
*  [strncat](http://itguru.tistory.com/82): 문자열에서 일부 문자들만 덧붙인다.
Link :  80
2010-05-09 10:21
----------------
title : C 언어 레퍼런스 - strncpy 함수
cat_title :  strncpy
publish_date : 2010-05-09 10:21
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strncpy

```info
#include <string.h> // C++ 에서는 <cstring>

char * strncpy ( char * destination, const char * source, size_t num );

```

문자열에서 일부 문자들 만을 복사한다.

`source` 에서 `destination` 으로 `source` 의 처음 `num` 개의 문자들 만을 복사(NULL 도 포함해서) 한다.

`num` 보다 `source` 의 문자 수가 더 적다면은 모자란 부분은 0 으로 생각되어서 `destination` 에 복사가 된다. 다시 말해 `source` 가 "abc" 인다, `num` 이 5 라면 `destination` 에는 "abc\0\0" 가 들어가게 된다.

`strncpy` 함수는 복사시 `destination` 끝에 반드시 `NULL` 문자를 붙이는 것이 아니므로 사용에 주의를 해야 한다.



###  인자

`destination`

`destination` 배열을 가리키는 포인터로 문자열이 복사될 곳이다.

`source`

복사 될 C 문자열이다.

`num`

`source` 에서 복사 할 문자의 개수 이다.



###  리턴값




`destination` 을 리턴한다.



###  실행 예제




```cpp-formatted
/*

str2 에  str1 의 첫 5 문자, 즉 "To be" 를 복사해 넣는다. 이 때, str2 에는
자동으로 끝에 NULL 문자가 붙는 것이 아니므로 인위적으로 넣어주어야 한다. 이
예제는 http://www.cplusplus.com/reference/clibrary/cstring/strncpy/ 에서
가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str1[] = "To be or not to be";
  char str2[6];
  strncpy(str2, str1, 5);
  str2[5] = '\0';
  puts(str2);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F135F511C4BF5F68C075CFF)



###  함수 구현 예




```cpp-formatted
/*

다음 소스는
http://www.jbox.dk/sanos/source/lib/string.c.html
에서 가져온 것입니다.

*/
char *strncpy(char *dest, const char *source, size_t count) {
  char *start = dest;

  while (count && (*dest++ = *source++)) count--;
  if (count)
    while (--count) *dest++ = '\0';
  return start;
}
```




###  연관된 함수

*  [strcpy](http://itguru.tistory.com/79): 문자열을 복사한다.
*  [memcpy](http://itguru.tistory.com/77)  :  메모리 블록을 복사한다.
*  [memmove](http://itguru.tistory.com/78):  메모리 블록을 옮긴다.
* memchr  :  메모리 블록에 문자를 위치시킨다.
*  [memcmp](http://itguru.tistory.com/84)  :  두 개의 메모리 블록을 비교한다.
*  [memset](http://itguru.tistory.com/104)  :  메모리 블록을 채운다.
Link :  79
2010-05-02 20:31
----------------
title : C 언어 레퍼런스 - strcpy 함수
cat_title :  strcpy
publish_date : 2010-05-02 20:31
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strcpy

```info
#include <string.h> // C++ 에서는 <cstring>

char * strcpy ( char * destination, const char * source );
```


문자열을 복사한다.

`source` 가 가리키는 C 형식의 문자열 (널 종료 문자열) 을 `destination` 이 가리키는 곳에 복사한다. 이 때, 널도 포함해서 복사한다.

오버플로우를 방지하기 위해서, `destination` 이 가리키는 배열의 크기는 반드시 `source` 문자열의 크기와 같거나 이보다 커야 한다. 또한, 복사하는 영역이 `source` 와 겹치면 안된다.

참고로 위와 같은 오버플로우 문제를 방지하기 위해 `ISO/IEC TR 24731` 에서 제안된 `strcpy_s` 함수를 이용하면 된다. 이 함수는 마이크로소프트 C 런타임 라이브러리와 일부 C 라이브러리에서 사용 가능하다. 

하지만 `GLibc` 와 같은 라이브러리 에서는 지원되지 않는다. 일각에서는 마이크로소프트 컴파일러가 `strcpy` 나 `strncpy` 함수를 사용시 경고 메세지를 뜨게 하는 이유가, 자사의 플랫폼에만 묶어두기 위한 계획이라고도 한다. 이 `strcpy_s` 함수는 만일 `source` 의 크기가 `destination` 보다 크다면 복사를 수행하지 않고 0 이 아닌 값을 리턴하며, (호출자가 리턴값을 무시하였을 때를 대비하여) 버퍼를 비워버린다.



###  간단한 `strcpy` 함수의 구현




별다른 변수들을 사용하지 않고도 다음과 같이 간단하게 구현할 수 있다.

```cpp-formatted
/* 이 소스는 http://www.jbox.dk/sanos/source/lib/string.c.html#:38  에서
 * 가져옴*/
char *strcpy(char *dst, const char *src) {
  char *cp = dst;
  while (*cp++ = *src++)
    ;
  return dst;
}
```




###  인자




`destination`

문자열이 복사될 곳을 가리키는 포인터

`source`

복사할 문자열을 보관하고 있는 포인터



###  리턴값




`destination` 이 리턴된다.



###  실행 예제




```cpp-formatted
/*

str2 에 str1 의 내용, 즉 "Sample string" 을 복사하고, str3 에는 "copy
successful" 을 복사한다. 이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strcpy/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str1[] = "Sample string";
  char str2[40];
  char str3[40];
  strcpy(str2, str1);
  strcpy(str3, "copy successful");
  printf("str1: %s\nstr2: %s\nstr3: %s\n", str1, str2, str3);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1344D41A4BDD61EA254EAF)



###  연관된 함수

*  [strncpy](http://itguru.tistory.com/80) : 문자열에서 일부 문자들을 복사한다.
*  [memcpy](http://itguru.tistory.com/77)  :  메모리 블록을 복사한다.
*  [memmove](http://itguru.tistory.com/78) :  메모리 블록을 옮긴다.
*  [memchr](http://itguru.tistory.com/92)  :  메모리 블록에 문자를 위치시킨다.
*  [memcmp](http://itguru.tistory.com/84)  :  두 개의 메모리 블록을 비교한다.
* `memset`  :  메모리 블록을 채운다.
Link :  78
2010-04-25 18:43
----------------
title : C 언어 레퍼런스 - memmove 함수
cat_title :  memmove
publish_date : 2010-04-25 18:43
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ memmove

```info
#include <string.h> // C++ 에서는 <cstring>

void * memmove ( void * destination, const void * source, size_t num );
```


메모리 블록을 옮긴다.

`source` 가 가리키는 곳 부터 `num` 바이트 만큼을 `destination` 이 가리키는 곳으로 옮긴다. 

메모리 복사 수행시, 중간에 버퍼를 이용하게 되므로 `destination` 과 `source` 의 해당하는 범위가 겹쳐져도 문제는 없다.

`destination` 와 `source` 가 가리키는 타입은 위 함수에서는 상관이 없다. 오직 단순하게 이진 데이터 만을 복사하는 것이기 때문이다. 또한 위 함수는 `source` 의 널 종료 문자를 확인하지 않는다. 언제나 정확히 `num` 바이트 만큼 복사를 수행한다.

오버플로우를 방지하기 위해 `destination` 와 `source` 가 가리키는 배열 모두 적어도 `num` 바이트 이상은 되어야 한다.



###  인자

`destination`

데이터가 복사될 곳을 가리키는 포인터로, 언제나 `void*` 형이다.

`source`

복사할 데이터가 있는 위치를 가리키는 포인터로 언제나 `void*` 형이다.

`num`

복사할 바이트 수 이다.



###  리턴값




`destination` 이 리턴된다.



###  실행 예제




```cpp-formatted
/*

memmove can be very useful...... 에서, 문자열 시작 주소 부터 15 번째 부분 부터
11 바이트, 즉 "very useful" 을 문자열 시작 주소 부터 20 번째 부분, 즉 "use~"
부분에 복사해 넣는다. 다시말해, 위 문자열은 "memmove can be very very useful."
이 된다. 이 예제는 http://www.cplusplus.com/reference/clibrary/cstring/memmove/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str[] = "memmove can be very useful......";
  memmove(str + 20, str + 15, 11);
  puts(str);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F19158D034BDD5D6A30A5D5)





###  연관된 함수

*  [memcpy](http://itguru.tistory.com/77)  :  메모리 블록을 복사한다.
*  [memchr](http://itguru.tistory.com/92)  :  메모리 블록에 문자를 위치시킨다.
*  [memcmp](http://itguru.tistory.com/84)  :  두 개의 메모리 블록을 비교한다.
*  [memset](http://itguru.tistory.com/104)  :  메모리 블록을 채운다.
*  [strncpy](http://itguru.tistory.com/80)  :  문자열에서 문자들을 복사한다.
Link :  77
2010-04-24 22:56
----------------
title : C 언어 레퍼런스 - memcpy 함수
cat_title :  memcpy
publish_date : 2010-04-24 22:56
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ memcpy



```info
#include <string.h> // C++ 에서는 <cstring>

void * memcpy ( void * destination, const void * source, size_t num );
```

메모리의 일부분을 복사한다.

`memcpy` 함수의 인자인 `source` 가 가리키는 곳 부터 `num` 바이트 만큼을 `destination` 이 가리키는 곳에 복사한다.

이 때, `destination` 과 `source` 의 타입은 모두 위 함수와 무관하다. 왜냐하면 이 함수는 단순히 이진 데이터를 복사하는 것이기 때문이다. 또한, 이 함수는 `source` 의 **널 종료 문자(null terminating character)** 을 검사하지 않는다. 언제나 정확히 `num` 바이트 만큼을 복사한다.

오버플로우 문제를 방지하기 위해 `destination` 과 `source` 가 가리키는 배열의 크기는 반드시 `num` 바이트 이상이여야 하며, 서로 겹치면 안된다. (만일 두 메모리 블록이 겹쳐져 있다면 `memmove` 함수를 이용하는 것이 현명하다)



###  인자

`destination`

데이터가 복사될 곳의 주소로, `void*` 형으로 형 변환 되어서 전달된다.

`source`

복사할 데이터들이 위치한 주소로 역시 `void*` 형으로 형 변환 되어서 전달된다.

`num`

복사할 데이터의 바이트 수 이다.



###  리턴값




`destination` 이 리턴된다.



###  실행 예제


```cpp-formatted
/*

첫번째 memcpy 함수는 str2 에 str1 의 문자열 길이 + 1 (끝의 널 문자 때문에 1 을
더해줌) 만큼을 str2 에 복사해 넣는다.

두번째 memcpy 함수는 str3 에 "copy successful\0" 을 복사해 넣는다.

이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/memcpy/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>
int main() {
  char str1[] = "Sample string";
  char str2[40];
  char str3[40];

  memcpy(str2, str1, strlen(str1) + 1);
  memcpy(str3, "copy successful", 16);
  printf("str1: %s\nstr2: %s\nstr3: %s\n", str1, str2, str3);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F110F06254BD40CE9845AFA)



###  연관된 함수


* [memmove](http://itguru.tistory.com/78)  :  메모리의 블록을 옮긴다.
*  [memchr](http://itguru.tistory.com/92)  :  메모리의 특정한 블록에 문자를 쓴다.
*  [memcmp](http://itguru.tistory.com/84)  :  두 메모리 블록을 비교한다.
*  [memset](http://itguru.tistory.com/104)  :  메모리 블록을 채운다.
*  [strncpy](http://itguru.tistory.com/80)  :  문자열에서 특정한 개수의 문자를 복사한다.
Link :  76
2010-04-24 20:37
----------------
title : C 언어 레퍼런스 - string.h (cstring) 헤더파일
cat_title :  string.h (cstring)
publish_date : 2010-04-24 20:37
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ <string.h> (cstring)

이 헤더파일에는 C 형식 문자열 (널 종료 문자열) 을 다룰 수 있는 함수들을 포함하고 있다.

### 문자열 복사 함수


*  [memcpy](http://itguru.tistory.com/77)  :  메모리의 특정한 블록을 복사한다.



*  [memmove](http://itguru.tistory.com/78)  :  메모리의 특정한 블록을 이동시킨다.



*  [strcpy](http://itguru.tistory.com/79)  :  문자열을 복사한다.

*  [strncpy](http://itguru.tistory.com/80):  문자열에서 지정한 부분 만큼 복사한다.


### 문자열 합치는 함수


*  [strcat](http://itguru.tistory.com/81)  :  두 개의 문자열을 합친다.

*  [strncat](http://itguru.tistory.com/82)  :  두 개의 문자열을 지정한 부분 만큼 합친다.


### 문자열 비교 함수


*  [memcmp](http://itguru.tistory.com/84)  :  메모리의 두 부분을 비교한다.

*  [strcmp](http://itguru.tistory.com/85)  :  두 개의 문자열을 비교한다.



*  [strcoll](http://itguru.tistory.com/86)  :   `locale` 을 이용하여 두 개의 문자열을 비교한다.



*  [strncmp](http://itguru.tistory.com/90)  :  두 개의 문자열의 일부분을 비교한다.

*  [strxfrm](http://itguru.tistory.com/91):  `locale` 을 이용하여 문자열을 변환한다.




### 문자열 검색함수 

*  [memchr](http://itguru.tistory.com/92):  메모리 블록에서 특정한 문자를 찾는다.
*  [strchr](http://itguru.tistory.com/93)  :  문자열에서 특정한 문자를 찾아 그 위치를 구한다.
*  [strcspn](http://itguru.tistory.com/94)  :  특정한 문자열에 포함된 문자들을 다른 문자열에서 찾아 가장 먼저 나오는 것을 구한다.
*  [strpbrk](http://itguru.tistory.com/95):  특정한 문자열에 포함된 문자들을 다른 문자열에서 찾아 일치되는 것을 가리킨다.
*  [strrchr](http://itguru.tistory.com/96)  :  문자열에서 특정한 문자를 찾되, 뒤에서 부터 찾는다.
*  [strspn](http://itguru.tistory.com/97)  :  특정한 문자열에서 다른 문자열에 포함되어 있는 부분을 찾되, 처음 부터 연속된 부분으로 구한다.
*  [strstr](http://itguru.tistory.com/101)  :  특정한 문자열을 다른 문자열에서 검색한다.
*  [strtok](http://itguru.tistory.com/102)  :  문자열을 토큰으로 분리한다.


### 다른 잡다한 함수들

*  [memset](http://itguru.tistory.com/104)  :  메모리 블록을 채운다.
*  [strerror](http://itguru.tistory.com/105)  :  오류 메세지 문자열을 가리키는 포인터를 구한다.
*  [strlen](http://itguru.tistory.com/106)  :  문자열의 길이를 잰다.

### 매크로


* NULL  :  널 포인터

### 타입


* size_t  :  부호없는 정수
Link :  75
2010-04-24 17:57
----------------
title : C 언어 레퍼런스 - rewind 함수
cat_title :  rewind
publish_date : 2010-04-24 17:57
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ rewind

```info
#include <stdio.h> // C++ 에서는 <cstdio>

void rewind ( FILE * stream );

```

스트림의 위치 지정자를 맨 처음으로 설정한다.
참고로 위 함수의 작업은

```cpp-formatted
fseek(stream, 0, SEEK_SET);
```

과 정확히 동일하다. 단, [fseek](http://itguru.tistory.com/72)함수와는 달리 `rewind` 함수는 오류 지정자를 초기화 한다.

따라서, 스트림이 읽기 및 쓰기 형식으로 열려있을 경우, `rewind` 함수를 호출함으로써 읽기에서 쓰기 모드로, 쓰기에서 읽기 모드로 변경할 수 있다.



###  인자




`stream`

스트림의 `FILE` 객체를 가리키는 포인터



###  리턴값




없음



###  실행 예제




```cpp-formatted

/*myfile.txt 에 A 부터 Z 까지 출력한 뒤, 다시 pFile 을 파일의 처음으로 옮긴 후
 * 파일의 내용을 읽어들인다. 즉, buffer 에는 A 부터 Z 까지 들어가게 된다. 따라서
 * 화면에는 ABCDEFGHIZKLMNOPQRSTUVWXYZ 가 출력된다.이
 * 예제는http://www.cplusplus.com/reference/clibrary/cstdio/rewind/에서
 * 가져왔습니다.*/
#include <stdio.h>
int main() {
  int n;
  FILE* pFile;
  char buffer[27];
  pFile = fopen("myfile.txt", "w+");
  for (n = 'A'; n <= 'Z'; n++) fputc(n, pFile);
  rewind(pFile);
  fread(buffer, 1, 26, pFile);
  fclose(pFile);
  buffer[26] = '\0';
  puts(buffer);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F2010CA164BD2B5D56CBB0B)

`myfile.txt` 의 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1745BD164BD2B5D502B924)



###  연관된 함수

*  [fseek](http://itguru.tistory.com/72):  스트림 위치 지정자를 설정한다.
*  [fsetpos](http://itguru.tistory.com/73)  :  스트림 위치 지정자를 설정한다.
*  [fflush](http://itguru.tistory.com/57)  :  스트림을 비운다.
Link :  74
2010-04-24 17:37
----------------
title : C 언어 레퍼런스 - ftell 함수
cat_title :  ftell
publish_date : 2010-04-24 17:37
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ ftell

```info
#include <stdio.h> // C++ 에서는 <cstdio>

long int ftell ( FILE * stream );

```

스트림의 위치 지정자의 현재 위치를 구한다.

이진(binary) 스트림의 경우, 리턴된 값이 파일의 시작 부분에서 부터 현재 위치까지의 바이트 수를 말한다.
텍스트 스트림의 경우 위의 경우와는 조금 다르게,파일의 시작 부분으로 부터 현재 위치 까지의 바이트 수라고 단정짓기 힘들다.

(이진 스트림과 텍스트 스트림에 대해 자세히 알고 싶다면 [stdio.h](http://itguru.tistory.com/34)를 참조) 하지만, 이 리턴된 값을 가지고 [fseek](http://itguru.tistory.com/72)함수를 이용하면 현재의 위치로 파일 위치 포인터를 설정할 수 있다.



###  인자


`stream`

작업을 수행할 스트림의 `FILE` 객체를 가리키는 포인터



###  리턴값




성공적으로 수행하였다면 현재의 위치 포인터가 가진 값이 리턴된다.
만일 오류가 발생하였다면 `NULL` 이 리턴되고, 전역 변수 `errno` 의 값은 양수로 설정된다. [perror](http://itguru.tistory.com/53)함수를 통해 `errno` 의 값을 해석할 수 있다.



###  실행 예제




```cpp-formatted
/*

파일 전체의 크기를 읽어온다. pFile 을 파일 끝으로 선택한 뒤, ftell 함수를 통해서
파일 처음 부터 pFile 까지, 즉 파일 처음 부터 끝 까지의 바이트 수를 계산한다. 이
예제는 http://www.cplusplus.com/reference/clibrary/cstdio/ftell/ 에서
가져왔습니다.

 */
#include <stdio.h>
int main() {
  FILE* pFile;
  long size;

  pFile = fopen("myfile.txt", "rb");

  if (pFile == NULL)
    perror("Error opening file");
  else {
    fseek(pFile, 0, SEEK_END);
    size = ftell(pFile);
    fclose(pFile);
    printf("Size of myfile.txt: %ld bytes.\n", size);
  }
  return 0;
}
```


`myfile.txt` 의 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1858FF104BD2ACF234484A)

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F134E27104BD2ACF2879D3F)




###  연관된 함수

*  [fseek](http://itguru.tistory.com/72)  :  스트림 위치 지정자를 다시 조정한다.
*  [fgetpos](http://itguru.tistory.com/70):  스트림의 위치 지정자의 현재 위치를 구한다.
*  [rewind](http://itguru.tistory.com/75)  :  스트림 위치 지정자를 맨 처음으로 설정한다.
Link :  102
2010-11-27 20:07
----------------
title : C 언어 레퍼런스 - strtok 함수
cat_title :  strtok
publish_date : 2010-11-27 20:07
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strtok



```info
#include <string.h> // C++ 에서는 <cstring>

char * strtok ( char * str, const char * delimiters );
```

문자열을 토큰들로 분리한다.

이 함수를 여러분 호출함해서 문자열을 토큰들로 분리할 수 있다. 이 때 토큰(token) 은 구분문자(delimiter) 로 쪼개진 문자열 조각을 의미한다.

이 함수에 `str` 에 쪼개고자 하는 문자열을 전달하면 `str` 의 첫번째 문자 부터 토큰들의 위치를 찾아내게 된다. 이 다음에 인자로 `NULL` 을 전달하며 함수를 호출하게 된다면 이전에 찾았던 토큰 바로 다음 문자 부터 시작하여 토큰들의 위치를 찾게 된다.

토큰들의 시작과 끝을 결정하기 위해서 `strtok` 함수는 구분 문자를 포함하지 않는 가장 첫번째 문자 부터 (이 문자가 토큰의 시작이 된다) 그 다음으로 등장하는 첫번째 구분 문자가 토큰의 마지막이 된다. 이 때, 토큰의 마지막은 (구분 문자가 있었을 곳) 은 함수에 의해 널 문자로 바뀌며 이 토큰의 시작 주소가 리턴된다.

만일 `strtok` 에서 맨 처음에 `str` 에 인자로 전달하였던 문자열의 종료 널 문자에 도달하게 된다면 그 후의 `str` 에 널을 전달하는 모든 호출에서는 널 포인터를 리턴하게 된다. 물론 나중에 `str` 에 다른 문자열을 전달한다면 그 문자열을 토큰으로 분리하기 시작할 것이다.



###  인자




`str`

토큰으로 불리할 C 형식 문자열이다. 만일 기존에 `str` 에 전달하였던 문자열을 계속 토큰으로 분리해 나가고 싶다면 `str` 에 널을 전달하면 된다.

`delimiters`

구분 문자들을 포함하고 있는 C 형식 문자열이다.



###  리턴값




문자열에서 찾은 마지막 토큰의 주소값을 리턴하며 토큰이 더이상 없다면 널 포인터를 리턴한다.



###  구현 예


```cpp-formatted
/*

이 소스는
http://research.microsoft.com/en-us/um/redmond/projects/invisible/src/crt/strtok.c.htm
에서 가져왔습니다.

*/

char *__cdecl strtok(char *s1, const char *delimit) {
  static char *lastToken = NULL; /* UNSAFE SHARED STATE! */
  char *tmp;                     /* Skip leading delimiters if new string. */
  if (s1 == NULL) {
    s1 = lastToken;
    if (s1 == NULL) /* End of story? */
      return NULL;
  } else {
    s1 += strspn(s1, delimit);
  } /* Find end of segment */
  tmp = strpbrk(s1, delimit);
  if (tmp) { /* Found another delimiter, split string and save state. */
    *tmp = '\0';
    lastToken = tmp + 1;
  } else { /* Last segment, remember that. */
    lastToken = NULL;
  }
  return s1;
}
```




###  실행 예제


```cpp-formatted
/*' ', ',', '-', '.' 들을 구분 문자로 이용하여 - This, a sample string. 이라는
 * 문자열을 토큰들로 분리한다.이 예제는
 * http://www.cplusplus.com/reference/clibrary/cstring/strtok/ 에서 가져왔습니다
 */
#include <stdio.h>
#include <string.h>
int main() {
  char str[] = "- This, a sample string.";
  char* pch;
  printf("Splitting string \"%s\" into tokens:\n", str);
  pch = strtok(str, " ,.-");
  while (pch != NULL) {
    printf("%s\n", pch);
    pch = strtok(NULL, " ,.-");
  }
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F1415910C4CF0E82149948F)




###  연관된 함수
* [strcspn](http://itguru.tistory.com/94)  :  특정한 문자를 찾을 때 까지의 길이를 구한다.
* [strpbrk](http://itguru.tistory.com/95)  :  문자열에서 특정한 문자를 찾는다.
Link :  101
2010-11-27 17:23
----------------
title : C 언어 레퍼런스 - strstr 함수
cat_title :  strstr
publish_date : 2010-11-27 17:23
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strstr



```info
#include <string.h> // C++ 에서는 <cstring>

const char * strstr ( const char * str1, const char * str2 );
      char * strstr (       char * str1, const char * str2 );
```


문자열을 검색한다.

`str1` 에서 `str2` 를 검색하여 가장 먼저 나타나는 곳의 위치를 리턴한다. 이 때 일치하는 문자열이 없다면 널 포인터를 리턴하게 된다. 검색에서 마지막 널 문자는 포함하지 않는다.



###  인자




`str1`

검색이 수행되는 C 형식 문자열

`str2`

찾을 C 형식 문자열



###  리턴값




`str1` 에서 `str2` 를 찾았다면 가장 먼저 나오는 곳의 위치를 리턴한다. 만일 `str2` 가 `str1` 에 존재하지 않는다면 널을 리턴한다.



###  구현 예




```cpp-formatted
/*이 소스는 http://www.jbox.dk/sanos/source/lib/string.c.html에서 가져왔습니다*/
char *strstr(const char *str1, const char *str2) {
  char *cp = (char *)str1;
  char *s1, *s2;
  if (!*str2) return (char *)str1;
  while (*cp) {
    s1 = cp;
    s2 = (char *)str2;
    while (*s1 && *s2 && !(*s1 - *s2)) s1++, s2++;
    if (!*s2) return cp;
    cp++;
  }
  return NULL;
}
```




###  문자열 검색에 관련된 알고리즘


통상적으로 구현된 `strstr` 함수는 위에서 사용된 코드 처럼 단순하게도 각 문자열을 일일히 검색하는 방식을 취하고 있다. 이는 짧은 문자열을 검색하는데 에는 요긴하게 사용될 수 있지만 문자열의 길이가 길어진다면, 예를 들어 수십장 짜리 문서에서 특정 단어를 찾을 때 에는 적합하지 않은 방식이라 할 수 있다.

이를 위해 여러가지 문자열 검색 알고리즘이 있는데 대표적으로 사용되는 것이 보이어 무어(Boyer-Moore) 알고리즘 이다. (이는 현재 대부분의 워드 프로세서에서 '찾기' 기능에 사용되고 있다) 그 외에도 카프- 라빈(Karp-Rabin) 검색 알고리즘, 크누스 - 모리스 - 프랫(Knuth - Morris - Pratt, KMP) 알고리즘 등이 있지만 여기서는 보이어 무어 알고리즘만 소개한다.

**보이어 무어(Boyer - Moore)** 알고리즘은 크게 두 가지 종류의 이동으로 구성되어 있는데 하나는 **착한 접미부 이동(Good Suffix Shift)** 와 다른 하나는 **나쁜 문자 이동(Bad Character Shift)** 이다. 가장 먼저 착한 접미부 이동이 무엇인지 보자


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F1733B5304CF0C6110482E0)

위와 같이 `y` 라는 문자열에서 `x` 라는 문자열을 찾는다고 하자. 보이어 무어 알고리즘의 특징은, 문자열의 이동 자체는  왼쪽에서 오른쪽으로 쭉 가면서 찾지만 정작 문자열의 비교는 오른쪽에서 왼쪽으로 한다. 따라서 만일 특정 위치에서 `x` 와 `y` 를 비교하는데, 오른쪽의 `u` 만큼의 부분이 일치되었다고 하자 (위 그림에서 `u` 라고 표시된 부분, 이 부분을 가리켜 '착한 접미부(Good Suffix)' 라고 부른다) 

그리고 왼쪽의 'b' 와 'a' 가 일치하지 않은 부분이라고 하자. 이렇게 된다면 보이어 무어 알고리즘에서는 `x` 를 문자열 `x` 의 또다른 착한 접미부가 나오는 곳과 기존의 착한 접미부가 있던 곳으로 오게 오른쪽으로 쉬프트를 하게 된다. 위 그림에서 보듯이 기존에 `u` 가 위치했던 곳에 `x` 의 또다른 `u` 가 일치되었음을 볼 수 있다. 예를 들어 아래의 그림을 보면 단박에 이해가 된다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F142E0E034CF0CA1F31835B)


  위와 같이 또다른 접미부에 도달하게 문자열을 이동시키는 것이다. 그리고는 다시 이동 시킨 문자열의 맨 오른쪽으로 부터 검사를 수행한다. 그런데, 만일 문자열에 또다른 착한 접미부가 없다면 어떻게 될까.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F206642334CF0CD0C22CED4)

그렇게 된다면 일치하는 착한 접미부에서 `x` 에 들어있는 가장 긴 접미부를 찾게 된다. 위 그림에서는 `v` 가 착한 접미부 `u` 중 `x` 에 들어있는 가장 긴 접미부가 된다. 그리고 `v` 가 일치되게 오른쪽으로 쉬프트를 하게 된다. 이 과정을 예를 들어 보면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F164CEE334CF0CD0C5BB5A3)

와 같이 나타난다.

그런데 만일 착한 접미부가 나타나지 않는다면 어떻게 될까. 예를 들면 아래와 같은 상황이다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1345DF044CF0CFB9517DC5)

이렇게 처음 부터 불일치 되는 문자를 '나쁜 문자' 라 부르며 여기서 검색하는 문자열의 문자가 해당된다. 즉, 위 경우 나쁜 문자는 'b' 가 된다. 이렇게 나쁜 문자가 오는 경우는 검색하는 문자열에서 가장 오른쪽에 나타나는 나쁜 문자를 찾아서 그 위치로 이동 시켜 주면 된다. 즉, 아래 처럼 된다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1348DC054CF0D04946E324)

만일 나쁜 문자가 포함되어 있지 않는다면 그 문자열 전체 길이 만큼 오른쪽으로 쉬프트 해주면 된다.

위와 같이 보이어 무어 알고리즘은 두 개의 쉬프트로 구성되어 있는데, 각 쉬프트를 빠르게 처리하기 위해 테이블을 만든다. 테이블을 만드는 과정은 간단하므로 생략하도록 한다. (테이블을 만드는 방법을 보시려면 [http://xenostudy.tistory.com/72](http://xenostudy.tistory.com/72)로 들어가보시기 바랍니다)

이를 바탕으로 코드를 짜보면 아래와 같이 된다.

```cpp-formatted
/*

참고로 다음 코드는
http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm 에서
가져왔습니다.

테이블을 생성하는 함수는
나쁜 문자 이동의 경우 static void prepare_badcharacter_heuristic,
착한 접미부 이동의 경우 void prepare_goodsuffix_heuristic 이다.

*/
#include <limits.h>
#include <string.h>

#define ALPHABET_SIZE (1 << CHAR_BIT)

static void compute_prefix(const char *str, size_t size, int result[size]) {
  size_t q;
  int k;
  result[0] = 0;

  k = 0;
  for (q = 1; q < size; q++) {
    while (k > 0 && str[k] != str[q]) k = result[k - 1];

    if (str[k] == str[q]) k++;
    result[q] = k;
  }
}

static void prepare_badcharacter_heuristic(const char *str, size_t size,
                                           int result[ALPHABET_SIZE]) {
  size_t i;

  for (i = 0; i < ALPHABET_SIZE; i++) result[i] = -1;

  for (i = 0; i < size; i++) result[(size_t)str[i]] = i;
}

void prepare_goodsuffix_heuristic(const char *normal, size_t size,
                                  int result[size + 1]) {
  char *left = (char *)normal;
  char *right = left + size;
  char reversed[size + 1];
  char *tmp = reversed + size;
  size_t i;

  /* reverse string */
  *tmp = 0;
  while (left < right) *(--tmp) = *(left++);

  int prefix_normal[size];
  int prefix_reversed[size];

  compute_prefix(normal, size, prefix_normal);
  compute_prefix(reversed, size, prefix_reversed);

  for (i = 0; i <= size; i++) {
    result[i] = size - prefix_normal[size - 1];
  }

  for (i = 0; i < size; i++) {
    const int j = size - prefix_reversed[i];
    const int k = i - prefix_reversed[i] + 1;

    if (result[j] > k) result[j] = k;
  }
}
/*
 * Boyer-Moore search algorithm
 */
const char *boyermoore_search(const char *haystack, const char *needle) {
  /*
   * Calc string sizes
   */
  size_t needle_len, haystack_len;
  needle_len = strlen(needle);
  haystack_len = strlen(haystack);

  /*
   * Simple checks
   */
  if (haystack_len == 0) return NULL;
  if (needle_len == 0) return haystack;

  /*
   * Initialize heuristics
   */
  int badcharacter[ALPHABET_SIZE];
  int goodsuffix[needle_len + 1];

  prepare_badcharacter_heuristic(needle, needle_len, badcharacter);
  prepare_goodsuffix_heuristic(needle, needle_len, goodsuffix);

  /*
   * Boyer-Moore search
   */
  size_t s = 0;
  while (s <= (haystack_len - needle_len)) {
    size_t j = needle_len;
    while (j > 0 && needle[j - 1] == haystack[s + j - 1]) j--;

    if (j > 0) {
      int k = badcharacter[(size_t)haystack[s + j - 1]];
      int m;
      if (k < (int)j && (m = j - k - 1) > goodsuffix[j])
        s += m;
      else
        s += goodsuffix[j];
    } else {
      return haystack + s;
    }
  }

  /* not found */
  return NULL;
}
```




###  실행 예제





```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strstr/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str[] = "This is a simple string";
  char* pch;
  pch = strstr(str, "simple");
  strncpy(pch, "sample", 6);
  puts(str);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F187E1D1A4CF0D1AF0A3D05)




###  연관된 함수


*  [strspn](http://itguru.tistory.com/97)  :  특정한 문자열이 포함된 정도를 구한다.
*  [strpbrk](http://itguru.tistory.com/95): 어떠한 문자열들의 문자들을 키로 하여 특정 문자열에서 그 키들을 검색한다.
*  [strchr](http://itguru.tistory.com/93)  : 특정 문자열에서 특정 문자가 첫번째로 나타나는 곳의 위치를 구한다.
Link :  99
2010-11-21 11:56
----------------
title : 씹어먹는 C 언어 - <21. 매크로 함수, 인라인 함수>
cat_title : 21. 매크로 함수, 인라인 함수
next_page : 103
publish_date : 2010-11-21 11:56
--------------

이번 강좌에서는

* 매크로 함수에 대해 배운다

* 인라인 함수에 대해 배운다.


![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분. 저의 36 번째 강좌가 시작되었습니다. 요즘에 뒤로 갈 수 록 강좌들의 댓글 수가 적어지는 것을 보아 처음에 큰마음 먹고 강좌 보기를 시작하였다가 시간적 여유의 한계나 온라인 상의 한계를 느끼고 포기하신 분들이 많은 것 같은데 과연 누가 여기 까지 성공적으로 달려왔는지 궁금하네요. 전체 강좌의 앞부분은 C 언어 자체를 아는데 주력하였다면 후반으로 갈 수록 C 언어 자체를 이해하기 보다는 C 언어와 친해지는 과정으로 진행이 되고 있습니다.

아무튼. 적어도 제 강좌만 다 이해한다면 C 의 기초 부분은 훌륭하게 다진 프로그래머로 만들어 줄 수 있으니 열심히 따라와주세요:)


###  매크로 함수


```cpp-formatted
/* 매크로 함수*/
#include <stdio.h>
#define square(x) x *x

int main(int argc, char **argv) {
  printf("square(3) : %d \n", square(3));

  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F1574AB204C597BDD8BE6F9)

와 같이 나옵니다.

매크로 함수를 정의하는 방법은 아래와 같습니다.

```info
#define 함수 이름(인자) 치환할 것
```


그렇다면

```cpp-formatted
#define square(x) x* x
```


위 문장의 의미는 `square` 라는 이름의 매크로 함수고 인자로 `x` 를 `x*x` 로 치환한다는 의미 입니다. `#define` 문은 앞서 배웠듯이 '어떠한 것을 다른 것으로 치환해주는 것' 이라고 배웠습니다. 여기서도 그 역할이 똑같습니다. `squre(x)` 부분을 `x*x` 로 치환해주게 되지요. 따라서

```cpp-formatted
printf("square(3) : %d \n", square(3));
```


위 문장은

```cpp-formatted
printf("square(3) : %d \n", 3 * 3);
```


과 정확히 동일하게 됩니다. 위와 같은 것을 '매크로 함수' 라 부르는 이유는 정말 하는 일이 함수와 비슷하기 때문입니다. 만일 우리가 `int squre(x)` 라는 함수를 만들어서 `x*x` 를 리턴하게 하였다면 말그대로 `3*3` 이 리턴될 것이지요. 하지만 이 매크로 함수와 진짜 함수는 엄연한 차이가 있습니다.

```cpp-formatted
printf("square(3) : %d \n", square(3));
```


우리가 컴파일러라고 생각하고 위 문장을 어떻게 해석할지 봅시다. 만일 `int squre(int x)` 라는 실제 함수가 있다면 '`square` 라는 함수를 호출해서 인자에 3 을 전달하고 9 를 리턴한다' 가 됩니다. 하지만 매크로 함수는 위 문장이 컴파일 되기 전에 전처리기에 의해 그냥

```cpp-formatted
printf("square(3) : %d \n", 3 * 3);
```


로 바뀌어 버립니다. 여기서 중요한 점은 '컴파일 되기 전에' 부분에 있지요. 다시 말해 컴퓨터는 함수를 호출하고 뭐시기 뭐시기 하는 부분 없이 그냥 `3*3` 을 계산해 버립니다. 이는 앞서 보았던 `#define` 문을 통한 치환과 동일합니다.

```cpp-formatted
/* 매크로 함수*/
#include <stdio.h>
#define square(x) x *x

int main(int argc, char **argv) {
  printf("square(3) : %d \n", square(3 + 1));

  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F112AFA224C8F0EC197F54B)

흠. 조금 놀라운 결과가 나왔습니다.

분명히

```cpp-formatted
printf("square(3) : %d \n", square(3 + 1));
```


위 문장에서 우리의 의도는 `4*4` 를 계산하는 것이였을 것입니다. 그런데 16 이 아니라 전혀 엉뚱한 답인 7 이 나왔습니다. 도대체 왜 이런 일이 벌어진 것일까요? 제가 아까 한 말, 매크로 함수는 단순히 '싹 치환해 버리는 것이다' 라는 것을 상기 시켜 보세요. 전처리기에서 `square(3+1)` 이 어떻게 바뀔지 말이지요. 단순히 생각해보면

```cpp-formatted
printf("square(3) : %d \n", 3 + 1 * 3 + 1);
```


이 됩니다. 그런데 놀랍게도 맞습니다. 컴퓨터는 실제로 위 문장을 위와 같이 치환해버립니다. 따라서 결과적으로 7 이 출력된 것이지요. 이러한 문제를 해결하기 위해서는 어떻게 해야 할까요. 방법은 단순합니다.

```cpp-formatted
#define square(x) x* x
```


를

```cpp-formatted
#define square(x) (x) * (x)
```


로 바꾸어 주기만 하면 됩니다. 그렇게 된다면 `printf` 안에 있었던 문장은

```cpp-formatted
printf("square(3) : %d \n", (3 + 1) * (3 + 1));
```


가 되어 16 이 성공적으로 출력될 것입니다.

```cpp-formatted
/* 라디안에서 도로 바꾸기*/
#include <stdio.h>
#define RADTODEG(x) (x) * 57.295

int main(int argc, char **argv) {
  printf("5 rad 는 : %f 도", RADTODEG(5));

  return 0;
}
```

  성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1904F7164C8F12790B161E)

아마 위 소스 코드의 내용 보다 라디안(radian) 이 무엇인지 모르는 분들이 더 많을 듯 한데, 그냥 말하자면 원주의 길이와 반지름의 길이의 비를 이용해 각도를 나타내는 단위로 자세한 내용은 생략하고 여기서는 단순히 `1 rad` 는 `57.295` 도 라는 것만 아시면 됩니다.

```cpp-formatted
#define RADTODEG(x) (x) * 57.295
```


위와 같이 라디안에서 각도로 변환하는 매크로 함수를 정의하였습니다. 그리고 `printf` 에서

```cpp-formatted
printf("5 rad 는 : %f 도", RADTODEG(5));
```


와 같이 매크로 함수를 이용하였을 때

```cpp-formatted
printf("5 rad 는 : %f 도", 5 * 57.295);
```


로 잘 바뀌어 값이 잘 출력되었습니다. 물론 `RADTODEG(1+4)` 를 하더라도 `(1+4) * 57.295` 로 잘 바뀌어 원하는 결과를 출력할 수 있게 되지요. 그렇다면 위와 같이 정의한 `RADTODEG` 는 문제가 없을까요?

한 5 초 만 생각해보세요. 위와 같이 완벽하게 잘 정의했다고 하더라도 문제는 있습니다. 바로 아래와 같은 문장이지요

```cpp-formatted
printf("5 rad 는 : %f 도", 1 / RADTODEG(5));
```


위 문장은 전처리기에 의해

```cpp-formatted
printf("5 rad 는 : %f 도", 1 / 5 * 57.295);
```


로 바뀝니다. 이는 우리가 원하는 결과인 `1 / (5 * 57.295)` 와 전혀 다른 것이지요. 이와 같은 문제를 막기 위해서 역시 전체 수식을 소괄호로 감싸 `#define RADTODEG(x) ((x) * 57.295)`와 같이 만들어야 합니다. 상당히 귀찮은 일이지요. 사소한 실수 하나로 꽤 큰 문제가 초래될 수 있으니까요.

```cpp-formatted
/* 변수의 이름 출력하기 */
#include <stdio.h>
#define PrintVariableName(var) printf(#var "\n");

int main(int argc, char **argv) {
  int a;

  PrintVariableName(a);

  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F140BEE1D4C8F14514649BF)

와 같이 잘 나옵니다.

```cpp-formatted
#define PrintVariableName(var) printf(#var "\n");
```


위 문장의 의미 부터 살펴봅시다. `#define` 과 같은 전처리기 문에서만 사용되는 것을 `#` 이 있는데, 어떠한 인자 앞에 `#` 을 붙이게 되면 이 인자를 문자열로 바꾸어 버립니다. 따라서

```cpp-formatted
PrintVariableName(a);
```


은

```cpp-formatted
printf(
  "a"
  "\n");
```


으로 바뀌게 되지요. 이 때 C 언어에서 연속한 두 개의 문자열은 그냥 하나로 합쳐지므로 위 코드는 그냥

```cpp-formatted
printf("a\n");
```


와 동일하게 됩니다. 따라서 결과적으로 `a` 가 화면에 출력되는 것이지요. 여러분은 `#` 가 붙으면 단순히 '이 것을 문자열로 바꾼다' 라고 생각만 해주시면 됩니다.

```cpp-formatted
/* ## 의 사용 */
#include <stdio.h>
#define AddName(x, y) x##y

int main(int argc, char **argv) {
  int AddName(a, b);

  ab = 3;

  printf("%d \n", ab);

  return 0;
}
```

  성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F114F850C4C8F1D4D15BA94)

와 같이 나옵니다.

이번에는 `#` 의 친구 격인 `##` 에 대해 보도록 합시다. 한 가지 명심할 점은 `#` 나 `##` 모두 '전처리기 문' 에서만 사용할 수 있다는 것입니다. 즉 `#define` 에서만 사용할 수 있다는 정도로만 알아두세요. `##` 문은 아마 짐작했지만 입력된 것을 하나로 '합쳐주는' 역할을 합니다.

```cpp-formatted
#define AddName(x, y) x##y
```


위와 같이 `AddName` 에서는 `x##y` 는 `x` 에 있는 것과 `y` 에 있는 것을 하나로 합쳐줍니다. 따라서


```cpp-formatted
int AddName(a, b);
```


이 부분은 전처리기에 의해

```cpp-formatted
int ab;
```


로 정확히 치환됩니다. 따라서 컴파일러는 `ab` 라는 이름의 변수를 선언하게 되고 그 뒤로 쭉 가는 것이지요.

매크로함수가 위와 같이 여러 편리한 점들은 있지만 앞서 집고 나간 것 처럼 여러가지 어려운 문제점들도 많습니다. 위에서 처럼 괄호를 제대로 쓰지 않아 오류가 나는 경우가 많은데 이 경우 디버깅하기가 매우 까다롭기 때문에 오랜 시간을 잡아먹는 경우도 많습니다. 이러한 문제를 해결하기 위해 C 언어에서는 또다른 해결책을 제시하였는데요, 이는 바로 **인라인(inline)** 함수 입니다.


###  인라인 함수

```cpp-formatted
/* 인라인 함수 */

#include <stdio.h>
__inline int square(int a) { return a * a; }
int main(int argc, char **argv) {
  printf("%d", square(3));

  return 0;
}
```




성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F12778B224C8F233008B8C8)


음. 일단 내용만을 보아서는 크게 어렵지 않습니다.


```cpp-formatted
__inline int square(int a) { return a * a; }
```



위 부분은 `__inline` 을 빼고 본다면 단순히 `square` 라는 함수를 만든데 지나지 않습니다. 또한 `printf` 에서도 역시 함수를 호출했던 것처럼 똑같은 방식으로

```cpp-formatted
printf("%d", square(3));
```


로 사용하고 있지요. 하지만 이는 함수와는 전혀 다른 행동을 합니다. 함수의 경우 호출을 하게 되면 프로그램의 흐름이 완전히 다른 곳으로 넘어가게 됩니다. 예를 들어서

```cpp-formatted
int cubic(int a) { return a * a * a; }
```
와 같은 세제곱을 하는 ‘평범한’ 함수 하나를 만들고, `main` 함수에서

```cpp-formatted
int main(int argc, char **argv) {
  printf("%d", cubic(3));
  return 0;
}
```

와 같이 `cubic` 함수를 호출을 하게 된다면, `cubic (3)` 을 실행 시, 프로그램의 흐름이 `main` 함수를 벗어나 메모리 어딘가에 위치한 `cubic` 함수에 찾아가서 인자로 3 을 전달하고 27 을 리턴하는데, 그 리턴값을 가지고 다시 `main` 함수로 돌아오게 되는 것이지요. 이렇게 함수를 사용하게 되면 프로그램의 흐름이 기존의 함수 내부에서 벗어나 다른 함수에 들렸다가 오게 되는데 이러한 과정을 줄여서 ‘함수를 호출하는 과정’ 이라고 말하게 됩니다.

이렇게 함수를 호출하게 된다면 단순히 `a` 를 세 번 곱하는 작업인데도 시간이 꽤 걸리게 되죠. 즉 `cubic` 함수처럼 단순한 작업만을 하는 함수의 경우에는 굳이 함수로 따로 만들 필요 없이 차라리 `main` 함수 내에서

```cpp-formatted
printf("%d", 3 * 3 * 3);
```



으로 하는 것이 훨씬 효율적일 것입니다.

이러한 생각을 살려 만든 것이 `inline` 함수 입니다. 위에서 `inline` 형식으로 만든 `square` 함수는 우리가 생각하는 함수가 전혀 아닙니다. 단순히 ‘함수 처럼 보이는 것’ 일 뿐이지요. `inline` 함수를 사용하게 되면 마치 매크로 함수처럼

```cpp-formatted
int main(int argc, char **argv) {
  printf("%d", square(3));
  return 0;
}
```



위 코드가

```cpp-formatted
int main(int argc, char **argv) {
  printf("%d", 3 * 3);
  return 0;
}
```

과 정확히 동일해집니다. 한 가지 매크로 함수와 차이점이 있다면 매크로 함수와는 달리 인라인 함수는 전처리기가 무식하게 치환해 버리는 것이 아닙니다. 매크로 함수를 사용 했었을 때 에는 전처리기가 무식하게 치환해 버리는 바람에 연산자 우선 순위를 정확하게 고려해서 괄호도 적당히 묶어주고 해야겠지만 인라인 함수의 경우 똑똑한 컴파일러가 인라인 함수를 사용한 문장 내부에서 적절하게 ‘우리가 보통 함수를 사용하는 것처럼’ 바꿔 줍니다.

다시 말해

```cpp-formatted
int main(int argc, char **argv) {
  printf("%d", square(3 + 1));
  return 0;
}
```

과 같은 문장은 우리가 보통 함수를 사용 하는 것처럼 처리가 되기 때문에 똑똑하게

```cpp-formatted
int main(int argc, char **argv) {
  printf("%d", (3 + 1) * (3 + 1));
  return 0;
}
```

이 됩니다.

```cpp-formatted
/* 다른 인라인 함수 예제*/
#include <stdio.h>
__inline int max(int a, int b) {
  if (a > b)
    return a;
  else
    return b;
}
int main(int argc, char **argv) {
  printf("3 과 2 중 최대값은 : %d", max(3, 2));
  return 0;
}
```



성공적으로 컴파일 하였다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F11402F164CE8823F55E151)


와 같이 나옵니다.

이번에도 역시 인라인 함수를 사용하였습니다. 컴파일러는 `max(3,2)` 라는 문장을 보고 `max` 함수 내부의 코드를 어떻게 하면 `printf` 안에 쑤셔 놓을 수 있을지 고민을 하게 되는데, 만일 쑤셔 놓을 수 있다면 인라인 함수의 역할이 발휘되는 것이고 쑤셔 놓을 수 없다고 판명된다면 단순히 `int` 형을 ‘리턴’ 하는 함수로 간주하여 보통 함수처럼 생각하게 됩니다. 즉, `inline` 키워드를 빼버린다고 보면 됩니다.

다행히도 이 `max` 함수의 경우 한 문장으로 표현할 수 있는데 아마 컴파일러는 이 함수의 내용을 아마

```cpp-formatted
int main(int argc, char **argv) {
  printf("%d 과 %d 중 최대값은 : %d \n", 3, 2, 3 > 2 ? 3 : 2);
  return 0;
}
```


같은 문장으로 변환 시켜서 3 이 출력되게 할 것입니다.

여태까지 인라인 함수와 매크로 함수를 살펴 보았는데, 많은 사람들은 매크로 함수 보다는 인라인 함수를 사용하도록 권장하고 있습니다. 이 때문에 원래는 C 표준에 없던 인라인 함수가 `C99` 라는 새로운 C 표준에 포함된 것만 보아도 알 수 있습니다. 인라인 함수는 매크로 함수와는 달리 ‘컴파일러’ 가 처리하기 때문에 훨씬 더 똑똑하게 동작하는데 일단, 매크로 함수와는 달리 인라인 함수는 인자들의 타입을 확인합니다. 또한 인라인 함수는 매크로와는 달리 단순 치환을 하는 것이 아니라 진짜 함수 처럼 동작하기 때문에 훨씬 구현하기 쉽고 편리합니다. 뿐만 아니라 디버깅 역시 인라인 함수가 편리하지요.

앞으로 여러분들은 단순한 작업들을 보기 편하게 함수로 처리하고 싶을 때 에는 인라인 함수들을 적극적으로 사용하였으면 합니다 :)


### 생각 해 보기

#### 문제 1

다음과 같은 인라인 함수를 여러분이 컴파일러라면 어떻게 하나의 문장으로 바꿀 수 있는지 생각해보세요.

```cpp-formatted
__inline int some_function(int a) {
  if (a == 0)
    return 1;
  else if (a == 1)
    return 3;
  else
    return a * 2;
}
```

##@ chewing-c-end
Link :  97
2010-11-21 11:56
----------------
title : C 언어 레퍼런스 - strspn 함수
cat_title :  strspn
publish_date : 2010-11-21 11:56
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strspn

```info
#include <string.h> // C++ 에서는 <cstring>

size_t strspn ( const char * str1, const char * str2 );
```


`str2` 의 문자들만을 포함하고 있는 `str1` 의 처음 부분의 길이를 구한다.
다시 말하면 `str2` 에 "12346" 이 들어있고 `str1` 에는 "321ab" 가 들어 있다면 `str1` 의 맨 처음 부터 문자들을 비교하는데, `str2` 에 들어 있는 문자들 만을 포함한 곳 까지의 길이, 즉 이 경우에는 `3,2,1` 이 해당하므로 3 이 리턴된다. 이 때 중요한 점은 `str1` 의 맨 처음 부터 비교한다는 점인데 만일 `str1` 에 "ab321" 이였다면 리턴값이 0 이 된다.



###  인자




`str1`

검색을 수행되는 C 문자열

`str2`

검색할 문자들을 포함하고 있는 문자열



###  리턴값




`str1` 에서 오직 `str2` 에 포함되어 있는 문자들만이 있는 부분의 길이로, `str1` 의 맨 처음 부분 부터 잰다. 따라서 만일 `str1` 에 있는 모든 문자들이 `str2` 에 포함되어 있다면 리턴값은 `str1` 의 길이와 동일하겠지만, 만일 `str1` 에 있는 첫 번째 문자가 `str2` 에 없다면 리턴값은 0 이 된다.



###  구현 예


```cpp-formatted
/*

 이 소스는
http://www.jbox.dk/sanos/source/lib/string.c.html
에서 가져왔습니다.

*/

size_t strspn(const char *string, const char *control) {
  const unsigned char *str = string;
  const unsigned char *ctrl = control;
  unsigned char map[32];
  int count;  // Clear out bit map
  for (count = 0; count < 32; count++)
    map[count] = 0;  // Set bits in control map
  while (*ctrl) {
    map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    ctrl++;
  }  // 1st char NOT in control map stops search
  if (*str) {
    count = 0;
    while (map[*str >> 3] & (1 << (*str & 7))) {
      count++;
      str++;
    }
    return count;
  }
  return 0;
}
```

위 예는 상당히 복잡하고도 참신한 아이디어를 방법으로 `strspn` 함수를 구현하였는데, 위 코드에 대한 자세한 설명을 위해서는 [http://itguru.tistory.com/94](http://itguru.tistory.com/94) 를 참조하면 된다.



###  실행 예제

```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strstr/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  int i;
  char strtext[] = "129th";
  char cset[] = "1234567890";

  i = strspn(strtext, cset);
  printf("The length of initial number is %d.\n", i);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F207075134CE88952A5D63C)



###  연관된 함수

*  [strcspn](http://itguru.tistory.com/94): 특정한 문자열을 키로 하여 다른 문자열을 검색하되 첫번째로 검색된 곳의 거리를 리턴
*  [strstr](http://itguru.tistory.com/101)  :    특정한 문자열을 키로 하여 다른 문자열에서 '키' 의 위치를 리턴
*  [strncmp](http://itguru.tistory.com/90)  :   두 문자열의 일부분을 비교한다.
Link :  100
2010-09-13 10:34
----------------
title : 씹어먹는 C 언어 - <20 - 2. 메모리 동적할당 + 메모리 갖고 놀기>
cat_title : 20 - 2. 메모리 동적할당 + 메모리 갖고 놀기
next_page : 99
publish_date : 2010-09-13 10:34
--------------



이번 강좌에서는

* 구조체의 동적 할당

* 노드의 이용

* 메모리 관리 함수(memmove, memcpy, memcmp) 함수의 사용

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분. 메모리에 관해서 두 번째 이야기를 풀어 나가려고 합니다. 원래 메모리 동적 할당은 강의 한 개로 끝내려고 했는데 코이치 님이 무언가 조금 모자라다는 듯한 느낌이 든다고 하셔서 두 개의 강의로 이어 나가려고 합니다. 물론 동적 할당에 관한 기본 개념은 지난 강좌에서 모두 다루었지만 조금 보충 설명과 함께 새로운 것들을 이야기 하고자 합니다.


###  구조체 동적 할당


```cpp-formatted
#include <stdio.h>
#include <stdlib.h>
struct Something {
  int a, b;
};
int main() {
  struct Something *arr;
  int size, i;

  printf("원하시는 구조체 배열의 크기 : ");
  scanf("%d", &size);

  arr = (struct Something *)malloc(sizeof(struct Something) * size);

  for (i = 0; i < size; i++) {
    printf("arr[%d].a : ", i);
    scanf("%d", &arr[i].a);
    printf("arr[%d].b : ", i);
    scanf("%d", &arr[i].b);
  }

  for (i = 0; i < size; i++) {
    printf("arr[%d].a : %d , arr[%d].b : %d \n", i, arr[i].a, i, arr[i].b);
  }

  free(arr);

  return 0;
}
```

성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F121D49344D209B37546E36)


와 같이 나옵니다.

저의 구조체 강좌를 여태까지 잘 보신 분들은 잘 아시겠지만 '구조체' 역시 특별하게 생각해야 될 것이 아니라 '사용자가 만든 하나의 데이터 타입' 이라고 보시면 된다고 했습니다. 다시 말해 구조체도 `int` 처럼 사용할 수 있다는 것이지요. 따라서 구조체 배열을 `malloc` 을 이용하여 지지고 볶는 일은 전혀 이상할 것이 없는 행동 입니다.

```cpp-formatted
struct Something *arr;
```


일단 1 차원 구조체 배열을 가리키기 위한 `arr` 을 선언하였습니다. `int` 형 배열을 만들기 위해 `int` *arr; 이라 했던 것과 정확히 일치 합니다.

```cpp-formatted
arr = (struct Something *)malloc(sizeof(struct Something) * size);
```


이제 `malloc` 함수를 이용하여 `arr` 을 위한 공간을 할당해줍니다. 이에 필요한 크기는 당연히도 `sizeof(struct Something) * size` 입니다. 만일 `sizeof` 대신에 구조체의 실제 크기를 계산해서 더하시는 분이 있는데 이는 오류를 발생 시킬 수 있습니다. 예를 들어 위 `Somehting` 구조체의 경우 1 개당 8 바이트를 차지한다고 볼 수 있는데 사실 그렇지 않을 수 도 있습니다.

물론 위 경우는 조금 특별하지만 예를 들어 구조체의 크기가 10 바이트일 경우 컴퓨터가 **더블워드 경계(double word boundary)** 에 놓음으로 속도를 향상시키는 경우가 있는데 이 경우 구조체의 크기는 12 바이트로 간주될 수 있습니다. 사실 자세한 내용은 여기서 생략하기로 하고 아무튼 기역해야 할 점은 언제나 `sizeof` 를 사용해야 한다는 점입니다. 무턱대고 크기를 추정하지 맙시다!

```cpp-formatted
for (i = 0; i < size; i++) {
  printf("arr[%d].a : ", i);
  scanf("%d", &arr[i].a);
  printf("arr[%d].b : ", i);
  scanf("%d", &arr[i].b);
}
```


이렇게 할당을 하고 나면 입력을 받아야 겠지요? 위와 같은 `for` 문을 열심히 돌려서 입력을 받으면 됩니다.

```cpp-formatted
free(arr);
```


그리고 마지막에 위와 같이 `free` 로 깔끔하게 메모리를 정리해주는 것도 잊으면 안됩니다!



###  노드


여태까지 여러분들은 여러가지 자료형들을 배워왔습니다. 변수를 무식하게 나열하는 것을 막기 위해 배열을 이용하였고, 또 배열의 기능에 한계를 느낀 여러분은 구조체를 만들었습니다. 그리고 구조체 하나에 한 개 한 개를 다루는데 한계를 느낀 여러분은 구조체 배열을 이용해왔구요. 결국 배열로 다시 돌아왔습니다. 동적 할당을 함으로써 사용자가 원하는 크기의 입력을 다룰 수 있게 되었다고 하더라도 아직 많은 문제를 느끼고 있습니다. 만일 사용자가 마음이 변해서 한 개의 입력을 더 받고 싶다면 말이죠. 새롭게 동적할당을 하면 되지만 예컨대 1000 개 의 데이터가 있는데 1 개의 추가적인 데이터를 위해 1001 개를 위한 공간을 새로 잡으면 너무 아까운 것 같습니다.

이를 해결하는 것이 바로 '노드' 입니다. 노드는 이렇게 생겼습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F173659214C8DEDB426E889)

상당히 단순하지요? 이를 C 코드로 나타내면 다음과 같습니다.

```cpp-formatted
struct Node {
  int data;              /* 데이터 */
  struct Node* nextNode; /* 다음 노드를 가리키는 부분 */
};
```


아무튼 이렇게 생긴 노드를 어떻게 사용할까요?


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F155838374C8DEF1755C838)
위와 같이 사용합니다. 다시 말해 첫번째 노드가 다음 노드를 가리키면 다음 노드는 그 다음다음 노드를 가리키는 식으로 쭉 이어지며 마지막 노드 까지 이어지는데 마지막 노드는 아무것도 가리키지 않습니다. 또한 각각의 노드는 데이터를 하나씩 가지고 있지요. 다시 말해 나중에 데이터를 한 개 더 추가하려고 하면 마지막 노드에 새 노드를 만들어서 이어주기만 하면 됩니다.

뿐만 아닙니다. 기존의 배열에서는 거의 불가능 하였던 작업인 '배열 중간에 새 원소 집어넣기' 가 가능해집니다. 다시 말해 노드 사이에 새로운 노드를 끼워 넣을 수 있게 된다는 것이지요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F166252054C8DF0D2A57736)
위 그림 처럼 기존에 있었던 연결을 없애버리고 그 사이에 새롭게 연결해주기만 하면 됩니다. 이러한 사실을 바탕으로 노드를 만들어봅시다. 가장 먼저 새로운 노드를 생성하는 `CreateNode` 함수 부터 만들어봅시다. 이 함수는 노드를 생성하기만 합니다. 노드를 생성하기 위해서는 데이터와 이 노드가 가리키는 다음 노드가 필요한데 이 함수는 단순히 첫번째 노드를 만드는 역할을 한다고 하고 `nextNode` 를 `NULL` 로 줍시다.

```cpp-formatted
/* 새 노드를 만드는 함수 */
struct Node* CreateNode(int data) {
  struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));

  newNode->data = data;
  newNode->nextNode = NULL;

  return newNode;
}
```


따라서 `CreateNode` 함수는 위와 같이 만들 수 있습니다. 일단 `malloc` 을 통해 노드를 메모리에 할당하였고 이 할당된 노드는 `newNode` 가 가리키게 됩니다. 이제, `newNode->data` 에 `data` 를 집어넣고 이 노드가 가리키는 다음 노드를 `NULL` 로 주면 됩니다.

사실 이 함수는 노드를 생성하기만 할 뿐 노드를 어떻게 관계짓지는 못합니다. 따라서 어떠한 노드 뒤에 새로운 노드를 생성하는 함수를 만들어야 할 것입니다. 이 함수는 `InsertNode` 함수라고 합시다. 따라서 어떠한 노드뒤에 올지 '앞에 있는 노드' 에 관한 정보와 '새로운 노드를 위한 데이터' 가 필요하므로 `struct Node *current, int data` 를 인자로 가져야 합니다.

```cpp-formatted
/* current 라는 노드 뒤에 노드를 새로 만들어 넣는 함수 */
struct Node* InsertNode(struct Node* current, int data) {
  /* current 노드가 가리키고 있던 다음 노드가 after 이다 */
  struct Node* after = current->nextNode;

  /* 새로운 노드를 생성한다 */
  struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));

  /* 새 노드에 값을 넣어준다. */
  newNode->data = data;
  newNode->nextNode = after;

  /* current 는 이제 newNode 를 가리키게 된다 */
  current->nextNode = newNode;

  return newNode;
}
```



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F154468154C8DF2543ECA4E)

위 함수에 대한 설명을 위 그림을 보면서 해봅시다.

```cpp-formatted
/* 새로운 노드를 생성한다 */
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
```


일단 위 문장을 통해 새로운 노드 `newNode` 를 생성하였습니다.

```cpp-formatted
/* 새 노드에 값을 넣어준다. */
newNode->data = data;
newNode->nextNode = after;
```


이제 위 과정을 통해 `newNode` 에 `nextNode` 를 넣어주는 과정인데요, 이는 위 그림에서 3 번에 해당하는 과정입니다.

```cpp-formatted
/* current 는 이제 newNode 를 가리키게 된다 */
current->nextNode = newNode;
```


또한 `newNode` 앞에 있던 노드의 `nextNode` 가 바뀌었으므로 새롭게 수정하는 과정이 위 코드인데 이는 위 그림에서 `1,2` 번에 해당하는 과정입니다. 이렇듯, 그림에 있던 과정들이 함수에 잘 구현이 되어 있음을 알 수 있습니다.

이렇게 노드를 잘 만들어주었다면 노드를 파괴하는 역할을 가지는 함수 역시 만들어야 합니다. 이를 위해서는 이 노드를 가리키고 있던 이전 노드가 필요하게 됩니다. 그런데 이 노드를 가리키고 있던 노드를 찾기 위해서는 맨 처음 부터 뒤져나가야 하는데, 맨 처음 노트를 헤드 라고 하며 우리의 `DestoryNode` 함수는 헤드를 인자로 받아야 합니다. 물론 파괴하고자 하는 노드도 인자로 받아야 하지요

```cpp-formatted
/* 선택된 노드를 파괴하는 함수 */
void DestroyNode(struct Node *destroy, struct Node *head) {
  /* 다음 노드를 가리킬 포인터*/
  struct Node *next = head;

  /* head 를 파괴하려 한다면 */
  if (destroy == head) {
    free(destroy);
    return;
  }

  /* 만일 next 가 NULL 이면 종료 */
  while (next) {
    /* 만일 next 다음 노드가 destroy 라면 next 가 destory 앞 노드*/
    if (next->nextNode == destroy) {
      /* 따라서 next 의 다음 노드는 destory 가 아니라 destroy 의 다음 노드가
       * 된다. */
      next->nextNode = destroy->nextNode;
    }
    /* next 는 다음 노드를 가리킨다. */
    next = next->nextNode;
  }
  free(destroy);
}
```


위와 같이 만들면 됩니다. `head` 노드로 부터 차례 차례 하나 씩 다음 노드와 비교해가면서 찾아나가는 모습입니다. 이 과정은


```cpp-formatted
while (next) {
  /* 만일 next 다음 노드가 destroy 라면 next 가 destory 앞 노드*/
  if (next->nextNode == destroy) {
    /* 따라서 next 의 다음 노드는 destory 가 아니라 destroy 의 다음 노드가 된다.
     */
    next->nextNode = destroy->nextNode;
  }
  /* next 는 다음 노드를 가리킨다. */
  next = next->nextNode;
}
```



에 잘 나타나 있습니다. 만일 `next->nextNode == destroy` 라면 `next` 의 다음 노드가 바로 `destroy` 가 되는 것이므로 거꾸로 생각해보면 `destroy` 를 가리키고 있었던 이전 노드는 `next` 가 됩니다. 이 때 `destroy` 는 메모리에서 파괴되어 사라지기 때문에 `next` 의 `nextNode` 가 `destroy` 가 되면 안되고 그 다음 다음 노드, 즉 `destory` 의 `nextNode` 가 되어야 한다는 것입니다. 따라서 위와 같은 과정을 수행하고침내 마지막에 `free` 를 해주면 됩니다.


이 과정을 한 소스에 정리하면



```cpp-formatted
#include <stdio.h>
#include <stdlib.h>
struct Node* InsertNode(struct Node* current, int data);
void DestroyNode(struct Node* destroy);
struct Node* CreateNode(int data);
void PrintNodeFrom(struct Node* from);

struct Node {
  int data;              /* 데이터 */
  struct Node* nextNode; /* 다음 노드를 가리키는 부분 */
};
int main() {
  struct Node* Node1 = CreateNode(100);
  struct Node* Node2 = InsertNode(Node1, 200);
  struct Node* Node3 = InsertNode(Node2, 300);
  /* Node 2 뒤에 Node4 넣기 */
  struct Node* Node4 = InsertNode(Node2, 400);

  PrintNodeFrom(Node1);
  return 0;
}
void PrintNodeFrom(struct Node* from) {
  /* from 이 NULL 일 때 까지,
     즉 끝 부분에 도달할 때 까지 출력 */
  while (from) {
    printf("노드의 데이터 : %d \n", from->data);
    from = from->nextNode;
  }
}
/* current 라는 노드 뒤에 노드를 새로 만들어 넣는 함수 */
struct Node* InsertNode(struct Node* current, int data) {
  /* current 노드가 가리키고 있던 다음 노드가 after 이다 */
  struct Node* after = current->nextNode;

  /* 새로운 노드를 생성한다 */
  struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));

  /* 새 노드에 값을 넣어준다. */
  newNode->data = data;
  newNode->nextNode = after;

  /* current 는 이제 newNode 를 가리키게 된다 */
  current->nextNode = newNode;

  return newNode;
} /* 선택된 노드를 파괴하는 함수 */
void DestroyNode(struct Node* destroy,
                 struct Node* head) { /* 다음 노드를 가리킬 포인터*/
  struct Node* next = head;           /* head 를 파괴하려 한다면 */
  if (destroy == head) {
    free(destroy);
    return;
  }              /* 만일 next 가 NULL 이면 종료 */
  while (next) { /* 만일 next 다음 노드가 destroy 라면 next 가 destory 앞 노드*/
    if (next->nextNode == destroy) { /* 따라서 next 의 다음 노드는 destory 가
                                        아니라 destroy 의 다음 노드가 된다. */
      next->nextNode = destroy->nextNode;
    } /* next 는 다음 노드를 가리킨다. */
    next = next->nextNode;
  }
  free(destroy);
}
/* 새 노드를 만드는 함수 */
struct Node* CreateNode(int data) {
  struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));

  newNode->data = data;
  newNode->nextNode = NULL;

  return newNode;
}
```




성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F11474E154C8DFAC13AA03C)


와 같이 잘 나옵니다.



```cpp-formatted
void PrintNodeFrom(struct Node *from) {
  /* from 이 NULL 일 때 까지,
     즉 끝 부분에 도달할 때 까지 출력 */
  while (from) {
    printf("노드의 데이터 : %d \n", from->data);
    from = from->nextNode;
  }
}
```




일단 추가적으로 위와 같이 `from` 이후의 모든 노드의 값을 출력하는 함수인 `PrintNodeFrom` 이라는 함수를 정의하였습니다.



```cpp-formatted
struct Node* Node1 = CreateNode(100);
struct Node* Node2 = InsertNode(Node1, 200);
struct Node* Node3 = InsertNode(Node2, 300);
/* Node 2 뒤에 Node4 넣기 */
struct Node* Node4 = InsertNode(Node2, 400);
```




메인 함수에서 위와 같이 `Node` 들을 정의하였습니다. 먼저 헤드 노드인 `Node1` 을 `CreateNode` 함수를 통해 정의하였고, `Node1` 뒤에 `Node2 , Node2` 뒤에 `Node3,` 그리고 `Node2` 뒤에 `Node4` 를 끼워넣었습니다. 그리고 실행한 결과 `100, 200, 400, 300` 순으로 제대로 나온 것을 볼 수 있습니다.

이렇게 노드는 배열과는 달리 추가/삭제/삽입이 월등히 편리합니다. 그렇다고 해서 노드가 배열 보다 월등한 것일까요? 꼭 그렇다고는 말할 수 없습니다. 왜냐하면 배열의 경우 3 번째 원소에 접근하기 위해서는 단순히 `arr[3]` 으로 하면 되지만 노드의 경우 헤드로 부터 3 번째 까지 일일히 찾아가야만 하기 때문이죠. 따라서 `N` 개의 노드가 있다면 최악의 경우 `N` 번동안 계속 찾아야 하지만 배열의 경우 특정한 상수 시간 내에 찾아갈 수 있기 때문에 이부분에서는 배열이 월등히 좋다고 할 수 있습니다. 또한 노드의 경우 데이터를 위한 공간 말고도 다음 노드를 가리키기 위한 4 바이트가 더 필요하기 때문에 공간적으로도 약간 손해를 본다고 생각할 수 있습니다.


따라서 결론적으로 이야기 하자면 추가/삭제/삽입이 자주 일어나는 경우 노드를 사용하고 특정한 번째에 찾아가야 하는 일이 잦은 일은 배열을 사용하는 것이 이롭다는 것을 알 수 있습니다.


사실 노드 말고도 여러가지 형태의 자료 구조들이 있는데 예를 들면 스택, 큐, 트리 등이 있다고 볼 수 있습니다. 이들에 관한 자세한 내용은 여러분 스스로 찾아 보시기 바랍니다.




###  메모리 관련 함수



이번 단원이 메모리에 관한 것인 만큼 메모리에 관해서는 빠삭하게 알아가도록 합시다. 이를 위해 메모리에 관련된 C 표준 라이브러리에서 기본으로 지원되는 것들에 대해 알아보도록 합시다. 일단 메모리를 직접적으로 가지고 논다고 말할 수 있는 함수들은 `memmove, memcpy, memcmp, memset` 등이 있는데 우리는 여기서 대표적인 3 개의 함수인 `memmove, memcpy, memcmp` 만 알아보도록 합시다. 이 함수들 모두 `string.h` 에 정의되어 있습니다.


먼저 `memcpy` 함수 부터 봅시다.


```cpp-formatted
/* memcpy 함수 */

#include <stdio.h>
#include <string.h>

int main() {
  char str[50] = "I love Chewing C hahaha";
  char str2[50];
  char str3[50];

  memcpy(str2, str, strlen(str) + 1);
  memcpy(str3, "hello", 6);

  printf("%s \n", str);
  printf("%s \n", str2);
  printf("%s \n", str3);

  return 0;
}
```





성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1477090B4C8E0E432F5108)


와 같이 나옵니다.


`memcpy` 함수는 메모리의 특정한 부분으로 부터 얼마 까지의 부분을 다른 메모리 영역으로 복사해주는 함수 입니다. 위와 같이 문자열을 복사하는데 사용될 수 있죠. 물론 문자열 복사를 전문적으로 하는 함수는 `strcpy` 이지만 위와 같이 `memcpy` 함수를 사용하는 것도 나쁘지 않습니다.


```cpp-formatted
memcpy(str2, str, strlen(str) + 1);
```



일단 위 문장은 '`str` 로 부터 `strlen(str) + 1` 만큼의 문자를 `str2` 로 복사해라' 라는 의미 입니다. 이 때, `strlen` 함수는 문자열의 길이를 리턴해주는 함수로 예를 들어 `strlen("abc");` 를 하면 3 이 리턴됩니다. 이 때 마지막의 `NULL` 문자는 세지 않으므로 `str2` 에 `memcpy` 로 복사할 때 에는 1 을 더한만큼을 더 복사해주어야 합니다.


```cpp-formatted
memcpy(str3, "hello", 6)
```



마찬가지로 `str3` 의 경우도 `hello` 의 5 문자와 끝에 `NULL` 을 위해 총 6 문자를 `hello` 의 시작 주소로 부터 복사를 하게 됩니다. `memcpy` 에 관한 자세한 내용은 [여기](http://itguru.tistory.com/77) 을 참조하시기 바랍니다.


다음으로 `memmove` 함수에 대해 살펴봅시다. 이 함수는 메모리의 특정한 부분의 내용을 다른 부분으로 옮겨주는 역할을 합니다. 이 때 '옮긴다' 고 해서 이전 공간에 있던 데이터가 사라지지는 않습니다.


```cpp-formatted
/* memmove 함수 */

#include <stdio.h>
#include <string.h>

int main() {
  char str[50] = "I love Chewing C hahaha";

  printf("%s \n", str);
  printf("memmove 이후 \n");
  memmove(str + 23, str + 17, 6);
  printf("%s", str);

  return 0;
}
```





성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F14653A2F4C8E10BF619E3B)


와 같이 나옵니다.


```cpp-formatted
char str[50] = "I love Chewing C hahaha";
memmove(str + 23, str + 17, 6);
```


`memmove` 함수는 위 경우 `str+17` 에서 6 개의 문자를 `str+23` 에 옮겼습니다. 다시 말해 `hahaha` 의 시작 부분에서 6 개의 문자인 "hahaha" 를 `str` 의 맨 마지막 부분으로 복사해 넣었다는 뜻입니다. 다시 말해 `str` 뒤에 "hahaha" 를 추가하게 된 셈이지요. 이를 통해 문자열을 *I love Chewing C hahahahahaha* 로 만들 수 있게 되었습니다. `memmove` 함수의 장점은 `memcpy` 와 하는 일이 많이 비슷해보이지만 사실 `memcpy` 와는 달리 메모리 공간이 겹쳐도 됩니다. 위 경우도 `str` 과 복사하는 부분이 겹쳤지만 성공적으로 복사가 수행되었습니다. 덕분에 나중에는 `memmove` 함수를 아주 많이 사용하게 될 것입니다.


마지막으로 `memcmp` 함수를 살펴보도록 합시다. 이는 이름에서도 충분히 짐작이 되듯이 두 개의 메모리 공간을 서로 비교하는 함수 입니다.


```cpp-formatted
/* memcmp 함수 */

#include <stdio.h>
#include <string.h>

int main() {
  int arr[10] = {1, 2, 3, 4, 5};
  int arr2[10] = {1, 2, 3, 4, 5};

  if (memcmp(arr, arr2, 5) == 0)
    printf("arr 과 arr2 는 일치! \n");
  else
    printf("arr 과 arr2 는 일치 안함 \n");

  return 0;
}
```


성공적으로 컴파일 하였다면



![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F164D9B1F4C8E1ED414C774)


와 같이 나옵니다.


`memcmp` 함수는 꽤 유용하게 사용될 수 있습니다. 이 함수는 메모리의 두 부분을 원하는 만큼 비교를 합니다. 이 때 같다면 0, 다르다면 결과에 따라 0 이 아닌 값을 리턴하게 되지요.


```cpp-formatted
if (memcmp(arr, arr2, 5) == 0) ```



위 문장의 경우 `arr` 과 `arr2` 를 비교해서 처음 5 개의 바이트가 같다면 0 을 리턴하게 됩니다. 주의해야 할 점은 '5 개의 원소' 가 아니라 5 바이트 라는 점 이지요. 만일 `arr1` 과 `arr2` 전체를 비교하고 싶다면 3 번째 인자로 `sizeof(int) * 5` 를 넣어 주어야 했었을 것입니다.


이렇게 메모리를 가지고 노는 3 개의 함수들을 모두 살펴보았습니다. 저는 이 함수를 사용하는 아주 기본적인 방법만을 가르쳐 주었을 뿐 이 함수들을 어떻게 응용시켜서 적용시키냐는 여러분들의 몫입니다. 이제, 메모리를 아주 빠삭하게 다룰 수 있기 되었으니 (동적 메모리 할당도 할 줄 알고, `memmove` 와 같은 놀라운 메모리 관련 함수들도 사용할 줄 아니..) 이번 강좌는 여기서 끝마치도록 하겠습니다.


### 생각 해보기


앞서 배운 노드는 여러모로 생각해볼 점이 많다. 다음의 과제들을 차례대로 해결해보기 바랍니다.

#### 문제 1

`head` 가 주어질 때 전체 노드의 개수를 세는 `int CountNode(Node* head)` 함수를 작성하시오 (난이도 : 下)


#### 문제 2 

`head` 와 원하는 노드가 주어질 때 원하는 노드의 데이터 값을 출력하는 `int SearchNode(Node* head, Node *search)` 함수를 작성하시오 (난이도 : 下)


#### 문제 3

앞서 구현하였던 `Node` 의 단점으로 '이 노드를 가리키는 노드' 를 쉽게 알 수 없다는 점이다. 이를 보완하기 위해

```cpp-formatted
struct Node {
  int data;              /* 데이터 */
  struct Node* nextNode; /* 다음 노드를 가리키는 부분 */
  struct Node* prevNode; /* 이전 노드를 가리키는 부분 */
};
```

형식으로 노드를 만들어보고 앞서 작성했던 모든 함수들을 다시 작성해보시오 (난이도 : 中)

#### 문제 4

위와 같은 형식의 노드를 개량하여 `head` 가 맨 마지막 노드인 `tail` 을 `prevNode` 로 가리키는 원형의 노드를 만들어보시오. 다시 말해 노드의 처음과 끝이 없다고 볼 수 있다. 이러한 형태의 노드를 이용하여 앞서 구현하였던 모든 함수를 구현해보시오 (난이도 : 中上)


#### 문제 5

이전 강좌에서 만들었던 도서 관리 프로그램을 동적 할당과 구조체를 이용하여 만들어보세요 (난이도 : 中)

##@ chewing-c-end
Link :  98
2010-08-03 13:17
----------------
title : 씹어먹는 C 언어 - <20 - 1. 동동동 메모리 동적할당(Dynamic Memory Allocation)>
cat_title : 20 - 1. 동동동 메모리 동적할당(Dynamic Memory Allocation)
next_page : 100
publish_date : 2010-08-03 13:17
--------------



이번 강좌에서는

* `malloc` 함수의 이해

* 1 차원 배열 메모리 동적 할 1 차원 배열 메모리 동적 할당

* 2 차원 배열 (정확히 말하면 우리가 아는 2 차원 배열과 틀리지만) 메모리 동적 할당

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요. 여러분. 정말 멀리 달려 온 것 같네요. 벌써 제 20 장을 지나가고 있습니다. 물론 강의 수로 따지면 더 많죠.

아마도 여러분은 프로그램을 만들면서 다음과 같은 문제에 봉착했던 적들이 많았었을 것입니다.


배열의 크기를 자유 자재로 다룰 수 있으면 얼마나 좋을까?

맞습니다. 우리가 배열을 정할 때 그 크기는 언제나 **컴파일 시간에 확정** 되어 있어야 합니다. 즉 컴파일러가 배열의 크기를 추측할 필요 없이 명확하게 나타나 있어야 된다는 것이지요. 하지만 이는 정말 고역스러운 일이 아닙니다. 예를 들어 우리가 컴퓨터로 부터 학생들의 수학 점수를 입력 받아 평균을 내는 프로그램을 만든다고 해봅시다. 각 학급 마다 학생들의 수가 모두 다르기 때문에 배열의 크기를 명확하게 정할 수 없게 됩니다. 따라서 보통 이 경우 배열을 '충분히 크게' 잡게 되는데 이렇게 된다면 메모리가 낭비되는 경우가 허다하게 발생합니다.

컴퓨터에서 낭비란 곧 비효율적인 프로그램을 의미하는 것이지요. 이렇게 쓸데 없이 낭비되는 자원을 막기 위해 '학생 수' 를 입력 받고 그 학생 수 만큼 배열의 크기를 지정하면 얼마나 좋을까요. 하지만 놀랍게도 이렇게 할 수 있는 방법이 있습니다.

바로 **동적 메모리 할당** 이라는 방법 입니다. 이 것은 말그대로 동적으로 메모리를 할당 합니다. 여기서 '동적' 이란 말은 딱 정해진 것이 아니라 가변적으로 변할 수 있다는 말이지요. 또한 메모리를 '할당' 한다는 이야기는 역시 우리가 배열을 정의하면 배열에 맞는 메모리의 특정한 공간이 배열을 나타내는 것 처럼 메모리의 특정한 부분을 사용할 수 있게 됩니다.참고적으로 아마 다 아시겠지만 할당되지 않는 메모리는 절대로 사용할 수 없습니다.

도대체 어떻게 그런 일이 가능할까요.

```cpp-formatted
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  int SizeOfArray;
  int *arr;

  printf("만들고 싶은 배열의 원소의 수 : ");
  scanf("%d", &SizeOfArray);

  arr = (int *)malloc(sizeof(int) * SizeOfArray);
  // int arr[SizeOfArray] 와 동일한 작업을 한 크기의 배열 생성

  free(arr);

  return 0;
}
```


성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1623460D4C578DE32320B7)

일단 위 예제를 통해서는 정말 우리가 원하는 크기의 배열이 생겼는지는 모르겠지만 일단 위 소스코드 부터 파헤쳐봅시다.

```cpp-formatted
printf("만들고 싶은 배열의 원소의 수 : ");
scanf("%d", &SizeOfArray);
```


먼저 우리는 위 과정을 통해서 우리가 원하고자 하는 `int` 배열의 원소의 개수를 입력 받았습니다. 그리고,

```cpp-formatted
arr = (int *)malloc(sizeof(int) * SizeOfArray);
```


두둥. 바로 이 녀석이 우리가 원하는 작업을 해주는 역할을 합니다. 이 함수의 이름은`malloc` 이며 **memory allocation** 의 약자 입니다.

이 함수는 `<stdlib.h>` 에 정의되어 있기 때문에 `#include <stdlib.h>` 를 추가해주어야 합니다. 

이 함수는 인자로 전달된 크기의 바이트 수 만큼 메모리 공간을 만듭니다. 즉 메모리 공간을 할당하게 되는 것이지요. 우리가 원소의 개수가 `SizeOfArray` 인 `int` 형 배열을 만들기 위해서는 당연히 (int 의 크기) `* (SizeOfArray)` 가 되겠지요. 이 때, 우리는 `int` 의 크기가 4 바이트 란 것을 알고 있지만 사실 이 '4 바이트' 라는 것이 정확히 정해진 것이 아니기 때문에 (즉 다른 컴퓨터에서는 `int` 가 4 바이트가 아닐 수 있습니다) `sizeof` 키워드를 사용하게 됩니다. `sizeof` 는 이 타입의 크기를 정확하게 알려줍니다. 따라서 `sizeof(int) * SizeOfArray` 를 인자로 전달해 주면 됩니다.

이 함수가 리턴하는 것은 자신이 할당한 메모리의 시작 주소를 리턴하게 됩니다. 이 때, 리턴형이 `(void *)` 형이므로 우리는 이를 `(int *)` 형으로 형변환 하여 `arr` 에 넣어주기만 하면 됩니다. 이렇게 보니 마치 `malloc` 함수가 공원에서 돗자리를 까는 역할을 하는 것과 같네요. 사람이 바글바글한 공원에서 `malloc` 함수는 '원하는 크기의 돗자리' 를 깔아주고 이 돗자리로 사람들이 올 수 있도록 손을 흔들어주는 역할을 하는 것과 같습니다.

따라서 `arr` 에는 `malloc` 이 할당해준 메모리를 이용할 수 있게 됩니다. 즉, `arr[SizeOfArray]` 만큼을 사용할 수 있게 되죠.

```cpp-formatted
free(arr);
```


그리고 마지막에`free` 는 우리가 할당받은 다 쓰고 난 후에 메모리 영역을 다시 컴퓨터에게 돌려주는 역할을 합니다. 이를 **해제(free)** 한다 그러는데 이 `free` 를 제대로 하지 않게 된다면 딱히 사용하지도 않는 메모리를 쓸데없이 자리만 차지하게 되겠지요.

이렇게 `free` 를 제대로 하지 않아 발생되는 문제를 **메모리 누수(memory leak)** 이라고 합니다. 이는 마치 공원에 돗자리를 깔아놓고 그대로 놓고 집에 가는 것과 똑같은 일입니다. (이런 일이 반복된다면 나중에 다시 왔을 때 공원에는 돗자리를 놓을 수 있는 공간이 하나도 없겠죠?)



###  malloc 은 어디에 할당할까?

우리가 이전에 [17 강](http://itguru.tistory.com/83)에서 메모리 구조에 대해 배울 때 메모리에는 다음과 같은 구조들이 있다는 것을 배웠습니다.

이 때 다른 부분은 모두 설명하였는데 오직 **힙(Heap)** 에 대해서만 언급을 안했다는 것을 기억 하실 것입니다. 자, 이제 드디어 힙의 정체를 알 수 있는 시간입니다. 스택 이나, 데이타 영역, Read Only Data 부분은 당연하게도 `malloc` 함수가 결코 건드릴 수 없는 부분 입니다. 이 부분의 크기는 반드시 컴파일 때에 100% 추호의 의심의 여지도 없이 정해져야 합니다.

하지만 힙의 경우 다릅니다. 메모리의 힙 부분은 사용자가 자유롭게 할당하거나 해제할 수 있습니다. 따라서 우리의 `malloc` 함수도 이 힙을 이용하는 것입니다. 우리가 만들어낸 `arr` 은 힙에 위치하고 있습니다.

힙은 할당과 해제가 자유로운 만큼 제대로 사용해야 합니다. 만일 힙에 할당은 하였는데 해제를 하지 않았다면 공간이 낭비되겟지요. 다른 메모리 부분의 경우 컴퓨터가 알아서 처리하기 때문에 문제가 발생할 여지가 적지만 힙은 인간이 다루는 만큼 철저히 해야 합니다.


```cpp-formatted
/* 동적 할당의 활용 */
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  int student;  // 입력 받고자 하는 학생 수
  int i, input;
  int *score;   // 학생 들의 수학점수 변수
  int sum = 0;  // 총점

  printf("학생의 수는? : ");
  scanf("%d", &student);

  score = (int *)malloc(student * sizeof(int));

  for (i = 0; i < student; i++) {
    printf("학생 %d 의 점수 : ", i);
    scanf("%d", &input);

    score[i] = input;
  }

  for (i = 0; i < student; i++) {
    sum += score[i];
  }

  printf("전체 학생 평균 점수 : %d \n", sum / student);
  free(score);
  return 0;
}
```


성공적으로 컴파일 하였다면

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F16365A014C57925EC450CA)

와 같이 나옵니다.

```cpp-formatted
score = (int *)malloc(student * sizeof(int));
```


먼저 위 부분을 통해 원소의 개수가 `student` 인 `int` 형 배열을 생성하였죠. 따라서 우리는 `score` 을 `int score[student]` 로 한 것 마냥 사용할 수 있게 됩니다.

```cpp-formatted
for (i = 0; i < student; i++) {
  printf("학생 %d 의 점수 : ", i);
  scanf("%d", &input);

  score[i] = input;
}

for (i = 0; i < student; i++) {
  sum += score[i];
}
```


따라서 위와 같이 `score` 에 원소를 입력 받고 그 원소들을 모두 더해 평균을 구하게 됩니다. 어때요. 간단하지요.



###  2 차원 배열의 동적 할당


그렇다면 좀더 높은 난이도의 문제에 도전해봅시다. 2 차원 배열을 동적으로 할당할 수 있을까요? 물론 가능합니다. 여러분은 지금 머리속으로 마구 어떻게 할지 생각하고 있으실 텐데 의외로 간단합니다. 바로 포인터 배열을 이용하면 됩니다.

포인터 배열이라 함은 이전에도 이야기 했었지만 배열의 각 원소들이 모두 포인터 인 것이지요. 따라서, 각 원소들이 다른 일차원 배열들을 가리킬 수 있습니다. 따라서, 이 배열은 2  차원 배열이 되겠지요. 따라서 우리가 해야할 일은 먼저 포인터 배열을 동적으로 할당한 뒤에 다시 포인터 배열의 각각의 원소들이 가리키는 일차원 배열을 다시 동적으로 할당해 주면 됩니다.

그럼 이를 실행에 옮기도록 하겠습니다.

```cpp-formatted
/* 2 차원 배열의 동적 할당 */
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  int i;
  int x, y;
  int **arr;  // 우리는 arr[x][y] 를 만들 것이다.

  printf("arr[x][y] 를 만들 것입니다.\n");
  scanf("%d %d", &x, &y);

  arr = (int **)malloc(sizeof(int *) * x);
  // int* 형의 원소를 x 개 가지는 1 차원 배열 생성

  for (i = 0; i < x; i++) {
    arr[i] = (int *)malloc(sizeof(int) * y);
  }

  printf("생성 완료! \n");

  for (i = 0; i < x; i++) {
    free(arr[i]);
  }
  free(arr);

  return 0;
}
```


성공적으로 컴파일 했다면

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1901341B4C5797E91E51F1)

흠. 일단 잘 생성은 된 것 같기는 한데, 한 번 차근 차근 소스를 따라가 봅시다.


```cpp-formatted
int **arr;  // 우리는 arr[x][y] 를 만들 것이다.
```


일단 `int **arr` 부터 봅시다. 만일 `int array[3];` 이란 배열을 만들었다면 `array` 의 형은 무엇일까요. 네 맞습니다. `int *` 입니다. 그렇다면 `int * arr[10];` 이란 배열을 만들었다면 `arr` 의 형은? 네. `int **arr` 이죠. 따라서 우리는 `int **arr;` 과 같이 선언하였습니다.

```cpp-formatted
arr = (int **)malloc(sizeof(int *) * x);
```


따라서 위와 같이 `int *` 형 배열을 동적 할당 할 수 있었습니다. 위 과정을 거치게 되면 `arr` 은 다음과 같은 모습일 것입니다.

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F121B36104C57A23F6C4DB6)

자. 그럼 `arr` 배열의 각각의 원소들은 `int *` 형 이므로 다른 `int` 배열을 가리키기를 갈망하고 있을 것입니다. 우리는 그 욕구를 해소 시켜 주어야 겠죠. 따라서 각각의 원소들에 대해 원하는 메모리 공간을 짝지어 줍시다.

```cpp-formatted
for (i = 0; i < x; i++) {
  arr[i] = (int *)malloc(sizeof(int) * y);
}
```


각각의 원소들에 대해 메모리 공간을 할당하고 있습니다. `arr[i]` 는 `malloc` 이 정의한 또다른 공간을 가리키겠네요.

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F161D45184C57A55A450594)

따라서 `arr` 의 하나의 원소가 크기가 `y` 인 배열을 가리키고 있는데 `arr` 의 원소가 `x` 개 이므로 전체적으로 보았을 때 총 `x * y` 배열을 가지는 셈입니다. 하지만 이렇게 만들어진 배열은 정확히 말해 2 차원 배열이라 말하기는 힘듧니다. 왜냐하면 배열은 모름지기 메모리에 연속적으로 있어야 하기 때문이죠. 예를 들어 이전 강의의 사진을 잠깐 가져오면

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile30.uf.tistory.com%2Fimage%2F1108E70B4C57A770849D95)

와 같이 말이지요. 하지만 우리가 만든 배열은 `arr` 의 원소들이 가리키는 메모리 공간이 연달아 존재한다고 보장할 수 없습니다. 또한 한 가지 재미있는점은 우리가 만든 '2 차원 배열 처럼 생긴' 포인터 배열은 2 차원 배열과는 달리 함수의 인자로 손쉽게 넘길 수 있습니다. 예를 들면

```cpp-formatted
int array(int **array);
```

처럼 말이지요. `array(arr);` 을 하게 되면 우리가 만든 배열을 함수에 넘길 수 있게 됩니다. 이게 가능한 이유는 사실 우리가 만든 배열은 1 차원 배열들이지 2 차원 배열이 아니기 때문입니다. `arr` 은 단순히 `int *` 형 원소들을 가지는 1 차원 배열 이지요. 1 차원 배열을 함수의 인자로 넘겨줄 때 에는 크기를 써 주지 않아도 되지 않았습니까. 사실 `main` 함수의 인자로 전달되는 argv 역시 이와 같은 성격을 띕니다.

그렇다고 해서 2 차원 배열의 성질을 잃어버리는 것은 아닙니다. 이 배열도 2 차원 배열 처럼 `arr[3][4]` 과 같이 원소에 접근할 수 있습니다 (그렇기 때문에 우리가 만든 이 배열을 2 차원 배열이라 부르는 것입니다). 왜냐하면 `arr[3][4]` 는 `*(*(arr + 3)+4)` 로 해석되는데, `*(arr + 3)` 을 통해 `arr` 의 세번째 원소에 접근하게 되고 `*(arr + 3)` 은 자신이 가리키는 `int` 형 배열의 주소값읠 의미하므로 `+ 4` 를 하면 `int` 형 배열의 5 번째 원소에 접근하는 것과 같습니다.

아무튼 이와 같은 방법으로 2 차원 배열 (사실은 다르지만 이렇게 부르겠습니다) 를 생성하였습니다. 우리가 이 배열을 힙에 할당하였으면 사용이 끝났으면 역시 되돌려 주어야 하겠죠. 해제하는 순서는 할당하는 순서와 정 반대로 하면 됩니다. 즉, `arr[i]` 들이 가리키고 있던 `int` 배열들을 해제한 후, `arr` 을 해제하면 되겠지요. 만일 `arr` 을 먼저 해제하면 `arr[i]` 들이 메모리 상에서 사라지게 되므로 `arr[i]` 들이 가리키고 있던 `int` 배열들을 해제할 수 없게 되므로 오류가 나게 됩니다.

```cpp-formatted
/* 2 차원 배열 동적 할당의 활용 */
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  int i, j, input, sum = 0;
  int subject, students;
  int **arr;
  // 우리는 arr[subject][students] 배열을 만들 것이다.

  printf("과목 수 : ");
  scanf("%d", &subject);

  printf("학생의 수 : ");
  scanf("%d", &students);

  arr = (int **)malloc(sizeof(int *) * subject);

  for (i = 0; i < subject; i++) {
    arr[i] = (int *)malloc(sizeof(int) * students);
  }

  for (i = 0; i < subject; i++) {
    printf("과목 %d 점수 --------- \n", i);

    for (j = 0; j < students; j++) {
      printf("학생 %d 점수 입력 : ", j);
      scanf("%d", &input);

      arr[i][j] = input;
    }
  }

  for (i = 0; i < subject; i++) {
    sum = 0;
    for (j = 0; j < students; j++) {
      sum += arr[i][j];
    }
    printf("과목 %d 평균 점수 : %d \n", i, sum / students);
  }

  for (i = 0; i < subject; i++) {
    free(arr[i]);
  }

  free(arr);

  return 0;
}
```


성공적으로 컴파일 하였다면

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F134E8C274C57AD69885E45)

와 같이 나옵니다. 대성공이군요!

```cpp-formatted
int **arr;
```


위 예제에서 우리는 과목별 학생의 점수를 보관하기 위해 이차원 배열을 사용하였습니다. 즉 `arr[subject][students]` 를 만든 것이지요. 이를 위해

```cpp-formatted
arr = (int **)malloc(sizeof(int *) * subject);

for (i = 0; i < subject; i++) {
  arr[i] = (int *)malloc(sizeof(int) * students);
}
```

를 통해 `arr[subject][students]` 를 만들 수 있었습니다. 따라서 이제 과목별 학생의 점수를

```cpp-formatted
for (i = 0; i < subject; i++) {
  printf("과목 %d 점수 --------- \n", i);

  for (j = 0; j < students; j++) {
    printf("학생 %d 점수 입력 : ", j);
    scanf("%d", &input);

    arr[i][j] = input;
  }
}
```


로 얻었습니다. `arr` 은 사실 2 차원 배열은 아니지만 2 차원 배열과 똑같이 행동하므로 `arr[i][j]` 와 같은 문장도 맞게 되지요. `arr[i][j]` 를 `i` 행 `j` 열에 위치한 값이라 생각해도 무방합니다.

```cpp-formatted
for (i = 0; i < subject; i++) {
  sum = 0;
  for (j = 0; j < students; j++) {
    sum += arr[i][j];
  }
  printf("과목 %d 평균 점수 : %d \n", i, sum / students);
}
```


이제 값을 모두 입력받았다면 각 과목별 평균을 내면 되는데 이는 간단히 위와 같은 `for` 문으로 해결할 수 있었습니다.

```cpp-formatted
for (i = 0; i < subject; i++) {
  free(arr[i]);
}

free(arr);
```

마지막으로 할당 받은 메모리의 사용이 끝났기 때문에 해제해야 하는데 이는 이전에 설명했던 예제와 동일하게 하면 됩니다.

```cpp-formatted
/* 할당한 (2 차원 배열 처럼 생긴) 배열 전달하기 */
#include <stdio.h>
#include <stdlib.h>

void get_average(int **arr, int numStudent, int numSubject);

int main(int argc, char **argv) {
  int i, j, input, sum = 0;
  int subject, students;
  int **arr;
  // 우리는 arr[subject][students] 배열을 만들 것이다.

  printf("과목 수 : ");
  scanf("%d", &subject);

  printf("학생의 수 : ");
  scanf("%d", &students);

  arr = (int **)malloc(sizeof(int *) * subject);

  for (i = 0; i < subject; i++) {
    arr[i] = (int *)malloc(sizeof(int) * students);
  }

  for (i = 0; i < subject; i++) {
    printf("과목 %d 점수 --------- \n", i);

    for (j = 0; j < students; j++) {
      printf("학생 %d 점수 입력 : ", j);
      scanf("%d", &input);

      arr[i][j] = input;
    }
  }

  get_average(arr, students, subject);

  for (i = 0; i < subject; i++) {
    free(arr[i]);
  }
  free(arr);

  return 0;
}
void get_average(int **arr, int numStudent, int numSubject) {
  int i, j, sum;

  for (i = 0; i < numSubject; i++) {
    sum = 0;
    for (j = 0; j < numStudent; j++) {
      sum += arr[i][j];
    }
    printf("과목 %d 평균 점수 : %d \n", i, sum / numStudent);
  }
}
```


성공적으로 컴파일 했다면

![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F20023A1D4C57B2DE9350C5)

와 같이 나옵니다. 다른 부분은 모두 똑같으므로 함수만 살펴봅시다.

```cpp-formatted
void get_average(int **arr, int numStudent, int numSubject)
```


일단 `void` 형이고 `int **arr` 와 `numStudent, numSubject` 를 인자로 받고 있습니다. 앞에서 설명 했지만 `arr` 은 2 차원 배열 처럼 행동함에도 불구하고 사실은 단순히 원소가 `int *` 형인 배열이기 때문에 (1 차원 배열의 경우 단순히 배열의 타입에 `*` 만 붙이면 된다는 사실은 다 알고계시죠?)  위와 같이 `int **arr` 로 기존의 2 차원 배열 처럼 열의 개수에 대한 정보가 없어도 됩니다. (2 차원 배열의 경우 `int (*arr)[3]`과 같이 열에 관한 정보가 있어야 함)

물론 함수 내부에서 총 학생의 명수와 총 과목의 개수를 알아야 하므로 위와 같이 `numStudent` 와 `numSubject` 를 넣어주었지만요.자. 그럼 동적 할당 까지 배웠군요. 이제 여러분은 C 언어의 대부분을 배웠다고 해도 무방합니다만, 아직 몇 가지 재미있는 것들이 남아있으니 다음 강좌가 나올 때 까지 생각해 볼 문제나 풀어보세요. ㅎ


### 생각해보기

#### 문제 1

위 성적 프로그램을 개량하여 학생별 평균을 내어 학생의 등수를 출력하는 프로그램을 만들어보세요 (난이도 : 下)

#### 문제 2

동적으로 할당된 배열의 크기를 다시 바꾸는 프로그램을 만들어보세요.즉 `p` 가 이미 원소가 10 인 동적으로 할당된 배열을 가리키고 있었는데 예상치 못하게 원소 5 개를 더 추가하려면 어떻게 해야 할까요. (난이도 : 中)

##@ chewing-c-end
Link :  89
2010-08-02 16:20
----------------
title : 씹어먹는 C 언어 - <19. main 함수의 인자, 텅 빈 void 형>
cat_title : 19. main 함수의 인자, 텅 빈 void 형
next_page : 98
publish_date : 2010-08-02 16:20
--------------


이번 강좌에서는

* `void` 형의 함수, `void` 형의 포인터에 대한 이해

* `main` 함수의 인자에 대한 이해 (argc, argv)

* 포인터 배열

![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분. 그동안 잘 지내셨는지요? 책 만드는 것도 어느 정도 진척이 되었고 `Latex` 도 어느정도 능숙하게 다룰 줄 알아서 꽤 괜찮게 만들 수 는 있었는데 표지가 문제네요. 혹시 '씹어먹는 C 언어' 를 위한 멋진 표지를 만드실 분을 찾고 있으니 혹시 좋은 아이디어가 있으신 분들은 kev0960@gmail.com 으로 꼭 메일을 보내주시기 바랍니다.

만일 여러분이 다른 곳에서 C 를 배웠더라면 다음과 같은 것을 보셨을 수 도 있습니다.

```cpp-formatted
/* 특별한 hello world */
#include <stdio.h>

void main() { printf("Hello, World! \n"); }
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1747A5304C4FE429165D46)

일단, 위 소스 코드에서 살펴볼 부분은 두 가지 입니다. 먼저 함수의 정의 부분을 보면

```cpp-formatted
void main()
```


입니다. 우리가 `int main()` 이라 하는 것 처럼 이 역시 'void 형을 리턴하는 `main` 함수' 라고 보시면 되겠습니다. 그런데 `void` 형이 뭔가요? 놀랍게도 이 함수는 `return` 하는 값이 없습니다. 보통 `int main()` 의 경우 마지막에 `return` 0; 와 같이 반드시 정수값을 반환해 주어야 하는데 이 함수는 리턴하는 값이 없음에도 불구하고 아무런 오류가 뜨지 않습니다.

여기서 바로 `void` 형이 뭔지 알 수 있습니다. `void` 란'아무 형(타입)도 아닌' 이란 뜻으로 생각하시면 됩니다. 즉, 이 함수는 아무런 값도 리턴하지 않습니다. (오히려 값을 리턴하게 되면 오류가 나게 됩니다) 실제로 영어에서도 'void' 라는 단어의 의미는 '텅빈, 공허한' 이란 뜻입니다.

이렇게 `void` 형 함수는 아무것도 리턴하지 않으므로 다음과 같은 문장은 모두 틀린 셈입니다.

```cpp-formatted
void a();
int main() {
  int i;
  i = a();

  return 0;
}

void a() {}
```


즉 함수 `a` 가 리턴하는 값이 없으므로 `main` 함수의 변수 `i` 의 값에 `a` 의 리턴값을 대입할 수 없습니다. 이 모두 오류로 처리됩니다.

`void` 형 변수는 많은 곳에서 사용 됩니다. 주로, '리턴을 할 필요가 없는 함수' 들의 경우가 대부분이죠. 예를 들어서 두 변수의 값을 교환하는 함수를 생각해봅시다. 아마 여러분은 여태까지 다음과 같이 함수를 만들었을 것입니다.

```cpp-formatted
int swap(int *a, int *b) {
  int temp;

  temp = *a;
  *a = *b;
  *b = temp;

  return 0;
}
```

하지만 `swap` 함수는 리턴할 필요가 전혀 없죠. 단순히 두 수의 값만 바꾸면 끝인데 뭐하러 귀찮게 리턴을 하냐 말이죠. 오히려 불필요한 `return` 0; 를 수행할 시간 동안 다른 작업을 하는 것이 훨씬 효율적이라 생각됩니다. 이렇게 `return` 문이 불필요한 경우 `void` 함수를 사용하면

```cpp-formatted
void swap(int *a, int *b) {
  int temp;

  temp = *a;
  *a = *b;
  *b = temp;
}
```


로 깔끔하게 만들 수 있습니다.
이렇게 굳이 리턴을 할 필요가 없는 곳에서 `void` 함수를 이용하는 것이 효율적이라 볼 수 있습니다.



###  void 형 변수




```cpp-formatted
/* void 형 변수?? */
#include <stdio.h>
int main() {
  void a;

  a = 3;

  return 0;
}
```


성공적으로 컴파일 하였다면

```warning
error C2182: 'a' : 'void' 형식을 잘못 사용했습니다.
```


와 같은 오류 메세지를 보게 됩니다. 우리가 위에서 `void` 형 함수에 대해 살펴 보았습니다. 그렇다면 `void` 형의 변수도 정의할 수 있을 것 같은데 사실 이는 오류 입니다. 컴파일러가

```cpp-formatted
int a;
```


라는 문장을 보게 된다면 컴파일러는 '아, `int` 형의 변수 `a` 를 선언하는 구나. 메모리 상에 미리 4 바이트의 공간을 마련해 놓아야지' 라고 생각할 것입니다. 그런데

```cpp-formatted
void a;
```


를 보게 된다면, '응? 이 변수의 타입은 뭐지?' 라고 생각하게 되죠. 다시 말해 이 변수를 위해서 메모리 상에 얼마나 많은 공간을 설정해 놓아야 하는지 모르게 되는 셈입니다. (참고로 컴파일 때 모든 변수들의 메모리 상의 위치가 결정 되어야 합니다) 따라서 이와 같은 형식은 틀리게 된 셈이죠.

그렇다면 이것은 가능할까요?

```cpp-formatted
/* void 형을 가리키는 포인터 */
#include <stdio.h>
int main() {
  void* a;

  return 0;
}
```


성공적으로 컴파일 해 본다면 아무런 오류가 뜨지 않는 다는 것을 알 수 있습니다. 왜 그럴까요? 일단, `void *a;` 의 경우 위에서 지적한 문제는 없다는 것을 알 수 있습니다. 왜냐하면 앞에서 `void` a; 의 경우 `a` 의 크기를 정할 수 없기 때문에 메모리 상에 `a` 를 위해 얼마나 많은 공간을 설정해 놓아야 하는지 모르지만, `void *a` 의 경우 '포인터' 이기 때문에 100% 메모리 상에 `int` 의 크기, 즉 4 바이트 만큼을 지정하게 됩니다. (앞에서 부터 강조해 왔던 이야기 이지만 모든 포인터의 크기는 4 바이트로 동일합니다) 즉, `a` 에는 어떠한 지점의 메모리의 주소 값이 들어가게 되는 것이지요.

그렇다면 `void* a` 포인터는 `void` 형의 변수의 메모리 주소를 가지게 될까요? 물론, 논리를 따지고 보면 맞지만 `void` 형 변수라는 것은 존재할 수 없기 때문에 `void` 형 포인터의 존재는 쓸모가 없어 보입니다. 하지만 사실 `void` 는 타입이 없기 때문에 거꾸로 생각해 보면어떠한 형태의 포인터의 값이라도 담을 수 있게 됩니다. 예를 들면

```cpp-formatted
void *a;
double b = 123.3;

a = &b;
```

와 같이 말이죠. 다시 말해 `a` 는 순전히 오직 '주소값의 보관' 역할만 하게 되는 셈입니다.

```cpp-formatted
/* b 의 값을 보려면 */
#include <stdio.h>
int main() {
  void *a;
  double b = 123.3;

  a = &b;

  printf("%lf", *a);
  return 0;
}
```


성공적으로 컴파일 하였다면

```warning
error C2100: 간접 참조가 잘못되었습니다.
```


와 같은 오류를 보게 됩니다. 이 오류가 발생하는 이유 역시 쉽게 알 수 있습니다. 왜냐하면 컴파일러는 `*a` 가 무엇을 말하는지 알 수 없거든요. 여태까지 `*a` 를 해석할 때 컴파일러는 `a` 가 가리키는 것의 타입을 보고 메모리 상에서 `a` 부터 얼마 만큼 읽어들어야 할 지 결정했는데 `void a;` 의 경우 메모리 상에서 얼마만큼 읽어들여야 할 지 모르기 때문입니다. 따라서 이는 다음과 같이 수정되어야 합니다.

```cpp-formatted
#include <stdio.h>
int main() {
  void *a;
  double b = 123.3;

  a = &b;

  printf("%lf", *(double *)a) return 0;
}
```

성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F13654C1A4C500DBD6D8F6F)

와 같이 잘 출력됨을 알 수 있습니다.

```cpp-formatted
printf("%lf", *(double *)a);
```


우리는 위 문장에서 형변환 을 이용하였습니다. 즉 단순히 주소값 만을 담고 있는 `a` 에게 `(double *)` 를 취함으로써, 컴파일러로 하여금 "이 포인터 `a` 가 담고 있는 주소값은 `double` 을 가리키는 주소값이라 생각해" 라고 말한 것이지요. 따라서 `(double *)a` 부분을 통해 컴파일러는 현재 `a` 가 가리키고 있는 곳의 주소값을 `double` 로 생각하게 되어 8 바이트를 읽어들이게 합니다.

`void` 형 포인터는 단순히 어떤 타입의 포인터의 주소 값도 편리하게 담을 수 있기 때문에 많은 부분에서 활용되고 있습니다. 예를 들어 다음과 같은 역할을 하는 함수를 생각해봅시다

어떠한 특정한 주소값으로 부터 1 바이트 씩 값을 읽어오는 함수

그렇다면 이 함수는에는 인자가 2 개 전달될 텐데, 일단 그 특정한 주소값을 가리키고 있는 포인터와, 얼마나 읽을지 `int` 형 변수 하나를 받아야 겠지요. 그런데, 인자로 전달될 '특정한 주소값을 가리키고 있는 포인터' 의 타입이 제각각 이라는 것이지요. 예를 들어서 `int*` 일 수 도 있고 `double*` 일 수 도 있지요.

따라서 우리는 순전히 주소값 만을 받기 위해서는 `void` 형 포인터를 사용하는 것이 바람직하다고 볼 수 있습니다. 물론 포인터 간의 형변환을 통해서 처리할 수 있지만 어떠한 형태의 포인터 주소값도 가능하다라는 의미를 살리기 위해서는 `void` 형 포인터를 이용하는 것이 바람직합니다.

```cpp-formatted
/* 임의의 주소값 p 로 부터 byte 만큼 읽은 함수*/
#include <stdio.h>
int read_char(void *p, int byte);
int main() {
  int arr[1] = {0x12345678};

  printf("%x \n", arr[0]);
  read_char(arr, 4);
}
int read_char(void *p, int byte) {
  do {
    printf("%x \n", *(char *)p);
    byte--;

  } while (((char *)p)++ && byte);

  return 0;
}
```


성공적으로 컴파일 하였다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1328E9274C5656B5A01A3C)

`read_char` 함수를 살펴봅시다. 무언가 여태까지 해온 것 보다 코딩 실력이 업그레이드 된 것 같은데 찬찬히 살펴 보면

```cpp-formatted
do {
  printf("%x \n", *(char *)p);
  byte--;

} while (((char *)p)++ && byte);
```


먼저 `((char *)p) ++` 의 뜻 부터 생각해봅시다. `(char *)p` 는 '이 `p` 에 들어있는 값을 `char` 형 변수의 주소값이라 생각해!' 라는 의미 이지요. 그런데, 거기에 `++` 을 했으므로 포인터의 덧셈이 행해지는데 컴퓨터는 `p` 를 '`char` 형 변수의 주소값' 이라 생각하고 있으므로 `p` 에 1 을 더하게 되면 주소값이 `char` 의 크기, 즉 1 만큼 늘어납니다.

참고로 `(char *)p ++` 이라 안하고 `((char *)p)++` 이라 한 이유는 우선순위 문제 때문인데, 전자의 경우 `p++` 이 먼저 실행되어 문제가 생기기 때문입니다.

아무튼 이와 같은 방법으로 `p` 의 주소값을 계속 1 씩 증가시키는데, 이 때 `byte` 의 값이 0 이되거나 (`(char *)p)` 의 값이 0 (즉 `NULL` 일 때) `while` 문이 종료됩니다. 제가 `do while` 을 이용한 이유는 만일 동일한 조건문으로 `while` 문을 만들게 된다면 처음에 `((char *)p)++` 이 먼저 실행되기 때문에 `p` 부터 읽지 않고 `p + 1` 부터 읽게되는 불상사가 발생하기 때문에 이를 막기 위해 `do while` 문을 이용했습니다.

```cpp-formatted
printf("%x \n", *(char *)p);
```

는 `p` 가 가리키는 주소값에 위치한 데이터 1 바이트 씩 16 진수로 출력하게 됩니다. 따라서 `read_char` 함수를 호출함을 통해 `int` 형 배열인 `arr` 의 원소를 1 바이트씩 읽게 되는 것이죠. 어떤 사람들은 그 결과가 12 34 56 78 순으로 출력해야 한다고 물을 수 있는데, 이는 '엔디안' 에 대한 개념이 없는 것이기 때문에 [이 강좌](http://itguru.tistory.com/71)를 잠시 보고 오시기 바랍니다.

간단히 말하자면 우리가 쓰는 대부분의 프로세서는 리틀 엔디안 방식으로 저장하기 때문에 낮은 자리수가 낮은 주소값을 가지게 됩니다. 즉, 낮은 자리수인 78 이 낮은 주소값인 앞쪽에 저장되게 되죠. 따라서 12 34 56 78 순이 아닌 78, 56, 34, 12 순으로 저장되는 것이 맞습니다. (그렇게 따지면 87, 65, 43, 21 순으로 나타나야 되지 않냐고 물을 수 있는데 저장의 단위가 바이트 이므로 한 바이트 내에서는 우리가 생각하는 순서대로 저장됩니다. )



###  메인 함수의 인자

```cpp-formatted
/* main 함수의 인자라고?? */
#include <stdio.h>
int main(int argc, char **argv) {
  printf("받은 인자의 개수 : %d \n", argc);
  printf("이 프로그램의 경로 : %s \n", argv[0]);

  return 0;
}
```

성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F19601A1D4C566103A4699E)

아마도 이 강좌를 보고 계신 여러분 중 일부는 위와 같은 메인 함수에 친숙하실 지도 모릅니다.

```cpp-formatted
int main(int argc, char **argv)
```


보시다싶이 `main` 함수가 인자를 받고 있습니다. 이게 도대체 무슨 일인가요. 다른 함수가 인자를 받는 것은 이해가 잘되는데 `main` 함수가 인자를 받다니. 도대체 누가 인자를 넣어 주고 있는 것일까요? 바로 운영체제에서 인자를 알아서 넣어주는 것입니다. 바로 위와 같이요.

일단 `argc` 는 `main` 함수가 받은 인자의 수 입니다. 그리고 `argv` 는 `main` 함수가 받은 각각의 인자들을 나타내죠. 프로그램을 실행하면 기본적으로 아무런 인자들을 넣지 않더라도 위와 같은 정보는 들어가게 됩니다. 즉, `main` 함수는 자신의 실행 경로를 인자로 받게 되죠. 그렇다면 다른 인자들도 넣을 수 있을까요? 한 번 해봅시다.

```cpp-formatted
/* 인자를 가지는 메인 함수 */
#include <stdio.h>
int main(int argc, char **argv) {
  int i;
  printf("받은 인자의 개수 : %d \n", argc);

  for (i = 0; i < argc; i++) {
    printf("이 프로그램이 받은 인자 : %s \n", argv[i]);
  }

  return 0;
}
```


성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F19601A1D4C566103A4699E)

일단 우리는 프로그램을 임의의 개수의 인자를 받아 받은 인자들을 모두 출력하게 하였습니다. 그렇다면 프로그램에 직접 인자를 넣어 봅시다.

윈도우즈 XP 의 경우

시작 -> 실행 -> cmd

윈도우즈 `Vista, 7` 의 경우

시작 -> 하단에 '프로그램 밑 파일 검색' 에 `cmd` 라고 친다.

그렇다면 아래와 같은 모습을 보실 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F160928314C56633710E391)

이것은 '명령 프롬포트' 라고 부르는 것인데 기존의 `MS-DOS` 와 유사합니다. (그러나 본질적으로 다릅니다) 우리는 여기서 윈도우즈 처럼 파일을 클릭하여 실행하는 것과는 달리 직접 명령어를 침으로써 파일을 실행시켜야 합니다. 그러기 위해선 우리가 원하는 파일이 어디있는지 알아야겠죠.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F172AA82F4C5663AE0CF8A7)

먼저 위와 같이 화면에 `cd C:\\` 을 씁니다. 이 명령어의 의미는 'C:\' 라는 경로로 들어가라 입니다. 즉 'cd' 의 의미는 지정하는 경로로 들어가게 해주죠. 참고로 여기서도 역시 \ 하나만 치면 다른 의미로 해석되기 때문에 \ 하나를 나타내기 위해서는 \ 를 두번 써야 합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F110A721C4C56644C8E26B5)

이제 화면에 `dir` 을 쳐봅시다. 'dir' 의 의미는 이 경로에 들어있는 폴더와 파일들을 보여주라는 의미 입니다. 위 사진에서는 사생활보호 차원을 위해 `Program Files` 빼고 이름을 모두 가렸습니다. 이 때, 어떤 것은 왼쪽에 `<DIR>` 이라고 나오고 어떤 것은 없는 것을 볼 수 있는데, `<DIR>` 이란 것은 '폴더' 와 같은 뜻으로 파일이 아니라는 것입니다. 반면에 `<DIR>` 이 없는 것은 파일이 되겠지요. 아마 프로그램을 C 드라이브에 깔았기 때문에 아마 모든 파일은 동일한 경로에 있을 것입니다.

위와 같은 방식으로 우리의 파일을 찾는 일만 남았습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F155D211D4C566685DB208B)

우리가 원하는 파일은 아마 `C:\Users\Lee\Documents\Visual Studio 2008` 에 있습니다. 이를 `cd` 명령어로 다 치면 됩니다. 이 때, 중간에 띄어쓰기가 있으므로 큰 따옴표로 묶어주어야 합니다. 즉 `cd "C:\\Users\\Lee\Documents\\Visual Studio 2008"` 처럼 말이죠. 그렇지 않고 `cd C:\\Users\\Lee\Documents\\Visual Studio 2008` 로 쓴다면 컴퓨터는 `cd C:\\Users\\Lee\Documents\\Visual` 로 인식합니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1667FD1D4C566686838374)

이제 `Project` 폴더로 들어가보겠습니다. 단순히 `cd Projects` 라고 치면 됩니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1104D31A4C5666FFAD95D0)

오. 저의 프로젝트인 'teach' 가 보이네요. 여러분과 저와의 프로젝트 이름이 다를 수 있으니 각기 맞는 프로젝트로 들어가시면 됩니다. 여기서도 물론 폴더 이름에 띄어쓰기가 있다면 큰따옴표로 묶어주는 것을 잊지 마세요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1678121B4C5667816BA805)

이제, 파일들을 쭉 보면 `Debug` 라는 폴더와 `teach` 라는 폴더가 있는데, `teach` 폴더에는 우리의 소스 코드가, `Debug` 폴더에는 만들어진 실행 파일이 있습니다. 그렇다면 우리는 어디로 가야 할까요? 네, `Debug` 로 갑시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F1949391B4C5667D801C548)

우와 그렇다면 위와 같이 `teach.exe` 를 보실 수 있습니다. 이제 `teach.exe` 를 침으로써 위 프로그램을 실행할 수 있습니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1639E21B4C566825263E53)

우왕. 잘 실행되는 군요. 일단 신기한 점은 이 프로그램이 받은 인자가 더이상 그 프로그램의 경로가 들어가지 않고 `teach.exe` 가 들어갔습니다. 맞습니다. 우리가 `teach.exe` 를 침으로써 실행한 순간 이 프로그램의 첫번째 인자는 `teach.exe` 가 됩니다. 만일 우리가 이 프로그램을 `"C:\\Users\\Lee\\Documents\\Visual Studio 2008\\Projects\\teach\\Debug\\teach.exe"` 라고 쳐서 실행하였다면 인자가 `C:\\Users\\Lee\\Documents\\Visual Studio 2008\\Projects\\teach\\Debug\\teach.exe` 가 되겠지요.

그렇다면 다른 인자들을 넣어봅시다. 이는 간단합니다. 프로그램 이름 뒤에 다른 것들을 써주면 되죠. 예를 들어


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1621C0324C566A1F1C450F)

`teach.exe abc def` 라고 쓰게 된다면 `teach.exe` 가 첫번째 인자, `abc` 가 두번째 인자, `def` 가 세번재 인자가 되고 받은 인자의 수는 3 이 되지요. 어때요. 쉽지요?

그런데 여태까지 배운 내용을 잘 숙지하신 분이라면 다음과 같은 질문을 하실 수 있습니다.

`main` 함수의 두번째 인자 말이에요, `char **` 인데 제 기억에 이차원 배열을 전달하기 위해서는 `char (*argv)[5]` 와 같이 반드시 크기를 명시해 주어야 하는데 여기서는 단순히 `char**` 로 해놓고 어떻게 그리 잘 작동하는지요?

그 이유는 간단합니다. `char**` 은 `(char *)` 형 배열을 가리키는 포인터 이지요. 즉, 포인터의 배열 입니다. (배열 포인터가 절대로 아닙니다) `int arr[4]` 라는 배열을 가리키는 포인터가 `int *` 형인 것 (여기서는 `arr` 이겠네요) 처럼 `char *arr[5];` 를 가리키는 포인터의 형은 `char**` 이 되겠지요.

즉, 다음과 같은 꼴이 되겠지요.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F162720344C566E5670E92B)

즉 `argv` 는 포인터들의 배열을 가리키고 있고, 그 포인터 배열에서의 각각의 원소, 즉 포인터들은 인자로 전달된 문자열들을 가리키고 있습니다. 이 때, 이 문자열들은 메모리의 다른 공간에 보관되어 있겠죠.

따라서 우리는 `argv[i]` 를 통해 특정한 인자의 문자열에 저장된 주소값을 나타낼 수 있게 됩니다.

그럼 이상으로 이번 강좌를 마치도록 하겠습니다. 이번 강좌는 다음에 배울 동적 메모리 할당에 밑바탕이 되는 정보 이니 절대로 잊지 마시기 바랍니다.

### 생각해 보기

#### 문제 1

메인함수의 인자를 활용한 계산기를 만들어보세요. 예를 들어서

```info
calc.exe 5 + 10
```

을 치면 15 가 나오게 하면 되지요.

이 때, `5, +, 10` 은 모두 다른 인자로 봐야하겠죠. 기초적인 단계 이므로 연산자는 하나만 써도 된다고 합시다.참고로 인자는 모두 문자열 형태로 오기 때문에 문자열로 된 수를 `int` 형으로 바꾸는 작업이 필요할 것입니다.

##@ chewing-c-end
Link :  96
2010-08-02 11:27
----------------
title : C 언어 레퍼런스 - strrchr 함수
cat_title :  strrchr
publish_date : 2010-08-02 11:27
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strrchr



```info
#include <string.h> // C++ 에서는 <cstring>

const char * strrchr ( const char * str, int character );
      char * strrchr (       char * str, int character );
```


문자열에서 문자를 검색하되 가장 마지막으로 나타나는 위치를 찾는다. 그리고 이를 가리키는 포인터를 리턴한다.
이 때 문자열의 널 종료 문자 역시 C 문자열의 일부분이라 생각한다. 따라서 이 함수는 문자열의 널 종료 문자를 가리키는데 사용될 수 도 있다.

C++ 에서는 함수 오버로딩이 가능하므로 위와 같이 두 개의 원형을 가져도 되지만 C 에서는 불가능 하므로 아래와 같은 하나의 원형만을 가진다 C++ 에서는 함수 오버로딩이 가능하므로 위와 같이 두 개의 원형을 가져도 되지만 C 에서는 불가능 하므로 아래와 같은 하나의 원형만을 가진다.

```info
char * strrchr ( const char *, int );
```




###  인자




`str`

C 문자 C 문자열

`character`

`str` 에서 찾을 문자로 `int` 로 전달되지만 함수 내부적으로는 다시 `char` 로 변환되어 처리된다.



###  리턴값


`str` 에서 찾은 문자의 위치를 리턴한다. 만일 찾지 못한다면 널을 리턴한다.





###  함수의 구현


```cpp-formatted
/*

이 소스는
http://www.jbox.dk/sanos/source/lib/string.c.html
에서 가져왔습니다.

*/

char *strrchr(const char *s, int ch) {
  char *start = (char *)s;
  while (*s++)
    ;
  while (--s != start && *s != (char)ch)
    ;
  if (*s == (char)ch) return (char *)s;
  return NULL;
}
```




###  실행 예제




```cpp-formatted
/*

strrchr 함수를 통해 str 에서 s 가 포함된 가장 오른쪽 위치를 찾는다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strrchr/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str[] = "This is a sample string";
  char* pch;
  pch = strrchr(str, 's');
  printf("Last occurence of 's' found at %d \n", pch - str + 1);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1132541D4C5629879BDA45)




###  연관된 함수

*  [strchr](http://itguru.tistory.com/93)  :   특정한 문자가 포함되어 있는 가장 왼쪽 위치를 찾는다.
*  [memchr](http://itguru.tistory.com/92)  :  메모리에서 특정한 문자를 찾는다.
*  [strpbrk](http://itguru.tistory.com/95)  :  다른 문자들의 문자를 검색어로 삼아 특정한 문자열의 문자들을 찾는다.
Link :  95
2010-08-02 02:34
----------------
title : C 언어 레퍼런스 - strpbrk 함수
cat_title :  strpbrk
publish_date : 2010-08-02 02:34
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strpbrk

```info
#include <string.h> // C++ 에서는 <cstring>

const char * strpbrk ( const char * str1, const char * str2 );
      char * strpbrk (       char * str1, const char * str2 );
```


문자열에서 다른 문자열에 들어 있는 문자들을 검색어로 생각하여 찾는다.

이 때, 가장 첫번째로 일치되는 문자를 가리키는 포인터를 반환한다. 만일 일치되는 것이 없다면 `NULL` 을 반환하게 된다.

또한 이 함수는 문자열의 `NULL` 종료 문자는 문자열에 포함되어 있지 않다고 생각한다.

위에 나온 두 원형은 C++ 에서만 적용된다. (C++ 에서는 함수 오버로딩이 가능하므로) 다만 C 에서는 아래와 같은 하나의 원형만을 가진다.

```info
char * strpbrk ( const char *, const char * );
```





###  인자


`str1`

검색을 수행할 문자열

`str2`

검색어들을 포함하고 있는 문자열



###  리턴값


`str2` 의 문자들 중 `str1` 의 문자들과 첫번째로 일치하는 문자를 가리키게 된다. 만일 `str1` 의 널 문자 이전 까지 일치하는 것이 없다면 널을 리턴한다.



###  함수의 구현


```cpp-formatted
/*

다음 소스는
http://www.jbox.dk/sanos/source/lib/string.c.html
에서 가져왔습니다.

*/

char *strpbrk(const char *string, const char *control) {
  const unsigned char *str = string;
  const unsigned char *ctrl = control;
  unsigned char map[32];
  int count;  // Clear out bit map    for (count = 0; count < 32; count++)
              // map[count] = 0;    // Set bits in control map    while (*ctrl)
              // {        map[*ctrl >> 3] |= (1 << (*ctrl & 7));        ctrl++;
              // }    // 1st char in control map stops search    while (*str) {
              // if (map[*str >> 3] & (1 << (*str & 7))) return (char *) str;
              // str++;    }    return NULL;}
```


위 함수의 작동 원리에 대해 이해가 잘 안되는 분들은 [http://itguru.tistory.com/94](http://itguru.tistory.com/94)을 보시기 바랍니다.



###  실행 예제




```cpp-formatted
/*

strpbrk 로 일치하는 문자를 찾았다면 포인터의 값을 1 증가시켜서 그 다음 부분 부터
계속 검색을 수행한다. 즉 str 에 포함된 모든 vowel 들의 위치를 구하게 된다. 이
예제는 http://www.cplusplus.com/reference/clibrary/cstring/strpbrk/ 에서
가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str[] = "This is a sample string";
  char key[] = "aeiou";
  char* pch;
  printf("Vowels in '%s': ", str);
  pch = strpbrk(str, key);

  while (pch != NULL) {
    printf("%c ", *pch);
    pch = strpbrk(pch + 1, key);
  }
  printf("\n");

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F194FCA104C562317E980E9)



###  연관된 함수


* 

 [strcspn](http://itguru.tistory.com/94)  :  이 함수와 동일한 검색을 수행하되, 찾은 문자까지 거리를 구한다.
*  [strchr](http://itguru.tistory.com/93):  특정한 문자를 검색하는데 가장 먼저 나타나는 위치를 찾는다.
* strrchr  :  특정한 문자를 검색하는데 가장 마지막으로 나타나는 위치를 찾는다.
*  [memchr](http://itguru.tistory.com/92)  :  메모리에서 특정한 문자를 찾는다.
Link :  94
2010-08-02 01:10
----------------
title : C 언어 레퍼런스 - strcspn 함수
cat_title :  strcspn
publish_date : 2010-08-02 01:10
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strcspn

```info
#include <string.h> // C++ 에서는 <cstring>

size_t strcspn ( const char * str1, const char * str2 );
```


문자열에서 다른 문자열에 포함되어 있는 문자들을 검색하되, 첫번째로 일치하는 문자에 도달하기 까지 읽어들인 문자의 개수를 리턴한다.

다시 설명 하자면 `str2` 에 들어있는 문자들 중에서 `str1` 에 들어있는 문자와 일치하는 것이 있다면 첫번째로 일치하는 문자 까지 읽어들인 수를 리턴한다.

예를 들어 `str1` 에 "Hello, World" 가 들어 있고, `str2` 에 "aeiou" 가 들어 있다면 `str2` 에 들어 있는 문자들, 즉 `a,e,i,o,u` 를 `str1` 에서 검색하는 것인데 첫번째로 일치하는 것, 즉 `e` 가 정답이 된다. 이 때, 리턴하는 값은 `str1` 에서 'e' 까지 읽어들이는데 읽은 문자의 수, 즉 1 을 리턴하게 된다.



###  인자


`str1`

검색을 수행할 C 형식 문자열

`str2`

검색할 문자들을 포함하고 있는 C 형식 문자열



###  리턴값


만일 `str2` 의 문자들 중 `str1` 에 일치하는 것이 있다면 첫번째로 일치하는 문자까지 도달하기 위해 읽어들인 문자들의 수 (즉, 그 문자의 위치 `- 1` 이라 보면 된다) 를 리턴한다. 만일 일치하는 것이 없다면 `str1` 의 길이가 리턴된다.





###  구현 예


```cpp-formatted
/*

아래 소스는
http://www.koders.com/c/fidE1F6D546E578F9FF41B8000B08F8A73D4D86F8FA.aspx
에서 가져왔습니다.

*/
size_t strcspn(const char *s, const char *reject) {
  size_t count = 0;

  while (*s != '\0')
    if (strchr(reject, *s++) == NULL)
      ++count;
    else
      return count;

  return count;
}
```


상당히 간단한 코드이다. `strchr` 의 사용법만 알면 쉽게 이해할 수 있지만, 살짝 비효율 적인데 함수를 호출하는 작업이 시간이 꽤 걸리기 때문이다. 아래 나온 코드는 좀더 복잡하지만 빠르게 수행된다.

```cpp-formatted
/*

아래 소스는
http://www.jbox.dk/sanos/source/lib/string.c.html
에서 가져왔습니다.

*/
size_t strcspn(const char *string, const char *control) {
  const unsigned char *str = string;
  const unsigned char *ctrl = control;

  unsigned char map[32];
  int count;

  // Clear out bit map
  for (count = 0; count < 32; count++) map[count] = 0;

  // Set bits in control map
  , while (*ctrl) {
    map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    ctrl++;
  }

  // 1st char in control map stops search
  count = 0;
  map[0] |= 1;
  while (!(map[*str >> 3] & (1 << (*str & 7)))) {
    count++;
    str++;
  }
  return count;
}
```


위 함수의 작동 원리를 해석하는데 에는 상당히 고난이도의 통찰력이 필요하다. 설명해보자면, 일단 `map` 이란 배열은 `control` 에 포함되어 있는 문자들에 대한 정보를 저장하는 배열이다. (control 이 검색될 문자들을 포함하고 있는 배열)

이 때, `map` 에는 다음과 같은 형식으로 문자에 대한 정보가 저장된다.

```cpp-formatted
map[*ctrl >> 3] |= (1 << (*ctrl & 7));
// map[*ctrl >> 3] = map[*ctrl >> 3] | (1 << (*ctrl & 7)); 와 같다.
```


이는 다음과 같이 해석할 수 있다.

`01100101` 이라는 값이 있다고 하자. (즉 `*ctrl` 에 해당한다) 이를 `>> 3` 수행 시킴으로써, 처음 5 부분만 추출할 수 있다. 이를 `000 01100 01100` 으로 만들면서 원래 값의 처음 5 자리 `01100` 을 추출한다. 이는 이 값의 `ID` 로 볼 수 있다. 같은 `ID` 를 가진 값들은 배열의 같은 원소 (`map[ID]`) 에 저장이 된다.

이 때, 나머지 세 자리 부분에 대한 정보를 저장해야 하는데, 이는 간단히 해결할 수 있다. 남은 세 부분의 값이 0 이면 `map[ID]` 의 마지막 비트, 3 이면 끝에서 세 번째 비트, 7 이면 맨 앞 비트를 1 로 만들어버리면 된다. 예를 들어서 `control` 에 `00110 00110 0101, 00110 00110 0011, 0011 00110 00111` 이 있었다면 `map[00110]` 에 값이` 10101000` 이 된다.

다시말해 `map[ID]` 에 해당하는 원소에 `ID000` 부터 `ID111` 까지의 정보를 모두 가지고 있다는 말이 된다. 상당히 기발한 아이디어 이다.

따라서 이렇게 `control` 에 대한 정보를 `map` 에 저장한 후, 이를 `str` 과 비교해보면 된다. `str` 에 비교하는 경우, `str` 의 특정한 문자에 해당하는 `map` 값이 0 인지 1 인지 확인만 해주면 된다. (즉 0 이면 `control` 에 없다는 것이고 1 이면 `control` 에 있다는 것이므로)



###  실행 예제


```cpp-formatted
/*

이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strcspn/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str[] = "fcba73";
  char keys[] = "1234567890";
  int i;
  i = strcspn(str, keys);
  printf("The first number in str is at position %d.\n", i + 1);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F164A00274C559C0D15F82D)



###  연관된 함수





*  [strspn](http://itguru.tistory.com/97)  :  문자열에 다른 문자열에 포함된 정도를 구한다.



*  [strstr](http://itguru.tistory.com/101)   :  문자열에 특정한 문자열에 포함된 위치를 구한다.

*  [strncmp](http://itguru.tistory.com/90)  :  두 문자열의 일부분일 비교한다.
Link :  93
2010-08-02 00:02
----------------
title : C 언어 레퍼런스 - strchr 함수
cat_title :  strchr
publish_date : 2010-08-02 00:02
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strchr

```info
#include <string.h> // C++ 에서는 <cstring>

const char * strchr ( const char * str, int character );
      char * strchr (       char * str, int character );

```

문자열에서 특정한 문자가 가장 먼저 나타나는 곳의 위치를 찾는다.

이 때, 그 위치를 가리키는 포인터를 리턴한다. 이 때 마지막 `NULL` 문자도 C 문자열의 일부로 간주하기 때문에 이 함수는 문자열의 맨 끝 부분을 가리키는 포인터를 얻기 위해 사용할 수 도 있다.

이 때, C 의 경우 함수 오버로딩을 할 수 없으므로 아래와 같은 하나의 원형만 존재한다.

```info
char * strchr ( const char *, int );
```


참고로 맨 위에 나타난 원형은 C++ 에서만 유효하다.



###  인자


`str`

C 형식 문자열

`character`

검색할 문자로, `int` 형태로 형변환 되어서 전달되지만 함수 내부적으로는 다시 `char` 형태로 처리된다.



###  리턴값




`str` 에서 검색한 문자가 가장 먼저 나타나는 곳을 가리키는 포인터를 리턴한다. 만일 문자가 없다면 `NULL` 포인터를 리턴하게 된다.



###  실행 예제




```cpp-formatted
/*

str 에서 's' 라는 문자를 계속 찾는다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strchr/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str[] = "This is a sample string";
  char* pch;
  printf("Looking for the 's' character in \"%s\"...\n", str);

  pch = strchr(str, 's');

  while (pch != NULL) {
    printf("found at %d\n", pch - str + 1);
    pch = strchr(pch + 1, 's');
  }

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F177446244C558BD59B51A7)


###  연관된 함수


* [strrchr](http://itguru.tistory.com/96)  :  문자열에서 특정한 문자를 검색하되, 가장 마지막으로 나타나는 위치를 구한다.
*  [memchr](http://itguru.tistory.com/92) :  메모리 블록에서 특정한 문자를 검색한다.
*  [strpbrk](http://itguru.tistory.com/95)  :  문자열에서 다른 문자열에 포함된 문자들 중 일치하는 문자를 검색한다.
Link :  92
2010-08-01 23:49
----------------
title : C 언어 레퍼런스 - memchr 함수
cat_title :  memchr
publish_date : 2010-08-01 23:49
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ memchr

```info
#include <string.h> // C++ 에서는 <cstring>

const void * memchr ( const void * ptr, int value, size_t num );
      void * memchr (       void * ptr, int value, size_t num );
```


메모리 블록에서의 문자를 찾는다.

`ptr` 이 가리키는 메모리의 처음 `num` 바이트 중에서 처음으로 `value` 와 일치하는 값의 주소를 리턴한다.

참고적으로 위에 나타난 두 함수의 원형은 C++ 에서 정의된 방식으로 경우에 따라 오버로딩 되어서 나타난다. C 에서는 함수 오버로딩이 없기 때문에 다음과 같이 하나의 원형만을 가진다.

```info
void * memchr ( const void *, int, size_t );
```

###  인자

`ptr`

검색을 수행할 부분의 시작 주소이다.

`value`

찾을 값으로, `int` 로 값이 전달되지만 함수 내부적으로는 한 바이트씩 비교하기 때문에 이 값은 `unsigned char` 로 변환되어 사용된다.

`num`

검색을 시작한 부분 부터 검색을 수행할 만큼의 바이트 수



###  리턴값




메모리 블록에서 `value` 와 일치하는 값이 있다면 그 곳의 주소를 리턴하고 값을 찾지 못한다면 `NULL` 을 리턴한다.




###  실행 예제

```cpp-formatted
/*

str 에서 처음으로 나타나는 'p' 의 위치를 찾는다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/memchr/
에서 가져왔습니다.

*/
#include <stdio.h>
#include <string.h>

int main() {
  char* pch;
  char str[] = "Example string";
  pch = (char*)memchr(str, 'p', strlen(str));

  if (pch != NULL)
    printf("'p' found at position %d.\n", pch - str + 1);
  else
    printf("'p' not found.\n");

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F207EAB0F4C5588E0CAACE4)

###  연관된 함수

* [memcmp](http://itguru.tistory.com/84)   :  두 메모리 블록을 비교한다.
*  [strchr](http://itguru.tistory.com/93)  :  문자열에서 특정한 문자를 검색하되 가장 먼저 나타나는 위치를 구한다.
*  [strrchr](http://itguru.tistory.com/96)  :
문자열에서 특정한 문자를 검색하되 가장 마지막에 나타나는 위치를 구한다.
Link :  91
2010-08-01 12:20
----------------
title : C 언어 레퍼런스 - strxfrm 함수
cat_title :  strxfrm
publish_date : 2010-08-01 12:20
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strxfrm

```info
#include <string.h> // C++ 에서는 <cstring>

size_t strxfrm ( char * destination, const char * source, size_t num );
```


`locale` 을 사용해 문자열을 변환한다.

`source` 가 가리키는 C 형식 문자열을 현재 `locale` 에 따라 문자열을 변환한 후 변환한 문자열의 처음 `num` 개 문자를 `destination` 에 복사한다.

이 때, 변환된 문자열의 길이를 리턴하게 된다.

이 함수는 또한 문자열의 길이를 계산하는데 (NULL 은 세지 않는다) 사용할 수 있는데, `destination` 에 `NULL` 포인터를 넣고, `num` 에 0 을 주면 된다.



###  인자


`destination`

변환된 문자열의 처음 `num` 개 문자가 보관될 곳의 주소값

`source`

변환될 C 형식의 문자열

`num`

`destination` 에 복사할 최대 문자의 수



###  리턴값




변환된 문자열의 길이로 `NULL` 은 세지 않는다.



###  실행 예제


```cpp-formatted
/*

strxfrm 을 이용하여 문자열의 길이를 구한다.

 */
#include <stdio.h>
#include <string.h>

int main() {
  char str[20] = "Hello, World";

  printf("문자열의 길이 : %d \n", strxfrm(NULL, str, 0));

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F186A6F1C4C54E5888668F1)




###  연관된 함수

*  [strncpy](http://itguru.tistory.com/80)  :  문자열의 일부분을 복사한다.
*  [strncmp](http://itguru.tistory.com/90)  :  두 문자열의 일부분을 비교한다.
*  [strcoll](http://itguru.tistory.com/86):  `locale` 을 사용하여 두 문자열을 비교한다.
Link :  90
2010-08-01 11:29
----------------
title : C 언어 레퍼런스 - strncmp 함수
cat_title :  strncmp
publish_date : 2010-08-01 11:29
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ strncmp

```info
#include <string.h> // C++ 에서는 <cstring>

int strncmp ( const char * str1, const char * str2, size_t num );
```


두 문자열의 일부 문자들을 비교한다.

C 형식 문자열인 `str1` 의 처음 `num` 개의 문자를 다른 C 형식 문자열인 `str2` 의 처음 `num` 개의 문자와 비교한다 C 형식 문자열인 `str1` 의 처음 `num` 개의 문자를 다른 C 형식 문자열인 `str2` 의 처음 `num` 개의 문자와 비교한다.

이 함수는 처음 문자들 부터 비교를 수행하되, 다른 문자가 나타나거나 `NULL` 에 도달하거나, `num` 개의 문자들을 비교할 때 까지 비교를 수행하게 된다.



###  인자




`str1`

비교할 C 형식 문자열

`str2`

비교할 C 형식 문자열

`num`

(처음 부터) 비교할 최대 문자의 개수



###  리턴값





리턴값은 다음과 같이 정해진다.

* 만일 `num` 개의 문자가 모두 일치한다면 0 을 리턴한다.
* 비교한 `num` 개의 문자 중 최초로 일치하지 않는 문자의 값이 `str1` 이 더 큰 경우 0 보다 큰 값을, str2  가 더 큰 경우 0 보다 작은 값을 리턴한다.



###  실행 예제


```cpp-formatted
/*

"R2xx" 의 처음 두 문자, 즉 R2 와 str 의 각 문자열들의 처음 두 문자를 비교한다.
이 예제는
http://www.cplusplus.com/reference/clibrary/cstring/strncmp/
에서 가져왔습니다.

*/
#include <stdio.h>
#include <string.h>

int main() {
  char str[][5] = {"R2D2", "C3PO", "R2A6"};
  int n;
  puts("Looking for R2 astromech droids...");
  for (n = 0; n < 3; n++)
    if (strncmp(str[n], "R2xx", 2) == 0) {
      printf("found %s\n", str[n]);
    }
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F11111F374C54DB6A68C480)





###  연관된 함수

*  [strcmp](http://itguru.tistory.com/85) :  두 문자열을 비교한다.
*  [memcmp](http://itguru.tistory.com/84)  :  두 메모리 블록을 비교한다.
*  [strrchr](http://itguru.tistory.com/96)  :  문자열에서 지정한 문자의 마지막 위치를 얻는다.
*  [strspn](http://itguru.tistory.com/97)  :  문자열의 일치된 정도를 얻는다. (자세한 내용은 레퍼런스 참조)
Link :  88
2010-07-20 23:49
----------------
title : 씹어먹는 C 언어 - <18 - 2. 파일 뽀개기 (# 친구들, 라이브러리)>
cat_title : 18 - 2. 파일 뽀개기 (# 친구들, 라이브러리)
next_page : 89
publish_date : 2010-07-20 23:49
--------------


이번 강좌에서는

* `#include, #define, #ifdef, #endif, #else` 와 같은 전처리기 구문에 대한 이해

* 헤더파일에 대한 설명

* 라이브러리 (string.h) 사용하기


![씹어먹는 C 언어](/img/ChewingClogo.png)


안녕하세요 여러분~ 잘 지내셨는지요. 그럼 군말 없이 바로 강의에 들어가겠습니다. 참고로 이게 32 번째 강의인데 이렇게 보니까 참 많이도 썻다고 생각되네요. 30 강 까지 모두 pdf 로 만들었는데 사진을 모두 빼고도 페이지가 380 페이지에 달하내요. 사진을 모두 넣게 되면 적어도 500 페이지 정도는 될 텐데 보기 조금 힘들 것 같네요. 제 블로그에 우수한 성적으로 (?) 방문해 주신 분들께 선물로 나눠드릴라 그랬는데 제본비만 만원이 넘을 것 같아서 그건 좀 힘들겠네요.



###  헤더 파일

여태까지 헤더 파일에는 오직 함수의 원형들 만을 넣었습니다. 하지만 헤더파일에는 함수의 원형 뿐만이 아니라 아래의 것들도 함께 주로 쓰는 경우가 대다수 입니다. (물론 헤더 파일에도 보통의 C 코드를 집어 넣을 수 있지만 권장하지는 않습니다.)



* 전역 변수


* 구조체, 공용체, 열거형




* 함수의 원형


* 일부 특정한 함수 (인라인 함수.. 나중에 설명함)


* 매크로 (나중에 설명함)




우리는 그 중에서도 위의 3 개 정도만 지금 사용해 보도록 하겠습니다. 다른 것들은 나중에 배워 가면서 익히도록 하죠.

이번에 만들어 볼 것은 `Human` 이라는 구조체 입니다. `Human` 구조체에서 가질 정보는, 사람의 이름, 나이, 성별 입니다. 또한, 이 구조체 변수에 대한 정보를 출력하는 함수와, 이 구조체를 설정하는 함수들이 필요합니다.

먼저, `Human` 구조체 부터 봅시다.

```cpp-formatted
/* human.h */
enum { MALE, FEMALE };

struct Human {
  char name[20];
  int age;
  int gender;
};

struct Human Create_Human(char *name, int age, int gender);
int Print_Human(struct Human *human);
```

`human.h` 에는 위와 같은 것들이 포함되어 있습니다. 일단 열거형으로 남자와 여자에 대한 정수값들이 선언되어 있으며, `Human` 구조체, 그리고 한 `Human` 구조체 변수를 설정하는 `Create_Human` 함수와 한 `Human` 에 대한 정보를 출력하는 `Print_Human` 함수들이 설정되어 있습니다.

그럼 이 함수들에 대한 정보를 가지는 `human.c` 파일을 봅시다.

```cpp-formatted
/* human.c */
#include <stdio.h>
#include "human.h"
#include "str.h"

struct Human Create_Human(char *name, int age, int gender) {
  struct Human human;

  human.age = age;
  human.gender = gender;
  copy_str(human.name, name);

  return human;
}
int Print_Human(struct Human *human) {
  printf("Name : %s \n", human->name);
  printf("Age : %d \n", human->age);
  if (human->gender == MALE) {
    printf("Gender : Male \n");
  } else if (human->gender == FEMALE) {
    printf("Gender : Female \n");
  }

  return 0;
}
```


일단 `Human` 구조체를 사용하므로 이 구조체에 대한 설명이 들어있는 `human.h` 와, `printf` 를 위한 `stdio.h,` 그리고 `copy_str` 함수를 위한 `str.h` 헤더 파일들을 모두 `include` 해주어야 합니다. 이를 안할 시에 함수를 찾을 수 없다는 오류가 발생하게 됩니다.

`str.h` 는 단순히 `copy_str` 함수를 위한 것이므로 `str.h` 에는 다음과 같이 써있습니다.

```cpp-formatted
/* str.h */
char copy_str(char *dest, char *src);
```

또한

```cpp-formatted
/* str.c */
#include "str.h"

char copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```


와 같이 함수의 몸체가 나타나 있지요. 자, 그럼 `main` 함수가 위치한 `test.c` 를 봅시다.

```cpp-formatted
#include <stdio.h>
#include "human.h"
int main() {
  struct Human Lee = Create_Human("Lee", 40, MALE);

  Print_Human(&Lee);

  return 0;
}
```


상당히 간단합니다. 이는 우리가 파일을 잘 나누었기 때문입니다. 좋은 프로그램일 수 록 `main` 함수에서 하는 일이 적어집니다.
성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1845010D4C45CCA868064E)

위에서 소스를 설명하면서 다 말했기 때문에 굳이 설명할 부분은 없습니다만, 만일 위 소스에서 하나라도 이해가 되지 않는 부분이 있다면 반드시 이전 강의를 복습해주시기 바랍니다.

이제 파일을 분할하는 과정에 대해 배웠으니 파일을 분할하는 것을 습관을 들이시기 바랍니다. 처음에 함수를 배웠을 때 프로그래밍이 상당히 편해진 것 처럼 파일을 분할하게 되면 프로그래밍이 상당히 편해지는 것을 느끼실 수 있을 것입니다. 각 소스 파일에 정확히 무엇을 하는지 나타내주는 것이 중요합니다.



###  다른 사람이 만들어 놓은 것 쓰기


이번에는 파일을 분할하는 것 만큼이나 중요한 것에 대해 알아볼 시간 입니다. 바로 '다른 사람이 만들어 놓은 함수들' 을 사용하는 방법에 대해서 말이지요. 이렇게 다른 사람들이 만들어 놓은 것을 가리켜서 **라이브러리** 라고 합니다. 우리가 도서관에 가서 책을 고르듯이, C 프로그래밍에서 우리는 원하는 함수를 라이브러리에서 찾아 사용할 수 있습니다. 이는 정말로 편리한 일이지요. 시시 콜콜 하게 함수들을 귀찮게 만들 필요가 없다는 말입니다.

아래 예제는 기존에 우리가 `copy_str` 을 이용하여 `str1` 에 `str2` 를 복사하는 과정을 나타냈습니다.

```cpp-formatted
/* test.c */
#include <stdio.h>
#include "str.h"
int main() {
  char str1[20] = {"hi"};
  char str2[20] = {"hello every1"};

  copy_str(str1, str2);

  printf("str1 : %s \n", str1);

  return 0;
}
```


```cpp-formatted
/* str.h */
char copy_str(char *dest, char *src);
```


```cpp-formatted
/* str.c */
#include "str.h"
char copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```



성공적으로 컴파일 했다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F1770D4364C45CE608F659A)

일단 위와 같이 잘 복사되었음을 알 수 있습니다. 하지만 이는 정말로 귀찮은 일이 아닐 수 없습니다. 문자열을 복사하는 과정은 정말로 많이 쓰이는 것입니다. 이렇게 문자열 복사가 필요할 때 마다 `copy_str` 함수를 만들어서 쓴다면 참으로 귀찮은 일이 아닐 수 없습니다. 하지만 정말 다행스럽게도, 사람들은 이 역할을 하는 함수를 '미리' 만들어 놓았습니다.

```cpp-formatted
/* 라이브러리의 사용 */
#include <stdio.h>
#include <string.h>
int main() {
  char str1[20] = {"hi"};
  char str2[20] = {"hello every1"};

  strcpy(str1, str2);

  printf("str1 : %s \n", str1);

  return 0;
}
```


성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F1770D4364C45CE608F659A)

와 같이 위와 똑같이 나옵니다.

```cpp-formatted
#include <string.h>
```

위 명령은 "string.h" 파일에 있는 내용을 모두 가져다 붙인다 라는 의미를 가지고 있습니다. 그런데 이 `string.h` 파일에는 '문자열을 처리하는데 관련된 함수들의 원형' 모음이 있습니다. 따라서 우리는 이 파일을 `include` 시킴으로써 문자열을 처리하는 여러가지 편리한 함수들을 사용할 수 있게 됩니다. 우리가 `str.h` 를 `include` 해서 `copy_str` 을 사용할 수 있었던 것과 일맥 상통합니다. 우리는 여기서 'strcpy' 라는 함수를 사용했습니다.

```cpp-formatted
strcpy(str1, str2);
```


이 함수는 `copy_str` 과 사용법이 정확히 똑같습니다. 문자열을 복사하고자 하는 곳의 주소값을 첫번째 인자로, 복사가 되는 문자열의 주소값을 두번째 인자로 주면 됩니다.

이렇게 사람들이 미리 만든 함수들의 모임을 가리켜서 '라이브러리' 라고 합니다. 우리가 현재 사용한 라이브러리는 **문자열(string) 라이브러리** 입니다. 그렇다면 `stdio.h` 도 라이브러리 일까요? 맞습니다. 이는 **입출력 라이브러리** 로 입력과 출력에 관련된 함수들을 모아놓았습니다. 대표적으로 `prinf` 와 `scanf` 가 있지만 이전에 잠깐 소개했던 `getchar()` 함수나 `puts()` 등등 수 많은 함수가 여기에 정의되어 있습니다. 이 목록은 제 블로그 C 언어 레퍼런스를 참조하세요.

```cpp-formatted
/* strcmp 함수 */
#include <stdio.h>
#include <string.h>
int main() {
  char str1[20] = {"hi"};
  char str2[20] = {"hello every1"};
  char str3[20] = {"hi"};

  if (!strcmp(str1, str2)) {
    printf("%s and %s is equal \n", str1, str2);
  } else {
    printf("%s and %s is NOT equal \n", str1, str2);
  }

  if (!strcmp(str1, str3)) {
    printf("%s and %s is equal \n", str1, str3);
  } else {
    printf("%s and %s is NOTequal \n", str1, str3);
  }

  return 0;
}
```


성공적으로 살펴 보았다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F152F3D264C45D10A38A0EF)



이번에 사용해본 함수는 `strcmp` 함수 입니다.

이 함수는 두 문자열을 비교해서 두 문자열이 같다면 0 을 다르면 0 이 아닌 값을 리턴하게 되어 있습니다.
이 함수의 사용법도 이전에 우리가 만들었던 `compare_str` 함수와 동일합니다. 첫 번째와 두 번째 인자에는 비교할 문자열들의 주소를 넣어주면 됩니다.

이렇게, 다른 라이브러리의 함수들을 사용하니 상당히 편리합니다. 이번에는 `string` 라이브러리 말고도 다른 여러가지 라이브러리들이 많은데 이 들에 대한 정보는 여러분이 직접 찾아보세요



###  # 친구들




여태까지 우리는 `#include` 라는 명령에 대해 알아보았습니다. 이렇게 # 이 들어간 명령들은 ‘전처리기 명령’ 이라고 하는데 전처리기의 의미는 컴파일 이전에 처리된다는 뜻 입니다. 즉, 컴파일이 되기 이전에 `#include` 라는 부분은 `#include` 에 해당하는 파일의 소스 코드로 정확히 바뀝니다.

이전 강좌에서 `stdio.h` 의 내용을 썼었을 때, `#include` 말고도 `#` 이 들어가 있는 엄청나게 많은 수의 명령들을 볼 수 있었습니다. 예를 들면 `#define, #ifdef` 등등 이죠. 이번에는 이러한 다양한 종류의 전처리기 명령들에 대해 알아보도록 합시다.

#### #define

```cpp-formatted
/* #define */
#include <stdio.h>
#define VAR 10
int main() {
  char arr[VAR] = {"hi"};
  printf("%s\n", arr);
  return 0;
}
```

성공적으로 컴파일 하였다면



![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1153F6234C4E846069CEC3)




여러분은 아마도 배열을 정의하는데 대괄호 안어에 수가 아닌 값이 들어왔는데도 컴파일이 어떻게 잘되고 실형 역시 잘되었는지 놀랐었을 수 도 있습니다. 배열을 정의할 때 대괄호 안에는 언제가 수가 와야 합니다. 심지어 상수 조차 올 수 없습니다. 하지만 위 경우 어떻게 된 것일까요?

`#define` 명령은 다음과 같이 사용합니다.

```info
#define 매크로이름 값
// 전처리기 문들은 끝에 ; 를 붙이지 않습니다!!
```



이는 소스 코드에서 ‘매크로이름’ 에 해당하는 부분을 ‘값’ 으로 대체하게 되는 것입니다. 물론, 전처리기 명령이기 때문에 컴파일 이전에 정확하게 대체됩니다. 따라서,

```cpp-formatted
#include <stdio.h>
#define VAR 10
int main() {
  char arr[VAR] = {"hi"};
  printf("%s\n", arr);
  return 0;
}
```



라는 문장은

```cpp-formatted
#include <stdio.h>
int main() {
  char arr[10] = {"hi"};
  printf("%s\n", arr);
  return 0;
}
```


과 완전히 똑같은 문장 입니다. 이 작업이 컴파일 이전에 처리되기 때문에 컴파일러 입장에서는 `arr[10]` 이라는 문장을 처리하는 것과 똑같으므로 오류 없이 정확하게 수행될 수 있다는 것이죠.

#### #ifdef, endif`

`ifdef` 와 `endif` 는 무언가 `if` 문과 관련이 있을 것 같습니다. `if` 문 처럼 특정한 조건에만 수행이 되겠지요.

```cpp-formatted
/* ifdef */
#include <stdio.h>#define A
int main() {
#ifdef A printf("AAAA \n"); #endif
#ifdef B printf("BBBB \n"); #endif
  return 0;
}
```



성공적으로 컴파일 하였다면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F206F8D204C4E8453AB502D)



만일, #define 부분을 #define `A` 에서 #define `B` 로 바꿔보면


![""](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1932ED234C4E846003ADD5)


와 같이 나옵니다.
상당히 재미있지요. 일단 `ifdef` 는 다음과 같은 형식으로 사용됩니다.

```info

#ifdef 매크로이름

// ‘매크로’ 가 정의되었다면 이 부분이 코드에 포함되고 그렇지 않다면 코드에 포함되지 않는다.
코드

#endif
```



언제나 `ifdef` 는 `endif` 와 짝을 지어서 사용하는데, `ifdef` 에서 지정한 매크로가 정의되어 있다면 `ifdef` 와 `endif` 속에 있는 코드가 포함되고 그렇지 않다면 코드에 포함되지 않는 것으로 간주 됩니다. `#define A` 를 통해 `A` 가 정의 되어 있다면

```cpp-formatted
#ifdef A
printf("AAAA \n");
#endif
```


부분은 전처리기에 의해

```cpp-formatted
printf("AAAA \n");
```



로 바뀌지만


```cpp-formatted
#ifdef B
printf("BBBB \n");
#endif
```


부분은 소스에 포함되어 있지 않은 것으로 간주되어 컴파일러 입장에서는 마치 주석 처럼 무시됩니다.
만일 `#define A` 대신에 `#define B` 를 하게 된다면 반대의 상황이 연출되고, 둘 다 `define` 해주게 된다면 둘 다 코드에 포함이 되겠지요. 이와 같은 기능을 도대체 왜 만들었냐고도 물어볼 수 있는데 사실 이 ‘조건부 컴파일 (특정한 조건에 따라 컴파일 되는 부분이 다른 것)’ 은 상당히 유용하게 쓰일 수 있습니다.

예를 들어 계산기 프로그램을 만드는데, 계산기 모델 마다 조금씩 메모리와 CPU가 틀려서 어떤 계산기에는 `double` 을 사용할 수 있지만 어떤 모델에서는 `float` 밖에 사용할 수 없다고 합시다.

그렇다면 각각 이 계산기를 위해 다음과 같이 소스를 짜야 할 것입니다.

```cpp-formatted
/*
계산기 모델 1 을 위한 코드
calculator1.c
*/
float var1, var2;
// do something
```



```cpp-formatted
/*
계산기 모델 2 을 위한 코드
calculator2.c
*/
double var1, var2;
// do something
```



하지만 조건부 컴파일을 이용하면 이 두 개의 파일로 나누어서 해야 했던 작업을 다음과 같이 줄일 수 있습니다.

```cpp-formatted
#define CACULATOR_MODEL_1

#ifdef CALCULATOR_MODEL_1
float var1, var2;
#endif
#ifdef CALCULATOR_MODEL_2
double var1, var2;
#endif;
// do something
```



이 때, `define` 되는 것이 무엇이냐에 따라 간단히 무엇을 컴파일 할 것인지를 나타낼 수 있습니다.
사실 `ifdef` 와 `endif` 가 사용되는 경우는 이것보다 훨씬 많지만 일단 여기서 매듭 짓기로 하겠습니다.


위 조건부 컴파일에서 #else 라는 것도 사용할 수 있는데 이는 #ifdef 의 경우 이외의 나머지 것들을 처리하는 것입니다. 이 역시 #endif 로 항상 끝을 맺어주어야 합니다. 예를 들면 아래와 같지요.

```cpp-formatted
#ifdef CALC_1
// do something
#else
// do something ‘else’
#endif
```



또한 `#ifdef` 의 친구로 `#ifndef` 도 있는데 이는 ‘매크로가 정의되어 있지 않다면’ 참이 됩니다. `#ifdef` 의 정 반대이지요.
이 기능들에 대해서는 나중에 좀더 큰 프로젝트를 진행하면서 차근 차근 알아가보도록 합시다.

### 생각해보기

#### 문제 1

헤더 파일이 두 번 중복되서 `include` 되지 않기 위해서는 헤더파일에 어떠한 조건문을 넣으면 좋을 지 생각해보세요.

##@ chewing-c-end
Link :  73
2010-04-24 09:47
----------------
title : C 언어 레퍼런스 - fsetpos 함수
cat_title :  fsetpos
publish_date : 2010-04-24 09:47
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fsetpos

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int fsetpos ( FILE * stream, const fpos_t * pos );
```


스트림의 파일 위치 지정자(position indicator)를 설정한다.

스트림의 위치 지정자를 새로운 위치로 변경한다. 위 함수에서 인자로 전달되는 `pos` 는 `fpos_t` 객체를 가리키는 포인터로 반드시 이전의 [fgetpos](http://itguru.tistory.com/70)함수의 호출을 통해 값을 가지고 있어야 한다.

파일 끝 지정자는 이 함수의 호출 뒤에 초기화 되며, 만일 이전에 [ungetc](http://itguru.tistory.com/49)함수를 호출하였더라면 이 함수의 호출로 인한 모든 영향도 사라지게 된다.

또한, 스트림의 읽기 및 쓰기 형식으로 열려있을 경우, 이 함수를 호출함을 통해서 읽기 - 쓰기 모드를 변경할 수 있다. (자세한 내용은 [fopen](http://itguru.tistory.com/58)함수를 참조)



###  인자

`stream`

작업을 수행할 스트림의 `FILE` 객체를 가리키는 포인터

`position`

`fpos_t` 객체를 가리키는 포인터로, 반드시 이전의 [fgetpos](http://itguru.tistory.com/70)함수를 통해서 값을 지니고 있어야 한다.



###  리턴값


만일 성공적으로 수행하였다면 0 을 리턴한다. 그렇지 않다면 0 이 아닌 값을 리턴하고, 전역 변수인 `errno` 를 양수로 설정한다. 이 `errno` 에 설정된 값은 [perror](http://itguru.tistory.com/53)함수를 통해서 무슨 오류인지 확인할 수 있다.



###  실행 예제


```cpp-formatted
/*
먼저 position 에 myfile.txt 의 맨 처음 부분을 넣은 후 myfile.txt 에 "That is a
sample" 을 쓴다. 그 다음에 fsetpos 함수를 호출함으로써 fputs 로 인해 변경되었던
위치 지정자가 다시 파일 맨 앞으로 옮겨진다. 그 후 "This" 를 다시 출력하면 결국
"This is a sample" 이 된다.이
예제는http://www.cplusplus.com/reference/clibrary/cstdio/fsetpos/에서
가져왔습니다.*/
#include <stdio.h>
int main() {
  FILE* pFile;
  fpos_t position;
  pFile = fopen("myfile.txt", "w");
  fgetpos(pFile, &position);
  fputs("That is a sample", pFile);
  fsetpos(pFile, &position);
  fputs("This", pFile);
  fclose(pFile);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F157059164BD2A5DB951099)

`myfile.txt` 의 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1701FE164BD2A5DB5B77A4)





###  연관된 함수


* [fgetpos](http://itguru.tistory.com/70)  :  스트림의 현재 위치 지정자 값을 가져온다.

*  [fseek](http://itguru.tistory.com/72)  :  스트림 위치 지정자를 다시 조정한다.

*  [rewind](http://itguru.tistory.com/75)  :  스트림 위치 지정자를 맨 처음으로 되돌린다.
Link :  72
2010-04-24 09:31
----------------
title : C 언어 레퍼런스 - fseek 함수
cat_title :  fseek
publish_date : 2010-04-24 09:31
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fseek

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int fseek ( FILE * stream, long int offset, int origin );

```

스트림 위치 지정자 (position indicator) 의 위치를 조정한다.

`origin` 인자로 전달된 위치로 부터 `offset` 인자로 전달된 만큼 더한 위치로 위치 지정자를 설정한다.
이 함수를 호출한 이후에는 파일 끝 지정자 (End of File indicator) 가 초기화 되고, 이전에 만일 [ungetc](http://itguru.tistory.com/49)함수를 호출하였다면 이로 인한 효과는 모두 사라지게 된다.

한가지 명심해야 할 점은, 만일 텍스트 파일에 `fseek` 함수를 사용할 때, `offset` 값으로 0 이 아닌 값 혹은 `ftell` 함수에 의해 반환된 값을 사용할 때에는 일부 플랫폼에서는 약간 문제가 생겨서 예상치 못했던 위치에 위치 지정자가 설정되어 있는 경우가 있으니 주의해야 한다.

`fseek` 함수는 또한 스트림이 읽기 및 쓰기 형식으로 열려있을 때, 이 함수를 호출함을 통해 읽기 - 쓰기 모드를 전환할 수 있다. (자세한 내용은 [fopen](http://itguru.tistory.com/58)함수를 참조하기 바란다)



###  인자




`stream`

작업을 수행할 스트림의 `FILE` 객체를 가리키는 포인터

`offset`

`orgin` 으로 부터 얼마나 떨어진 곳에 설정할 지에 대한 값

`origin`

오프셋이 더해지는 위치로, `<stdio.h>` 에 정의된 다음과 같은 매크로 상수들을 이용한다.

|상수|설명|
|----|---|
|`SEEK_SET`|파일의 시작|
|`SEEK_CUR`|현재 파일 포인터의 위치|
|`SEEK_END`|파일의 끝|


###  리턴값




만일 성공하였으면 0 을 리턴한다. 그렇지 않다면 0 이 아닌 값을 리턴한다.



###  실행 예제




```cpp-formatted
/*

example.txt 에 "This is an apple" 을 쓴 뒤에 다시 fseek 함수를 이용하여 n 부터
sam 으로 바꾼다. 즉, example.txt 에는 "This is an sample" 이 들어가게 된다. 이
예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fseek/ 에서
가져왔습니다.

 */
#include <stdio.h>

int main() {
  FILE* pFile;
  pFile = fopen("example.txt", "w");
  fputs("This is an apple.", pFile);
  fseek(pFile, 9, SEEK_SET);
  fputs(" sam", pFile);
  fclose(pFile);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1470C5114BD23C5D569FE8)

`myfile.txt` 에는


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1470A1114BD23C5D437B49)





###  연관된 함수

*  [ftell](http://itguru.tistory.com/74)  :  스트림의 현재 위치를 구한다.
*  [fsetpos](http://itguru.tistory.com/73):  스트림의 위치 지정자를 설정한다.
*  [rewind](http://itguru.tistory.com/75)  :  스트림의 위치 지정자를 맨 처음으로 설정한다.
Link :  70
2010-04-18 08:40
----------------
title : C 언어 레퍼런스 - fgetpos 함수
cat_title :  fgetpos
publish_date : 2010-04-18 08:40
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fgetpos

```cpp-formatted
#include <stdio.h>  // C++ 에서는 <cstdio>

int fgetpos(FILE* stream, fpos_t* position);
```


스트림의 위치 지정자(position indicator)가 가리키는 위치를 `position` 에 저장한다.

따라서 인자로 전달되는 `position` 은 `fpos_t` 의 형을 가리키는 포인터 형태로 사용되어야 하며, 거의 대부분 [fsetpos](http://itguru.tistory.com/73)의 인자로만 사용하게 된다.

만일 파일 위치 지정자의 값을 정수형 데이터로 얻고 싶다면 [ftell](http://itguru.tistory.com/74)함수를 호출하면 된다.



###  인자




`stream`

스트림의 `FILE` 객체에 대한 포인터

`position`

`fpos_t` 객체를 가리키는 포인터



###  리턴값




이 함수는 성공적으로 값을 구하였다면 0 을 리턴하고 그렇지 않을 경우 0 이 아닌 값을 리턴한다.



###  실행 예제

```cpp-formatted
/*

이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fgetpos/
에서 가져왔습니다.

 */
#include <stdio.h>
int main() {
  FILE* pFile;
  int c;
  int n;
  fpos_t pos;

  pFile = fopen("myfile.txt", "r");
  if (pFile == NULL)
    perror("Error opening file");
  else {
    c = fgetc(pFile);
    printf("1st character is %c\n", c);
    fgetpos(pFile, &pos);
    for (n = 0; n < 3; n++) {
      fsetpos(pFile, &pos);
      c = fgetc(pFile);
      printf("2nd character is %c\n", c);
    }
    fclose(pFile);
  }
  return 0;
}
```


`myfile.txt` 파일의 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F156B741F4BCA43C84F2A48)
실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F156A741F4BCA43C8528424)


위 예제에서 일단 `myfile.txt` 에서 문자 하나를 입력받는다. 그 이후, `pos` 에 현재의 파일 위치 지정자의 위치를 저장한다. 문자 하나를 입력 받았으므로 파일 위치 지정자는 두 번째 문자 (b) 를 가리킬 것이다.

그 후, `for` 문에서 [fsetpos](http://itguru.tistory.com/73)함수를 이용하여 파일 위치 지정자의 위치를 계속 `pos` 로 바꾼다.

즉, 문자를 입력 받더라도 파일 위치 지정자가 그 다음 문자를 가리키는 것이 아니라 [fsetpos](http://itguru.tistory.com/73)함수에 의해 계속 두 번째 문자만 가리키게 되는 것이다. 따라서 `c d` 가 출력되지 않고 계속 `b b` 만 출력되게 된다.



###  연관된 함수

* [fsetpos](http://itguru.tistory.com/73)  :  스트림 위치 지정자를 설정한다.
* [ftell](http://itguru.tistory.com/74)  :  스트림 위치 지정자의 현재 위치를 구한다.
* [fseek](http://itguru.tistory.com/72)  :  스트림 위치 지정자의 위치를 변경한다.
Link :  69
2010-04-11 14:28
----------------
title : C 언어 레퍼런스 - fwrite 함수
cat_title :  fwrite
publish_date : 2010-04-11 14:28
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fwrite

```cpp-formatted
#include <stdio.h>  // C++ 에서는 <cstdio>

size_t fwrite(const void* ptr, size_t size, size_t count, FILE* stream);
```


스트림에 데이터 블록을 쓴다.

스트림에 `count` 개의 원소를 가지는 배열을 쓴다. 각각의 원소는 `size` 바이트이고, 그 배열은 `ptr` 이 가리키는 것이다.

따라서, 전체 스트림에 써지는 바이트 수는 `size * count` 가 된다.
전체 스트림에 써지는 바이트 수 만큼 위치 지정자가 증가하게 된다.



###  인자




`ptr`

스트림에 쓰여질 배열을 가리키는 포인터.

`size`

그 배열의 각각의 원소의 크기

`count`

그 배열의 원소의 수 이다. 이 때, 각 원소의 크기는 `size` 바이트 이다.

`stream`

내용을 쓸 스트림을 가리키는 `FILE` 포인터



###  리턴값




스트림에 성공적으로 써진 전체 원소의 개수는 `size_t` 형으로 리턴된다. 이는 정수형이다. 만일, 쓰여진 바이트 수와 `count` 의 값이 다르다면 오류가 발생되게 된다.



###  실행 예제




```cpp-formatted
/*

myfile.bin 에 "xyz" 라는 문자열을 출력한다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fwrite/
에서 가져왔습니다.

 */
#include <stdio.h>
int main() {
  FILE* pFile;
  char buffer[] = {'x', 'y', 'z'};
  pFile = fopen("myfile.bin", "wb");
  fwrite(buffer, 1, sizeof(buffer), pFile);
  fclose(pFile);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F1602181D4BC9A451538037)


파일의 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F15745F1D4BC9A452724628)





###  연관된 함수





*  [fread](http://itguru.tistory.com/68)  :  스트림에서 데이터 블록을 읽어온다.



*  [fprintf](http://itguru.tistory.com/64): 스트림에 형식에 맞추어 출력한다.

*  [putc](http://itguru.tistory.com/46):  스트릠에 문자를 쓴다.

*  [fputc](http://itguru.tistory.com/39)  : 스트림에 문자를 쓴다.
Link :  60
2010-04-11 12:35
----------------
title : 씹어먹는 C 언어 - <16 - 2. 모아 모아 구조체(struct) - 구조체 인자로 가진 함수>
cat_title : 16 - 2. 모아 모아 구조체(struct) - 구조체 인자로 가진 함수
next_page : 71
publish_date : 2010-04-11 12:35
--------------



이번 강좌에서는

* 구조체 포인터

* 구조체를 인자로 받기

* 구조체의 대입

![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분~ 드디어 구조체의 두번째 강의를 시작하게 되었습니다. 지금 강좌를 쓰다가 느낀 건데 제가 구조체를 배웠을 때 에는 정말로 재미있게 배웠던 것 같습니다. 일단 이전 강좌에서도 말했듯이 `->` 기호가 상당히 매력적으로 다가왔는데 그것 이외에도 "struct" 라는 단어를 정말 좋아했던 것 같네요. 여러분은 안그러시나요?


###  구조체 포인터 연습하기

일단, 이번 장의 진도를 나가기 위해선 구조체 포인터에 아주 능숙해 져야 하므로 지난번의 내용을 잠깐 복습하도록 하겠습니다.

```cpp-formatted
/* 포인터 갖고 놀기 */
#include <stdio.h>
struct TEST {
  int c;
};
int main() {
  struct TEST t;
  struct TEST *pt = &t;

  /* pt 가 가리키는 구조체 변수의 c 멤버의 값을 0 으로 한다*/
  (*pt).c = 0;

  printf("t.c : %d \n", t.c);

  /* pt 가 가리키는 구조체 변수의 c 멤버의 값을 1 으로 한다*/
  pt->c = 1;

  printf("t.c : %d \n", t.c);

  return 0;
}
```

성공적으로 컴파일 했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F18181F034B7D593F6DD7A5)

만일 지난번의 강좌를 어렴풋이 나마 기억하고 있는 분들이라면 별로 어려운 내용은 아닐 듯 싶습니다.

```cpp-formatted
struct TEST t;
struct TEST *pt = &t;
```

일단 `struct TEST` 형의 구조체 변수 `t` 와 `struct TEST` 형을 가리키는 포인터" `pt` 를 선언하였습니다. 다시 강조하지만, 우리가 `int, char` 로 생각하는 것 처럼 `struct TEST` 도 우리가 창조해 낸 하나의 타입이며, 이를 가리키는 포인터 역시 다른 모든 포인터와 같은 크기라는 것입니다. 즉 `pt` 는절대로 구조체가 아니며, `pt` 는 단순히 구조체 변수 `t` 가 저장되어 있는 메모리 공간의 주소값을 보관하고 있을 뿐입니다.

이 때, `pt` 는 `t` 의 주소값을 가지고 있으므로 `pt` 는 `t` 를 가리키게 됩니다.

```cpp-formatted
(*pt).c = 0;

printf("t.c : %d \n", t.c);
```


이제, `pt` 가 `t` 를 가리키고 있으므로 우리는 `pt` 를 가지고 `t` 의 값을 마음대로 조작할 수 있게 되었습니다.

이전에 `int *pi = &i` 를 한 후, `*pi` 를 쓰면 `i` 를 간접적으로 나타낼 수 있었듯이 `*pt` 를 이용하면 `pt` 가 가리키고 있는 `struct TEST` 형의 변수, 즉 `t` 를 나타낼 수 있게 됩니다.

따라서 `(*pt).c` 를 하면 `t` 의 멤버 `c` 를 의미하게 되죠. 이 때, `*pt` 를 괄호로 감싸주는 이유는 `.` 이 우선순위가 `*` 보다 높기 때문에 그냥 `*pt.c` 라고 쓰면 "pt 의 `c` 멤버가 가리키는 것" 을 의미하게 됩니다.

아무튼 `(*pt).c = 0;` 을 통해 우리는 `t` 의 `c` 멤버의 값을 성공적으로 바꿀 수 있었습니다.

하지만 `(*pt).c` 는 너무 쓰기 불편합니다. 항상 `*pt` 를 괄호로 닫아 주어야 하는데, 괄호는 `Shift` 를 누르고 키보드의 9 번과 0 번을 눌러야 하니 정말로 손가락도 아프로 불편할 따름이지요. 그래서 훌륭한 C 언어 제작자들은 새로운 편리한 연산자를 만들었습니다.

```cpp-formatted
pt->c = 1;

printf("t.c : %d \n", t.c);
```


바로 `->` 이죠. `->` 연산자의 의미는 "`pt` 가 가리키는 구조체 변수의 멤버" 를 의미합니다. 따라서 `pt->c` 는 "`pt` 가 가리키는 구조체 변수, 즉 `t` 의 멤버 `c`" 를 의미하게 됩니다. 따라서 `pt->c = 1;` 을 통해 우리는 `t` 의 멤버 `c` 의 값을 1 로 바꿀 수 있었습니다.

```cpp-formatted
/* 헷갈림 */
#include <stdio.h>
struct TEST {
  int c;
  int *pointer;
};
int main() {
  struct TEST t;
  struct TEST *pt = &t;
  int i = 0;

  /* t 의 멤버 pointer 는 i 를 가리키게 된다*/
  t.pointer = &i;

  /* t 의 멤버 pointer 가 가리키는 변수의 값을 3 으로 만든다*/
  *t.pointer = 3;

  printf("i : %d \n", i);

  /*

  -> 가 * 보다 우선순위가 높으므로 먼저 해석하게 된다.
  즉,
  (pt 가 가리키는 구조체 변수의 pointer 멤버) 가 가리키는 변수의 값을 4 로
  바꾼다. 라는 뜻이다/

  */
  *pt->pointer = 4;

  printf("i : %d \n", i);
  return 0;
}
```


성공적으로 컴파일 했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F19492E144B7D5C5B2117C3)

아마 위 예제만 제대로 이해하신 다면 더이상 구조체 포인터 가지고 혼동하는 일은 없을 듯 합니다.
먼저, `TEST` 구조체의 멤버들 부터 살펴봅시다.

```cpp-formatted
struct TEST {
  int c;
  int *pointer;
};
```


흠. 쟁쟁한 녀석이 나왔군요. 포인터가 있습니다. 하지만 괜찮습니다. 우리는 포인터를 잘 다루거든요.

```cpp-formatted
struct TEST t;
struct TEST *pt = &t;
int i = 0;
```

마찬가지로 `pt` 는 `t` 를 가리키게 됩니다.

```cpp-formatted
t.pointer = &i;
```


일단, 위 문장에서 `t` 의 `pointer` 라는 멤버에는 `i` 의 주소값이 들어갑니다. 따라서 `pointer` 는 `i` 를 가리키게 됩니다. 그렇다면 `pointer` 를 가지고 `i` 의 값을 바꾸며 놀 수 있겠죠? 바로 다음 문장을 봅시다.

```cpp-formatted
*t.pointer = 3;
```

흠. 우선 순위를 고려하면 `.` 가 `*` 보다 높으므로 `t.pointer` 가 먼저 해석되고 그 다음에 `*(t.pointer)` 형태로 해석되게 됩니다. 따라서, `*t.pointer` 를 통해 구조체 변수 `t` 의 `pointer` 멤버가 가리키는 변수를 지칭할 수 있게 됩니다.

```cpp-formatted
*pt->pointer = 4;
```

`.` 과 마찬가지로 `->` 도 `*` 보다 우선순위가 높습니다. 즉, `*(pt->pointer)` 와 `*pt->pointer` 는 동일한 의미라는 것입니다. 아무튼, `pt->pointer` 를 통해 "pt 가 가리키는 구조체 변수의 `pointer` 멤버", 즉 `t.pointer` 을 의미할 수 `*(pt->pointer) = 4` 를 통해 `pointer` 가 가리키는 변수의 값을 4 로 바꿀 수 있게 됩니다.

```cpp-formatted
/*

구조체 포인터 연습

 */
#include <stdio.h>
int add_one(int *a);
struct TEST {
  int c;
};
int main() {
  struct TEST t;
  struct TEST *pt = &t;

  /* pt 가 가리키는 구조체 변수의 c 멤버의 값을 0 으로 한다*/
  pt->c = 0;

  /*
  add_one 함수의 인자에 t 구조체 변수의 멤버 c 의 주소값을
  전달하고 있다.
  */
  add_one(&t.c);

  printf("t.c : %d \n", t.c);

  /*
  add_one 함수의 인자에 pt 가 가리키는 구조체 변수의 멤버 c
  의 주소값을 전달하고 있다.

  */
  add_one(&pt->c);

  printf("t.c : %d \n", t.c);

  return 0;
}
int add_one(int *a) {
  *a += 1;
  return 0;
}
```

성공적으로 컴파일 했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F146925104B7D5EF68E44B1)

이제, 마지막으로 구조체 포인터 연습을 해볼깔 합니다.

```cpp-formatted
struct TEST t;
struct TEST *pt = &t;
```

이전과 마찬가지로 `pt` 는 `t` 를 가리키고 있습니다.

```cpp-formatted
add_one(&t.c);
```


그리고 `add_one` 함수에 `t` 의 멤버 `c` 의 주소값을 전달하였습니다. 역시 `&` 보다 . 이 우선순위가 높으므로 위 식은 `&(t.c)` 와 동일합니다. 아무튼, `add_one` 함수에 의해 `c` 의 값이 1 증가 합니다.

```cpp-formatted
add_one(&pt->c);
```

마찬가지로 `->` 가 `&` 보다 우선순위가 높습니다. 따라서, `pt` 가 가리키는 구조체의 멤버 `c` 의 값이 1 증가하게 됩니다.

이해가 잘 되시죠?



### 구조체의 대입



구조체의 복사라 하면 무언가 거창할 것 같지만 사실은 상당히 단순한 내용입니다.

바로, 구조체도 보통의 변수들과 같이 `=` 를 사용할 수 있다는 것이지요. (= 가 대입 연산자 라는 사실은 기억하시죠??)

```cpp-formatted
#include <stdio.h>
struct TEST {
  int i;
  char c;
};
int main() {
  struct TEST st, st2;

  st.i = 1;
  st.c = 'c';

  st2 = st;

  printf("st2.i : %d \n", st2.i);
  printf("st2.c : %c \n", st2.c);

  return 0;
}
```


  성공적으로 컴파일 했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F203B51194B815A09E19D54)

여러분은 아마도 위 소스 코드를 한눈에 이해하셨을 수 있을 것입니다.

```cpp-formatted
struct TEST {
  int i;
  char c;
};
```

멤버가 `i` 와 `c` 인 `struct TEST` 를 정의하였고, 이 구조체의 변수인

```cpp-formatted
struct TEST st, st2;
```


`st` 와 `st2` 를 정의하였습니다. 그리고 `st` 의 각 멤버에

```cpp-formatted
st.i = 1;
st.c = 'c';
```

를 넣였죠.

```cpp-formatted
st2 = st;
```

그리고 우리는 위와 같이 `st` 를 `st2` 에 대입하였습니다. 우리가 변수 `i` 를 `j` 에 대입하면 `i` 의 값이 `j` 에 그대로 복사되듯이, `st2` 의 멤버 `i` 의 값은 `st` 의 멤버 `i` 의 값과 같아지고, `st2` 의 멤버 `c` 의 값은 `st` 의 멤버 `c` 의 값과 동일해졌습니다. 이는 상당히 합리적이고 대입 연산자의 역할을 잘 해내는 것 같네요.

```cpp-formatted
#include <stdio.h>
char copy_str(char *dest, char *src);
struct TEST {
  int i;
  char str[20];
};
int main() {
  struct TEST a, b;

  b.i = 3;
  copy_str(b.str, "hello, world");

  a = b;

  printf("a.str : %s \n", a.str);
  printf("a.i : %d \n", a.i);

  return 0;
}
char copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```

성공적으로 컴파일 했다면

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F1433CC154B83C9B880ADCB)


위 코드 역시 구조체의 대입이 무엇인지 잘 이해만 했다면 별 무리 없이 이해하실 수 있으리라 생각 합니다.

```cpp-formatted
struct TEST {
  int i;
  char str[20];
};
```


위와 같이 `struct TEST` 를 정의하였습니다. 이번에는 `int i` 와 `char str[20]` 을 멤버로 가지고 있습니다.

```cpp-formatted
struct TEST a, b;

b.i = 3;
copy_str(b.str, "hello, world");
```


이제 구조체를 정의한 뒤, 위와 같이 각각의 멤버를 초기화 합니다. `copy_str` 함수는 [15 - 3 강](http://itguru.tistory.com/33)에서 만들어본 함수죠?

```cpp-formatted
a = b;
```


그리고 우리는 위와 같이 `b` 구조체를 `a` 구조체에 대입하였습니다. 따라서, `b` 구조체의 모든 멤버의 데이터가 `a` 구조체에 일대일로 대응이 되어 값이 복사됩니다. 즉, `i` 는 `i` 끼리, `str` 은 `str` 의 각 원소 끼리 쭈르륵 복사가 됩니다. 결과적으로 각각의 멤버의 값을 출력해 보면 동일하게 나옵니다.



### 구조체를 인자로 전달하기



```cpp-formatted
/*구조체를 인자로 전달하기 */
#include <stdio.h>
struct TEST {
  int age;
  int gender;
};
int set_human(struct TEST a, int age, int gender);
int main() {
  struct TEST human;
  set_human(human, 10, 1);
  printf("AGE : %d // Gender : %d ", human.age, human.gender);
  return 0;
}
int set_human(struct TEST a, int age, int gender) {
  a.age = age;
  a.gender = gender;
  return 0;
}
```


  성공적으로 컴파일 하였다면 다음과 같은 오류를 만날 수 있으셨을 것입니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F18631B174BAEA99F7C78E4)

허걱. 오래간만에 만나는 오류이군요. 오류의 내용을 보자 하니, `human` 이라는 구조체 변수가 값이 초기화되지 않은 채 사용되었다고 하네요. 일단 소스 부터 살펴보도록 합시다.


```cpp-formatted
struct TEST {
  int age;
  int gender;
};
```


일단 우리는 위와 같이 `TEST` 구조체를 정의하였습니다. 그리고

```cpp-formatted
int set_human(struct TEST a, int age, int gender) {
  a.age = age;
  a.gender = gender;

  return 0;
}
```

`set_human` 이라는 함수를 만들어서 `TEST` 구조체 변수들을 초기화 하도록 했습니다. 따라서,

```cpp-formatted
set_human(human, 10, 1);
```

와 같이 한다면 `human` 의 `age` 와 `gender` 멤버들이 초기화 될 것 처럼보이지요. 하지만 그렇지 않습니다. 왜냐구요? 아마 여태까지 강좌를 잘 따라오셨더라면 한 번에 짐작하실 수 있으실 텐데 말이죠.

바로 제가 [13 - 2 강](http://itguru.tistory.com/27)에서 말한 규칙, "특정한 변수의 값을 다른 함수를 통해 바꾸려면 변수의 주소값을 전달해야 한다" 라는 룰을 지키지 않았기 때문입니다. 다시 말해 위 경우에서 `a.age = age;` 를 했을 때 `age` 의 값이 바뀌는 것은 실제 `main` 함수에서의 `human` 이 아니라 `set_human` 함수의 `a` 라는 `human` 과 별개의 구조체변수의 `age` 멤버의 값이 바뀌게 되는 것이지요.

따라서 실제 `human` 구조체변수의 멤버들은 전혀 초기화 되지 않은 채 출력이 실행되어 오류가 발생했습니다.

이를 해결하기 위해서는 역시 `human` 구조체 변수의 주소값을 인자로 받는 함수를 만들어야 할 것입니다.

```cpp-formatted
/* 인자로 제대로 전달하기 */
#include <stdio.h>
struct TEST {
  int age;
  int gender;
};
int set_human(struct TEST *a, int age, int gender);
int main() {
  struct TEST human;

  set_human(&human, 10, 1);

  printf("AGE : %d // Gender : %d ", human.age, human.gender);
  return 0;
}
int set_human(struct TEST *a, int age, int gender) {
  a->age = age;
  a->gender = gender;

  return 0;
}
```



성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1848DC1B4BAEB19D56553A)

위와 같이 `human` 구조체 변수의 멤버의 값들이 제대로 변경되었음을 알 수 있습니다.


```cpp-formatted
int set_human(struct TEST *a, int age, int gender) {
  a->age = age;
  a->gender = gender;

  return 0;
}
```

위 `set_human` 함수는 이전 예제에서의 `set_human` 함수와는 다르게 구조체의 포인터를 인자로 취하고 있습니다. 그렇기 때문에 `set_human` 함수를 호출할 때 에서도

```cpp-formatted
set_human(&human, 10, 1);
```

위와 같이 `human` 의 주소값을 인자로 전달하고 있었죠. 따라서, `a` 는 `human` 을 가리키게 됩니다. (역시 주의할 점은 `a` 는 절대로 구조체 변수가 아니라는 것이죠. 단순히 `human` 구조체 변수가 메모리 상에 위치한 곳의 시작 지점의 주소값을 보관하고 있을 뿐입니다) 아무튼 위와 같이 전달한다면 이제 `a->` 를 통해 `a` 가 가리키고 있는 구조체 변수의 멤버, 즉 위의 경우에서는 `human` 의 멤버를 지칭할 수 있게 됩니다. 따라서 `a->age = age;` 를 하게 되면 `human` 의 `age` 멤버의 값이 바뀌게 되는 것입니다.

물론 주의할 점은 `a->age` 와 `age` 는 다르다는 것이죠. `a->age` 는 `human` 구조체 변수의 `int` 형 멤버 `age` 를 지칭하는 것이고, `age` 는 단순히 `set_human` 함수에서 인자로 받아들여진 `int` 형의 `age` 라는 변수를 가리키는 말입니다. 이 둘은 다른 것이고 실제로 컴퓨터 내부에서도 다르게 처리됩니다.

아무튼 위와 같이 제대로 값이 바뀌어서 출력됨을 알 수 있습니다.

```cpp-formatted
/* 살짝 업그레이드*/
#include <stdio.h>
struct TEST {
  int age;
  int gender;
  char name[20];
};
int set_human(struct TEST *a, int age, int gender, const char *name);
char copy_str(char *dest, const char *src);

int main() {
  struct TEST human;

  set_human(&human, 10, 1, "Lee");

  printf("AGE : %d // Gender : %d // Name : %s \n", human.age, human.gender,
         human.name);
  return 0;
}
int set_human(struct TEST *a, int age, int gender, const char *name) {
  a->age = age;
  a->gender = gender;
  copy_str(a->name, name);

  return 0;
}
char copy_str(char *dest, const char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```


성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F125F3F264BAEB62683A187)

기본적으로 이전의 예제와는 동일하지만 멤버를 하나 더 추가했습니다.

```cpp-formatted
struct TEST {
  int age;
  int gender;
  char name[20];
};
```


위와 같이 `name[20]` 이라는 멤버를 새로 추가해주었습니다.

```cpp-formatted
int set_human(struct TEST *a, int age, int gender, const char *name);
```

그리고 `set_human` 함수에서 `name` 멤버 역시 같이 초기화해주기 위해 인자로 `char *` 형의 `name` 이라는 인자를 추가로 받게 됩니다.

```cpp-formatted
set_human(&human, 10, 1, "Lee");
```

이제 `TEST` 구조체 변수인 `human` 을 초기화 하기 위해서 `set_human` 함수를 호출하였습니다.


```cpp-formatted
int set_human(struct TEST *a, int age, int gender, const char *name) {
  a->age = age;
  a->gender = gender;
  copy_str(a->name, name);

  return 0;
}
```



위 함수는 `a` 가 가리키는 구조체 변수의 각 멤버들을 초기화 하게 됩니다. 이 때, `main` 함수의 `human` 구초제 변수의 `name` 멤버를 초기화 하기 위해서는 `copy_str` 함수를 이용해야 합니다. 이를 위해서는 `name` 배열의 주소값과, 복사해 넣으려는 문자열의 주소값을 넣어야 하는데 `a->name` 을 통해 `human` 구조체 변수의 `name` 멤버의 주소값과, `name` (이는 두 번째 인자로 `a->name` 과 전혀 다른 것이다) 을 통해 복사해 넣으려는 문자열의 주소값을 `copy_str` 에 전달할 수 있게 됩니다. 아무튼, 위를 통해 성공적으로 `human` 의 각각의 멤버들을 초기화 할 수 있게 되었죠.

자, 그럼 이번 강좌는 여기서 마치도록 하겠습니다. 아무래도 이번 강좌를 통해 구조체에 대한 확실한 자신감이 생겼으면 하네요. 다음 강좌에서는 구조체에 대해서 조금 더 살펴보고 실습을 해보던지, 아니면 새로운 C 의 기능들에 대해 탐구해 보도록 하죠. (아마 여기까지 도달하신 여러분들은 C 의 모든 고비를 넘겼다고 하셔도 무방합니다. 이제 모든 것이 술술 풀리게 될 것입니다)


### 생각해보기

#### 문제 1

(이전에 만든)도서 관리 프로그램을만들되,구조체를 이용해 봅시다. 또한 `register_book` 과 같은 함수를 이용하여 책을 등록해봅시다. (난이도 : 下)

#### 문제 2

큰 수를 다루는 구조체를 생각해봅시다. 그 구조체의 이름은 `BigNum` 입니다. `BigNum` 구조체에는 다음과 같은 멤버들이 있을 수 있습니다.



```cpp-formatted
struct BigNum {
  int i_digit[100];   // 정수 부분
  int d_digit[100];   // 소수 부분
  int i_total_digit;  // 전체 사용되고 있는 정수부분 자리수
  int d_total_digit;  // 전체 사용되고 있는 소수부분 자리수
  char sign;  // 부호, 0 이면 양수, 1 이면 음수. 0 은 양수로 간주한다.
};
```


* 이 때, `BigNum` 구조체의 변수들의 덧셈, 뺄셈을 수행하는 함수를 작성해보세요 (난이도 : 中上)
* `BigNum` 구조체 변수들의 곱셈을 수행하는 함수를 만들어보세요 (난이도 : 上)
* `BigNum` 구조체 변수들의 나눗셈을 수행하는 함수를 만들어보세요 (난이도 : 最上)

참고로 `BigNum` 구조체를 다룰 때 중요한 점은 수의 크기가 위 배열에 들어가지 않을 정도로 클 때를 적절히 처리해 주어야 한다는 점에 있습니다.

##@ chewing-c-end
Link :  68
2010-03-21 22:37
----------------
title : C 언어 레퍼런스 - fread 함수
cat_title :  fread
publish_date : 2010-03-21 22:37
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fread



```cpp-formatted
#include <stdio.h>  // C++ 에서는 <cstdio>

size_t fread(void* ptr, size_t size, size_t count, FILE* stream);
```


스트림에서 데이터 블록을 읽어온다.

스트림에서 `count` 개의 원소를 가지는 배열을 읽어온다. 이 때, 각 원소의 크기는 `size` 바이트 이고 `ptr` 이 가리키는 배열에 넣게 된다. (이 때, `count` 와 `size` 와 `ptr` 은 모두 `fread` 의 각각의 인자들을 의미한다)

스트림의 위치 표시자는 읽어들인 바이트 수 만큼 증가하게 된다.
전체 읽어들인 바이트 수는 만일 성공적일 경우, `(size * count)` 가 된다.



###  인자




`ptr`

`size * count` 의 크기를 가지는 배열을 가리키는 포인터

`size`
읽어들일 원소의 크기로 단위는 바이트 이다. 예를 들어 `size` 가 4 이면 하나의 원소의 크기는 4 바이트 임을 일컫는다.

`count`
읽어들일 원소들의 개수로 각 원소의 크기는 `size` 바이트 이다.

`stream`
데이터를 입력받을 스트림의 `FILE` 객체를 가리키는 포인터



###  리턴값




만일 성공적으로 지정한 원소의 개수 만큼 읽어들였다면 읽어들인 원소의 개수가 `size_t` 형으로 리턴된다. 

참고로 `size_t` 형은 정수 타입이다. 만일 읽어들인 개수가 `count` 인자에서 지정한 것과 다르거나, `End OF File` 에 도달하였다면 오류가 발생한다. 이 때, 여러분은 [ferror](http://itguru.tistory.com/52)함수나 [feof](http://itguru.tistory.com/51)함수를 이용하여 어떠한 오류인지를 파악할 수 있다.



###  실행 예제


```cpp-formatted
/*

myfile.bin 의 내용을 읽어 들여와 동적으로 할당한 buffer 에 저장한다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fread/
에서 가져왔습니다.

 */
#include <stdio.h>
#include <stdlib.h>

int main() {
  FILE* pFile;
  long lSize;
  char* buffer;
  size_t result;

  pFile = fopen("myfile.bin", "rb");
  if (pFile == NULL) {
    fputs("File error", stderr);
    exit(1);
  }

  // 파일의 크기를 ISize 에 저장한다.
  fseek(pFile, 0, SEEK_END);
  lSize = ftell(pFile);
  rewind(pFile);

  // 전체 파일의 내용을 받을 수 있을 정도의 크기로 메모리를 할당한다.
  buffer = (char*)malloc(sizeof(char) * lSize);
  if (buffer == NULL) {
    fputs("Memory error", stderr);
    exit(2);
  }

  // 그 파일의 내용을 버퍼에 저장한다.
  result = fread(buffer, 1, lSize, pFile);
  if (result != lSize) {
    fputs("Reading error", stderr);
    exit(3);
  }

  /* 이제 파일의 모든 내용은 버퍼에 들어가게 된다. */

  // 종료
  fclose(pFile);
  free(buffer);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F154D38104BA61B89A274D0)

###  연관된 함수

* `fwrite` : 스트림에 데이터 블록을 쓴다.
*  [fgetc](http://itguru.tistory.com/37): 스트림에서 한 문자를 가져온다.
*  [fscanf](http://itguru.tistory.com/65): 스트림에서 형식에 맞추러 데이터를 읽어온다.
Link :  66
2010-02-22 02:46
----------------
title : C 언어 레퍼런스 - sprintf 함수
cat_title :  sprintf
publish_date : 2010-02-22 02:46
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ sprintf

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int sprintf ( char * str, const char * format, ... );
```


`str` 에 데이터를 형식에 맞추어 쓴다.
`str` 가 가리키는 배열에 형식 문자열에 지정한 방식 대로 C 문자열을 쓴다. 쉽게 설명하자면, `printf` 에서 화면에 출력하는 대신에 화면에 출력할 문자열을 인자로 지정한 문자열에 쓴다는 것이다. 이 때, 인자로 지정한 배열의 크기는 배열에 쓰여질 문자열의 크기 보다 커야만 한다. 주의할 점은 `sprintf` 함수는 자동적으로 `str` 맨 마지막에 NULL  문자를 붙이기 때문에 항상 한 칸의 여유가 있어야 한다.



###  인자

`str`

C 문자열이 저장될 `char` 배열을 가리키는 포인 C 문자열이 저장될 `char` 배열을 가리키는 포인터

`format`

위 `str` 에 쓰여질 문자열을 포함하는 형식 문자열으로, 이는 형식 태그를 포함할 수 있다. 이 때, 형식 태그는 부수적 인자로 지정한 데이터와 치환되어 쓰여지게 된다. 이 때, 데이터가 치환되는 방식은 형식 태그에 의해 좌우된다. 따라서 부수적 인자의 개수는 적어도 형식 문자열에 사용된 형식 태그의 수 보다 많아야 한다.

형식 태그는 아래와 같이 생겼다.

```info
%[플래그(flag)][폭(width)][.정밀도][크기(length)]서식 문자(specifier)
```

#### 서식문자

이 때 서식 문자(specifier) 는 대응하는 인자를 어떠한 형태로 표현할지를 결정하는데에 가장 중요한 역할을 한다.

|서식 문자|출력 형태|예시 |
|---------|---------|-----|
|`c`      | 문자    | `a` |
|`d` or `i` | 부호 있는 십진법으로 나타난 정수|`392`|
|`e`      | 지수 표기법(Scientific notation) 으로 출력하되, `e` 문자를 이용한다.| `3.9265e+2`|
|`E`      | 지수 표기법(Scientific notation) 으로 출력하되, `E` 문자를 이용한다.|`3.9265E+2`|
|`f`      | 십진법으로 나타낸 부동 소수점 수| `392.65` |
| `g`     | %e나 `%f` 보다 간략하게 출력 |`392.65`|
| `G`     | %E나 `%f` 보다 간략하게 출력| `392.65`|
|`o`      | 부호 있는 팔진수| `610`|
|`s`      | 문자열 | `sample`|
|`u`      | 부호없는 십진법으로 나타낸 정수|`7235`|
|`x`      | 부호없는 16 진법으로 나타낸 정수 (소문자 사용) |`7fa`|
|`X`      | 부호없는 16 진법으로 나타낸 정수 (대문자 사용) |`7FA`|
|`p`      | 포인터 주소 |B800:0000 |
|`n`      | 아무것도 출력하지 않는다. 그 대신, 인자로 부호 있는 `int` 형을 가리키는 포인터를 전달해야 되는데, 여기에 현재까지 쓰여진 문자 수가 저장된다.||
|`%`      |`%` 다음에 %를 또 붙이면 `stdout` 에 `%` 를 출력한다.||

위 서식 문자를 이용한 다양한 출력 형태는 아래와 같다.
```cpp-formatted
#include <stdio.h>
int main() {
  int integer = 123;
  char character = 'c';
  char string[] = "hello, world";
  int* pointer = &integer;
  double pi = 3.141592;
  char buf[100];

  sprintf(buf, "integer : (decimal) %d (octal) %o \n", integer, integer);
  printf("%s \n", buf);

  sprintf(buf, "character : %c \n", character);
  printf("%s \n", buf);

  sprintf(buf, "string : %s \n", string);
  printf("%s \n", buf);

  sprintf(buf, "pointer addr : %p \n", pointer);
  printf("%s \n", buf);

  sprintf(buf, "floating point : %e // %f \n", pi, pi);
  printf("%s \n", buf);

  sprintf(buf, "percent symbol : %% \n");
  printf("%s \n", buf);

  return 0;
}
```

출력 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F112B51264B816E0D281CCD)

#### 플래그

형식 태그에는 위 말고도 플래그, 폭, .정확도, 제한자(modifier), 부-서식문자(sub-specifiers) 에 관련한 정보들이 포함될 수 있다. 먼저 플래그를 살펴보면 플래그는 기본적으로 출력되는 형태에 대해 조금 더 자세하게 지정할 수 있게 해준다. 플래그는 아래와 같다.

|플래그    |설명|
|`-`      | 폭에 맞추어 왼쪽 정렬을 하여 출력한다. `-` 를 붙이지 않는다면 기본적으로 오른쪽 정렬이 되어 출력한다. (아래 폭 지정자 참조).|
|`+`      | 출력 결과값이 양수인 경우라도 `+` 기호를 앞에 붙여서 출력하도록 한다. (물론 음수면 자동적으로 `-` 가 붙는다). 기본적으로 지정하지 않았을 경우 음수에만 앞에 `-` 가 붙는다.|
|(공백)    | 앞에 부호가 붙지 않는다면 한 칸을 띄어서 출력한다. (다시말해 123 은 " 123" 으로 출력되고 -123 은 "-123" 으로 출력된다)|
| #       |`o, x, X` 서식 문자들과 사용되면 출력되는 값 앞에 각각 `0, 0x, 0X` 가 붙게 된다. (이 때 0 은 제외한다). `e, E, f` 서식 문자들과 사용되면 소수점 아래 수들이 없음에도 불구하고 강제적으로 소수점을 붙이도록 한다. 원래 소수점 아래 수들이 없다면 소수점을 붙이지 않는다. `g` 와 `G` 서식 문자들과 사용되면 `e` 와 `E` 일때와 동일한 작업을 하지만 소수들의 뒷부분에 붙는 0 들 (123.1200 등) 은 제거되지 않는다.|
|`0`      | 수들을 왼쪽으로 정렬하되 빈 칸을 삽입하는 대신에 0 을 삽입한다. (폭 지정자 참조)|

#### 폭

폭은 말그대로 출력되는 데이터의 폭을 지정해준다. 참고로 여기서의 폭(width)은 뒤에 나오는 길이(length) 와는 완전히 다른 개념이므로 유의 하시기 바란다.

|폭 | 설명 |
| (수) | 출력할 최소의 문자 개수. 만일 이 수 보다 출력할 수 보다 작다면 빈칸을 삽입하여 길이를 맞춘다. 대신에, 이 수 보다 출력할 수가 큰 수의 경우 잘려서 출력되지는 않는다.|
|`*`   |폭을 형식 문자열에 지정해서 받지 않지만, 그 대신에 형식 문자열 뒤에 오는 인자들에 넣어서 받는다. 이 때, 이는 정수 값이여야 하며 폭을 지정하는 변수 뒤에 출력할 데이터가 위치하면 된다.|

```cpp-formatted
/* 사용 예 */
#include <stdio.h>
int main() {
  FILE *fp = fopen("output.txt", "w");
  char buffer[100];
  int i = 123;
  int j = -123;
  double f = 3.141592;

  sprintf(buffer, "폭 맞추기 \n");
  fputs(buffer, fp);
  sprintf(buffer, "i : %6d \n", i);
  fputs(buffer, fp);
  sprintf(buffer, "i : %7d \n", i);
  fputs(buffer, fp);
  sprintf(buffer, "i : %2d \n\n", i);
  fputs(buffer, fp);

  sprintf(buffer, "왼쪽 정렬 \n");
  fputs(buffer, fp);
  sprintf(buffer, "i : %5d끝 \n", i);
  fputs(buffer, fp);
  sprintf(buffer, "오른쪽 정렬 \n");
  fputs(buffer, fp);
  sprintf(buffer, "i : %-5d끝 \n\n", i);
  fputs(buffer, fp);

  sprintf(buffer, "# 문자의 사용 \n");
  fputs(buffer, fp);
  sprintf(buffer, "i : %#x \n", i);
  fputs(buffer, fp);
  sprintf(buffer, "i : %#X \n\n", i);
  fputs(buffer, fp);

  sprintf(buffer, "부호 붙이기 \n");
  fputs(buffer, fp);
  sprintf(buffer, "%+d, %+d \n", i, j);
  fputs(buffer, fp);
  return 0;
}
```

출력결과
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F207483284B816ECE83B42C)

파일에 쓰여진 모습
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1979DC284B816ECEB91429)

#### 정밀도 

정밀도는 말그대로 수치 데이터를 출력할 때 어떠한 정밀도로 출력하는지 (즉, 몇 자리 까지 출력해야 되는지) 를 지정해준다. 참고적으로 정밀도를 나타낼 때, 앞에 꼭 마침표(.) 을 찍는 것을 잊지 말기 바란다. 마침표를 찍는 이유는 앞에 폭과 구분을 하기 위해서 이다.

|정밀도|설명|
|.숫자| 정수 지정자 (d,i,o,u,x,X) 의 경우 : 정밀도는 출력되야할 최소의 자리수를 일컫는다. 만일, 어떤 정수의 자리수가 정밀도 보다 작다면 앞에 0 이 붙어서 자리수를 맞추게 된다. 또한 자리수가 더 크다고 해서 정수를 잘라서 출력하지는 않는다. 만일 정밀도가 0 이라면, 소수점 뒤에 자리수를 출력하지 않는다. `e,E, F` 의 경우 : 여기서 정밀도는 소수점 이하 출력될 자리수를 의미한다. `g, G` 의 경우 : 출력될 유효 숫자의 수를 의미한다. `s` 의 경우 : 출력될 문자의 최대 개수를 의미한다. 원래는 널 문자를 만나기 전까지 모든 문자가 출력되었었다. `c` 의 경우 : 아무 효과 없다. 만일 정밀도가 지정되지 않는다면 기본값으로 1 이 된다. 또한, 마침표(.) 을 찍었는데 아무런 숫자를 적지 않았다면 기본적으로 0 이 적혔다고 생각한다.|
|`.*`|형식 문자열에서 정밀도를 나타내지는 않지만 뒤에 인자로 정밀도 값을 준다. 이 때 인자는 형식 태그가 적용되는 데이타 앞에 있어야 한다.|

#### 길이

길이는 출력하는 데이터의 정확한 크기를 지정하는데 사용된다. 예를 들어서 `%d` 서식문자의 경우 막연하게 '정수형 데이터를 십진법으로 출력한다' 였지만 길이를 지정해주면 어떻나 크기로 데이터를 출력해야되는지 (`int` 냐 `short` 냐 등등) 을 지정할 수 있다.

|길이|설명|
|`h`|인자를 `short int` 혹은 `unsigned short int` 로 생각한다. (오직 `i, d, o, u , x, X` 서식 문자에만 적용된다)|
|`l`|정수 서식 문자(i,d,o,u,x, `X)` 에 사용되었을 경우 인자를 `long int` 나 `unsigned long int` 로 생각하며 `c` 나 `s` 에 사용되었을 경우 `wide character` 나 `wide string` 으로 생각한다.|
|`L`|인자를 `long double` 로 생각한다. (오직 부동 소수점 서식 문자인 `e,E,f,g, G` 에만 적용된다)|

```cpp-formatted
/* 사용 예 */
#include <stdio.h>
int main() {
  double f = 3.141592;
  int i = 12345;
  char buffer[100];

  sprintf(buffer, "f : %.3f \n", f);
  printf("buf: %s \n", buffer);
  sprintf(buffer, "i : %.10d \n", i);
  printf("buf : %s \n", buffer);

  return 0;
}
```

출력 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F1825CF264B816F33170FE3)

#### 부수적인 인자

형식 문자열에 따라 함수는 여러 인자들을 가지며, 각 인자는 형식 문자열의 각 형식 태그에 순차적으로 대응된다. 기본적으로 형식 문자열에 들어 있는 형식 태그의 수와 뒤따라 붙는 인자들의 수는 같아야 한다. (물론 `.*` 이나 `*` 과 같은 예외적인 상황은 제외한다)



###  sprintf 함수의 활용 : 수를 문자열로 바꾸기


`sprintf` 함수를 잘 이용하면 수를 손쉽게 문자열로 바꿀 수 있다. 바로 다음과 같이.

```cpp-formatted
#include <stdio.h>
int main() {
  int i;
  char str[100];

  scanf("%d", &i);
  sprintf(str, "%d", i);

  printf("str : %s \n", str);

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F182E3B244B816FA01FF33B)

`i` 의 값을 `%d` 의 형태로 `str` 에 문자열로 넣었으니 `str` 에는 `i` 의 값이 문자열의 형태로 변환된다.
마찬가지 방법으로 `i` 의 값을 16 진수나 8 진수 형태로 (`%x, %o`) 넣을 수 도 있다.



###  리턴값


`str` 에 쓰기가 성공할 경우 쓰여진 총 문자의 개수가 반환된다. 이 때, 이 문자의 개수는 맨 마지막에 자동적으로 붙는 `NULL` 문자는 포함하지 않는다.
실패할 경우 음수가 리턴된다.



###  실행 예제


```cpp-formatted
/*

sprintf 함수 예제
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/sprintf/
에서 가져왔습니다.

*/
#include <stdio.h>
int main() {
  char buffer[50];
  int n, a = 5, b = 3;
  n = sprintf(buffer, "%d plus %d is %d", a, b, a + b);
  printf("[%s] is a %d char long string\n", buffer, n);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1203AA0C4B8170D90DA277)




###  연관된 함수

*  [printf](http://itguru.tistory.com/35) :  표준 출력(stdout) 에 데이터를 형식에 맞추어 출력한다.
*  [sscanf](http://itguru.tistory.com/67) :  문자열에서 데이터를 형식에 맞추어 읽는다.
Link :  65
2010-02-22 02:04
----------------
title : C 언어 레퍼런스 - fscanf 함수
cat_title :  fscanf
publish_date : 2010-02-22 02:04
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fscanf

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int fscanf ( FILE * stream, const char * format, ... );
```


스트림에서 데이터를 특정한 형식으로 읽어온다.

스트림에서 형식 문자열에서 지정한 방식대로 데이터를 읽어온 후, 형식 문자열의 각각의 형식 지정자에 대응하는 인자가 가리키는 메모리 공간에 그 데이터를 집어 넣는다.



###  인자

`stream`

데이터를 읽어올 스트림의 `FILE` 객체를 가리키는 포인터

`format`

C 형식 문자열로 다음의 것들을 포함하고 있 C 형식 문자열로 다음의 것들을 포함하고 있다

* 공백 문자 (Whitespace character 이라 부르며, 개행 문자(\n), 탭 문자, 띄어쓰기(' ') 이다)  : `fscanf` 함수는 비-공백 문자를 읽어들이기 전까지 읽혀지는 모든 공백 문자들을 무시한다.

* 비-공백 문자 (Non whitespcae character), 단 `%` 를 제외한다 : 공백 문자가 아니거나 형식 지정자에 포함되지 않는 것들은 함수로 하여금 다음 문자를 스트림에서 읽어 들이고 이와 이 비-공백 문자와 비교하여 같다면 버리고 다음 문자와 형식으로 진행한다. 만일 다르다면 함수가 종료되고, 스트림에서 읽혀지지 않은 다른 문자들은 모두 남아있게 된다.

* 형식 지정자 : 이는 `%` 로 지정되는 것들로 스트림에서 어떠한 형식으로 데이터를 읽어오고, 또 각각의 형식 지정자에 대응되는 인자에 어떠한 형식으로 저장할 지에 대해 결정한다. 형식 지정자는 아래와 같은 꼴로 생겼다.


```info
%[*][폭(width)][한정자(modifiers)]타입(type)
```

|종류|설명|
|----|----|
|`*`| 데이터를 `stdin` 에서 받아들이지만 무시된다. 물론, 이에 대응되는 인자에는 받아들인 데이터가 저장되지 않고 이 인자는 다음 형식 태그에 대응된다. 예를 들어 `fscanf(fp, "%*d%d", i,j);` 의 경우 먼저 수를 입력하더라도 `%*d` 형식이므로 무시 된다. 그 다음 수를 입력하면 `%d` 형식 태그가 `j` 가 아닌 `i` 에 대응되어 `i` 에 그 다음 입력한 수가 들어가게 된다. 이 때 `j` 에는 아무런 값도 들어가지 않는다.|
|폭|`stdin` 에서 읽어들일 최대 문자 수를 지정한다. 예를 들어 `fscanf(fp, "%10s", str);` 로 했을 경우 `stdin` 에서 최대 10 문자를 읽어와 `str` 에 저장한다. 이 때 주의할 점은 `str` 에는 `NULL` 문자가 들어갈 수 있는 충분한 공간이 남아 있어야 한다.|
|한정자|입력받는 데이터의 크기를 지정한다. `int, unsigned int, float` 형에 대해 입력받는 데이터의 크기를 설정할 수 있다. `h` 의 경우 `short int` (`d, i, n` 의 경우) 혹은 `unsigned short int` (`o, u, x` 일 경우). `l` 의 경우 `long int` (`d, i, n` 의 경우) 혹은 `unsigned long int` (`o, u, x` 일 경우), 혹은 `double` (`e, f, g` 일 경우). 마지막으로 `L` 의 경우 `long double` (`e, f, g` 일 경우) 에 사용할 수 있다.|
|타입|데이터를 어떠한 형식으로 혹은 어떠한 값만을 읽어들어야 할 지에 대해 지정해준다. 아래 표를 참고.|


#### fscanf 함수의 타입 지정자들

|타입|대응되는 입력 방식|대응되는 인자의 형태|
|`c`|단일 문자: 하나의 문자를 읽어들인다. 만일 폭에 1 이 아닌 값으로 지정되어 있다면 (기본값은 1) 함수는 폭 만큼의 문자를 읽어들인 후 이에 대응하는 인자가 가리키는 메모리 공간에 저장한다. 이 때 마지막에는 널 문자를 붙이지 않는다.|`char *`|
|`d`|십진법으로 표현된 정수: 말그대로 십진법으로 쓰인 정수로, `+` 나 `-` 기호로 시작할 수도 있다.`int *`|
|`e, E, f, g, G`|부동 소수점: 소수점을 포함하고 있는 소수(decimal number) 로 `+` 나 `-` 기호로 시작할 수도 있으며, `e` 나 `E` 문자(10 의 지수를 나타내기 위해)를 포함할 수 도 있다. -732.103, 12e-4, +123.10 은 모두 올바른 입력이다.| `float *`|
|`o`|8진법으로 표현된 정수|`int *`|
|`s`|문자열: 공백문자를 찾을 때 까지 문자들을 읽어들인다.|`char *`|
|`u`|부호가 없는 십진법으로 표현된 정수|`unsigned int *`|
|`x, X`|16진법으로 표현된 정수|`int *`|

#### 부수적 인자

형식 문자열의 정의된 순서대로 각 형식 지정자는 이에 대응하는 인자가 가리키는 메모리 공간에 데이터를 집어넣는다. 이 때, 부수적 인자들은 모두 포인터의 형태 (주소값) 여야 한다. 예를 들어서 `i` 라는 변수에 값을 대입하려면 인자로 `&i` 를 전달해야 한다. 절대로 `i` 를 전달하면 안된다.

에를 들면 아래와 같다.

```cpp-formatted
FILE *fp = fopen("out.txt", "w");
int i;
fscanf(fp, "%d", &i); /* 꼭 주소값을 전달해야 된다는 점에 유의! */
```

###  리턴값

성공할 경우, `fscanf` 함수는 읽어들인 데이터의 수를 리턴한다. 만일 어떠한 데이터도 형식 지정자와 일치하는 것이 없다면 0 이 될 수 도 있다.

만일 어떠한 데이터도 성공적으로 읽어들이기 전에 입력이 실패한다면 `EOF` 가 리턴된다.


###  실행 예제


```cpp-formatted
/*

myfile.txt 에 3.1416 과 PI 를 쓴 뒤, 이를 다시 myfile.txt 에서 읽어들인다. 이
때, myfile.txt 를 w+ 형식으로 열었으므로 출력 뒤에 입력을 하기 위해서는 fflush
나 rewind 와 같은 파일 위치 지정자 조정 함수를 호출해야 하는데 이 경우 rewind
함수를 호출하여 위치 표시자를 맨 앞으로 돌렸다.

 */
#include <stdio.h>
int main() {
  char str[80];
  float f;
  FILE* pFile;

  pFile = fopen("myfile.txt", "w+");
  fprintf(pFile, "%f %s", 3.1416, "PI");
  rewind(pFile);
  fscanf(pFile, "%f", &f);
  fscanf(pFile, "%s", str);
  fclose(pFile);
  printf("I have read: %f and %s \n", f, str);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F110817274B8166BB8D0682)

파일에 쓰여진 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F201841274B8166BC620379)

###  연관된 함수

*  [scanf](http://itguru.tistory.com/36)  :  표준 입력(stdin) 에서 데이터를 특정한 형식으로 읽어온다.
* `fprintf ` :  스트림에 특정한 형식으로 데이터를 쓴다.
* `fread ` :  스트림에서 데이터 블록을 읽어온다.
*  [fgets](http://itguru.tistory.com/38)  :  스트림에서 문자열을 읽어온다.
Link :  64
2010-02-19 02:11
----------------
title : C 언어 레퍼런스 - fprintf 함수
cat_title :  fprintf
publish_date : 2010-02-19 02:11
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fprintf

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int fprintf ( FILE * stream, const char * format, ... );

```

데이터를 형식에 맞추어 스트림에 쓴다.

특정한 스트림에 일련의 데이터를 특정한 형식에 맞추어 쓰게 된다. 이 때, 그 형식은 형식 문자열에 지정되어 있으며, 출력할 데이터는 형식 문자열 다음에 오는 인자들에 써주면 된다.



###  인자




`stream`

작업을 수행할 스트림의 `FILE` 객체

`format`

C 문자열로 스트림에 써질 텍스트를 포함하고 있다 C 문자열로 스트림에 써질 텍스트를 포함하고 있다.

또한 이 문자열에는 형식 태그를 부수적으로 포함할 수 있는데 이는 각각의 형식 태그에 대응되는 인자의 데이터가 형식 태그가 지정하는대로 치환된다.

따라서, 이 문자열에 포함되어 있는 형식 태그의 수는 뒤에 부수적으로 오는 인자의 개수 보다 언제나 같거나 적어야 한다.

형식 태그는 다음과 같은 꼴로 써야 한다.

```info
%[플래그(flag)][폭(width)][.정밀도][크기(length)]서식 문자(specifier)
```

#### 서식문자

이 때, 형식 태그에서 가장 중요한 부분은 서식 문자로 이는 이 형식 태그에 대응되는 인자의 값이 어떠한 형태로 출력되는지를 조정해 준다.

|서식 문자|출력 형태|예시 |
|---------|---------|-----|
|`c`      | 문자    | `a` |
|`d` or `i` | 부호 있는 십진법으로 나타난 정수|`392`|
|`e`      | 지수 표기법(Scientific notation) 으로 출력하되, `e` 문자를 이용한다.| `3.9265e+2`|
|`E`      | 지수 표기법(Scientific notation) 으로 출력하되, `E` 문자를 이용한다.|`3.9265E+2`|
|`f`      | 십진법으로 나타낸 부동 소수점 수| `392.65` |
| `g`     | %e나 `%f` 보다 간략하게 출력 |`392.65`|
| `G`     | %E나 `%f` 보다 간략하게 출력| `392.65`|
|`o`      | 부호 있는 팔진수| `610`|
|`s`      | 문자열 | `sample`|
|`u`      | 부호없는 십진법으로 나타낸 정수|`7235`|
|`x`      | 부호없는 16 진법으로 나타낸 정수 (소문자 사용) |`7fa`|
|`X`      | 부호없는 16 진법으로 나타낸 정수 (대문자 사용) |`7FA`|
|`p`      | 포인터 주소 |B800:0000 |
|`n`      | 아무것도 출력하지 않는다. 그 대신, 인자로 부호 있는 `int` 형을 가리키는 포인터를 전달해야 되는데, 여기에 현재까지 쓰여진 문자 수가 저장된다.||
|`%`      |`%` 다음에 %를 또 붙이면 `stdout` 에 `%` 를 출력한다.||


위 서식 문자를 이용한 다양한 출력 형태는 아래와 같다.
```cpp-formatted
#include <stdio.h>
int main() {
  FILE* fp = fopen("output.txt", "w");
  int integer = 123;
  char character = 'c';
  char string[] = "hello, world";
  int* pointer = &integer;
  double pi = 3.141592;

  fprintf(fp, "integer : (decimal) %d (octal) %o \n", integer, integer);

  fprintf(fp, "character : %c \n", character);

  fprintf(fp, "string : %s \n", string);

  fprintf(fp, "pointer addr : %p \n", pointer);

  fprintf(fp, "floating point : %e // %f \n", pi, pi);

  fprintf(fp, "percent symbol : %% \n");

  return 0;
}
```


출력 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F2043C0134B7C11CA50B5DB)


파일의 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F12480A134B7C11CA40B3C2)

`output.txt` 에 우리가 형식 문자열에서 지정해준대로 잘 표시되었음을 알 수 있다. 또한, 콘솔에는 출력을 하지 않았으므로 콘솔에는 아무것도 표시되지 않았다.

#### 플래그

형식 태그에는 위 말고도 플래그, 폭, .정확도, 제한자(modifier), 부-서식문자(sub-specifiers) 에 관련한 정보들이 포함될 수 있다. 먼저 플래그를 살펴보면 플래그는 기본적으로 출력되는 형태에 대해 조금 더 자세하게 지정할 수 있게 해준다. 플래그는 아래와 같다.

|플래그    |설명|
|`-`      | 폭에 맞추어 왼쪽 정렬을 하여 출력한다. `-` 를 붙이지 않는다면 기본적으로 오른쪽 정렬이 되어 출력한다. (아래 폭 지정자 참조).|
|`+`      | 출력 결과값이 양수인 경우라도 `+` 기호를 앞에 붙여서 출력하도록 한다. (물론 음수면 자동적으로 `-` 가 붙는다). 기본적으로 지정하지 않았을 경우 음수에만 앞에 `-` 가 붙는다.|
|(공백)    | 앞에 부호가 붙지 않는다면 한 칸을 띄어서 출력한다. (다시말해 123 은 " 123" 으로 출력되고 -123 은 "-123" 으로 출력된다)|
| #       |`o, x, X` 서식 문자들과 사용되면 출력되는 값 앞에 각각 `0, 0x, 0X` 가 붙게 된다. (이 때 0 은 제외한다). `e, E, f` 서식 문자들과 사용되면 소수점 아래 수들이 없음에도 불구하고 강제적으로 소수점을 붙이도록 한다. 원래 소수점 아래 수들이 없다면 소수점을 붙이지 않는다. `g` 와 `G` 서식 문자들과 사용되면 `e` 와 `E` 일때와 동일한 작업을 하지만 소수들의 뒷부분에 붙는 0 들 (123.1200 등) 은 제거되지 않는다.|
|`0`      | 수들을 왼쪽으로 정렬하되 빈 칸을 삽입하는 대신에 0 을 삽입한다. (폭 지정자 참조)|

#### 폭

폭은 말그대로 출력되는 데이터의 폭을 지정해준다. 참고로 여기서의 폭(width)은 뒤에 나오는 길이(length) 와는 완전히 다른 개념이므로 유의 하시기 바란다.

|폭 | 설명 |
| (수) | 출력할 최소의 문자 개수. 만일 이 수 보다 출력할 수 보다 작다면 빈칸을 삽입하여 길이를 맞춘다. 대신에, 이 수 보다 출력할 수가 큰 수의 경우 잘려서 출력되지는 않는다.|
|`*`   |폭을 형식 문자열에 지정해서 받지 않지만, 그 대신에 형식 문자열 뒤에 오는 인자들에 넣어서 받는다. 이 때, 이는 정수 값이여야 하며 폭을 지정하는 변수 뒤에 출력할 데이터가 위치하면 된다.|

```cpp-formatted
/* 사용 예 */
#include <stdio.h>
int main() {
  FILE *fp = fopen("output.txt", "w");
  int i = 123;
  int j = -123;
  double f = 3.141592;

  fprintf(fp, "폭 맞추기 \n");
  fprintf(fp, "i : %6d \n", i);
  fprintf(fp, "i : %7d \n", i);
  fprintf(fp, "i : %2d \n\n", i);

  fprintf(fp, "왼쪽 정렬 \n");
  fprintf(fp, "i : %5d끝 \n", i);
  fprintf(fp, "오른쪽 정렬 \n");
  fprintf(fp, "i : %-5d끝 \n\n", i);

  fprintf(fp, "# 문자의 사용 \n");
  fprintf(fp, "i : %#x \n", i);
  fprintf(fp, "i : %#X \n\n", i);

  fprintf(fp, "부호 붙이기 \n");
  fprintf(fp, "%+d, %+d \n", i, j);
  return 0;
}
```

출력결과
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F2043C0134B7C11CA50B5DB)

파일에 출력된 모습
![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F143AC8134B7C128D4E3B18)

이전의 예제와 같이 `output.txt` 에 우리가 지정한 방식대로 잘 출력되었음을 볼 수 있다.

#### 정밀도 

정밀도는 말그대로 수치 데이터를 출력할 때 어떠한 정밀도로 출력하는지 (즉, 몇 자리 까지 출력해야 되는지) 를 지정해준다. 참고적으로 정밀도를 나타낼 때, 앞에 꼭 마침표(.) 을 찍는 것을 잊지 말기 바란다. 마침표를 찍는 이유는 앞에 폭과 구분을 하기 위해서 이다.

|정밀도|설명|
|.숫자| 정수 지정자 (d,i,o,u,x,X) 의 경우 : 정밀도는 출력되야할 최소의 자리수를 일컫는다. 만일, 어떤 정수의 자리수가 정밀도 보다 작다면 앞에 0 이 붙어서 자리수를 맞추게 된다. 또한 자리수가 더 크다고 해서 정수를 잘라서 출력하지는 않는다. 만일 정밀도가 0 이라면, 소수점 뒤에 자리수를 출력하지 않는다. `e,E, F` 의 경우 : 여기서 정밀도는 소수점 이하 출력될 자리수를 의미한다. `g, G` 의 경우 : 출력될 유효 숫자의 수를 의미한다. `s` 의 경우 : 출력될 문자의 최대 개수를 의미한다. 원래는 널 문자를 만나기 전까지 모든 문자가 출력되었었다. `c` 의 경우 : 아무 효과 없다. 만일 정밀도가 지정되지 않는다면 기본값으로 1 이 된다. 또한, 마침표(.) 을 찍었는데 아무런 숫자를 적지 않았다면 기본적으로 0 이 적혔다고 생각한다.|
|`.*`|형식 문자열에서 정밀도를 나타내지는 않지만 뒤에 인자로 정밀도 값을 준다. 이 때 인자는 형식 태그가 적용되는 데이타 앞에 있어야 한다.|

#### 길이

길이는 출력하는 데이터의 정확한 크기를 지정하는데 사용된다. 예를 들어서 `%d` 서식문자의 경우 막연하게 '정수형 데이터를 십진법으로 출력한다' 였지만 길이를 지정해주면 어떻나 크기로 데이터를 출력해야되는지 (`int` 냐 `short` 냐 등등) 을 지정할 수 있다.

|길이|설명|
|`h`|인자를 `short int` 혹은 `unsigned short int` 로 생각한다. (오직 `i, d, o, u , x, X` 서식 문자에만 적용된다)|
|`l`|정수 서식 문자(i,d,o,u,x, `X)` 에 사용되었을 경우 인자를 `long int` 나 `unsigned long int` 로 생각하며 `c` 나 `s` 에 사용되었을 경우 `wide character` 나 `wide string` 으로 생각한다.|
|`L`|인자를 `long double` 로 생각한다. (오직 부동 소수점 서식 문자인 `e,E,f,g, G` 에만 적용된다)|

```cpp-formatted
/* 사용 예 */
#include <stdio.h>
int main() {
  double f = 3.141592;
  int i = 12345;

  fprintf(stdout, "f : %.3f \n", f);
  fprintf(stdout, "i : %.10d \n", i);

  return 0;
}
```

출력 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F135054234B5DB76133E080)

이번에는 파일 스트림에 출력하는 것이 아니라 표준 출력(stdout), 즉 콘솔 화면에 출력을 해 보았다. 역시 우리가 지정한 형식대로 잘 출력된다.

부수적인 인자

형식 문자열에 따라 함수는 여러 인자들을 가지며, 각 인자는 형식 문자열의 각 형식 태그에 순차적으로 대응된다. 기본적으로 형식 문자열에 들어 있는 형식 태그의 수와 뒤따라 붙는 인자들의 수는 같아야 한다. (물론 `.*` 이나 `*` 과 같은 예외적인 상황은 제외한다)



###  리턴값


출력 성공시, 화면에 출력된 총 문자의 개수를 반환한다.
실패했다면 음수가 반환된다.



###  실행 예제


```cpp-formatted
/*

사용자로 부터 이름을 입력받아 이를 깔끔하게 myfile.txt 에 기록한다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fprintf/
에서 가져왔습니다.

 */
#include <stdio.h>
int main() {
  FILE* pFile;
  int n;
  char name[100];

  pFile = fopen("myfile.txt", "w");
  for (n = 0; n < 3; n++) {
    puts("please, enter a name: ");
    gets(name);
    fprintf(pFile, "Name %d [%-10.10s]\n", n, name);
  }
  fclose(pFile);

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F115248014B7D726B2BDC4A)

파일에 출력된 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F18235C014B7D726B5F7BA8)

`fprintf` 에서 사용한 형식 문자열에 대해 설명을 하자면

```info
%-10.10s
```

먼저 봐야 할 것은 서식 문자인데, `s` 는 데이터를 문자열로 출력하라는 것이다. 맨 앞의 `-` 는 문자열을 "왼쪽 정렬" 해서 출력하라는 의미 이다. 그 뒤에 10 은 최소 10 개의 문자를 출력하라는 뜻으로 길이가 10 미만인 문자열은 공백으로 길이를 맞춘다. Psi 다음에 쭉 위치한 공백이 그것이다. 그리고 `.10` 은 최대 10 문자를 출력하라는 뜻으로 10 문자가 넘으면 잘리게 된다. 위에 `Genious Psi` 가 잘려서 `Genious Ps` 까지 출력된 것을 볼 수 있다.



###  연관된 함수


*  [printf](http://itguru.tistory.com/35)  :  특정한 형식에 맞추어 데이터를 `stdout` 에 출력한다.

*  [fscanf](http://itguru.tistory.com/65)  :  특정한 형식에 맞추어 스트림에서 데이터를 읽어온다.

*  [fwrite](http://itguru.tistory.com/69)  :  스트림에 데이터 블록을 쓴다.

*  [fputs](http://itguru.tistory.com/40)  :  스트림에 문자열을 쓴다.
Link :  63
2010-02-18 01:13
Link :  62
2010-02-18 00:36
----------------
title : C 언어 레퍼런스 - setvbuf 함수
cat_title :  setvbuf
publish_date : 2010-02-18 00:36
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ setvbuf

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );

```

스트림 버퍼링 방식을 변경한다.

버퍼를 특정한 스트림의 입출력 연산에 사용될 수 있도록 변경한다. 이 함수는 버퍼링 방식과 버퍼의 크기를 설정할 수 있게 지원한다.

버퍼의 크기는 세번째 인자에 바이트 수로 전달된다.

만일 버퍼를 설정하지 않는다면 (즉, 두 번째 인자가 `NULL` 이라면), 시스템은 동적으로, 함수에 의해 요청된 크기 만큼 메모리를 할당하게 되며 이를 스트림의 버퍼로 사용하게 된다.

`mode` 인자는 이 버퍼를 fully buffered, line buffered, 아니면 unbuffered 로 할 지 결정한다.

**fully buffered** 스트림의 경우 읽기 작업은 스트림에 대응되는 장비에 바로 쓰여지지 않는다. 그 대신에 쓰여질 데이터는 버퍼에 잠시 저장되었다가 버퍼에 일정한 블록 이상 쌓이게 되면 그제서야 장비에 쓰여지게 된다.

물론, 한 블록이 다 채워지지 않았는데도 불구하고 스트림을 강제로 비움으로써 (flush) 장비에 쓸 수 있는데 이는 [fflush](http://itguru.tistory.com/57)함수를 호출하거나 [fclose](http://itguru.tistory.com/54)함수를 호출해 파일을 닫으면 된다. 참고적으로 모든 버퍼는 프로그램이 종료시 자동적으로 비워지게 된다.

**line buffered** 스트림의 경우 버퍼에 개행 문자가 입력될 때 마다 장비에 쓰여지게 된다.

**unbuffered** 스트림의 경우 데이터는 버퍼와 같은 중간 경유지를 거치지 않고 직접적으로 쓰여지게 된다. 즉, 쓰기 작업을 할 때 바로바로 쓰이게 된다.

모든 열려진 파일들은 기본적으로 할당된 버퍼를 가지고 있다. 이 함수는 그렇게 할당된 버퍼의 크기를 재조정 하거나, 사용자가 특별히 할당한 버퍼로 버퍼를 바꾸거나, 파일의 버퍼링 방식을 변경할 수 있게 해준다. 표준 출력(stdout) 이나 표준 오류(stderr) 같은 시스템 표준 스트림은 리다이렉트(redirect) 되지 않는 한 기본적으로 unbuffered 로 설정되어 있다.



###  인자

`stream`

작업을 수행할 열린 스트림의 `FILE` 객체를 가리키는 포인터.

`buffer`

유저가 할당한 버퍼로 최소한 1 바이트의 크기는 되야 한다.
만일 `NULL` 로 설정하면 함수는 자동으로 지정한 크기의 버퍼를 할당하게 된다

`mode`

파일 버퍼링의 형식을 지정한다.

* `_IOFBF` 완전한 버퍼링(Full Buffering): 앞에서 설명한 fully buffered 스트림을 일컫는다.
* `_IOLBF` 행 버퍼링(Line Buffering): 출력시, 버퍼가 채워지거나 스트림에 개행 문자가 입력되었다면 데이터가 버퍼에서 출력된다. 입력 시에는 버퍼가 개행 문자를 만날 때 까지 버퍼를 채우게 된다.
* `_IONBF` 버퍼링 사용 안함(No Buffering): 버퍼를 사용하지 않는다. 각각의 입출력 작업은 버퍼를 지나지 않고 요청 즉시 진행되며 이 겨우 `buffer` 인자와 `size` 인자는 모두 무시된다.

`size`

지정할 버퍼의 크기로 단위는 바이트 이다. 이 때, 버퍼로 지정한 배열의 크기 보다 반드시 작거나 같아야 한다.

만일 이 인자가 `NULL` 이라면 컴퓨터가 스스로 버퍼가 취할 수 있는 최소의 크기를 결정하게 된다.



###  리턴값

만일 버퍼가 성공적으로 지정 되었다면 0 이 리턴된다.

그렇지 않을 경우 0 이 아닌 값이 리턴되는데 보통 적당하지 않은 `size` 값을 인자로 넘겼거나, `size` 에 `NULL` 을 넘겼지만 컴퓨터가 메모리를 할당하는 과정 중 오류가 발생하는 경우이다.



###  실행 예제


```cpp-formatted
/*

파일을 _IOFBF 형식으로 열며, 버퍼는 크기가 1024 바이트로 컴퓨터가 자동으로
할당하게 한다. 이 예제는
http://www.cplusplus.com/reference/clibrary/cstdio/setvbuf/ 에서 가져왔습니다.

 */
#include <stdio.h>
int main() {
  FILE *pFile;
  pFile = fopen("myfile.txt", "w");
  setvbuf(pFile, NULL, _IOFBF, 1024);

  /* 여러 파일 입출력 작업들 */

  fclose(pFile);

  return 0;
}
```


스트림 버퍼 형식이 `_IOFBF,` 즉 fully buffered 스트림이기 때문에 버퍼가 다 차지 않는 이상 쓰기 작업을 하지 않게 된다. 즉, 버퍼에 1024 바이트 이상 쓰이지 않는 이상 `myfile.txt` 에 쓰이지 않는다.



###  연관된 함수

*  [setbuf](http://itguru.tistory.com/61)  :  스트림 버퍼를 설정한다.
*  [fopen](http://itguru.tistory.com/58)   :  파일을 연다.
*  [fflush](http://itguru.tistory.com/57)   :  스트림을 비운다.
Link :  61
2010-02-16 20:58
----------------
title : C 언어 레퍼런스 - setbuf 함수
cat_title :  setbuf
publish_date : 2010-02-16 20:58
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ setbuf



```info
#include <stdio.h> // C++ 에서는 <cstdio>

void setbuf ( FILE * stream, char * buffer );
```


스트림 버퍼를 설정한다.
특정한 스트림의 입출력 작업을 위한 버퍼를 설정하며 이는 보통 `fully buffered` 스트림으로 설정된다. (fully buffered 나 뒤에 나오는 unbuffered, line buffered 에 대한 설명은 [stdio.h](http://itguru.tistory.com/34) 를 참조하세요) 만일 두 번째 인자가 `NULL` 이라면 이 스트림은 unbuffered 스트림으로 설정된다.

두 번째 인자는 반드시 `BUFSIZ` 이상의 길이를 가지는 배열을 가리켜야만 한다. (BUFSIZ 는 <stdio.h> (C++ 은 <cstdio> 에 정의되어 있는 상수이다) fully buffered 스트림의 경우 쓰기 작업은 스트림과 연관되는 장비(예를 들어 파일 입출력을 한다면 연관되는 장비는 하드 디스크가 된다) 에 바로 쓰이지 않는다. 그 대신, 쓰여질 데이터가 버퍼에 한 데 모인뒤, 한 블록이 채워지면 그제서야 쓰기를 시작하게 된다.

물론, 블록이 다 채워지지 않았는데도 불구하고 강제적으로 스트림을 비우므로써 (flush) 데이터가 쓰여지게 할 수 있고 이 작업은 [fflush](http://itguru.tistory.com/57)함수를 호출하거나, [fclose](http://itguru.tistory.com/54) 함수를 호출해 파일을 닫아버리면 된다. 참고로 모든 버퍼들은 프로그램이 종료 될 때 자동적으로 비워진다.

unbuffered 스트림의 경우, 데이터는 fully buffered 스트림과는 달리 한 블록이 될 동안 모이지 않고 매 쓰기 작업마다 장비에 직접적으로 쓰게 된다.

파일을 열게 되면 기본적으로 할당된 버퍼를 가지게 된다. 하지만 이 함수를 호출함으로써 사용자-정의 된 버퍼를 사용하거나 특정한 스트림을 unbuffered 스트림으로 만들어버릴 수 있다.

보통 시스템 표준 스트림들, 예를들면 `stdout` 이나 `stderr` 은 모두 기본적으로 리다이렉트(redirect) 되지 않는 이상 unbuffered 스트림으로 설정된다.

만일 스트림을 line buffered 스트림으로 바꾸고 싶다면 `setvbuf` 함수를 사용하면 된다.

###  인자


`stream`

작업을 수행할 스트림의 `FILE` 객체를 가리키는 포인터

`buffer`

사용자가 직접 할당한 버퍼로, 최소 `BUFSIZ` 이상의 바이트를 가져야 한다. 이 `BUFSIZ` 는 매크로 상수로 `<stdio.h>` (C++ 이면 `<cstdio>`) 에 정의되어 있다. 또한 unbuffered 스트림으로 바꾸려면 `NULL` 포인터를 전달하면 된다.



###  리턴값




없음



###  예제


```cpp-formatted
/* myfile.txt 와 myfile2.txt 를 각각 쓰기 모드 와 덧붙이기(append) 모드로 열어서
 * buffer 을 버퍼로 사용한다. 이 때, pFIle1 의 경우 buffer 를 버퍼로 사용하지만
 * pFile2 는 버퍼를 사용하지 않는다. */
#include <stdio.h>
int main() {
  char buffer[BUFSIZ];
  FILE *pFile1, *pFile2;
  pFile1 = fopen("myfile.txt", "w");
  pFile2 = fopen("myfile2.txt", "a");
  setbuf(pFile1, buffer);
  fputs("This is sent to a buffered stream\n", pFile1);
  fflush(pFile1);
  setbuf(pFile2, NULL);
  fputs("This is sent to an unbuffered stream\n", pFile2);
  fclose(pFile1);
  fclose(pFile2);
  return 0;
}
```

파일에 쓰여진 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F137E581E4B7816E90A324C)


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1705EC1E4B7816E90789F8)

일단 첫번째의 경우

```cpp-formatted
setbuf(pFile1, buffer);
fputs("This is sent to a buffered stream\n", pFile1);
fflush(pFile1);
```

`buffer` 을 `pFile1` 스트림의 버퍼로 사용하였다. 이 때, 데이터가 한 블록이 다 채워졌는지 아닌지 모르므로 마지막에 `fflush` 를 강제적으로 호출하여 파일에 써준다.

```cpp-formatted
setbuf(pFile2, NULL);
fputs("This is sent to an unbuffered stream\n", pFile2);
```

두번째의 경우 `pFile2` 는 버퍼를 사용하지 않는 `unbuffered` 스트림 이므로 버퍼를 강제적으로 비울 필요가 없다. (사실 비울 버퍼도 없다)왜냐하면 쓰기 작업을 하자 마자 바로 파일에 쓰여지기 때문이다.



###  연관된 함수


*  [fopen](http://itguru.tistory.com/58)  :  파일을 연다.
*  [fflush](http://itguru.tistory.com/57):  스트림을 비운다.
*  [setvbuf](http://itguru.tistory.com/62)  :  스트림 버퍼링 방식을 설정한다.
Link :  55
2010-02-14 23:41
----------------
title : 씹어먹는 C 언어 - <16 - 1. 모아 모아 구조체(struct)>
cat_title : 16 - 1. 모아 모아 구조체(struct)
next_page : 60
publish_date : 2010-02-14 23:41
--------------


이번 강좌에서는

* 구조체에 대한 소개

* 구조체 포인터 및 `->` 라는 새로운 연산자 도입


![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분. 잘 지내셨는지요? 제가 요즘에 강좌를 올리는 틈틈히 [C 레퍼런스](http://itguru.tistory.com/category/C%20Reference)를 정리하고 있습니다. 레퍼런스라 하면, 일종의 백과사전 같은 것으로 여러분들이 궁금한 함수들이 있다면 찾아볼 수 있게 해놓았습니다. 아직 일부 함수들 밖에 올리지는 못했지만 그래도 그 양이 꽤 되니 읽어 보시는 것이 좋을 듯 합니다.

특히, 화면에서 입력을 받는 함수는 아직 `scanf` 와 `getchar` 밖에 보지 못했지만 `fgets, gets` 등이 있고, 화면에 출력하는 함수는 `fputs, puts, putchar` 등등 매우 많습니다. 뿐만 아니라 우리가 `scanf` 함수나 `printf` 함수를 여태까지 써오면서 사용하지 못했던 기능이 수없이 많은데 이들 모두 [레퍼런스](http://itguru.tistory.com/category/C%20Reference)에 잘 정리되어 있으니 참조하시기 바랍니다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F111277144B780AC91786E6)

여러분은 지금 `Sims` 라는 게임을 만들고 있습니다. `Sims` 라는 게임은 워낙 유명하지만, 그래도 뭔지 설명 해보자면 사람을 육성(?) 하는 게임 입니다. 말그대로 '신' 이 되는 게임이죠. 자신의 사람들을 훌륭한 사람으로 키우는 것이 목표입니다. 아무튼, 만일 게임하는 유저가 사람을 한 명 추가했다고 합시다. 그렇다면 이를 어떻게 저장할까요?

여러분의 머리속에는 "음, 그럼 이전에 만들어놓은 문자열 배열의 `i` 번째 원소에 이름을 등록하고, `int` 형 배열의 `i` 번째 원소에 나이를 등록하고, 성격은..." 과 같이 생각할 것입니다. 맞아요. 이렇게 한 방법은 우리가 지난 강좌에서 도서 관리 프로그램을 만들 때 사용했던 방법이지요. `i` 번째 책에 대한 정보는 `book_name[i - 1], auth_name[i - 1], publ_name[i - 1] , borrow[i - 1]` (`i` 번째 이므로, 원소는 `[i - 1]` 이겠지요) 배열에 넣어서 보관하였습니다.

그런데 말이죠. 위 방법에는 살짝 문제점이 있었습니다. 책의 정보를 수정하기 위해서 함수에 인자로 전달할 때 상당히 불편하다는 사실입니다. 한 번 도서 관리 프로그램의 새로운 책을 추가하는 함수였던 `add_book` 함수의 원형을 가져와보았습니다.

```cpp-formatted
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
```

헐. `num_total_book` 을 빼더라도 인자가 너무나 깁니다. 그래도 도서 관리 프로그램은 봐줄만 했죠. 하지만 우리가 만들게 될 `Sims` 는 다릅니다. 일단 사람 한 명에는 수없이 많은 정보가 있습니다. 예를 들어, 이름, 나이, 직업, 성격 (외향적, 내향적, 사교적, ... 들을 모두 수치화 시켜서 보관한다), 직업, 재산, 가족 관계 등등 수없이 많은 정보가 있습니다. 책과는 완전히 다르지요. 우리가 사람의 정보를 수정하기 위해 함수를 호출할 때 마다 이렇게 무지막지 하게 많은 정보들을 인자로 전달하려면 손가락이 빠질 뿐더러 눈도 매우 아프게 됩니다.

우리가 배열을 배웠기 전의 모습을 생각해봅시다. 배열을 배우기 전에, 예를 들어 10 명의 학생의 점수를 보관하기 위해 10 개의 변수를 선언해서 각각에 보관했어야 했습니다. 하지만, 배열을 배운 이후는 어떨까요? 10 개의 변수를 한꺼번에 배열로 처리하여 배열의 각각의 원소를 손쉽게 다루기 위해서였습니다. 즉 `int arr[10];` 이라 한다면 `int` 형 변수 10 개를 쉽게 다룰 수 있는 것입니다. 뿐만 아니라 함수에 `int` 형 변수를 전달할 때, `int` 형 변수 10 개를 일일히 전달하려면

```cpp-formatted
int func(int a, int b, int c, .....(생략)...)
```


와 같이 해야 합니다. 그런데 `int` 형 변수 10 개를 `arr` 을 이용하여 쉽게 전달할 수 있습니다. 아래와 같이요.

```cpp-formatted
int func(int *arr);
```

그렇다면 위 배열과 같은 논리가 여기에도 적용될 수 있지 않을까요? 원소의 크기가 제각각인 배열을 만드는 것입니다.한 사람에 대한 정보를 한 개의 배열에 저장하는 것입니다! 첫번째 원소는 `int` 로 나이를 보관하고, 두 번째 원소는 `char [30]` 으로 이름을 보관하는 것입니다.

정말 괜찮은 아이디어입니다. 하지만 C 언어에서는 배열의 원소의 타입은 모두 동일해야 합니다. 다시말해 동일한 배열에서 어떤 원소는 `char` 이고 어떤 원소는 `int` 일 수 없다는 것이죠. 다행스럽게도 C 언어에서는 배열로 해결하지 못하는 문제를 **구조체** 를 이용하여 해결할 수 있었습니다.

```cpp-formatted
/* 구조체의 도입*/
#include <stdio.h>
struct Human {
  int age;    /* 나이 */
  int height; /* 키 */
  int weight; /* 몸무게 */
};            /* ; 붙이는 것 주의하세요 */
int main() {
  struct Human Psi;

  Psi.age = 99;
  Psi.height = 185;
  Psi.weight = 80;

  printf("Psi 에 대한 정보 \n");
  printf("나이   : %d \n", Psi.age);
  printf("키     : %d \n", Psi.height);
  printf("몸무게 : %d \n", Psi.weight);
  return 0;
}
```


성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F117079184B703C597BB598)

아마 여러분은 위 소스 코드에서 여러가지 새로운 것들을 보실 수 있으셨을 겁니다. 아마 이 강좌가 끝날 즈음에는 위 사실들을 자유롭게 다룰 수 있게 되니 크게 걱정 안하셔도 됩니다. 일단 구조체를 정의한 부분 부터 살펴 봅시다. 직관적으로 아래의 부분과 같다는 사실을 알 수 있습니다.

```cpp-formatted
struct Human {
  int age;    /* 나이 */
  int height; /* 키 */
  int weight; /* 몸무게 */
};            /* ; 붙이는 것 주의하세요 */
```


앞서 말했듯이 구조체는 "각 원소의 타입이 제각각인 배열" 이라고 말했습니다. 이 때문에 배열에서는 배열의 타입만으로 모든 원소의 타입을 알 수 있었지만 (예를 들어 `int array[100]` 이면 `array` 의 모든 원소의 타입은 `int` 형 이다)

구조체는 그렇지 않습니다. 따라서 구조체는 정의할 때 모든 원소의 타입을 명시해 주어야 합니다. 위와 같이 말이죠. 이 `Human` 이라는 이름의 구조체는 3 개의 멤버를 가지고 있는데 (보통 구조체 에서는 원소 보다는 **멤버(member)** 라고 부릅니다) 각각의 멤버는 `int age, int height, int weight` 로 3 개가 있습니다.

  구조체의 일반적인 정의는 아래와 같습니다.

```cpp-formatted
struct 구조체이름 {
  멤버들..예를 들면 char str[10];
  int i;
}; /* 마지막에 꼭 ; 를 붙인다. */
```

다음은 `main` 함수내부를 살펴 볼 것입니다.

```cpp-formatted
struct Human Psi;
```


위와 같이 `Human` 이라는 구조체의 구조체 변수 Psi 를 정의하였습니다. 여기서 놀라운 점은 `struct Human` 이라는 것이 우리가 마치 `int` 형 변수를 정의할 때 `int` 를 쓰는 것과 같이 사용되었다는 것입니다. 아무튼 이처럼 Psi 를 정의하고 나면,`Psi` 의 타입은 `struct Human`, 즉 `Human 구조체` 가 됩니다. `int a` 했을 때 `a` 의 타입이 `int` 인 것처럼 말이지요.

그렇다면 배열에서 `[]` 를 이용해서 원소에 접근하듯이, 구조체에서도 멤버에 접근할 방법이 있어야 겠죠? C 언어에서는 `.` 을 이용하여 원소에 접근할 수 있습니다. 예를 들어서, Psi 의 `height` 멤버에 접근하려면 `Psi.height` 라고 하면 됩니다. 이는 마치 배열에서 `arr[3]` 과 같이 원소에 접근하는 것과 동일한 것입니다. 다만 구조체는 `.` 을 이용하고, 멤버가 무엇인지 특별히 명시해주어야 하는 것만 빼고요.

```cpp-formatted
Psi.age = 99;
Psi.height = 185;
Psi.weight = 80;
```

따라서, 위 작업은 Psi 라는 구조체의 각 멤버에 값을 대입하는 것입니다. 이는 마치 배열에서 `arr[1] = 99, arr[2] = 185` 와 같이 하는 것과 동일합니다.

지금 구조체를 처음 배워서 살짝 이해가 안되는 것도 있고 무언가 혼동되는 것이 있을 것입니다. 그래도 구조체가 무엇인지는 감이 대충 오지 않나요? 이제, 다음 예제를 살펴 보아서 구조체가 뭔지 감을 확 잡아보도록 합시다.

```cpp-formatted
/* 구조체 예제 2 */
#include <stdio.h>
char copy_str(char *dest, char *src);
struct Books {
  /* 책 이름 */
  char name[30];
  /* 저자 이름 */
  char auth[30];
  /* 출판사 이름 */
  char publ[30];
  /* 빌려 졌나요? */
  int borrowed;
};
int main() {
  struct Books Harry_Potter;

  copy_str(Harry_Potter.name, "Harry Potter");
  copy_str(Harry_Potter.auth, "J.K. Rolling");
  copy_str(Harry_Potter.publ, "Scholastic");
  Harry_Potter.borrowed = 0;

  printf("책 이름 : %s \n", Harry_Potter.name);
  printf("저자 이름 : %s \n", Harry_Potter.auth);
  printf("출판사 이름 : %s \n", Harry_Potter.publ);

  return 0;
}
char copy_str(char *dest, char *src) {
  while (*src) {
    *dest = *src;
    src++;
    dest++;
  }

  *dest = '\0';

  return 1;
}
```


  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F181952154B757D69B2D89C)

일단, 저는 [지지난 강좌](http://itguru.tistory.com/33)에서 만들었던 `copy_str` 함수를 가져왔습니다. 이 함수는 문자열을 `src` 에서 `dest` 로 복사하는 함수이지요. 이렇게 이미 썼던 것을 활용하는 것은 상당히 시간도 절약되고 편리한 방법 중에 하나 입니다.

먼저, 구조체를 정의한 부분 부터 살펴 보도록 합시다.

```cpp-formatted
struct Books {
  /* 책 이름 */
  char name[30];
  /* 저자 이름 */
  char auth[30];
  /* 출판사 이름 */
  char publ[30];
  /* 빌려 졌나요? */
  int borrowed;
};
```


흥미로운 점은 이 `Book` 구조체가 우리가 이전에 만들었던 도서 관리 프로그램을 쏙 빼닮았다는 것이죠. 그 때 에는 각 책을 배열의 한 개의 원소로 표현했는데, 책 이름의 경우 `name[100][30]` 의 한 문자열 `name[i]` 으로, (여기서 `i` 는 임의의 수), 빌려 졌는지에 대한 유무의 경우, `borrowed[100]` 의 한 원소 `borrowed[i]` 로 표현했었죠. 하지만 구조체를 이용하면 책의 각각의 정보를 따로 따로 배열에 정의할 필요가 없게 됩니다. `main` 함수를 살펴보면

```cpp-formatted
struct Books Harry_Potter;

copy_str(Harry_Potter.name, "Harry Potter");
copy_str(Harry_Potter.auth, "J.K. Rolling");
copy_str(Harry_Potter.publ, "Scholastic");
Harry_Potter.borrowed = 0;
```

먼저 우리는 `Harry_Potter` 라는 `struct Books` 의 구조체 변수를 만들었습니다. 자, 그럼 `Harry_Potter` 의 각 멤버에 값을 대입해야 겠죠? 먼저 책의 이름, 즉 `Harry_Potter.name` 에 "Harry Potter" 를, 마찬가지로 저자 이름과 출판사에도 모두 대입합니다. 마지막으로 빌렸는지 안빌렸는지에 대한 유무 확인을 위한 `Harry_Potter.borrowed` 에도 0 을 넣어주어야 합니다.

그런데 말이죠. `borrowed` 멤버의 값은 처음에 언제나 0 으로 설정되어있습니다. 그렇다면 굳이 매번 책을 새로 등록할 때 마다 `borrowed = 0` 을 해줄 필요 없이 구조체 자체 에서 바꿔버리면 안될까요?

한 번 구조체 정의 부분을

```cpp-formatted
struct Books {
  /* 책 이름 */
  char name[30];
  /* 저자 이름 */
  char auth[30];
  /* 출판사 이름 */
  char publ[30];
  /* 빌려 졌나요? */
  int borrowed = 0;
};
```


로 바꿔서 컴파일 해보세요. 과연..?
잘 되리라 기대했지만 아래와 같은 오류의 향연을 보실 수 있습니다.

```warning
error C2143: 구문 오류 : ';'이(가) '=' 앞에 없습니다.
error C2059: 구문 오류 : '='
error C2059: 구문 오류 : '}'
error C2079: 'Harry_Potter'은(는) 정의되지 않은 struct 'Books'을(를) 사용합니다.
error C2224: '.name' 왼쪽에는 구조체/공용 구조체 형식이 있어야 합니다.
error C2198: 'copy_str' : 호출에 매개 변수가 너무 적습니다.
error C2224: '.auth' 왼쪽에는 구조체/공용 구조체 형식이 있어야 합니다.
error C2198: 'copy_str' : 호출에 매개 변수가 너무 적습니다.
error C2224: '.publ' 왼쪽에는 구조체/공용 구조체 형식이 있어야 합니다.
error C2198: 'copy_str' : 호출에 매개 변수가 너무 적습니다.
error C2224: '.borrowed' 왼쪽에는 구조체/공용 구조체 형식이 있어야 합니다.
error C2224: '.name' 왼쪽에는 구조체/공용 구조체 형식이 있어야 합니다.
error C2224: '.auth' 왼쪽에는 구조체/공용 구조체 형식이 있어야 합니다.
error C2224: '.publ' 왼쪽에는 구조체/공용 구조체 형식이 있어야 합니다.
```

도대체 이게 뭔일인가요?

사실 위 처럼 나온 이유는 간단합니다. 구조체의 정의에서는 변수를 초기화 할 수 없기 때문입니다. 그냥, 받아 들여주세요. 구조체 정의 내부에서는 변수를 초기화 할 수 없다고 말이죠. 특히, 위와 같이 실수를 할 경우 찾기도 잘 어렵고 오류들도 엉뚱한 것들만 나오기 때문에 위와 같은 실수를 조심하는 것이 아주 중요합니다.


```cpp-formatted
/* 구조체 예제*/
#include <stdio.h>
struct Books {
  /* 책 이름 */
  char name[30];
  /* 저자 이름 */
  char auth[30];
  /* 출판사 이름 */
  char publ[30];
  /* 빌려 졌나요? */
  int borrowed;
};
int main() {
  struct Books book_list[3];
  int i;

  for (i = 0; i < 3; i++) {
    printf("책 %d 정보 입력 : ", i);
    scanf("%s%s%s", book_list[i].name, book_list[i].auth, book_list[i].publ);
    book_list[i].borrowed = 0;
  }

  for (i = 0; i < 3; i++) {
    printf("------------------------------- \n");
    printf("책 %s 의 정보\n", book_list[i].name);
    printf("저자 : %s \n", book_list[i].auth);
    printf("출판사 : %s \n", book_list[i].publ);

    if (book_list[i].borrowed == 0) {
      printf("안 빌려짐\n");
    } else {
      printf("빌려짐 \n");
    }
  }
  return 0;
}
```


  성공적으로 컴파일 되었다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F1953ED1F4B77FE083B4039)

먼저 구조체의 정의에 대한 부분은 생략하고 바로 `main` 함수 부터 이야기 하겠습니다.

```cpp-formatted
struct Books book_list[3];
```


일단 위 문장을 보았을 때 어떤 분들은 이해가 잘 되지만 어떤 분들은 이해가 안될 수 도 있을 것이니 다시 한 번 설명하겠습니다. 이전에도 말했듯이 `int arr[3]` 에서 `int` 가 하나의 타입이듯이, `struct Books` 가 하나의 타입으로 생각하면 됩니다. 그런데, `int arr[3]` 을 하면 `arr` 에 `int` 형 원소가 3 개 만들어지듯이, `book_list` 배열에는 `struct Books` 형의 변수가 3 개 만들어지는 것이지요.

```cpp-formatted
for (i = 0; i < 3; i++) {
  printf("책 %d 정보 입력 : ", i);
  scanf("%s%s%s", book_list[i].name, book_list[i].auth, book_list[i].publ);
  book_list[i].borrowed = 0;
}
```


이제, `for` 문을 살펴봅시다. `scanf` 함수로 `book_list` 의 `i` 원소의 `name, auth, publ` 멤버에 문자열을 입력받고 있는 모습을 볼 수 있습니다 또한 `borrowed` 의 값도 0 으로 초기화 해주고 있습니다.

```cpp-formatted
for (i = 0; i < 3; i++) {
  printf("------------------------------- \n");
  printf("책 %s 의 정보\n", book_list[i].name);
  printf("저자 : %s \n", book_list[i].auth);
  printf("출판사 : %s \n", book_list[i].publ);

  if (book_list[i].borrowed == 0) {
    printf("안 빌려짐\n");
  } else {
    printf("빌려짐 \n");
  }
}
```


입력을 다 받고 나면 `for` 문에서 `book_list` 의 각 원소의 멤버들을 출력해줍니다. 특히 `borrowed` 값이 0 이면 "안빌려짐", 0 이 아니면 "빌려짐" 이 출력되는데 위의 경우 0 으로 값을 설정해 놓고 값을 바꾸는 부분이 없으므로 언제나 안 빌려짐이 출력됩니다. 어때요? 간단하죠?



###  구조체 포인터

으음... 위 파란색 제목만 보고도 눈살을 찌부리는 분들이 있을 지도 모릅니다. 한동안 포인터에게서 벗어난 줄 알았는데 또 등장하는거냐! 하지만 구조체 포인터, 말그대로 구조체를 가리키는 포인터 역시 잘만 이해하면 정말로 아무 것도 아닌 것이 됩니다. 오히려 나중엔 "내가 왜 여기서 겁먹었지?" 라는 생각이 들 정도로요.

```cpp-formatted
/* 구조체 포인터 */
#include <stdio.h>
struct test {
  int a, b;
};
int main() {
  struct test st;
  struct test *ptr;

  ptr = &st;

  (*ptr).a = 1;
  (*ptr).b = 2;

  printf("st 의 a 멤버 : %d \n", st.a);
  printf("st 의 b 멤버 : %d \n", st.b);

  return 0;
}
```


  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F126D58234B7802D8028612)

먼저 구조체 포인터에 대해 이야기 하기 전에 확실히 짚고 넘어가야 할 것이 있습니다. 여태까지 누누히 이야기 하였지만 `struct test` 역시 하나의 형 (타입) 이라는 것입니다. 위의 예제들의 `struct Human` 이나 `struct Book` 역시 하나의 타입이였지요.

즉, 구조체는 한 개의 타입을 창조하는 것과 마찬가지라는 것입니다. 마치 `int` 나 `char` 처럼 말이지요. 그런데 이러한 타입들을 가리킬 때 우리가 포인터를 어떻게 사용했나요? 바로, `int *` 나 `char *` 로 사용했습니다. 구조체도 마찬가지 입니다.

```cpp-formatted
struct test st;
struct test *ptr;
```

위의 두 번째 문장과 같이 `struct test *ptr,` 즉 "struct `test` 형을 가리키는 포인터 ptr" 을 정의한 것이지요. 여기서 주의해야 할 점은 `ptr` 은 절대로 **구조체가 아니라는 것**입니다. `ptr` 역시 다른 모든 포인터 처럼 4 바이트의 공간을 차지하는 것입니다. (물론 컴퓨터 마다 다를 수 있지만 아마 여러분이 사용하는 컴퓨터는 십중 팔구일 것입니다) \sidenote{이 강좌는 2010년에 제작되었습니다. 2018년 지금 현재 64비트 시스템을 사용하시는 분들의 경우 포인터는 8 바이트를 차지합니다.}

```cpp-formatted
ptr = &st;
```

그리고 위와 같이 `ptr` 에 `str` 의 주소값을 집어 넣습니다. 그런데 눈치가 조금 빠르신 분들은 다음과 같이 질문할 수 있습니다.

"아까 구조체는 단순히 원소의 크기가 제각각인 배열이라면서요? 그러면 구조체도 배열처럼 변수의 이름이 그 주소값이 되어야 하는 것 아닌가요? 다시 말해 우리가 `int arr[100];` 을 정의했다면 이를 가리키는 포인터를 정의할 때 `int *ptr = arr` 이라고 하지 `int *ptr = &arr` 이라 하지 않잖아요?"

상당히 좋은 질문 입니다. 하지만 조금 아래에 보면 구조체 변수의 이름은 역할이 살짝 다르다는 것을 알게 됩니다. 그냥 보통 변수 처럼, (그래서 구조체 변수라 부르지, 구조체 '배열' 이라고 부르지 않잖아요) `&` 를 붙여 구조체가 정의된 메모리의 주소값을 얻어온다고 생각해주세요.

이제 `ptr` 은 구조체 `st` 를 가리키는 포인터가 됩니다.

```cpp-formatted
(*ptr).a = 1;
(*ptr).b = 2;
```

그럼 `ptr` 이 가리키는 구조체의 멤버의 값을 변경하는 부분을 살펴 봅시다. 일단 여러분은 `(*ptr)` 이라는 부분이 `st` 라는 것과 동일하다는 사실을 알 수 있습니다. 왜냐하면 `ptr` 이 `st` 를 가리키고 있기 때문이죠. 따라서 `(*ptr).a = 1` 은 `st.a = 1` 과 완전히 `100%` 동일한 문장임을 알 수 있습니다. 그 아랫 줄도 마찬가지이죠. `(*ptr).b = 2` 도 `st.b = 2` 와 정확히 일치하는 문장입니다. 따라서 아래 `printf` 문에서 `st.a` 의 값은 `1, st.b` 의 값은 2 가 출력된 것입니다.

그런데 말이죠. 굳이 괄호를 쳐 주어야 하나요? 그냥 `*ptr.a = 1` 이라 하면 무엇이 문제이길래 그런 것인가요?

```info
    (*ptr).a = 1; 을
    *ptr.a = 1; 로 바꿔서 컴파일 해봅시다.
```

그렇다면 아래의 오류들을 만나실 수 있을 것입니다.

```warning
error C2231: '.a' : 왼쪽 피연산자가 'struct'을(를) 가리킵니다. '->'를 사용하십시오.
error C2100: 간접 참조가 잘못되었습니다.

```

도대체 왜 발생한 것일까요?
이에 대해 답하기 전에 연산자 우선 순위 표를 먼저 살펴봅시다.


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F183F47204B7806317A2E79)


가장 맨 위를 보면 `.` 이라고 되있는 것을 볼 수 있습니다. 찾았나요? 여기서 `.` 은 구조체의 멤버를 지칭할 때 사용하는 `.` 을 의미하는 것입니다. `(*ptr).a` 에서 사용된 `.` 을 말하지요. 그 바로 아래 행을 보면 `*(포인터)` 라고 써있는 것이 있습니다. `(*ptr).a` 에서의 `*` 를 말하는 것이지요. 여기서 주목해야 할 점은 `.` 이 `*` 보다 우선순위가 높다는 것입니다.

따라서, `*ptr.a` 를 사용하게 되면 `ptr.a` 를 먼저 실행한 후, 그 값에 `*` 를 한 것에 2 가 들어가게 됩니다. 즉 `*ptr.a` 는 `*(ptr.a)` 와 동일한 문장인 것이지요. 그런데 위에서도 말했지만 `ptr` 은 단순히 포인터에 불과합니다. `ptr` 은 절대로 구조체가 아니라는 것이지요. 그런데 구조체가 아닌 것의 있지도 않는 `a` 라는 멤버에 접근하라니 컴파일 시에 오류가 발생하는 것입니다.

결과적으로 구조체 포인터를 사용해서 멤버에 접근하려면 `(*ptr).a` 와 같이 언제나 괄호로 감싸 주어야 됩니다. 상당히 귀찮은 일이 아닐 수 없습니다. 하지만 똑똑한 C 프로그래머들은 이 문제를 해결하기 위해 다음과 같이 아름다운 기호를 등장시켰습니다.

```cpp-formatted
/* 구조체 포인터 */
#include <stdio.h>
struct test {
  int a, b;
};
int main() {
  struct test st;
  struct test *ptr;
  ptr = &st;
  ptr->a = 1;
  ptr->b = 2;
  printf("st 의 a 멤버 : %d \n", st.a);
  printf("st 의 b 멤버 : %d \n", st.b);
  return 0;
}
```

  성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F124CD7204B7808081A8128)

여기서 새로 등장한 기호는 제가 가장 좋아하는 기호입니다.

```cpp-formatted
ptr->a = 1;
ptr->b = 2;
```

위와 같이 `(*ptr).a = 1` 이라는 문장을 `ptr->a = 1` 로 간단히 표현할 수 있습니다. 아래 `ptr->b = 2` 역시 `(*ptr).b = 2` 와 정확히 일치하는 문장입니다. 단순히 사용자의 편의를 위해서 `->` 라는 새로운 기호를 도입한 것 뿐이지요. (이 기호는 위의 우선 순위 표 맨 위에서도 볼 수 있습니다)


자, 그럼 오늘 강좌는 여기서 마치도록 하겠습니다. 사실 이번 강좌는 구조체에 대한 개략 적인 소개만을 전해드린 것이지, 구조체의 진짜 면모는 다음 시간 부터 시작됩니다. 구조체는 정말 잘 쓰면 보물 같은 존재이니 포인터와 더불이 C 언어의 양대 산맥을 이루는 기능이라 말할 수 있습니다. 그럼, 이만 계세요~

### 생각해보기

#### 문제 1

구조체 안에 또다른 구조체 변수를 설정할 수 있을까요? (난이도 : 中)

#### 문제 2

구조체를 인자로 가지는 함수를 생각해보세요. (난이도 : 中)


##@ chewing-c-end
Link :  59
2010-02-13 23:12
----------------
title : C 언어 레퍼런스 - freopen 함수
cat_title :  freopen
publish_date : 2010-02-13 23:12
--------------


#@ freopen

```info
#include <stdio.h> // C++ 에서는 <cstdio>

FILE * freopen ( const char * filename, const char * mode, FILE * stream );
```


스트림을 다른 파일이나 방식(mode)으로 다시 연다. (물론 둘 다 바꿔도 된다)

`freopen` 함수는 먼저 세번째 인자로 전달된 스트림에 해당하는 파일을 닫아버립니다(`close`). 그 후, 그 파일이 성공적으로 닫혔든 안닫혔든 간에, `freopen` 함수는 첫번째 인자로 전달된 파일 이름에 해당하는 파일을 두번째 인자로 전달된 방식(mode)에 맞게 엽니다.

이 함수는 특히 이미 정의된 스트림들, 예를 들면 표준 입력(stdin) 이나 표준 출력(stdout), 표준 오류(stderr) 와 같은 스트림들을 특정한 파일에 해당하는 스트림으로 변경할 수 있습니다.


###  인자

`filename`

열을 파일의 이름을 포함하는 C 문자열. 특히, `freopen` 함수가 실행되는 환경에 따라 파일에 경로에 대한 정보도 포함할 수 있다.

(예를 들어 `Windows` 의 경우 `filename` 에 "C:\\a.txt" 를 전달하면 C 드라이브에 `a.txt` 파일을 열 게 된다. 이 때, \ 를 두 개 붙인 이유는 C 언어에서 \ 하나는 **탈출 문자(escape character)** 로 사용되기 때문이다)

만일 인자가 널 포인터라면 `freopen` 함수는 세번째 인자로 전달된 스트림과 연관되어 있던 파일의 열기 방식 만을 두 번째 인자로 전달된 방법으로 변경한다. (Windows 에선 이것이 지원되지 않으므로 사용하지 않도록 한다.. msdn 참조)

`mode`

C 문자열로 파일 접근 방식에 대한 정보를 포함해야 한다. 이 모드는 다음이 될 수 있다 C 문자열로 파일 접근 방식에 대한 정보를 포함해야 한다. 이 모드는 다음이 될 수 있다.


|mode|설명|
|------|------|
|"r"|파일을 읽기 형식으로 연다. 이 때, 파일은 반드시 존재해야 한다.|
|"w"|파일을 쓰기 형식으로 연다. 만일 동일한 파일이 이미 존재하고 있다면 그 파일의 내용은 모두 지워진 후 새롭게 생긴 빈 파일로 간주하며, 파일이 존재하고 있지 않는다면 빈 파일을 새롭게 생성한다.|
|"a"|파일을 덧붙이기(append) 형식으로 연다. 쓰기 작업은 파일 끝에 데이타를 덧붙일 것이다. 만일 파일이 존재하지 않는다면 새로 생성된다.|
|"r+"|파일을 읽기 및 쓰기 형식으로 연다. 이 때, 파일은 반드시 존재해야 한다.|
|"w+"|파일을 읽기 및 쓰기 형식으로 연다. 만일 동일한 파일이 이미 존재하고 있다면 그 파일의 내용은 모두 지워진 후 새롭게 생긴 빈 파일로 간주하며, 파일이 존재하고 있지 않다면 빈 파일을 새로 생성하게 된다.|
|"a+"|파일을 읽기 및 덧붙이기(append) 형식으로 연다. 지정한 파일이 존재하지 않는다면 새롭게 생성된다. 모든 쓰기 작업은 파일의 맨 끝에서 진행되며 기존의 파일 내용들에 덮혀씌여지지 않는다. 여러분은 읽기 작업에서는 [fseek](http://itguru.tistory.com/72)이나 [rewind](http://itguru.tistory.com/75)함수 등을 이용하여 파일 위치 포인터를 원하는 대로 움직일 수 있지만, 쓰기 작업에서는 위치 포인터를 언제나 파일 맨 끝으로 이동 시킬 것이다.|


또한 뒤에 `b` 를 붙인다면 바이너리 형식으로 파일을 열게 된다. (아무것도 안붙이면 자동적으로 텍스트 파일 형식으로 열린다). 파일 열기 방식에 대한 자세한 정보는 [fopen](http://itguru.tistory.com/58)함수를 참조하면 된다.

`stream`

작업을 수행할 스트림의 `FILE` 객체에 대한 포인터



###  리턴값

만일 파일이 성공적으로 열렸다면 이 함수는 세번째 인자로 전달되었던 스트림 포인터를 리턴하게 된다.
그렇지 않을 겨우 널 포인터가 리턴된다.

###  실행 예제

```cpp-formatted
/*

a.txt 를 쓰기 형식으로 열어서 Hello, Psi 를 쓴 뒤, 다시 읽기 형식으로 열어서 그
내용을 읽어 출력한다.

*/
#include <stdio.h>
int main() {
  FILE *fp;
  char str[100];

  fp = fopen("C:\\a.txt", "w");
  fputs("Hello, Psi!!", fp);

  fp = freopen("C:\\a.txt", "r", fp);
  fgets(str, 99, fp);

  printf("%s", str);
  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F171C77104B76B24B4F80E7)


```cpp-formatted
/*

표준 출력(stdout) 을 myfile.txt 의 스트림으로 변경한다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/freopen/
에서 가져왔습니다.

 */
#include <stdio.h>
int main() {
  freopen("myfile.txt", "w", stdout);
  printf("This sentence is redirected to a file.");
  fclose(stdout);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F13251E104B76B24CB820E6)

파일에 쓰여진 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F120B55104B76B24DB79354)





###  연관된 함수

* [fopen](http://itguru.tistory.com/58)  :  파일을 연다
* [fclose](http://itguru.tistory.com/54):  파일을 닫는다.
Link :  58
2010-02-11 11:14
----------------
title : C 언어 레퍼런스 - fopen 함수
cat_title :  fopen
publish_date : 2010-02-11 11:14
--------------


```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fopen

```info

#include <stdio.h> // C++ 에서는 <cstdio>
FILE * fopen ( const char * filename, const char * mode );
```

파일을 연다

`filename` 인자에서 지정한 파일을 열고, 이에 해당하는 스트림의 `FILE` 객체를 가리키는 포인터를 반환한다. 이 때, 이 스트림에서 어떠한 입출력 작업이 가능한지는 `mode` 인자에 의해 결정된다.

`fopen` 함수는 동시에 최소 `FOPEN_MAX` 개의 파일들을 열 수 있게 보장하고 있으며 (이 이상 열 수도 있지만 성공적으로 열 수 있을지에 대해선 보장할 수 없다) 이 값은 실행 환경에 따라 다를 수 있다. 참고로 `FOPEN_MAX` 는 [stdio.h](http://itguru.tistory.com/34) (C++ 에서는 [cstdio](http://itguru.tistory.com/34)) 에 정의되어 있는 매크로 상수 이다.



###  인자


`filename`

C 문자열로 열을 파일의 이름이다. 이 인자는 각 실행 환경에서 지정하는 파일 이름 형식을 따라야 하며, 만일 시스템에서 경로 설정이 지원된다면 경로도 포함할 수 있다 C 문자열로 열을 파일의 이름이다. 이 인자는 각 실행 환경에서 지정하는 파일 이름 형식을 따라야 하며, 만일 시스템에서 경로 설정이 지원된다면 경로도 포함할 수 있다.

`mode`

C 문자열로 파일 접근 모드를 설정한다. 이 모드는 다음이 될 수 있다 C 문자열로 파일 접근 모드를 설정한다. 이 모드는 다음이 될 수 있다.

|mode|설명|
|------|------|
|"r"|파일을 읽기 형식으로 연다. 이 때, 파일은 반드시 존재해야 한다.|
|"w"|파일을 쓰기 형식으로 연다. 만일 동일한 파일이 이미 존재하고 있다면 그 파일의 내용은 모두 지워진 후 새롭게 생긴 빈 파일로 간주하며, 파일이 존재하고 있지 않는다면 빈 파일을 새롭게 생성한다.|
|"a"|파일을 덧붙이기(append) 형식으로 연다. 쓰기 작업은 파일 끝에 데이타를 덧붙일 것이다. 만일 파일이 존재하지 않는다면 새로 생성된다.|
|"r+"|파일을 읽기 및 쓰기 형식으로 연다. 이 때, 파일은 반드시 존재해야 한다.|
|"w+"|파일을 읽기 및 쓰기 형식으로 연다. 만일 동일한 파일이 이미 존재하고 있다면 그 파일의 내용은 모두 지워진 후 새롭게 생긴 빈 파일로 간주하며, 파일이 존재하고 있지 않다면 빈 파일을 새로 생성하게 된다.|
|"a+"|파일을 읽기 및 덧붙이기(append) 형식으로 연다. 지정한 파일이 존재하지 않는다면 새롭게 생성된다. 모든 쓰기 작업은 파일의 맨 끝에서 진행되며 기존의 파일 내용들에 덮혀씌여지지 않는다. 여러분은 읽기 작업에서는 [fseek](http://itguru.tistory.com/72)이나 [rewind](http://itguru.tistory.com/75)함수 등을 이용하여 파일 위치 포인터를 원하는 대로 움직일 수 있지만, 쓰기 작업에서는 위치 포인터를 언제나 파일 맨 끝으로 이동 시킬 것이다.|

표에서 나온 바와 같이 `mode` 문자열 ("r", "w", "a", "r+", "w+", "a+")을 사용한다면 파일은 "텍스트(text) 파일" 형식으로 열리게 된다. (참고로, 이 파일이 텍스트 파일로 열린다는 사실을 굳이 명시해 주고 싶다면 끝에 "t" 를 붙이면 된다. 하지만 붙이나 안붙이나 효과는 똑같다)

만일 파일을 이진 형식으로 열고 싶다면 `mode` 문자열 뒤에 "b" 문자를 붙여주면 된다. 즉, "rb", "wb", "ab", "r+b", "w+b", "a+b"로 하면 된다. 이 때, `+` 기호는 맨 뒤로 보내도 된다. 다시 말해, "rb+", "wb+", "ab+" 는 각각 "r+b", "w+b", "a+b" 와 동일하다.

파일을 텍스트 파일 형식으로 열게 된다면, 프로그램이 실행되는 환경에 따라 일부 특수 문자들은 입출력 연산시 다른 방식으로 해석될 수 있다. (이 사실에 대해선 [stdio.h](http://itguru.tistory.com/34)를 참조하여라) 하지만, 이진 형식으로 파일을 읽게 된다면 실행 환경에 상관 없이 언제나 동일하게 해석될 수 밖에 없다.

읽기/쓰기를 동시에 하는 모드 ("r+", "w+", "a+") 의 경우, 읽기 작업을 한 후, 쓰기 작업을 하거나, 쓰기 작업을 한 후 읽기작업을 하는 경우 중간에 반드시 스트림을 비우거나 ([fflush](http://itguru.tistory.com/57)), 위치가 조정 되어야 한다.



###  리턴값

만일 파일이 성공적으로 열렸다면 `fopen` 함수는 `FILE` 객체에 대한 포인터를 리턴할 것이다. 이 포인터는 나중에 스트림 관련 작업시에 스트림을 구분하기 위해 자주 사용된다. 그렇지 않을 경우 널 포인터가 리턴된다.


###  실행 예제




```cpp-formatted
/*

example.txt 파일을 생성한 뒤, 쓰기 형식으로 오픈하여 "안녕하세요 여러분 \n Psi
입니다 \n" 를 파일 내용에 집어 넣는다. 그리고, example.txt 를 덧붙이기 형식으로
오픈한 뒤 뒤에 "어 그래 안녕" 을 덧붙인다.

*/
#include <stdio.h>
int main() {
  FILE *fp, *fp2;

  if ((fp = fopen("example.txt", "w")) == NULL) {
    printf("파일 읽기 오류! \n");
    return 0;
  }

  fputs("안녕하세요 여러분 \n Psi 입니다 \n", fp);

  if ((fp2 = fopen("example.txt", "a")) == NULL) {
    printf("파일 읽기 오류! \n");
    return 0;
  }

  fputs("어 그래 안녕?", fp2);
  return 0;
}
```


`example.txt` 에 쓰여진 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1345071D4B73C8EA199FA6)




###  연관된 함수



*  [fclose](http://itguru.tistory.com/54)   :  파일을 닫는다.

*  [setbuf](http://itguru.tistory.com/61)   :  스트림 버퍼를 설정한다.

*  [setvbuf](http://itguru.tistory.com/62)  :  스트림 버퍼의 모드를 설정한다.
* `tmpfile`   :  임시 파일을 연다.
* `tmpnam`  : 임시 파일 이름을 생성한다.
Link :  57
2010-02-10 01:28
----------------
title : C 언어 레퍼런스 - fflush 함수
cat_title :  fflush
publish_date : 2010-02-10 01:28
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fflush

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int fflush ( FILE * stream );
```

스트림을 비운다(flush)

만일 함수의 인자로 전달된 스트림이 쓰기 가능하고, 마지막 입출력 작업이 출력 작업이였다면 출력 버퍼에 쓰이지 않고 남아 있던 데이터들은 모두 파일에 쓰이게 된다.

만일 함수의 인자로 전달된 스트림이 읽기 가능하고 마지막 입출력 작업이 입력 작업이였다면, 이 함수가 어떠한 작업을 할지에 대해선 라이브러리에 따라 다르다. 몇몇의 라이브러리에선 입력 버퍼를 비워버리지만(이 때 비운다는 것은 버퍼에 있는 데이터들을 모두 삭제한다는 뜻이다) 이는 표준으로 정해진 것이 아니다.

만일 인자가 널 포인터라면 모든 열린 스트림을 비운다.

이 함수 호출 이후에도 스트림은 열려 있는 상태로 남아있다.

만일 파일이 [fclose](http://itguru.tistory.com/54)를 호출 하건 프로그램이 종료되건 어떤 연유에서 든지 닫히게 된다면 (close), 이 파일에 해당하는 모든 버퍼들은 자동적으로 비워지게 된다.


###  인자

`stream`

작업을 수행할 buffered (스트림의 상태 중 하나로 fully buffered 와 line buffered 를 일컫는다. 자세한 내용은 [stdio.h](http://itguru.tistory.com/34)를 참조) 스트림의 파일 객체를 가리키는 포인터.

###  리턴값

`0` 이 리턴되면 성공적으로 작동되었음을 의미한다 0 이 리턴되면 성공적으로 작동되었음을 의미한다.
오류가 발생하면 `EOF` 가 리턴되고 오류 표시자가 설정된다 ( [feof](http://itguru.tistory.com/51)참조)

###  실행 예제


```cpp-formatted
/*
example.txt 파일을 "r+" 로 오픈하여 "test" 를 쓴 뒤 pFile 버퍼를 비우고 다시
파일로 부터 읽어온다.

이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fflush/에서
가져왔습니다.
*/
#include <stdio.h>
char mybuffer[80];
int main() {
  FILE* pFile;
  pFile = fopen("example.txt", "r+");
  if (pFile == NULL)
    perror("Error opening file");
  else {
    fputs("test", pFile);
    fflush(pFile);
    fgets(mybuffer, 80, pFile);
    puts(mybuffer);
    fclose(pFile);
    return 0;
  }
}
```



실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F202412114B725620428B8C)

파일에 쓰여진 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1560F8134B725637318657)

위 소스 코드가 어떻게 작동하는지 잠깐 설명하자면, 파일을 "r+" 형식으로 오픈했다면 한 개의 스트림을 이용하여 파일 쓰기와 읽기를 동시에 수행할 수 있다.

다만, C 표준에 따르면 "r+" 형식으로 오픈한 파일에서 파일을 읽은 다음에 쓰기를 하려면 파일 위치 표시자 설정 함수 ([fseek](http://itguru.tistory.com/72), [fsetpos](http://itguru.tistory.com/73), [rewind](http://itguru.tistory.com/75)) 들을 호출하거나 `fflush` 함수를 호출해야 한다. 그렇지 않을 경우 오류가 발생하게 된다.

마찬가지로 파일을 쓴 다음에 읽기를 하려면 위와 동일한 작업을 해야 한다. 위 예제의 경우 마찬가지로 파일을 "r+" 형식으로 오픈하였는데, [fputs](http://itguru.tistory.com/40)로 "test" 를 쓴 후, 그 다음에 [fgets](http://itguru.tistory.com/38)로 파일에서 입력 받는다. 따라서 중간에 파일 위치 표시자 설정 함수를 호출하거나 `fflush` 함수를 호출해야 하는데 이 경우 `fflush` 함수를 호출하였다.

참고로, 왜 실행 화면에 `example.txt` 로 부터 입력받은 것이 아무것도 없냐면, 파일 위치 표시자가 파일에서 `test` 문자열 다음 위치를 가리키고 있기 때문이다. (참고적으로 개행 문자가 출력된 것처럼 보이는데 사실 [puts](http://itguru.tistory.com/48) 함수는 출력할 문자열 뒤에 자동으로 개행 문자를 붙여서 출력하기 때문에 실질적으로 출력된 것은 아무것도 없다)



###  연관된 함수

*  [fclose](http://itguru.tistory.com/54)  :  파일을 닫는다.
*  [fopen](http://itguru.tistory.com/58)   : 파일을 연다.
*  [setbuf](http://itguru.tistory.com/61)  : 스트림 버퍼를 지정한다.
*  [setvbuf](http://itguru.tistory.com/62)  :  스트림 버퍼링 모드를 설정한다.
Link :  54
2010-02-08 17:18
----------------
title : C 언어 레퍼런스 - fclose 함수
cat_title :  fclose
publish_date : 2010-02-08 17:18
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ fclose

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int fclose ( FILE * stream );

```

파일을 닫는다.

인자로 지정한 스트림에 해당하는 파일을 닫는다.

이 때, 그 스트림의 모든 버퍼들은 비워(flush)진다. 아직 파일에 쓰이지 않고 남아있던 버퍼의 내용물은 모두 파일에 쓰이고, 아직 읽히지 않고 남아있떤 버퍼의 내용물은 모두 사라진다.

`fclose` 함수의 호출이 실패하더라도 인자로 전달된 스트림과 이에 해당하는 파일의 관계는 끊어지게 된다.

###  인자

`stream`

파일을 닫을 스트림의 `FILE` 객체를 가리키는 포인터.

###  리턴값

많일 스트림이 성공적으로 닫힌다면 0 이 리턴된다.
실패할 경우 `EOF` 가 리턴된다.

###  실행 예제

```cpp-formatted
/*myfile.txt 를 오픈하여 "fclose example" 을 쓴 후 파일을 닫는다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fclose/에서
가져왔습니다.*/
#include <stdio.h>
int main() {
  FILE* pFile;
  pFile = fopen("myfile.txt", "wt");
  fprintf(pFile, "fclose example");
  fclose(pFile);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F192A9D1F4B702E01249504)

파일에 쓰여진 모습


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F127B681F4B702E017E42DF)

###  연관된 함수

* `fopen` :  파일을 연다(open)
* `fflush` :  스트림을 비운다(flush)
Link :  53
2010-02-08 01:54
----------------
title : C 언어 레퍼런스 - perror 함수
cat_title :  perror
publish_date : 2010-02-08 01:54
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ perror

```info
#include <stdio.h> // C++ 에서는 <cstdio>

void perror ( const char * str );
```

오류 메세지를 출력한다.

전역 변수 `errno` 의 값을 해석하여 이에 해당하는 시스템 오류 메세지를 **표준 오류 출력 스트림(stderr)**에 출력한다. 또한 추가적으로 전달하고자 하는 사용자 정의 메세지를 `str` 인자에 담아 출력할 수 도 있다.

`errno` 는 정수형 변수로 이전의 라이브러리 함수에 의해 발생한 오류에 대한 정보를 가지고 있다. 이 때, `errno` 에 값에 따라 `perror` 함수에 의해 출력되는 시스템 오류 메세지는 플랫폼이나 컴파일러에 따라 달라질 수 있다.

만일 `str` 이 널 포인터가 아니라면 사용자 정의 메세지가 시스템 오류 메세지 이전에 출력된다. 이 때 두 개의 메세지는 ": " 로 구분된다. 그리고 `str` 이 널 포인터인지 아닌지에 상관 없이 맨 마지막에는 개행 문자('\n')가 출력된다.

`perror` 은 오류가 발생한 바로 다음에 호출되어야 한다. 그렇지 않을 경우 다른 함수들의 호출에 의해 출력 결과가 달라질 수 있다.



###  인자

`str`

C 형식 문자열로 시스템 오류 메세지 다음에 이어서 출력할 사용자 정의 메세지이다 C 형식 문자열로 시스템 오류 메세지 다음에 이어서 출력할 사용자 정의 메세지이다.

만일 널 포인터라면, 시스템 오류 메세지 다음에 어떠한 메세지도 출력되지 않는다.

관습적으로 프로그램의 이름이 인자로 주로 사용된다.

###  리턴값




없음



###  실행 예제


```cpp-formatted

/*존재하지 않는 파일(unexist.ent) 을 열어 오류를 발생시켜 perror 함수를
 * 호출시킨다.이 예제는
 * http://www.cplusplus.com/reference/clibrary/cstdio/perror/에서
 * 가져왔습니다.*/
#include <stdio.h>
int main() {
  FILE* pFile;
  pFile = fopen("unexist.ent", "rb");
  if (pFile == NULL)
    perror("The following error occurred");
  else
    fclose(pFile);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F121F7E144B6EEFA0172711)

###  연관된 함수

*  [clearerr](http://itguru.tistory.com/50)  :  오류 표시자들을 초기화한다.
*  [ferror](http://itguru.tistory.com/52)  :  오류 표시자를 검사한다.
Link :  43
2010-02-08 01:23
----------------
title : 씹어먹는 C 언어 - <15 - 4. 일로와봐, 문자열(string) - 도서 관리 프로젝트>
cat_title : 15 - 4. 일로와봐, 문자열(string) - 도서 관리 프로젝트
next_page : 55
publish_date : 2010-02-08 01:23
--------------


이번 강좌에서는

* 도서 관리 프로그램을 만든다.


![씹어먹는 C 언어](/img/ChewingClogo.png)

안녕하세요 여러분. 지난번 강좌의 마지막 생각하기 문제를 기억하시나요? 일단 이 강의는 여러분이 그 문제에 대해 충분한 시간 노력해서 생각해 보았다는 것을 가정한 하에 진행하도록 하겠습니다.

지난번에 생각해보기 마지막 문제는 아래와 같았습니다.

도서 관리 프로그램을 만들어봅시다. 프로그램에는 다음과 같은 기능들이 구현되어 있어야 합니다. (난이도 : 上)

* 책을 새로 추가하는 기능 (책의 총 개수는 100 권이라 하자. 이 때, 각 책의 정보는 제목, 저자의 이름, 출판사로 한다)

* 책의 제목을 검색하면 그 책의 정보가 나와야 한다.

* 위와 마찬가지로 저자, 출판사 검색 기능이 있어야 한다.

* 책을 빌리는 기능

* 책을 반납하는 기능


흠. 여러분은 위들 중 얼마나 해결 하셨나요? 저는 개인적으로 여러분이 위들 중에서 적어도 3 개 이상은 했으리라 믿고 싶습니다. 만일 그렇지 않다면 이 강의를 얼른 닫아서 다시 생각해보도록 하세요.


###  프로그램을 어떻게 만들 것인가?

사실 여러분이 이 문제를 해결했을 때 많은 어려움이 있었을 것이라 생각합니다. 왜냐하면 여러분은 아직까지 조그마한 작업들을 하는 프로그램만을 만들었지 이렇게 거대한(?) 프로그램은 만들어보지 않았기 때문이죠. 이렇게 거대한 프로그램을 만들 때면 이전의 작은 프로그램들을 만들때와는 달리 체계적으로 계획을 세우는 자세가 필요합니다.

이 때, 체계적으로 계획을 세우는 자세란 다음을 모두 생각해보는 것입니다.


1. 이 프로그램은 무슨 작업을 하는가?
2. 과연 이 작업이 꼭 필요한 것인가? (만일 그렇지 않다면 (1) 로 되돌아갑니다)
3. 어떠한 환경에서 프로그램이 작동되는가?
4. 무슨 언어로 개발할 것인가?


정도로 되겠습니다. 일단 1 번의 경우 프로그램을 계획하는 단계에서 가장 중요한 부분 중에 하나 입니다. 우리가 만들 프로그램의 경우 "도서 관리 프로그램" 입니다. 이 도서 관리 프로그램에는 정말 도서를 관리하는데 꼭 필요한 기능들 만이 들어가야 되겠지요. 예를 들면 제가 위해서 요구한 것들이지요. 만일 쓸데 없는 작업들을 많이 넣게 되면 프로그램 용량도 커질 뿐더러 개발하는데 드는 시간도 많이 들기 때문에 좋지 않습니다.

2 번의 경우 1 번에서 내가 한 것들을 확인하는 단계입니다. 필요 없는 기능이나 꼭 필요하지 않거나, 아니면 이 프로그램의 목적과 부합하지 않는 작업들의 경우 다시 1 번으로 돌아가 생각해 보아야할 필요성이 있습니다. 우리가 만들어야 할 도서프로그램은 제가 요구한 조건 만을 만들어 주면 충분합니다.

3 번은 우리에게는 큰 문제가 아니지만 실제로 프로그램을 개발하게 되면 상당히 중요한 역할을 차지합니다. 우리가 만드는 프로그램은 Windows 에서 작동될 수 도 있고 Linux 나 MacOS 에서 작동될 수 도 있습니다. 아니면 TV 나 냉장고 아니면 세탁기와 같은 가전 제품에서도 작동될 수 있고 요즘 가장 화제가 되는 iPhone 과 같은 스마트 폰에서 작동될 수 도 있습니다.

우리는 이러한 프로그램의 작동 환경에 맞추어 프로그램을 어떻게 만들어야 될지 고민해야 합니다. 예를 들어 은행의 ATM 에서 작동되는 프로그램은 보안이 최고로 우선이어야 겠죠. 비교적 속도가 느리더라도 말이죠. iPhone 과 같은 스마트 폰에서 작동하는 프로그램은 스마트폰의 사양이 보통 PC 보다 좋지 않으므로 프로그램을 가볍고 빠르게 만들어야 합니다. 우리가 만들 도서 관리 프로그램은 그냥 Windows 에서만 작동되도 충분합니다 

4 번은 프로그램을 어떠한 언어 (물론 우리의 경우 무조건 C 이지만...) 로 만들지 결정하는 단계입니다. 세상에서는 수 많은 언어들이 있는데 우리가 지금 배우는 C 말고도 (물론 C 가 가장 기본적이면서도 중요한 언어지요^^) 각각의 특성을 가지는 언어들이 많습니다. 우리는 이 때 마다 1,2,3 번을 충분히 고려하여 가장 효율적인 언어를 선택해서 프로그램을 만들어야 겠지요. 물론 우리가 만들 도서 프로그램은 C 언어로 만듭니다.


###  프로그램의 기본 뼈대


자. 그럼 무슨 작업을 하는 프로그램을 만들지 정했으니 이제, 어떠한 방식으로 작동되는지 생각해보도록 합시다. 우리가 만들어야 할 프로그램은 단순히 C 언어 프로그래밍 실력을 키우기 위한 것이기 때문이 굳이 예쁘게 까지 만들 필요는 없을 것 같습니다. 따라서, 이 도서 관리 프로그램은 매우 단순하게, 첫 화면에서 메뉴를 입력 받고 입력 받은 작업을 수행 한 후 다시 메뉴로 돌아오는 것으로 하면 될 것 같습니다.

따라서 프로그램의 기본 뼈대는 아래 처럼 만들 수 있습니다. (물론 여러분이 하신 방법도 좋은 방법 일 것입니다. 제 방법은 단순히 참고로만 알아두세요)

```cpp-formatted
#include <stdio.h>
int main() {
  int user_choice; /* 유저가 선택한 메뉴*/

  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");

    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);
    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    }
  }

  return 0;
}
```


성공적으로 컴파일 하면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F1316E80E4B6D80F00CEDD6)

소스 코드에는 특별히 어려운 부분이 없으나 혹시 다음 문장이 무슨 뜻인지 모를 수 있을 것입니다.

```cpp-formatted
while (1) ```

위 말은, 이전에도 이야기 했듯이 컴퓨터는 0 을 거짓, 0 이 아닌 값을 참 으로 판별한다고 말했습니다. 따라서 `while` 문의 조건이 1 이므로, 다시 말하면 `while` 문의 조건이 언제나 참이라는 것이지요. 따라서 이 `while` 문은 무한히 반복되게 됩니다. 우리가 `break` 를 하지 않을 경우 말이죠.

위 소스 코드에서 중요한 점은 각 작업을 선택할 때 마다 이에 해당하는 '함수' 를 호출한다는 점입니다. 물론, 함수를 반드시 호출할 필요는 없습니다. 그냥 `if` 문 안에다가 위 작업을 처리하는 코드를 열심히 적어주면 되지요. 하지만 함수를 호출하게 되면 코드를 보기에 상당히 깔끔하며 이해도 잘됩니다.



### 이 프로그램에 필요한 변수는?

기본적으로 생각해 보아도 책의 제목, 출판사의 이름, 저자의 이름을 저장할 배열이 있어야 합니다. 또한 현재 이 책의 상태 (빌려갔는지, 안 빌려갔는지) 를 표시할 수 있는 배열도 필요합니다. 마지막으로 현재 책의 총 개수가 있어야지만 나중에 책을 새로 추가할 때 배열의 몇 번째 원소에 표시할 지 알 수 있습니다. 따라서 이들을 조합하면 다음과 같이 변수를 선언할 수 있습니다.

```cpp-formatted
int user_choice;        /* 유저가 선택한 메뉴 */
int num_total_book = 0; /* 현재 책의 수 */

/* 각각 책, 저자, 출판사를 저장할 배열 생성. 책의 최대 개수는 100 권*/
char book_name[100][30], auth_name[100][30], publ_name[100][30];
/* 빌렸는지 상태를 표시 */
int borrowed[100];
```


이 때 `book_name` 의 크기가 `[100][30]` 인 이유는 이전에도 말했듯이 이 도서프로그램에 들어갈 수 있는 책의 최대 개수는 100 권이고, 제목의 크기는 최대 30 자로 제한되기 때문이죠. 나머지 변수들도 마찬가지 입니다. 이 때 `borrowed` 배열의 경우 원소의 값이 1 이면 빌림, 0 이면 빌리지 않음 이라고 생각하시면 됩니다.

이제 무슨 변수가 필요한지도 알았으니 먼저 1 번 작업, 즉 책을 새로 추가하는 함수를 만들어보도록 합시다. 이름은 `add_book` 이고 리턴형은 `int` 로 합시다.

```cpp-formatted
/* 책을 추가하는 함수*/
int add_book() {}
```

일단 함수를 만들기 전에 인자로 무엇을 받아야 하는지 생각해봅시다. 책을 추가하려면 책의 이름, 출판사, 저자를 저장할 배열에 대한 포인터를 인자로 받아야 합니다. 그래야지만 이 배열에 새로운 책의 정보를 추가할 수 있지요. 또한 `borrowed` 배열도 인자로 받아서 기본 설정을 해주어야 합니다. 물론 `borrowed` 배열의 기본 값은 `0,` 즉 빌려가지 않음 이겠지요. 마지막으로 `num_total_book` 도 필요합니다. 왜냐하면 현재 책의 총 수를 알아야 배열의 몇번째 원소에 값을 집어 넣을 지 알게 되기 때문이죠.

이를 종합하여 인자를 만들어보면

```cpp-formatted
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {}
```


참고로 팁으로 알려주는 사실은 위와 같이 인자를 쓰는 부분에 엔터를 쳐도 큰 문제는 없습니다. 왜냐하면 C 언어는 위 인자들이 같은 문장에 나열되어 있다고 생각하기 때문이죠. 인자가 길어져서 보기 흉할 때 자주 쓰는 방법 입니다. 자, 그럼 얼른 `add_book` 함수를 완성시켜봅시다. `add_book` 함수는 매우 간단합니다.

```cpp-formatted
/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);

  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);

  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);

  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;

  return 0;
}
```

저는 위와 같이 하였습니다.

이제 `add_book` 함수를 이용하기 위해 `main` 함수의 `if (user_choice == 1)` 부분에 `add_book` 함수를 호출하는 코드를 넣어 주시면 됩니다. 아래와 같이 말이지요.

```cpp-formatted
#include <stdio.h>
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */

  /* 각각 책, 저자, 출판사를 저장할 배열 생성. 책의 최대 개수는 100 권*/
  char book_name[100][30], auth_name[100][30], publ_name[100][30];
  /* 빌렸는지 상태를 표시 */
  int borrowed[100];

  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");

    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);

    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
      add_book(book_name, auth_name, publ_name, borrowed, &num_total_book);
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    }
  }

  return 0;
}
/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);

  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);

  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);

  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;

  return 0;
}
```


성공적으로 컴파일 했으면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1574EC164B6D8E0092933E)

어때요. 프로그램이 아주 잘 작동하고 있는 것 같네요. `main` 함수의 `if` 문에서 주의해야 할 점은

```cpp-formatted
add_book(book_name, auth_name, publ_name, borrowed, &num_total_book);
```

과 같이 `&` 를 어디에 붙일지 매우 헷갈린다는 것입니다. 기본적으로 배열의 경우, 배열의 이름이 배열의 메모리 상의 시작 주소 이기 때문에 `&` 를 붙일 필요가 없습니다. (정확히 말하면 붙이면 안됩니다). 그러나 `num_total_book` 과 같은 `int` 형 변수의 경우 `int*` 포인터에 주소값을 전달하려면 `&` 를 이용하여 `num_total_book` 변수의 주소값을 전달 해주어야 합니다.

또 하나 주의해야 할 부분은 `add_book` 함수의 원형에서

```cpp-formatted
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
```


와 같이 해야 하는데 마지막의 세미 콜론을 빠뜨리게 되면

```warning
error C2085: 'main' : 정식 매개 변수 목록에 없습니다.
error C2143: 구문 오류 : ';'이(가) '{' 앞에 없습니다.
error C2082: 'num_total_book' 정식 매개 변수 재정의
error C2082: 'book_name' 정식 매개 변수 재정의
error C2082: 'auth_name' 정식 매개 변수 재정의
error C2082: 'publ_name' 정식 매개 변수 재정의
error C2082: 'borrowed' 정식 매개 변수 재정의
warning C4047: '함수' : 'int *'의 간접 참조 수준이 'int **'과(와) 다릅니다.
warning C4024: 'add_book' : 형식 및 실제 매개 변수 5의 형식이 서로 다릅니다.
error C2084: 'int add_book(char (*)[30],char (*)[30],char (*)[30],int *,int *)' 함수에 이미 본문이 있습니다.

```

와 같이 이해하기 힘든 오류의 향연을 맛보게 됩니다.



### 책 검색하기

자. 이번에는 두 번째 작업, 책을 검색하는 작업을 수행하는 함수를 만들어보기로 합시다. 이 함수의 이름은 `serach_book` 이라고 합시다. 그렇다면 이 함수는 어떠한 인자를 취해야 될까요? 일단, 단순히 생각해 보아도 `book_name, auth_name, publ_name` 은 모두 취해야 될 것 같네요. 왜냐하면 우리가 검색을 수행 시, 책 제목에서, 지은이 이름에서, 출판사 이름에서 중 어느 하나를 선택해서 검색할 것이기 때문이죠. 또한 전체 책의 총 개수도 필요합니다. 검색할 때 불필요한 부분은 찾지 않게 하기 말이죠. 결과적으로 함수의 인자는 아래와 같으면 충분하다는 사실을 알 수 있습니다.

```cpp-formatted
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book)
```


참고로, 우리가 도서 관리 프로그램에서 만들 "검색" 기능은 우리가 알고 있는 검색 기능과는 살짝 다릅니다. 우리가 흔히 쓰는 검색 기능은 문자열이 비슷하거나 형태를 포함해도 검색 결과에 나타나지만 우리가 만들 검색 기능은 문자열이 완전히 같을 때 나타난다고 합시다. (나중에 업그레이드시 이 부분도 고려해서 하도록 합시다)

그렇다면 머리속에 번뜩이는 생각은 아마,

" [지난번 강좌](http://itguru.tistory.com/33)에서 만들었던 문자열 비교 함수를 이용하면 되겠네!"

그럼, 지난번 강좌에서 문자열 비교 함수 코드를 복사해오겠습니다.

```cpp-formatted
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```

이렇게 미리 만들어놓은 소스 코드를 이용하는 것도 매우 중요한 기술중에 하나 입니다. 이미 만든 것을 또 만드느랴 시간을 굳이 낭비할 필요가 없게 되죠.

이번에는 `book_search` 함수에 어떠한 변수들이 필요할지 생각해봅시다. (굳이 지금 변수들이 뭐가 필요하나 생각을 안해도 됩니다. 저 역시 프로그래밍을 하다가 필요한 변수들이 있으면 그때 그때 추가하는 스타일 입니다. 여기서 집고 넘어가는 것은 기본적으로 무슨 변수들이 필요할 지 생각해 보는 것입니다)

먼저, 사용자의 검색어를 받는 배열이 필요합니다. 따라서 나중에 이 검색어와 책 정보를 비교할 수 있겠지요. 또한 사용자가 어떠한 검색을 할지 (책 제목 검색, 지은이 검색, 출판사 검색) 선택을 할 때도 변수가 필요합니다. 마지막으로 첫번째 책 부터 `num_total_book` 번째 책 까지 책 정보를 비교하기 현재 몇 번째 책의 정보와 검색어를 비교하고 있는지에 대한 변수가 필요합니다.

그렇다면 아래와 같이 되겠군요.

```cpp-formatted
int user_input; /* 사용자의 입력을 받는다. */
int i;
char user_search[30]; /* 사용자가 입력한 검색어 */
```


자 이제, 사용자로 부터 입력을 받아 봅시다.

```cpp-formatted
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];

  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);

  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);

  return 0;
}
```


자. 그럼 사용자로 부터 검색어 까지 입력을 받았으니 검색어를 처리하는 일만 남았습니다. 사실 '검색' 이란 말이 거창해 보이지만 우리가 만들 도서 프로그램에서는 상당히 단순합니다. 단순히 `compare` 함수를 이용해서 책 제목 검색을 했다면, 각 책들의 제목과 `user_search` 와 비교하면 되는 것이지요. 이 아이디어를 바탕으로 만들면 다음과 같이 됩니다.

```cpp-formatted
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];

  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);

  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);

  printf("검색 결과 \n");

  if (user_input == 1) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(book_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 2) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(auth_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 3) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(publ_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  }

  return 0;
}
```


어때요? 소스가 그다지 어렵지 않죠? 위 소스코드에 대한 해석은 여태까지 강좌를 정말 보았다고 한 사람이라면 이해할 수 있을 것입니다. 그럼, 다시 `main` 함수에 `search_book` 함수를 적용시켜 봅시다.

```cpp-formatted
#include <stdio.h>
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book);

char compare(char *str1, char *str2);

int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */

  /* 각각 책, 저자, 출판사를 저장할 배열 생성. 책의 최대 개수는 100 권*/
  char book_name[100][30], auth_name[100][30], publ_name[100][30];
  /* 빌렸는지 상태를 표시 */
  int borrowed[100];

  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");

    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);

    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
      add_book(book_name, auth_name, publ_name, borrowed, &num_total_book);
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
      search_book(book_name, auth_name, publ_name, num_total_book);
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    }
  }

  return 0;
}
/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);

  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);

  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);

  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;

  return 0;
}
/* 책을 검색하는 함수 */
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];

  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);

  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);

  printf("검색 결과 \n");

  if (user_input == 1) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(book_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 2) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(auth_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 3) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(publ_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  }

  return 0;
}
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
```


성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F116BB2174B6DAB63173D26)

위와 같이 아주 잘 작동함을 알 수 있습니다.

아마도 위 도서 프로그램에서는 검색하기 기능이 가장 어려운 것 같네요. 나머지 기능들은 정말로 단순합니다. 3 번째 기능인 "책을 빌리기" 는 단순히 사용자가 빌리려는 책의 번호를 입력하면 `borrowed` 배열의 책 번호에 위치한 원소의 값을 0 에서 1 로 바꾸어주면 됩니다. 왜냐하면 `borrowed` 가 1 이면 빌려진 것, 0 이 면 안 빌려진 것 이기 때문이죠. 마찬가지로  책을 반납하는 기능도 만들 수 있습니다.



### 3, 4 번 기능


먼저, 3 번 기능 부터 만들어봅시다. 함수 이름은 `borrow_book` 으로 합시다.

```cpp-formatted
int borrow_book(int *borrowed) {
  /* 사용자로 부터 책번호를 받을 변수*/
  int book_num;

  printf("빌릴 책의 번호를 말해주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &book_num);

  if (borrowed[book_num] == 1) {
    printf("이미 대출된 책입니다! \n");
  } else {
    printf("책이 성공적으로 대출되었습니다. \n");
    borrowed[book_num] = 1;
  }

  return 0;
}
```


사실 위 함수는 매우 매우 간단하므로 특별히 설명할 것은 없습니다. 다만 주의할 점은 책이 이미 대출되어 있는 경우에도 처리를 잘 해주어야 한다는 점입니다. 책이 대출되어 있을 경우 "이미 대출된 책입니다" 라는 메세지를 표시하고 대출을 시키면 안됩니다. 자, 그럼 이제 위 함수를 `main` 함수에 넣어 작동시켜 봅시다.

```cpp-formatted
#include <stdio.h>
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book);

char compare(char *str1, char *str2);
int borrow_book(int *borrowed);

int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */

  /* 각각 책, 저자, 출판사를 저장할 배열 생성. 책의 최대 개수는 100 권*/
  char book_name[100][30], auth_name[100][30], publ_name[100][30];
  /* 빌렸는지 상태를 표시 */
  int borrowed[100];

  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");

    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);

    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
      add_book(book_name, auth_name, publ_name, borrowed, &num_total_book);
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
      search_book(book_name, auth_name, publ_name, num_total_book);
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
      borrow_book(borrowed);
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    }
  }

  return 0;
}
/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);

  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);

  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);

  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;

  return 0;
}
/* 책을 검색하는 함수 */
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];

  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);

  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);

  printf("검색 결과 \n");

  if (user_input == 1) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(book_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 2) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(auth_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 3) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(publ_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  }

  return 0;
}
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
int borrow_book(int *borrowed) {
  /* 사용자로 부터 책번호를 받을 변수*/
  int book_num;

  printf("빌릴 책의 번호를 말해주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &book_num);

  if (borrowed[book_num] == 1) {
    printf("이미 대출된 책입니다! \n");
  } else {
    printf("책이 성공적으로 대출되었습니다. \n");
    borrowed[book_num] = 1;
  }

  return 0;
}
```


성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F112C861D4B6EDBE9726CA1)

위와 같이 책이 잘 대출됨을 알 수 있습니다.

마찬가지 아이디어를 이용해서 책을 반납하는 함수를 만들어봅시다. 함수의 이름은 `return_book` 으로 합시다. 이 역시 `borrow_book` 과 하는 일이 거의 똑같으므로 설명을 생략하도록 하겠습니다.

```cpp-formatted
int return_book(int *borrowed) {
  /* 반납할 책의 번호 */
  int num_book;

  printf("반납할 책의 번호를 써주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &num_book);

  if (borrowed[num_book] == 0) {
    printf("이미 반납되어 있는 상태입니다\n");
  } else {
    borrowed[num_book] = 0;
    printf("성공적으로 반납되었습니다\n");
  }

  return 0;
}
```


역시 간단하군요. `borrow_book` 함수의 거의 똑같습니다. 이제, 이 함수를 `main` 함수에 넣어 봅시다.

```cpp-formatted
#include <stdio.h>
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book);
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book);

char compare(char *str1, char *str2);
int borrow_book(int *borrowed);
int return_book(int *borrowed);

int main() {
  int user_choice;        /* 유저가 선택한 메뉴 */
  int num_total_book = 0; /* 현재 책의 수 */

  /* 각각 책, 저자, 출판사를 저장할 배열 생성. 책의 최대 개수는 100 권*/
  char book_name[100][30], auth_name[100][30], publ_name[100][30];
  /* 빌렸는지 상태를 표시 */
  int borrowed[100];

  while (1) {
    printf("도서 관리 프로그램 \n");
    printf("메뉴를 선택하세요 \n");
    printf("1. 책을 새로 추가하기 \n");
    printf("2. 책을 검색하기 \n");
    printf("3. 책을 빌리기 \n");
    printf("4. 책을 반납하기 \n");
    printf("5. 프로그램 종료 \n");

    printf("당신의 선택은 : ");
    scanf("%d", &user_choice);

    if (user_choice == 1) {
      /* 책을 새로 추가하는 함수 호출 */
      add_book(book_name, auth_name, publ_name, borrowed, &num_total_book);
    } else if (user_choice == 2) {
      /* 책을 검색하는 함수 호출 */
      search_book(book_name, auth_name, publ_name, num_total_book);
    } else if (user_choice == 3) {
      /* 책을 빌리는 함수 호출 */
      borrow_book(borrowed);
    } else if (user_choice == 4) {
      /* 책을 반납하는 함수 호출 */
      return_book(borrowed);
    } else if (user_choice == 5) {
      /* 프로그램을 종료한다. */
      break;
    }
  }

  return 0;
}
/* 책을 추가하는 함수*/
int add_book(char (*book_name)[30], char (*auth_name)[30],
             char (*publ_name)[30], int *borrowed, int *num_total_book) {
  printf("추가할 책의 제목 : ");
  scanf("%s", book_name[*num_total_book]);

  printf("추가할 책의 저자 : ");
  scanf("%s", auth_name[*num_total_book]);

  printf("추가할 책의 출판사 : ");
  scanf("%s", publ_name[*num_total_book]);

  borrowed[*num_total_book] = 0; /* 빌려지지 않음*/
  printf("추가 완료! \n");
  (*num_total_book)++;

  return 0;
}
/* 책을 검색하는 함수 */
int search_book(char (*book_name)[30], char (*auth_name)[30],
                char (*publ_name)[30], int num_total_book) {
  int user_input; /* 사용자의 입력을 받는다. */
  int i;
  char user_search[30];

  printf("어느 것으로 검색 할 것인가요? \n");
  printf("1. 책 제목 검색 \n");
  printf("2. 지은이 검색 \n");
  printf("3. 출판사 검색 \n");
  scanf("%d", &user_input);

  printf("검색할 단어를 입력해주세요 : ");
  scanf("%s", user_search);

  printf("검색 결과 \n");

  if (user_input == 1) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 책 제목을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(book_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 2) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 지은이 이름을
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(auth_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }

  } else if (user_input == 3) {
    /*

    i 가 0 부터 num_total_book 까지 가면서 각각의 출판사를
    사용자가 입력한 검색어와 비교하고 있다.

    */
    for (i = 0; i < num_total_book; i++) {
      if (compare(publ_name[i], user_search)) {
        printf("번호 : %d // 책 이름 : %s // 지은이 : %s // 출판사 : %s \n", i,
               book_name[i], auth_name[i], publ_name[i]);
      }
    }
  }

  return 0;
}
char compare(char *str1, char *str2) {
  while (*str1) {
    if (*str1 != *str2) {
      return 0;
    }

    str1++;
    str2++;
  }

  if (*str2 == '\0') return 1;

  return 0;
}
int borrow_book(int *borrowed) {
  /* 사용자로 부터 책번호를 받을 변수*/
  int book_num;

  printf("빌릴 책의 번호를 말해주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &book_num);

  if (borrowed[book_num] == 1) {
    printf("이미 대출된 책입니다! \n");
  } else {
    printf("책이 성공적으로 대출되었습니다. \n");
    borrowed[book_num] = 1;
  }

  return 0;
}
int return_book(int *borrowed) {
  /* 반납할 책의 번호 */
  int num_book;

  printf("반납할 책의 번호를 써주세요 \n");
  printf("책 번호 : ");
  scanf("%d", &num_book);

  if (borrowed[num_book] == 0) {
    printf("이미 반납되어 있는 상태입니다\n");
  } else {
    borrowed[num_book] = 0;
    printf("성공적으로 반납되었습니다\n");
  }

  return 0;
}
```


성공적으로 컴파일 했다면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F1142561D4B6EDE859221FE)

위와 같이 아주 잘 작동됨을 알 수 있습니다.

아. 그럼 마침내 우리는 도서 관리 프로그램을 완성하였습니다!! 처음에 막연하게 도서 관리 프로그램을 만들라고 하니까 상당히 막연해 보였는데 하나 하나 조금씩 해보니 금새 만들게 되었습니다. 뿐만 아니라 함수를 이용해서 소스 코드의 가독성도 높여주었습니다.

뿐만 아니라 여러분이 도서 관리 프로그램을 만들면서 느끼게 될 점은 **주석의 유용함** 일 것입니다. 만일 우리가 주석 하나 없이 단순하게 프로그램을 만들었다면 나중에.. 한 1 달 뒤에 이 소스 코드를 다시 보게 된다면 "이 변수가 뭐지? 이 부분은 뭐하는 것이지?" 라는 생각이 들 것입니다. 저는 심지어 주석이 없이 프로그래밍 한 경우 어제 한 코드도 이해 못하는 경우가 있었습니다. 하지만 주석이 있다면 정말 아무리 오래 전에 만든 프로그램이여도 소스를 보면서 손쉽게 이해해 나갈 수 있습니다.

그럼 여기서 이번 강좌를 마치도록 하겠습니다.

### 생각해보기

#### 문제 1

위 프로그램을 다 지우고 다시 만들어보자. 물론 소스가 정확히 일치하지 않아도 된다. 기능만 동일하면 된다. (난이도 : 下)

#### 문제 2

`search_book` 함수는 살짝 지저분한 편이다. 다른 함수를 제작하여 조금 간추릴 수 있겠는가? (난이도 : 中下)

#### 문제 3

`search_book` 함수를 조금 개량하여 빌려진 책은 검색결과 출력되지 않게 하거나, "대출됨" 이라는 문구가 출력되게 해보자. (난이도 : 下)

#### 문제 4

`search_book` 함수를 개량하여 특정한 검색어를 입력했을 때 그 검색어를 포함하는 문자열도 검색되게 해보자. (난이도 : 中)

예를 들어 책 제목이 "learnCfast", "learningC", "whatisC?" 일 때, learn 를 검색하면 "learnCfast" 와 "learningC" 가 나온다. 왜냐하면 이들은 모두 "learn 라는 문자열을 포함하고 있기 때문이다.

##@ chewing-c-end
Link :  52
2010-02-05 14:49
----------------
title : C 언어 레퍼런스 - ferror 함수
cat_title :  ferror
publish_date : 2010-02-05 14:49
--------------

```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ ferror

```info
#include <stdio.h> // C++ 에서는 <cstdio>
int ferror ( FILE * stream );
```

오류 표시자를 검사한다.

인자에서 지정한 스트림의 오류 표시자가 설정 되어 있는지 확인하고, 설정 되어 있다면 0 이 아닌 값을 리턴한다.

보통 오류 표시자는 이전의 스트림 작업에서 오류가 발생했을 때 설정된다.

###  인자

`stream`

오류 표시자의 값을 확인할 스트림의 `FILE` 객체를 가리키는 포인터

###  리턴값

만일 스트림의 오류 표시자가 설정되어 있다면 0 이 아닌 값을 리턴한다.
그렇지 않을 경우 0 을 리턴한다.

###  실행 예제

```cpp-formatted
/*

읽기 전용으로 열은 파일에 fputc 를 이용해 강제적을 파일에 쓰기를 함으로써 오류를
발생시켜 ferror 함수에 의해 어떻게 처리되는지 살펴본다. 이 예제는
http://www.cplusplus.com/reference/clibrary/cstdio/ferror/ 에서 가져왔습니다.
*/
#include <stdio.h>
int main() {
  FILE* pFile;
  pFile = fopen("myfile.txt", "r");
  if (pFile == NULL)
    perror("Error opening file");

  else {
    fputc('x', pFile);
    if (ferror(pFile)) printf("Error Writing to myfile.txt\n");
    fclose(pFile);
  }
  return 0;
}
```

실행 결과

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F12149C1E4B6EEBF2A949BD)



###  연관된 함수

*  [feof](http://itguru.tistory.com/51)  :  파일 끝 표시자를 검사한다.
*  [clearerr](http://itguru.tistory.com/50):  오류 표시자들을 클리어(clear) 한다.
*  [perror](http://itguru.tistory.com/53)  :  오류 메세지를 표시한다.
Link :  51
2010-02-05 01:41
----------------
title : C 언어 레퍼런스 - feof 함수
cat_title :  feof
publish_date : 2010-02-05 01:41
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ feof

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int feof ( FILE * stream );
```


파일 끝 표시자(End-of-File indicator)를 검사한다.

인자로 넘겨준 스트림의 파일 끝 표시자를 검사하여 설정(set) 되어 있다면 0 이 아닌 값을 리턴한다.
보통 표시자는 이전의 입출력 작업에 의해 스트림이 파일 끝에 도달하였을 때 설정된다.

[rewind](http://itguru.tistory.com/75)이나 [fseek](http://itguru.tistory.com/72), [fsetpos](http://itguru.tistory.com/73)함수들 중 어느 하나가 성공적으로 위치 표시자의 값을 바꾸기 전 까지, 모든 입출력 작업들은 오류를 리턴하게 된다.

###  인자

`stream`

작업을 수행할 스트림의 `FILE` 객체를 가리키는 포인터.

###  리턴값

인자로 전달된 스트림의 파일 끝 지시자가 설정되어 있다면 0 이 아닌 값을 리턴한다.
그렇지 않을 경우 0 이 리턴된다.

###  실행 예제


```cpp-formatted
/*

myfile.txt 의 총 바이트 수를 센다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/feof/
에서 가져왔습니다.

*/
#include <stdio.h>
int main() {
  FILE* pFile;
  long n = 0;
  pFile = fopen("myfile.txt", "rb");
  if (pFile == NULL)
    perror("Error opening file");

  else {
    while (!feof(pFile)) {
      fgetc(pFile);
      n++;
    }
    fclose(pFile);
    printf("Total number of bytes: %d\n", n - 1);
  }
  return 0;
}
```

`myfile.txt` 의 내용


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F145B2A1B4B6EEADA2826C0)

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F135DE91B4B6EEADA159C42)

만일 파일을 읽어들이다가 파일 끝에 도달하게 되면 `feof` 가 0 이 아닌 값을 리턴하게 되어 `while` 문을 빠져나가게 된다.



###  연관된 함수

* [clearerr](http://itguru.tistory.com/50):  오류 표시자들을 클리어한다.
* [ferror](http://itguru.tistory.com/52)  :  오류 표시자를 검사한다.
Link :  50
2010-02-05 00:56
----------------
title : C 언어 레퍼런스 - clearerr 함수
cat_title :  clearerr
publish_date : 2010-02-05 00:56
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ clearerr

```info
#include <stdio.h> // C++ 에서는 <cstdio>

void clearerr ( FILE * stream );
```


오류 표시자를 초기화(clear) 한다.

스트림의 `EOF` 표시자와 오류 표시자를 모두 재설정(reset) 한다.

만일 스트림 함수가 오류 혹은 파일끝에 도달하였기 때문에 실패한다면, 이 두 개의 표시자들 중 하나가 설정된다. 이 표시자들은 `rewind, fseek, fsetpos` 함수 들 중 어느 하나가 호출 되기 전 까지 변경되지 않는다.



###  인자

`stream`

작업을 수행할 스트림의 `FILE` 객체를 가리키는 포인터

###  리턴값

없음

###  실행 예제

```cpp-formatted
/* 인위적으로 오류를 발생시킨 뒤 이 오류가 clearerr 에 의해 어떻게 처리되는지
살펴본다.

이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/clearerr/에서
가져왔습니다. */
#include <stdio.h>
int main() {
  FILE* pFile;
  pFile = fopen("myfile.txt", "r");
  if (pFile == NULL)
    perror("Error opening file");
  else {
    fputc('x', pFile);
    if (ferror(pFile)) {
      printf("Error Writing to myfile.txt\n");
      clearerr(pFile);
    }
    fgetc(pFile);
    if (!ferror(pFile)) printf("No errors reading myfile.txt\n");
    fclose(pFile);
  }
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F143FEB114B6AED222A25EB)

이 예제에서 `myfile.txt` 를 읽기 전용 (r) 로 열었으나, `fputc` 함수를 이용해 이 파일에 쓰기를 시도하였기 때문에 오류가 발생하였다.

따라서 첫번째 `if` 문에서 *Error Writing to myfile.txt\n* 이 출력되었지만, `clearerr` 함수를 이용하여 오류 플래그를 비워버렸다. 따라서 아래 `if` 문에서 성공적으로 *No errors reading myfile.txt\n* 가 출력될 수 있었다.


###  연관된 함수

*  [feof](http://itguru.tistory.com/51)   :  파일 끝 표시자(EOF) 를 검사한다.
*  [ferror](http://itguru.tistory.com/52):  오류 표시자를 검사한다.
* `rewind ` :  위치 표시자를 처음으로 되돌린다.
Link :  49
2010-02-04 22:14
----------------
title : C 언어 레퍼런스 - ungetc 함수
cat_title :  ungetc
publish_date : 2010-02-04 22:14
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ ungetc

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int ungetc ( int character, FILE * stream );
```


스트림에 문자를 다시 집어 넣는다(unget)

스트림에 마지막으로 문자가 읽어들여졌던 자리에 문자(`ungetc` 함수에 인자로 전달된 character)가 말그대로 들어가고, 파일 위치 표시자가 감소하여 이전 위치를 가리키게 한다. 따라서, 다음 읽기 작업에서는 방금 스트림에 집어 넣어졌던 문자가 읽히기 된다.

예를 들면

```cpp-formatted
FILE *fp = fopen("a.txt", "r");
char ch;
getc(fp);
getc(fp);
ungetc('a', fp);
ch = getc(fp);
```

을 한다면 `a.txt` 에 무엇이 들어 있던 간에 `ch` 에는 `a` 가 들어가게 된다. 왜냐하면 `ungetc` 를 실행하기 직전에 위치 표시자의 값은 2 였다.

그런데 `ungetc` 를 호출함으로써 위치 표시자의 값은 1 이 되고, 그 자리에 `a` 가 써지게 된다.

그 후 `getc` 함수를 호출하면 현재 파일 위치 표시자의 문자를 리턴하는데, 여기서 위치 표시자의 값은 1 이고 그 자리에 `a` 가 있으므로 결과적으로 `ch` 에는 `a` 가 들어간다. 물론, `a` 가 써진다는 말은파일에 실질적으로 `a` 가 기록되는 것이 아니라 버퍼에 써지는 것이다.

`unget` 함수를 여러번 호출하게 되면 나중 읽기작업에서 호출된 역순으로 출력된다.예를 들어

```cpp-formatted
ungetc('a', fp);
ungetc('b', fp);

ch = getc(fp);  // ch 에는 b 가 들어간다.
ch = getc(fp);  //  ch 에는 a 가 들어간다.
```

주의할 점은 `unget` 함수를 여러번 호출하여서 중간에 파일 위치 표시자의 값이 0 이 된다면 그 이후에 호출된 `unget` 함수들은 모두 무시된다. 예를 들어

```cpp-formatted
fp = fopen("test.txt", "r");
getc(fp);         // 이 함수 호출 이후 위치 표시자의 값은 1
ungetc('a', fp);  // 이 함수 호출 이후 값은 0
ungetc('b', fp);  // 따라서 버퍼에 b 가 들어갈 수 없다.

ch = getc(fp);  // ch 에는 a 가 들어간다.
printf("%c", ch);
ch = getc(fp);  //  ch 에는 test.txt 의 두 번째 문자가 들어간다.
```

만일 `EOF` 표시자가 설정된 상태에서 이 함수를 호출하면 `EOF` 표시자는 초기화(clear) 된다.

`fseek` 나 `fsetpos` 나 `rewind` 함수를 호출하면 이전에 `unget` 함수에 의해 들어갔었던 문자들이 모두 삭제된다.

만일 `unget` 함수의 `character` 인자로 전달된 값이 `EOF` 라면 입력 스트림에는 아무런 변화가 없게된다.

###  인자




`character`

스트림에 집어 넣을 문자. 이 때, 문자는 `int` 로 형변환 되어 전달된다.

`stream`

문자를 넣을 입력 스트림의 `FILE` 객체를 가리키는 포인터.



###  리턴값




성공적으로 문자가 들어간다면 들어갔던 문자가 리턴된다.
실패한다면 `EOF` 가 리턴되고 스트림에는 아무런 변화가 없게 된다.



###  실행 예제




```cpp-formatted
/*myfile.txt 로 부터 각 문장을 입력 받되  # 로 시작하는 문장은 @ 로 대체해서
 * 입력받는다.이 예제는
 * http://www.cplusplus.com/reference/clibrary/cstdio/ungetc/에서 가져왔습니다.
 */
#include <stdio.h>
int main() {
  FILE* pFile;
  int c;
  char buffer[256];
  pFile = fopen("myfile.txt", "rt");
  if (pFile == NULL)
    perror("Error opening file");
  else {
    while (!feof(pFile)) {
      c = getc(pFile);
      if (c == '#')
        ungetc('@', pFile);
      else
        ungetc(c, pFile);
      fgets(buffer, 255, pFile);
      fputs(buffer, stdout);
    }
  }
  return 0;
}
```

`myfile.txt` 의 내용


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F2040C2284B6ACA04A4744E)

실행 화면


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1205D2284B6ACA02032FD1)

위 프로그램 소스에 대해 간단히 설명을 하자면

```cpp-formatted
c = getc(pFile);
if (c == '#')
  ungetc('@', pFile);
else
  ungetc(c, pFile);
```

일단 `getc` 를 통해 `pFile` 에서 문장의 첫번째 문자를 읽어온다. (왜냐하면 밑의 `fgets` 를 통해 개행 문자가 있을 때 까지 읽어오기 때문에 `getc` 는 언제나 문장의 첫번째 문자를 읽어오게 된다) 이 때, 그 문자가 # 이라면 `ungetc('@', pFile)` 을 통해 버퍼에서 현재 '#' 가 들어 있는 위치에 @ 가 들어가게 된다. 따라서

```cpp-formatted
fgets(buffer, 255, pFile);
fputs(buffer, stdout);
```

를 하게 되면 `buffer` 에는 @ 부터 '\n' 이 나올 때 까지, 즉 한 문장의 끝까지 들어가게 된다.

이 때 주목할 점은 `myfile.txt` 의 내용은 전혀 바뀌지 않았다는 것이다. `ungetc` 함수는 단지 버퍼의 내용만을 조작하는 함수 이므로 `myfile.txt` 의 # 들은 결코 @ 로 바뀌지 않는다.



###  연관된 함수





*  [getc](http://itguru.tistory.com/41):  스트림에서 문자를 받는다.



*  [fgetc](http://itguru.tistory.com/37):  스트림에서 문자를 받는다.

*  [putc](http://itguru.tistory.com/46)  :  스트림에 문자를 쓴다.
Link :  48
2010-02-04 21:15
----------------
title : C 언어 레퍼런스 - puts 함수
cat_title :  puts
publish_date : 2010-02-04 21:15
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ puts

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int puts ( const char * str );
```


표준 출력에 문자열을 쓴다.

`str` 이 가리키는 C 문자열을 표준 출력(stdout) 에 쓴 뒤 자동으로 개행 문자('\n') 도 추가로 쓴다.
(즉 문자열에 \n 이 마지막에 없더라도 한 줄 개행이 되어 출력된다)

`puts` 함수는 `str` 이 가리키는 주소 부터 널 종료 문자 ('\0') 에 도달할 때 까지 표준 출력에 문자를 복사하지만 마지막 널 문자는 표준 출력에 복사되지 않는다.

`fputs(str, stdout)` 을 통해 `puts` 함수와 동일한 작업을 할 수 있지만 `fputs` 함수의 경우 마지막에 개행 문자를 붙이지 않는다.



###  인자




`str`

표준 출력에 쓰여질 C 형식 문자열



###  리턴값




성공적으로 쓰였다면 음이 아닌 값이 리턴된다.
오류가 발생하였다면 `EOF` 를 리턴한다.



###  실행 예제




```cpp-formatted
/* 화면에 str 의 내용을 출력한다 */
#include <stdio.h>

int main() {
  char str[] = "Hello, World!";
  puts(str);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F116332134B6AB977BD3643)

주목해 볼 점은 `str` 에 개행 문자가 없었는데도 불구하고 화면에는 자동적으로 개행되어 나타났다는 점이다. 즉 `puts` 함수는 자동적으로 마지막에 \n 을 추가해서 스트림에 쓴다는 사실을 알 수 있다.




###  연관된 함수





*  [fputs](http://itguru.tistory.com/40)  :  문자열을 스트림에 쓴다.

*  [printf](http://itguru.tistory.com/35)  :  표준 출력(stdout) 에 데이터를 형식에 맞추어 출력한다.

*  [putchar](http://itguru.tistory.com/47)  :  `stdout` 에 문자를 쓴다.

*  [gets](http://itguru.tistory.com/45)  :  `stdin` 에서 문자열을 받는다.
Link :  47
2010-02-04 21:02
----------------
title : C 언어 레퍼런스 - putchar 함수
cat_title :  putchar
publish_date : 2010-02-04 21:02
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ putchar

```info
#include <stdio.h> // C++ 에서는 <cstdio>

int putchar ( int character );
```

표준 출력(stdout) 에 문자를 쓴다.

표준 출력에서 현재 위치 표시자가 가리키는 곳에 문자를 쓴 뒤, 위치 표시자를 다음 위치로 전진시킨다.
`putchar` 함수는 `putc(character, stdout)` 를 한 것과 동일하다.



###  인자

`character`

표준 출력에 쓸 문자. 이 때 문자는 `int` 형태로 형변환되어 전달된다.



###  리턴값

오류가 하나도 없다면 표준 출력에 쓰여진 문자가 반환된다.
만일 오류가 발생한다면 `EOF` 가 반환되고 오류 표시자가 설정된다.

###  실행 예제

```cpp-formatted
/* 화면에 'p' 를 출력한다 */
#include <stdio.h>
int main() {
  char ch = 'p';

  putchar(ch);

  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F16415F144B6AB65213766E)

```cpp-formatted
/*

화면에 알파벳 A 부터 Z 까지 출력한다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/putchar/
에서 가져왔습니다.

*/
#include <stdio.h>

int main() {
  char c;
  for (c = 'A'; c <= 'Z'; c++) {
    putchar(c);
  }
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F1304D4134B6AB693652E08)




###  연관된 함수





*  [putc](http://itguru.tistory.com/46)  :  스트림에 문자를 쓴다.

*  [fputc](http://itguru.tistory.com/39):  스트림에 문자를 쓴다.

*  [getchar](http://itguru.tistory.com/44)  :  표준 입력(stdin) 에서 문자를 받는다.
Link :  46
2010-02-04 19:29
----------------
title : C 언어 레퍼런스 - putc 함수
cat_title :  putc
publish_date : 2010-02-04 19:29
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ putc

```info


#include <stdio.h> // C++ 에서는 <cstdio>int putc ( int character, FILE * stream );
```


스트림에 문자를 쓴다.

스트림에 한 문자를 쓴 뒤 위치 표시자 (Position indicator) 를 한 칸 전진시킨다.
문자가 스트림에 어떤 부분에 쓰일지는 위치 표시자에 의해 정해진다.

`putc` 는 [fputc](http://itguru.tistory.com/39)와 동일하며 [fputc](http://itguru.tistory.com/39)와 마찬가지로 스트림을 인자로 받지만 `putc` 는 매크로의 형태로 구현되어 있기 때문에 인자를 전달할 때, 복잡한 식을 사용하지 않는 것이 좋다.
`putchar` 함수는 `putc` 와 비슷한 작업을 하지만 `stream` 인자를 받지 않고 무조건 `stdout` 에 쓴다.



###  putc




`character`

스트림에 쓰여질 문자. 이 때 `int` 로 형변환되어 전달된다.

`stream`

문자가 쓰여질 스트림의 `FILE` 객체를 가리키는 포인터



###  리턴값




만일 오류가 없다면 스트림에 쓰인 문자가 똑같이 반환된다.
오류가 발생한다면 `EOF` 가 리턴되고 오류 표시자가 설정된다.



###  예제




```cpp-formatted
/* stdout (표준 출력) 에 p 를 쓴다.*/
#include <stdio.h>
int main() {
  char ch = 'p';

  putc(ch, stdout);

  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1666211A4B6AB39234C27A)


```cpp-formatted
/*

alphabet.txt 에 (없다면 파일을 생성해서) A 부터 Z 까지 쓴다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/putc/
에서 가져왔습니다.

 */
#include <stdio.h>
int main() {
  FILE* pFile;
  char c;

  pFile = fopen("alphabet.txt", "wt");
  for (c = 'A'; c <= 'Z'; c++) {
    putc(c, pFile);
  }
  fclose(pFile);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F20227D1B4B6AB3446E7630)




###  연관된 함수





* putchar  :   표준 출력(stdout) 에 문자를 쓴다.



*  [fputc](http://itguru.tistory.com/39)  :  스트림에 문자를 쓴다.



*  [getc](http://itguru.tistory.com/41)   :  스트림에서 문자를 받는다.



*  [fwrite](http://itguru.tistory.com/69)  :  스트림에 데이터 블록을 쓴다.



*  [fprintf](http://itguru.tistory.com/64)  :  스트림에 형식에 맞춘 데이터를 쓴다.
Link :  45
2010-02-03 23:48
----------------
title : C 언어 레퍼런스 - gets 함수
cat_title :  gets
publish_date : 2010-02-03 23:48
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ gets

```info
#include <stdio.h> // C++ 에서는 <cstdio>

char * gets ( char * str );
```


표준 입력(stdin) 에서 문자열을 가져온다.

표준 입력에서 문자들을 개행 문자 ('\n') 이나 파일 끝(EOF) 를 만나기 전 까지 가져와서 `str` 에 저장한다.

이 때, 개행 문자 ('\n') 은 문자열에 포함되지 않는다.

널 문자 ('\0') 는 문자열 맨 마지막에 자동적으로 추가된다.

참고로 `gets` 함수에서 주의할 점은, 이 함수는 인자가 `stdin` 인 [fgets](http://itguru.tistory.com/38)함수와 다르다는 것이다. 일단 `gets` 는 개행 문자를 문자열에 포함시키지 않지만 [fgets](http://itguru.tistory.com/38)함수는 개행 문자도 포함시킨다.

또한, `gets` 함수는 얼마나 많은 문자를 읽어들일 것인지에 대해 지정하지 않기 때문에 여러분은 `gets` 함수를 사용시 충분한 크기의 `str` 배열을 만들어서 버퍼 오버플로우를 방지해야 한다.



###  인자




`str`

C 형식의 문자열이 저장될 `char` 배열의 포인터 C 형식의 문자열이 저장될 `char` 배열의 포인터.



###  리턴값




성공적으로 읽어 들였다면 `str` 을 리턴한다.

만일 아무런 문자도 읽어들이지 못했는데 `EOF` 에 도달하였다면 `str` 의 내용은 하나도 바뀌지 않고 `NULL` 포인터를 리턴한다.

오류가 발생했다면 `NULL` 포인터가 리턴된다.

여러분은 [ferror](http://itguru.tistory.com/52)이나 [feof](http://itguru.tistory.com/51)함수를 이용해서 각각 어떤 오류가 발생했는지, `EOF` 에 도달하였는지 알 수 있다.




###  실행 예제




```cpp-formatted
/* 사용자로 부터 문자열을 입력받는다.  */
#include <stdio.h>
int main() {
  char str[100];
  printf("당신의 이름은 무엇인가요? ");
  gets(str);
  printf("만나서 반가워요 %s 님 \n", str);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F11671B284B698C0E2350EE)




###  연관된 함수





*  [fgets](http://itguru.tistory.com/38)  :  스트림에서 문자열을 읽어온다.

*  [getchar](http://itguru.tistory.com/44)  :  표준 입력(stdin)에서 문자를 읽어온다.

*  [scanf](http://itguru.tistory.com/36)  :  표준 입력에서 데이터를 형식에 맞추어 읽어온다.
Link :  44
2010-02-03 02:25
----------------
title : C 언어 레퍼런스 - getchar 함수
cat_title :  getchar
publish_date : 2010-02-03 02:25
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?

```

#@ getchar


```info

#include <stdio.h> // C++ 의 경우 <cstdio>int getchar ( void );
```


`stdin` 에서 한 문자를 가져온다.

표준 입력에서 다음 문자를 리턴한다.
이는 인자가 `stdin` 인 `getc` 함수와 동일하다.



###  인자

없음

###  리턴값

읽어들인 문자를 `int` 값으로 리턴한다.

만일 파일 끝에 도달하거나, 읽기 오류가 발생한다면 함수는 `EOF` 를 리턴하고 이에 대응하는 오류혹은 `EOF` 표시자가 설정된다. 여러분은 [ferror](http://itguru.tistory.com/52)이나 [feof](http://itguru.tistory.com/51)함수를 통해 각각 어떤 오류가 발생했는지, 파일 끝에 도달하였는지 알 수 있다.



###  실행 예제




```cpp-formatted
/* 한 문자를 읽는다.*/
#include <stdio.h>
int main() {
  char ch = getchar();
  printf("문자 : %c \n", ch);

  return 0;
}
```


실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1465C7154B685E0307EE2B)

`getchar` 함수는 아래와 같이 버퍼를 비우는데에도 종종 사용될 수 있다.

```cpp-formatted
/* 버퍼 비우기 */
#include <stdio.h>
int main() {
  int i;
  char c;

  scanf("%d", &i);
  getchar();
  scanf("%c", &c);

  printf("입력한 문자 : %c \n", c);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F190939164B685E7E02CEC7)

만일 위 프로그래램에서 `getchar()` 부분을 지워버린다면 `scanf` 는 문자 `c` 를 사용자로 부터 입력받지 않고 지나갈 것이다. 왜냐하면 이전에 호출한 `scanf` 에 의해 버퍼에 이미 `\n` 이 남아 있었기 때문이다. 

하지만 `getchar` 함수를 호출함으로 통해 버퍼에 남아 있던 `\n` 을 날려버릴 수 있었다. 자세한 내용을 알고 싶다면 [여기를 클릭하세요](http://itguru.tistory.com/32)

물론 `getchar` 함수를 호출하지 않고도 `scanf` 함수 만으로 문제를 해결할 수 있다. [자세한 내용은 여기를 클릭하세요](http://itguru.tistory.com/36)

```cpp-formatted
/*

타이프기 처럼 한 문장을 입력하면 아래 써진다.
. 이 입력되면 입력이 종료된다.
다음 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/getchar/
에서 가져왔습니다.

*/
#include <stdio.h>
int main() {
  char c;
  puts("Enter text. Include a dot ('.') in a sentence to exit:");
  do {
    c = getchar();
    putchar(c);
  } while (c != '.');

  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F173C481F4B685F6E015E38)





###  연관된 함수



*  [getc](http://itguru.tistory.com/41)  : 스트림에서 한 문자를 가져온다.

* `putchar ` : `stdout` 에 한 문자를 쓴다.

*  [scanf](http://itguru.tistory.com/36)  :  형식 문자열에 정의된 방법에 따라 데이터를 `stdin` 에서 읽는다.
Link :  36
2010-02-03 02:05
----------------
title : C 언어 레퍼런스 - scanf 함수
cat_title :  scanf
publish_date : 2010-02-03 02:05
--------------



```warning
아직 C 언어와 친숙하지 않다면, [씹어먹는 C 언어 강좌](http://itguru.tistory.com/notice/15)를 보는 것이 어떻까요?
참고로 이 레퍼런스는 scanf 함수에 대해 어느 정도의 지식을 가지고 있는 사람을 대상으로 하는 것이므로 scanf 함수를 처음 접하시는 분들은 [여기를 클릭하시기](http://itguru.tistory.com/9) 바랍니다. 또한 scanf 와 버퍼에 관련지어 공부를 하시고 싶은 분들은 [여기를 클릭하시기](http://itguru.tistory.com/32) 바랍니다.

```

#@ scanf

```info

<stdio.h> // C++ 의 경우<cstdio>
int  scanf ( const char * format, ... );
```



표준입력(stdin) 으로 부터 데이터를 형식에 맞추어 읽어온다.


`scanf` 함수는 표준입력(stdin) 으로 부터 데이터를 읽어와 형식(format) 문자열에 따라 나머지 인자들이 가리키는 장소에 값을 대입한다. 이 때, 나머지 인자들은 반드시 할당된 공간을 가리켜야 하며, 형식 문자열의 형식 태그(format tag) 가 지정하는 바에 따라 대응되는 인자들이 가리키는 공간에 값이 대입된다.



###  인자

#### 형식(format) 문자열

형식 문자열은 한 개 이상의 아래 것을 포함하는 C 형식 문자열이다.


* 공백 문자(Whitespace character) : `scanf` 함수는 공백문자(띄어쓰기 한 칸, 개행 문자, 탭 문자) 가 아닌 것들 이전에 나오는 모든 공백 문자 를 모두 무시한다.

* 퍼센트 기호(%) 를 제외한 비-공백문자들(non-whitespace character) : 형식 문자열에 있는 공백 문자나 형식 지정자(% 로 시작하는 것들) 을 제외한 나머지 문자들은 `scanf` 함수로 하여금 `stdin` 에서 다음 문자를 읽어여 이 비-공백 문자와 비교하여 같다면 무시한 후, 형식 문자열의 다음 문자들을 처리하고, 다르다면 함수를 종료하게 되고 `stdin` 에는 읽히지 않은 다음 문자들이 남아 있게 된다.


* 형식 지정자(Format specifier) : `%` 다음에 오는 문자들은 `scanf` 함수의 형식 지정자를 나타내며 이 형식 지정자는 `stdin` 에서 어떠한 타입과 형식의 데이터를 가져올지에 대해서 알려준다. 이 때, 형식 지정자에 따라 `stdin` 에서 입력받은 데이터는 각 형식 지정자에 대응되는 인자들이 가리키는 주소에 저장된다. 형식 지정자는 아래와 같이 생겼다.


```info
%[*][폭(width)][한정자(modifiers)]타입(type)
```

|종류|설명|
|----|----|
|`*`| 데이터를 `stdin` 에서 받아들이지만 무시된다. 물론, 이에 대응되는 인자에는 받아들인 데이터가 저장되지 않고 이 인자는 다음 형식 태그에 대응된다. 예를 들어 `scanf("%*d%d", i,j);` 의 경우 먼저 수를 입력하더라도 `%*d` 형식이므로 무시 된다. 그 다음 수를 입력하면 `%d` 형식 태그가 `j` 가 아닌 `i` 에 대응되어 `i` 에 그 다음 입력한 수가 들어가게 된다. 이 때 `j` 에는 아무런 값도 들어가지 않는다.|
|폭|`stdin` 에서 읽어들일 최대 문자 수를 지정한다. 예를 들어 `scanf("%10s", str);` 로 했을 경우 `stdin` 에서 최대 10 문자를 읽어와 `str` 에 저장한다. 이 때 주의할 점은 `str` 에는 `NULL` 문자가 들어갈 수 있는 충분한 공간이 남아 있어야 한다.|
|한정자|입력받는 데이터의 크기를 지정한다. `int, unsigned int, float` 형에 대해 입력받는 데이터의 크기를 설정할 수 있다. `h` 의 경우 `short int` (`d, i, n` 의 경우) 혹은 `unsigned short int` (`o, u, x` 일 경우). `l` 의 경우 `long int` (`d, i, n` 의 경우) 혹은 `unsigned long int` (`o, u, x` 일 경우), 혹은 `double` (`e, f, g` 일 경우). 마지막으로 `L` 의 경우 `long double` (`e, f, g` 일 경우) 에 사용할 수 있다.|
|타입|데이터를 어떠한 형식으로 혹은 어떠한 값만을 읽어들어야 할 지에 대해 지정해준다. 아래 표를 참고.|


####  scanf 함수의 타입 지정자들

|타입|대응되는 입력 방식|대응되는 인자의 형태|
|`c`|단일 문자: 하나의 문자를 읽어들인다. 만일 폭에 1 이 아닌 값으로 지정되어 있다면 (기본값은 1) 함수는 폭 만큼의 문자를 읽어들인 후 이에 대응하는 인자가 가리키는 메모리 공간에 저장한다. 이 때 마지막에는 널 문자를 붙이지 않는다.|`char *`|
|`d`|십진법으로 표현된 정수: 말그대로 십진법으로 쓰인 정수로, `+` 나 `-` 기호로 시작할 수도 있다.|`int *`|
|`e, E, f, g, G`|부동 소수점: 소수점을 포함하고 있는 소수(decimal number) 로 `+` 나 `-` 기호로 시작할 수도 있으며, `e` 나 `E` 문자(10 의 지수를 나타내기 위해)를 포함할 수 도 있다. -732.103, 12e-4, +123.10 은 모두 올바른 입력이다.| `float *`|
|`o`|8진법으로 표현된 정수|`int *`|
|`s`|문자열: 공백문자를 찾을 때 까지 문자들을 읽어들인다.|`char *`|
|`u`|부호가 없는 십진법으로 표현된 정수|`unsigned int *`|
|`x, X`|16진법으로 표현된 정수|`int *`|

#### 부수적 인자

형식 문자열의 정의된 순서대로 각 형식 지정자는 이에 대응하는 인자가 가리키는 메모리 공간에 데이터를 집어넣는다. 이 때, 부수적 인자들은 모두 포인터의 형태 (주소값) 여야 한다. 예를 들어서 `i` 라는 변수에 값을 대입하려면 인자로 `&i` 를 전달해야 한다. 절대로 `i` 를 전달하면 안된다.



###  리턴값


입력이 성공적이였다면 함수는 성공적으로 읽어들인 인자의 개수를 리턴한다.
(즉 `scanf("%d%d", &i, &j);` 를 했는데 성공적으로 읽어들였다면 2 가 리턴되는 셈이다).

대부분의 경우 이 리턴값은 형식 문자열에서 읽어들이고자 기대하는 개수와 동일하지만 가끔식 적을 수도 있고 심지어 읽기에 오류가 발생한다면 0 일 수 도 있다.

만일 성공적으로 읽어보기도 전에 읽기 오류가 발생한다면 `EOF` 가 리턴된다.

###  scanf 함수의 고질적인 문제 및 해결책


`scanf` 함수를 사용하다 보면 다음과 같이 입력을 받지 않고 넘어가는 경우가 종종 있다.

```cpp-formatted
printf("숫자를 입력하세요 : ");
scanf("%d", &num);

printf("문자를 입력하세요 : ");
scanf("%c", &c);
```

로 하면 "문자를 입력하세요 : " 부분이 실행되지 않고 넘어간다.
이러한 일이 발생하는 원인과 해결책은 [여기를 누르면 알 수 있다](http://itguru.tistory.com/32)

이 글에 제시된 해결책 보다 조금 높은 수준을 원한다면 `*` 문자를 활용하면 된다. 앞에서 말했듯이 `*` 문자는 `stdin` 에서 입력은 받지만 그 데이터는 버려버리는 특징을 이용하면

```cpp-formatted
scanf("%d", &num);
scanf("%*c%c", &c);
```

와 같이 하면 된다. 왜냐하면 `"%*c%c"` 라는 형식 문자열의 의미는 "`stdin` 에서 한 문자를 얻어오되 그 값은 버리고 (이 경우 \n 이 버려진다), 그 다음에 한 문자를 얻어와 이에 대응되는 인자 (&c) 에 저장한다" 이기 때문이다.

하지만 이러한 문제를 가장 잘 해결하는 방법은 [fgets](http://itguru.tistory.com/38)함수를 이용하는 것이다.


###  scanf 함수 사용시 주의할 점


`scanf` 함수는 문자열 입력시 입력받을 문자열의 최대 개수를 제한을 두지 않으므로버퍼 오버플로우가 발생할 여지가 충분히 있다. 이를 해결하기 위해서는 역시 [fgets](http://itguru.tistory.com/38)함수를 이용하거나 폭을 지정해 주면 된다.예를 들어서

```cpp-formatted
char str[10];
scanf("%9s", str);
```

와 같이 한다면 우리가 `stdin` 에 아무리 많이 입력해도 `scanf` 는 오직 9 문자만을 취하므로 안전하게 입력이 가능하다. (배열의 크기는 10 이지만 `NULL` 문자를 위해서 9 자만 입력해야 한다) 하지만 이와 같이 할 경우에도 문제가 있는데, 사용자가 9 문자 보다 많이 입력했을 경우 `scanf` 는 오직 9 문자만을 처리하므로 일부 문자가 버퍼에 남아 있어서 다음번 입력 시 차질이 생긴다. 이는 다음과 같이 해결 할 수 있다.

```cpp-formatted
scanf("%9s%*s", str);
```

왜냐하면 처음 `%9s` 를 통해서 9 문자만 입력 받고 `stdin` 에 남아있는 나머지 문자열들은 `%*s` 가 날려버리기 때문이다.



###  실행 예제


```cpp-formatted
/* 각 형식에 맞는 입력을 받은 뒤 이를 출력한다.*/
#include <stdio.h>
int main() {
  char str[10];
  char ch;
  int dec, hex, oct;
  float db;
  printf("문자열, 문자, 십진수, 16 진수, 8 진수, 소수를 각각 입력하세요\n");
  scanf("%9s %*s %c %d %x %o %f", str, &ch, &dec, &hex, &oct, &db);
  printf("문자열 : %s \n", str);
  printf("문자 : %c \n", ch);
  printf("십진수 : %d \n", dec);
  printf("16 진수 : %x \n", hex);
  printf("8 진수 : %o \n", oct);
  printf("소수 : %f \n", db);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1653C4014B6857C23335C6)

```cpp-formatted
/*

다음 예제는

  http://www.cplusplus.com/reference/clibrary/cstdio/scanf/

에서 가져왔습니다.

*/
#include <stdio.h>
int main() {
  char str[80];
  int i;
  printf("Enter your family name: ");
  scanf("%s", str);
  printf("Enter your age: ");
  scanf("%d", &i);
  printf("Mr. %s , %d years old.\n", str, i);
  printf("Enter a hexadecimal number: ");
  scanf("%x", &i);
  printf("You have entered %#x (%d).\n", i, i);
  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1612E6054B685860348FB9)



###  연관된 함수들

* `fscanf`  :  스트림에서 특정한 형식으로 데이터를 읽어온다.
* [printf](http://itguru.tistory.com/35)  :  `stdout` 에 특정한 형식으로 데이터를 출력한다.

* [gets](http://itguru.tistory.com/45)    :  `stdin` 에서 문자열을 가져온다.
* `fopen`  :  파일을 연다
Link :  41
2010-02-02 21:02
----------------
title : C 언어 레퍼런스 - getc 함수
cat_title :  getc
publish_date : 2010-02-02 21:02
--------------


#@ getc



```info


﻿#include <stdio.h> // C++ 의 경우 <cstdio>﻿﻿﻿int getc ( FILE * stream );
```

스트림에서 한 문자를 읽어온다.

문자를 읽어온 스트림의 내부 파일 위치 표시자가 현재 가리키는 문자를 리턴한다. 그리고 내부 파일 표시자는 그 다음 문자를 가리키게 된다.

`getc` 는 [fgetc](http://itguru.tistory.com/37)와 동일하며 역시 스트림을 인자로 취하고 있지만 매크로의 형태로 만들어져 있기 때문에 인자는 만일을 위해 식이 아닌 형태여야 한다.
`getchar` 함수는 `getc` 와 비슷하지만 스트림을 인자로 받지 않는다.



###  인자




`stream`

문자를 읽어올 스트림의 `FILE` 객체를 가리키는 포인터



###  리턴값




읽어들인 문자는 `int` 값으로 리턴된다.
만일 파일 끝에 도달하거나, 읽기 오류가 발생한다면 함수는 `EOF` 를 리턴하고 이에 대응하는 오류 혹은 `EOF` 표시자가 설정된다. 여러분은 [ferror](http://itguru.tistory.com/52)이나 [feof](http://itguru.tistory.com/51)함수를 통해 각각 어떤 오류가 발생했는지, 파일 끝에 도달하였는지 알 수 있다.



###  실행 예제


```cpp-formatted
/*

한 문자를 입력받은 후 이를 출력한다.

*/
#include <stdio.h>
int main() {
  int c;

  c = getc(stdin);

  printf("입력한 문자 : %c", c);

  return 0;
}
```

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F1703A41F4B6817C08DA705)



위와 같이 입력한 문자가 출력되었음을 볼 수 있다. `getc` 함수는 `scanf` 와는 달리 공백 문자도 입력 받을 수 있다.

```cpp-formatted
/*

myfile.txt 에 들어있는 $ 문자의 개수를 셉니다.
이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/getc/
에서 가져왔습니다.

 */
#include <stdio.h>
int main() {
  FILE* pFile;
  int c;
  int n = 0;
  pFile = fopen("myfile.txt", "r");
  if (pFile == NULL)
    perror("Error opening file");
  else {
    do {
      c = getc(pFile);
      if (c == '$') n++;
    } while (c != EOF);
    fclose(pFile);
    printf("File contains %d$.\n", n);
  }
  return 0;
}
```

현재 파일의 모습

![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F127BE4224B68175B48FF15)

실행 결과


![](http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F11249C204B68174A101E4C)




###  연관된 함수





*  [fgetc](http://itguru.tistory.com/37)  : 스트림에서 한 문자를 가져온다.



*  [fputc](http://itguru.tistory.com/39)  : 스트림에 한 문자를 쓴다.



*  [fread](http://itguru.tistory.com/68)  : 스트림에서 데이터 블록을 읽어온다.



*  [fwrite](http://itguru.tistory.com/69): 스트림에 데이터 블록을 쓴다.
