<p>itguru Top itguru Top</p><p>이번 강좌에서는</p><ul><li><p> is - a 와 has - a 관계</p></li><li><p> 오버라이딩(overriding)</p></li><li><p> virtual 키워드와 가상함수(virtual function)</p></li><li><p> 다형성(polymorphism)에 대해서 배웁니다.</p></li></ul><p>안녕하세요 여러분! 지난번 강좌는 재미있으셨나요. C++ 이란 산을 넘기 위해 아직도 지나가야 할 관문이 앞에 수 없이 많지만, 그래도 이번 강좌를 통해서 그 관문 하나는 지나갈 수 있으리라 생각합니다. 이번 강좌에서는 객체지향프로그래밍의 핵심 개념 하나에 대해서 배울 것입니다. 기대하세요 :)</p><p> is - a 와 has - a</p><p>일단 이야기를 진행하기 전에, 어떠한 경우에서 상속을 사용하는지 생각해봅시다. C++ 에서 상속을 도입한 이유는 단순히 똑같은 코드를 또 쓰는 것을 막기 위한 Ctrl + C, Ctrl + V 방지용으로 위한 것이 아닙니다 (물론 그러한 이유도 약간 있겠지만). 실제 이유는 상속이라는 기능을 통해서 객체지향프로그래밍에서 추구하는실제 객체의 추상화를 좀 더 효과적으로 할 수 있게 되었습니다.</p><p>이게 무슨 말이냐면 상속이란 것이 없던 C 언어에서는 어떠한 구조체 사이의 관계를 표현할 수 있는 방법이 없었습니다. 하지만 C++ 에서 상속이란 것을 도입함으로써, 클래스 사이에 관계를 표현할 수 있게 되었는데, 예를 들어서 Manager 가 Employee 를 상속한다;</p><p>class Manager : public Employee</p><p>의 의미는,</p><p>→Manager 클래스는 Employee 의 모든 기능을 포함한다→ Manager 클래스는 Employee 의 기능을 모두 수행할 수 있기 때문에 (Manager 에게는 약간 기분 나쁘겠지만) Manager 를 Employee 라고 칭해도 무방하다→ 즉, 모든 Manager 는 Employee 이다→"Manageris a Employee !!"</p><p>따라서, 모든 상속 관계는 'is a' 관계라고 볼 수 있습니다. 당연한 점은, 이를 뒤바꾸면 성립되지 않는 다는 점입니다. 즉 Manager 는 Employee 이지만 Employee 는 Manager 가 아닙니다. 이렇기에, Manager 를 Employee 로 부를 수 있지만, Employee 는 Manager 로 (미안하게도) 부를 수 없습니다.</p><p>프로그램 설계 시에 클래스들 간의 상속 관계를 도표로 나타내는 경우가 종종 있는데, 많은 경우 파생 클래스가 부모 클래스를 화살표로 가리키게 그립니다.</p><p>실제 세상에서 is a 관계로 이루어진 것들은 수 없이 많습니다. 예를 들어, '사람' 이라는 클래스가 있다면, '프로그래머는 사람이다 (A programmer is a human)' 이므로, 만일 우리가 프로그래머 클래스를 만든다면 사람 이라는 클래스를 상속 받을 수 있도록 구성할 수 있습니다.</p><p>위는 또 다른 is - a 관계의 예로, BankAccount (은행 계좌) 라는 클래스가 있고 Checking Account (자유롭게 입출금이 가능한 계좌지만 이자가 없다) 와 Savings Account ( (비교적)자유롭게 입출금이 불가능하지만, 매 달 이자가 붙음) 가 이를 상속 받고 있습니다. 즉, 같은 계좌지만 기능이 약간 씩 다른 두 계좌 클래스들이 좀 더 '일반적인' BankAccount 클래스를 상속 받았지요.</p><p>이를 통해서 상속의 또 하나의 중요한 특징을 알 수 있습니다. 바로 클래스가 파생되면 파생될 수 록 좀 더 특수화 (구체화;specialize) 된다는 의미 입니다.즉, Employee 클래스가 일반적인 사원을 위한 클래스 였다면 Manager 클래스 들은 그 일반적인 사원들 중에서도 좀 더 특수한 부류의 사원들을 의미하게 됩니다. 또, BankAccount 도 일반적인 은행 계좌를 위한 클래스 였다면, 이를 상속 받는 CheckingAccount, SavingsAccount 들은 좀 더 구체적인 클래스가 되지요. 반대로, 부모 클래스로 거슬러 올라가면 올라갈 수 록 좀 더 일반화 (generalize) 된다고 말합니다.</p><p>그렇다면 모든 클래스들의 관계를 is - a 로만 표현할 수 있을까요? 당연히 그렇지 않습니다. 어떤 클래스들 사이에서는 is - a 대신에 has - a 관계가 성립하기도 합니다. 예를 들어서, 간단히 자동차 클래스를 생각해봅시다. 자동차 클래스를 구성하기 위해서는 엔진 클래스, 브레이크 클래스, 오디오 클래스 등 수 많은 클래스들이 필요합니다. 그렇다고 이들 사이에 is a 관계를 도입 할 수 없습니다. (자동차 is a 엔진? 자동차 is a 브레이크?) 그 대신, 이들 사이는 has - a 관계로 쉽게 표현할 수 있습니다.</p><p>즉, 자동차는 엔진을 가진다 (자동차 has a 엔진), 자동차는 브레이크를 가진다 (자동차 has a 브레이크) 이와 같이 말이지요. 이런 has - a 관계는 우리가 흔히 해왔듯이 다음과 같이 클래스로 나타내면 됩니다.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Car</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="n">Engine</span> <span class="n">e</span><span class="p">;</span>
<span class="n">Brake</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 아마 break 아니냐고 생각하는 사람들이 있을 텐데 :)
</span><span class="c1"></span><span class="p">.</span><span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>또 다른 예로 바로 우리의 EmployeeList 를 들을 수 도 있습니다. EmployeeList 는 Employee 들과 has - a 관계 이지요. 따라서, 실제로 EmployeeList 클래스를 보면</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">EmployeeList</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">alloc_employee</span><span class="p">;</span> <span class="c1">// 할당한 총 직원 수
</span><span class="c1"></span><span class="kt">int</span> <span class="n">current_employee</span><span class="p">;</span> <span class="c1">// 현재 직원 수
</span><span class="c1"></span><span class="n">Employee</span> <span class="o">*</span><span class="o">*</span><span class="n">employee_list</span><span class="p">;</span> <span class="c1">// 직원 데이터
</span><span class="c1"></span></pre><p>와 같이 Employee 를 포함하고 있음을 알 수 있습니다.</p><p> (다시 보는) 오버라이딩</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span><span class="err"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Parent</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">부모</span><span class="s">&#34;</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">부모 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>


<span class="k">public</span><span class="o">:</span>
<span class="n">Child</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">자식</span><span class="s">&#34;</span><span class="p">)</span><span class="p">,</span> <span class="n">Parent</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">자식 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>


<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> === 부모 클래스 생성 ===</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">Parent</span> <span class="n">p</span><span class="p">;</span>


<span class="n">p</span><span class="p">.</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> === 자식 클래스 생성 ===</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">Child</span> <span class="n">c</span><span class="p">;</span>


<span class="n">c</span><span class="p">.</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>이미 저번 강좌에서도 이야기 했었지만, Parent 에서 what 을 호출하면 당연히 Parent 의 what 이 실행되어서 '부모' 라고 나오고, Parent 를 상속받는 Child 클래스에서 what 을 호출하면, Child 의 what 이 Parent 의 what 을 오버라이드 해서 Child 의 what 이 호출되게 됩니다.</p><p>이번에는 코드를 약간 변형해보도록 하겠습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span><span class="err"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Parent</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">부모</span><span class="s">&#34;</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">부모 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>


<span class="k">public</span><span class="o">:</span>
<span class="n">Child</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">자식</span><span class="s">&#34;</span><span class="p">)</span><span class="p">,</span> <span class="n">Parent</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">자식 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>


<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Parent</span> <span class="n">p</span><span class="p">;</span>
<span class="n">Child</span> <span class="n">c</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">=== 포인터 버전 ===</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">Parent</span><span class="o">*</span> <span class="n">p_c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">p_c</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>이번에는 Child 의 객체 c 를 Parent 객체를 가리키는 포인터에 넣었습니다.</p><pre class="chroma">
<span class="n">Parent</span><span class="o">*</span> <span class="n">p_c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
</pre><p>어떤 분들은 이와 같은 대입이 가능하냐고 물을 수 있습니다. Parent 와 Child 는 다른 클래스 이니까요. 하지만, 그 분들이 간과하고 있는 점은 Child 가 Parent 를 상속 받고 있다는 점입니다. 상속 받는다면 뭐죠? ==> Child is a Parent</p><p>즉 (말이 조금 이상하지만) Child 객체 c 도 어떻게 보면 Parent 객체이기 때문에 Parent 객체를 가리키는 포인터가 c 를 가리켜도 무방하다는 것입니다. 이를 그림으로 표현한다면 아래와 같습니다.</p><p>그 대신 p 는 엄연한 Parent 객체를 가리키는 포인터 입니다. 따라서, p 의 what 을 실행한다면 p 는 당연히 '아 Parent 의 what 을 실행해 주어야 겠구나' 하고, Parent 의 what 을 실행해서, Parent 의 what 은 Parent 의 s 를 출력 하게 됩니다. 따라서 위 처럼 '부모' 가 출력됩니다.</p><p>이러한 형태의 캐스팅을 (즉 파생 클래스에서 부모 클래스로 캐스팅 하는 것) 을 업 캐스팅 이라고 부릅니다.</p><p>위 그림을 보면 왜 업 캐스팅이라 부르는지 이해가 확 되지요.</p><p>그렇다면 업 캐스팅의 반대인 다운 캐스팅도 있을까요?</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span><span class="err"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Parent</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">부모</span><span class="s">&#34;</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">부모 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>


<span class="k">public</span><span class="o">:</span>
<span class="n">Child</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">자식</span><span class="s">&#34;</span><span class="p">)</span><span class="p">,</span> <span class="n">Parent</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">자식 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>


<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Parent</span> <span class="n">p</span><span class="p">;</span>
<span class="n">Child</span> <span class="n">c</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">=== 포인터 버전 ===</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">Child</span><span class="o">*</span> <span class="n">p_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>
<span class="n">p_p</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>컴파일 한다면 다음과 같은 오류 메세지를 볼 수 있습니다.</p><pre class="chroma">
error C2440: &#39;initializing&#39; : cannot convert from &#39;Parent *&#39; to &#39;Child *&#39;
Parent * 에서 Child * 로 변환할 수 없습니다.
</pre><p>사실 위와 같은 오류가 발생한 이유는 간단합니다.</p><p>만일 Child<span class='font-italic'> 포인터가 Parent 객체를 가리킨다고 해봅시다. 그렇다면 p</span>p->what() 하게 된다면 Child 의 what 함수가 호출되어야만 하는데, 이는 불가능 합니다. (왜냐하면 p<span class='font-italic'>p 가 가리키는 객체는 Parent 객체 이므로 Child 에 대한 정보가 없습니다). 따라서, 이와 같은 문제를 막기 위해서 컴파일러 상에서 함부로 다운 캐스팅 하는 것을 금지하고 있습니다.</p><p>하지만 다음과 같은 상황은 어떨까요.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span><span class="err"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Parent</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">부모</span><span class="s">&#34;</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">부모 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>


<span class="k">public</span><span class="o">:</span>
<span class="n">Child</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">자식</span><span class="s">&#34;</span><span class="p">)</span><span class="p">,</span> <span class="n">Parent</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">자식 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>


<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Parent</span> <span class="n">p</span><span class="p">;</span>
<span class="n">Child</span> <span class="n">c</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">=== 포인터 버전 ===</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">Parent</span><span class="o">*</span> <span class="n">p_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>


<span class="n">Child</span><span class="o">*</span> <span class="n">p_c</span> <span class="o">=</span> <span class="n">p_p</span><span class="p">;</span>
<span class="n">p_c</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>컴파일 하였다면</p><pre class="chroma">
error C2440: &#39;initializing&#39; : cannot convert from &#39;Parent *&#39; to &#39;Child *&#39;
</pre><p>Child<span class='font-italic'> p</span>c 에 Parent <span class='font-italic'> 를 대입하면 안된다는 똑같은 오류가 발생합니다. 하지만 우리는 p</span>p 가 가리키는 것이 Parent 객체가 아니라 Child 객체라는 사실을 알고 있습니다. 그렇기 때문에 비록 Parent <span class='font-italic'> 포인터를 다운 캐스팅 함에도 불구하고 p</span>p 가 실제로는 Child 객체를 가리키기 때문에</p><pre class="chroma">
<span class="n">Child</span><span class="o">*</span> <span class="n">p_c</span> <span class="o">=</span> <span class="n">p_p</span><span class="p">;</span>
</pre><p>를 해도 전혀 문제가 없습니다. 이를 위해서는 아래 처럼 강제적으로 타입 변환을 하면 됩니다.</p><pre class="chroma">
<span class="n">Child</span><span class="o">*</span> <span class="n">p_c</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Child</span> <span class="o">*</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_p</span><span class="p">)</span><span class="p">;</span>
</pre><p>비록 약간은 위험하지만 (만일 p<span class='font-italic'>p 가 사실은 Child 객체를 가리키지 않는다면?) 컴파일 오류를 발생시키지 않고 성공적으로 컴파일 할 수 있습니다. 그렇다면 만일 p</span>p 가 사실 Parent 객체를 가리키는데 강제적으로 타입 변환을 해서 what 을 실행한다면 어떨까요?</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span><span class="err"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Parent</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">부모</span><span class="s">&#34;</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">부모 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>


<span class="k">public</span><span class="o">:</span>
<span class="n">Child</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">자식</span><span class="s">&#34;</span><span class="p">)</span><span class="p">,</span> <span class="n">Parent</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">자식 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>


<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Parent</span> <span class="n">p</span><span class="p">;</span>
<span class="n">Child</span> <span class="n">c</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">=== 포인터 버전 ===</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">Parent</span><span class="o">*</span> <span class="n">p_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>


<span class="n">Child</span><span class="o">*</span> <span class="n">p_c</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Child</span> <span class="o">*</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p_p</span><span class="p">)</span><span class="p">;</span>
<span class="n">p_c</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같은 런타임 오류가 발생하게 됩니다.</p><p>이러한 강제적으로 다운 캐스팅을 하는 경우, 컴파일 타임에서 오류를 찾아내기 매우 힘들기 때문에 다운 캐스팅은 작동이 보장되지 않는 한매우매우 추천하지 않는 바 입니다.</p><p> EmployeeList 다시 보기</p><p>자, 그럼 이제 위에서 다룬 내용을 가지고 EmployeeList 를 어떻게 하면 좀 더 간단하게 만들 수 있을 지 생각해봅시다.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">EmployeeList</span>

<span class="p">{</span>
<span class="kt">int</span> <span class="n">alloc_employee</span><span class="p">;</span> <span class="c1">// 할당한 총 직원 수
</span><span class="c1"></span>

<span class="kt">int</span> <span class="n">current_employee</span><span class="p">;</span> <span class="c1">// 현재 직원 수
</span><span class="c1"></span><span class="kt">int</span> <span class="n">current_manager</span><span class="p">;</span> <span class="c1">// 현재 매니저 수
</span><span class="c1"></span>

<span class="n">Employee</span> <span class="o">*</span><span class="o">*</span><span class="n">employee_list</span><span class="p">;</span> <span class="c1">// 직원 데이터
</span><span class="c1"></span><span class="n">Manager</span> <span class="o">*</span><span class="o">*</span><span class="n">manager_list</span><span class="p">;</span> <span class="c1">// 매니저 데이터
</span><span class="c1"></span></pre><p>...위와 같은 구성에서 가장 문제가 되는 것이 각 클래스 별로 데이터를 따로 보관해야 된다는 것입니다. 즉 Employee 들은 Employee <span class='font-italic'> 가 가리켜야 하고, Manager 들은 Manager </span> 가 가리켜야 합니다. 만일 무한 상사에서 클래스 하나를 더 추가해달라고 연락이 왔다간 때릴 지도 모르겠지요.하지만, 한 가지 위에서 배운 사실은, 업 캐스팅은 매우 자유롭게 수행될 수 있다는 점입니다. 즉, Employee <span class='font-italic'> 가 Manager 객체를 가리켜도 별 문제가 없다는 것이지요. 그렇다면 manager</span>list 를 그냥 지워 버리고, employee<span class='font-italic'>list 가 Employee, Manager 상관없이 가리키게 해도 될까요? 그러면 참 좋겠지만 다음과 같은 문제점이 있습니다.</p><pre class="chroma"><span class="kt">void</span> <span class="nf">print_employee_info</span><span class="p">(</span><span class="p">)</span><span class="p">{</span><span class="kt">int</span> <span class="n">total_pay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_employee</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span><span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">print_info</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="n">total_pay</span> <span class="o">+</span><span class="o">=</span> <span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">calculate_pay</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="p">}</span><span class="p">.</span><span class="p">.</span><span class="p">.</span>
<span class="err">바</span><span class="err">로</span> <span class="err">여</span><span class="err">기</span><span class="err">서</span><span class="p">,</span> <span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">print_info</span><span class="p">(</span><span class="p">)</span> <span class="err">를</span> <span class="err">하</span><span class="err">게</span> <span class="err">되</span><span class="err">면</span> <span class="err">무</span><span class="err">조</span><span class="err">건</span> <span class="n">Employee</span> <span class="err">클</span><span class="err">래</span><span class="err">스</span><span class="err">의</span> <span class="n">print_info</span> <span class="err">함</span><span class="err">수</span><span class="err">가</span> <span class="err">호</span><span class="err">출</span><span class="err">된</span><span class="err">다</span><span class="err">는</span> <span class="err">것</span><span class="err">입</span><span class="err">니</span><span class="err">다</span><span class="p">.</span> <span class="err">왜</span><span class="err">냐</span><span class="err">하</span><span class="err">면</span> <span class="err">위</span><span class="err">에</span><span class="err">서</span><span class="err">도</span> <span class="err">이</span><span class="err">야</span><span class="err">기</span> <span class="err">하</span><span class="err">였</span><span class="err">듯</span><span class="err">이</span><span class="p">,</span> <span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="err">는</span> <span class="n">Employee</span> <span class="err">객</span><span class="err">체</span><span class="err">를</span> <span class="err">가</span><span class="err">리</span><span class="err">키</span><span class="err">는</span> <span class="err">포</span><span class="err">인</span><span class="err">터</span> <span class="err">이</span><span class="err">기</span> <span class="err">때</span><span class="err">문</span><span class="err">에</span> <span class="err">자</span><span class="err">신</span><span class="err">이</span> <span class="err">가</span><span class="err">리</span><span class="err">키</span><span class="err">는</span> <span class="err">객</span><span class="err">체</span><span class="err">가</span> <span class="n">Employee</span> <span class="err">객</span><span class="err">체</span><span class="err">라</span><span class="err">고</span> <span class="err">생</span><span class="err">각</span><span class="err">합</span><span class="err">니</span><span class="err">다</span><span class="p">.</span>
<span class="err">하</span><span class="err">지</span><span class="err">만</span> <span class="err">우</span><span class="err">리</span><span class="err">는</span> <span class="n">Manager</span> <span class="err">객</span><span class="err">체</span><span class="err">와</span> <span class="n">Employee</span> <span class="err">객</span><span class="err">체</span> <span class="err">모</span><span class="err">두</span> <span class="n">Employee</span><span class="o">*</span> <span class="err">가</span> <span class="err">가</span><span class="err">리</span><span class="err">키</span><span class="err">도</span><span class="err">록</span> <span class="err">하</span><span class="err">였</span><span class="err">으</span><span class="err">므</span><span class="err">로</span><span class="p">,</span> <span class="err">만</span><span class="err">일</span> <span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="err">가</span> <span class="err">가</span><span class="err">리</span><span class="err">키</span><span class="err">는</span> <span class="err">것</span><span class="err">이</span> <span class="n">Manager</span> <span class="err">객</span><span class="err">체</span> <span class="err">일</span> <span class="err">때</span><span class="p">,</span> <span class="n">Manager</span> <span class="err">의</span> <span class="n">print_info</span> <span class="err">함</span><span class="err">수</span><span class="err">가</span> <span class="err">아</span><span class="err">니</span><span class="err">라</span> <span class="n">Employee</span> <span class="err">의</span> <span class="n">print_info</span> <span class="err">함</span><span class="err">수</span><span class="err">가</span> <span class="err">호</span><span class="err">출</span><span class="err">되</span><span class="err">서</span> <span class="err">다</span><span class="err">른</span> <span class="err">결</span><span class="err">과</span><span class="err">를</span> <span class="err">냅</span><span class="err">니</span><span class="err">다</span><span class="p">.</span> <span class="err">마</span><span class="err">찬</span><span class="err">가</span><span class="err">지</span><span class="err">로</span> <span class="n">calculate_pay</span> <span class="err">함</span><span class="err">수</span><span class="err">도</span> <span class="n">Manager</span> <span class="err">의</span> <span class="n">calculate_pay</span> <span class="err">가</span> <span class="err">호</span><span class="err">출</span> <span class="err">되</span><span class="err">어</span><span class="err">야</span> <span class="err">하</span><span class="err">는</span><span class="err">데</span> <span class="n">Employee</span> <span class="err">의</span> <span class="n">calculate_pay</span> <span class="err">가</span> <span class="err">호</span><span class="err">출</span><span class="err">되</span><span class="err">어</span><span class="err">서</span> <span class="p">(</span><span class="err">월</span><span class="err">급</span><span class="err">이</span> <span class="err">더</span> <span class="err">적</span><span class="err">게</span><span class="err">나</span><span class="err">오</span><span class="err">는</span> <span class="err">ㅠ</span><span class="err">ㅠ</span><span class="p">)</span> <span class="err">틀</span><span class="err">린</span> <span class="err">결</span><span class="err">과</span><span class="err">가</span> <span class="err">나</span><span class="err">옵</span><span class="err">니</span><span class="err">다</span><span class="p">.</span> <span class="err">나</span><span class="err">쁜</span> <span class="err">회</span><span class="err">사</span><span class="err">였</span><span class="err">으</span><span class="err">면</span> <span class="err">환</span><span class="err">영</span><span class="err">할</span> <span class="err">일</span><span class="err">이</span><span class="err">였</span><span class="err">겠</span><span class="err">지</span><span class="err">만</span> <span class="err">착</span><span class="err">한</span> <span class="err">우</span><span class="err">리</span><span class="err">의</span> <span class="err">입</span><span class="err">장</span><span class="err">에</span><span class="err">선</span> <span class="err">이</span> <span class="err">문</span><span class="err">제</span><span class="err">를</span> <span class="err">꼭</span> <span class="err">해</span><span class="err">결</span><span class="err">해</span><span class="err">야</span> <span class="err">합</span><span class="err">니</span><span class="err">다</span><span class="p">.</span>
<span class="err">실</span><span class="err">제</span><span class="err">로</span><span class="p">,</span>
</pre><p>cpp</p><p>#include <iostream>#include <string>using namespace std;class Employee{protected:string name;int age;string position; // 직책 (이름)int rank; // 순위 (값이 클 수록 높은 순위)public:Employee(string name, int age, string position, int rank): name(name), age(age), position(position), rank(rank) {}// 복사 생성자Employee(const Employee& employee){name = employee.name;age = employee.age;position = employee.position;rank = employee.rank;}// 디폴트 생성자Employee () {}void print<span class='font-italic'>info(){cout << name << " (" << position << " , " << age << ") ==> " << calculate</span>pay() << "만원" << endl;}int calculate<span class='font-italic'>pay(){return 200 + rank </span> 50;}};class Manager : public Employee{int year<span class='font-italic'>of</span>service;public:Manager(string name, int age, string position, int rank, int year<span class='font-italic'>of</span>service): year<span class='font-italic'>of</span>service(year<span class='font-italic'>of</span>service), Employee(name, age, position, rank) {}// 복사 생성자Manager(const Manager& manager): Employee(manager.name, manager.age, manager.position, manager.rank){year<span class='font-italic'>of</span>service = manager.year<span class='font-italic'>of</span>service;}// 디폴트 생성자Manager () : Employee() {}int calculate<span class='font-italic'>pay(){return 200 + rank </span> 50 + 5 <span class='font-italic'> year</span>of<span class='font-italic'>service;}void print</span>info(){cout << name << " (" << position << " , " << age << ", "<< year<span class='font-italic'>of</span>service << "년차) ==> " << calculate<span class='font-italic'>pay() << "만원" << endl;}};class EmployeeList{int alloc</span>employee; // 할당한 총 직원 수int current<span class='font-italic'>employee; // 현재 직원 수Employee <span class='font-weight-bold'>employee</span>list; // 직원 데이터public:EmployeeList(int alloc<span class='font-italic'>employee) : alloc</span>employee(alloc<span class='font-italic'>employee){employee</span>list = new Employee<span class='font-italic'> [alloc</span>employee];current<span class='font-italic'>employee = 0;}void add</span>employee(Employee<span class='font-italic'> employee){// 사실 current</span>employee 보다 alloc<span class='font-italic'>employee 가 더// 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는// 최대한 단순하게 생각해서 alloc</span>employee 는// 언제나 current<span class='font-italic'>employee 보다 크다고 생각한다.// (즉 할당된 크기는 현재 총 직원수 보다 많음)employee</span>list[current<span class='font-italic'>employee] = employee;current</span>employee ++;}int current<span class='font-italic'>employee</span>num(){return current<span class='font-italic'>employee;}void print</span>employee<span class='font-italic'>info(){int total</span>pay = 0;for(int i = 0; i < current<span class='font-italic'>employee; i ++) {employee</span>list[i]->print<span class='font-italic'>info();total</span>pay += employee<span class='font-italic'>list[i]->calculate</span>pay();}cout << "총 비용 : " << total<span class='font-italic'>pay << "만원 " << endl;}~EmployeeList(){for(int i = 0; i < current</span>employee; i ++) {delete employee<span class='font-italic'>list[i];}delete [] employee</span>list;}};int main(){EmployeeList emp<span class='font-italic'>list(10);emp</span>list.add<span class='font-italic'>employee(new Employee("노홍철", 34, "평사원", 1));emp</span>list.add<span class='font-italic'>employee(new Employee("하하", 34, "평사원", 1));emp</span>list.add<span class='font-italic'>employee(new Manager("유재석", 41, "부장", 7, 12));emp</span>list.add<span class='font-italic'>employee(new Manager("정준하", 43, "과장", 4, 15));emp</span>list.add<span class='font-italic'>employee(new Manager("박명수", 43, "차장", 5, 13));emp</span>list.add<span class='font-italic'>employee(new Employee("정형돈", 36, "대리", 2));emp</span>list.add<span class='font-italic'>employee(new Employee("길", 36, "인턴", -2));emp</span>list.print<span class='font-italic'>employee</span>info();return 0;}성공적으로 컴파일 하였다면</p><p>와 같이 전부다 Employee 의 print<span class='font-italic'>info 와 calculate</span>pay 함수가 호출되서 원래 결과와 달라집니다.</p><p>그런데 놀랍게도 이러한 문제를 5초 만에 해결할 수 있는 방법이 있습니다.</p><p> virtual 키워드</p><p>EmployeeList 문제를 해결하기 전에 좀 더 간단한 예시로 살펴보겠습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span><span class="err"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Parent</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">부모</span><span class="s">&#34;</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">부모 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">virtual</span> <span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Child</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>


<span class="k">public</span><span class="o">:</span>
<span class="n">Child</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">자식</span><span class="s">&#34;</span><span class="p">)</span><span class="p">,</span> <span class="n">Parent</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">자식 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>


<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">Parent</span> <span class="n">p</span><span class="p">;</span>
<span class="n">Child</span> <span class="n">c</span><span class="p">;</span>


<span class="n">Parent</span><span class="o">*</span> <span class="n">p_c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">Parent</span><span class="o">*</span> <span class="n">p_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> == 실제 객체는 Parent == </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">p_p</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> == 실제 객체는 Child == </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">p_c</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>어라? 위 결과를 보셨다면 놀라움을 금치 못하셨을 것입니다.</p><pre class="chroma">
<span class="n">Parent</span><span class="o">*</span> <span class="n">p_c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="n">Parent</span><span class="o">*</span> <span class="n">p_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> == 실제 객체는 Parent == </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">p_p</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> == 실제 객체는 Child == </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">p_c</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>분명히 여기서 p<span class='font-italic'>p 와 p</span>c 모두 Parent 객체를 가리키는 포인터 입니다. 따라서, p<span class='font-italic'>p->what() 와 p</span>c->what() 을 하면 모두 Parent 객체의 what() 함수가 실행되서 둘 다 '부모' 라고 출력이 되어야만 했습니다. 그런데, 놀랍게도, 실제 p<span class='font-italic'>p 와 p</span>c 가 무엇과 결합해 있는지 아는 것 처럼 (p<span class='font-italic'>p 는 Parent 객체를 가리키고, p</span>c 는 Child 객체를 가리킴) 이에 따른 적절한 what 함수를 호출해준 것입니다.</p><p>이와 같은 일이 가능해진 이유는 바로;</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Parent</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Parent</span> <span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">부모</span><span class="s">&#34;</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">부모 클래스</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">virtualvoid</span> <span class="n">what</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>이 virtual 키워드 하나 때문입니다. 이 virtual 키워드는, 다음과 같은 역할을 합니다.</p><pre class="chroma">
<span class="n">p_c</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>위 코드를 실행시에 (런타임), 컴퓨터 입장에서;</p><pre class="chroma">
&#34;흠, p_c 는 Parent 포인터니까 Parent 의 what() 을 실행해야지&#34;
&#34;어 근데 what 이 virtual 이네?&#34;

&#34;잠깐. 이거 실제 Parent 객체 맞어? 아니네 Child 객체네&#34;
&#34;그럼 Child 의 what 을 실행해야지&#34;
</pre><p>반면에</p><pre class="chroma">
<span class="n">p_p</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>였을 경우에는</p><pre class="chroma">
&#34;흠, p_c 는 Parent 포인터니까 Parent 의 what() 을 실행해야지&#34;
&#34;어 근데 what 이 virtual 이네?&#34;

&#34;잠깐. 이거 실제 Parent 객체 맞어? 어 맞네.&#34;
&#34;Parent 의 what 을 실행하자&#34;
</pre><p>이렇게 컴파일 시에 어떤 함수가 실행될 지 정해지지 않고 런타임 시에 정해지는 일을 가리켜서동적 바인딩(dynamic binding)이라고 부릅니다. 즉,</p><pre class="chroma">
<span class="n">p_c</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>에서 Child 의 what 을 실행할지, Parent 의 what 을 실행하지 결정은 런타임에 이루어지게 됩니다. 물론 위 코드에선 컴파일 시에 무조건 p<span class='font-italic'>c->what() 이 Child 의 what 이 실행되도록 정해진 거 아니냐고 물을 수 있지만 다음과 같은 상황을 생각해보세요.</p><pre class="chroma">
  <span class="c1">// i 는 사용자로부터 입력받는 변수
</span><span class="c1"></span><span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">p_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
<span class="n">p_p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">p_p</span><span class="o">-</span><span class="o">&gt;</span><span class="n">what</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>이렇게 된다면 p<span class='font-italic'>p->what() 이 어떤 what 일지에는 런타임에 정해지겠지요? 물론 동적 바인딩의 반대말로 정적 바인딩(static binding) 이란 말도 있습니다. 이는 컴파일 타임에 어떤 함수가 호출될 지 정해지는 것으로 여태까지 여러분이 알고 오셨던 함수에 해당합니다. 덧붙여서, virtual 키워드가 붙은 함수를 '가상 함수(virtual function)'라고 부릅니다.</p><p>이제 여러분은 그동안 골머리를 썩여왔던 EmployeeList 문제도 해결할 수 있게 되었습니다. 단순히 Employee 클래스의 calculate<span class='font-italic'>pay 함수와 print</span>info 함수 앞에 virtual 만 붙여주면 깔끔하게 정리 되지요.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">class</span><span class="err"> </span><span class="nc">Employee</span>
<span class="p">{</span>


<span class="k">protected</span><span class="o">:</span>
<span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>


<span class="n">string</span> <span class="n">position</span><span class="p">;</span> <span class="c1">// 직책 (이름)
</span><span class="c1"></span><span class="kt">int</span> <span class="n">rank</span><span class="p">;</span> <span class="c1">// 순위 (값이 클 수록 높은 순위)
</span><span class="c1"></span>

<span class="k">public</span><span class="o">:</span>


<span class="n">Employee</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">,</span> <span class="n">string</span> <span class="n">position</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rank</span><span class="p">)</span>
<span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="p">,</span> <span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">)</span><span class="p">,</span> <span class="n">position</span><span class="p">(</span><span class="n">position</span><span class="p">)</span><span class="p">,</span> <span class="n">rank</span><span class="p">(</span><span class="n">rank</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>


<span class="c1">// 복사 생성자
</span><span class="c1"></span><span class="n">Employee</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">employee</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="n">age</span> <span class="o">=</span> <span class="n">employee</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
<span class="n">position</span> <span class="o">=</span> <span class="n">employee</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
<span class="n">rank</span> <span class="o">=</span> <span class="n">employee</span><span class="p">.</span><span class="n">rank</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 디폴트 생성자
</span><span class="c1"></span><span class="n">Employee</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>


<span class="n">virtualvoid</span> <span class="n">print_info</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">name</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> (</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">position</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> , </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">age</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">) ==&gt; </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">calculate_pay</span><span class="p">(</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">만원</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">virtualint</span> <span class="n">calculate_pay</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">return</span> <span class="mi">200</span> <span class="o">+</span> <span class="n">rank</span> <span class="o">*</span> <span class="mi">50</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>


<span class="k">class</span><span class="err"> </span><span class="nc">Manager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Employee</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">year_of_service</span><span class="p">;</span>


<span class="k">public</span><span class="o">:</span>
<span class="n">Manager</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">,</span> <span class="n">string</span> <span class="n">position</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rank</span><span class="p">,</span> <span class="kt">int</span> <span class="n">year_of_service</span><span class="p">)</span>
<span class="o">:</span> <span class="n">year_of_service</span><span class="p">(</span><span class="n">year_of_service</span><span class="p">)</span><span class="p">,</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>


<span class="kt">int</span> <span class="n">calculate_pay</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">return</span> <span class="mi">200</span> <span class="o">+</span> <span class="n">rank</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">year_of_service</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">print_info</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">name</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> (</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">position</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> , </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">age</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">, </span><span class="s">&#34;</span>
<span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">year_of_service</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">년차) ==&gt; </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">calculate_pay</span><span class="p">(</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">만원</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">EmployeeList</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">alloc_employee</span><span class="p">;</span> <span class="c1">// 할당한 총 직원 수
</span><span class="c1"></span><span class="kt">int</span> <span class="n">current_employee</span><span class="p">;</span> <span class="c1">// 현재 직원 수
</span><span class="c1"></span><span class="n">Employee</span> <span class="o">*</span><span class="o">*</span><span class="n">employee_list</span><span class="p">;</span> <span class="c1">// 직원 데이터
</span><span class="c1"></span>

<span class="k">public</span><span class="o">:</span>


<span class="n">EmployeeList</span><span class="p">(</span><span class="kt">int</span> <span class="n">alloc_employee</span><span class="p">)</span> <span class="o">:</span> <span class="n">alloc_employee</span><span class="p">(</span><span class="n">alloc_employee</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">employee_list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">*</span> <span class="p">[</span><span class="n">alloc_employee</span><span class="p">]</span><span class="p">;</span>
<span class="n">current_employee</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">add_employee</span><span class="p">(</span><span class="n">Employee</span><span class="o">*</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// 사실 current_employee 보다 alloc_employee 가 더
</span><span class="c1"></span><span class="c1">// 많아지는 경우 반드시 재할당을 해야 하지만, 여기서는
</span><span class="c1"></span><span class="c1">// 최대한 단순하게 생각해서 alloc_employee 는
</span><span class="c1"></span><span class="c1">// 언제나 current_employee 보다 크다고 생각한다.
</span><span class="c1"></span><span class="c1">// (즉 할당된 크기는 현재 총 직원수 보다 많음)
</span><span class="c1"></span><span class="n">employee_list</span><span class="p">[</span><span class="n">current_employee</span><span class="p">]</span> <span class="o">=</span> <span class="n">employee</span><span class="p">;</span>
<span class="n">current_employee</span> <span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">current_employee_num</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">return</span> <span class="n">current_employee</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">print_employee_info</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">total_pay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_employee</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
<span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">print_info</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="n">total_pay</span> <span class="o">+</span><span class="o">=</span> <span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">calculate_pay</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">총 비용 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">total_pay</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">만원 </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">~</span><span class="n">EmployeeList</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_employee</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
<span class="k">delete</span> <span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">delete</span> <span class="p">[</span><span class="p">]</span> <span class="n">employee_list</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">EmployeeList</span> <span class="n">emp_list</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="p">;</span>
<span class="n">emp_list</span><span class="p">.</span><span class="n">add_employee</span><span class="p">(</span><span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">노홍철</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">평사원</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">emp_list</span><span class="p">.</span><span class="n">add_employee</span><span class="p">(</span><span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">하하</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">평사원</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">emp_list</span><span class="p">.</span><span class="n">add_employee</span><span class="p">(</span><span class="k">new</span> <span class="n">Manager</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">유재석</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">부장</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">emp_list</span><span class="p">.</span><span class="n">add_employee</span><span class="p">(</span><span class="k">new</span> <span class="n">Manager</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">정준하</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">과장</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">emp_list</span><span class="p">.</span><span class="n">add_employee</span><span class="p">(</span><span class="k">new</span> <span class="n">Manager</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">박명수</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">차장</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">emp_list</span><span class="p">.</span><span class="n">add_employee</span><span class="p">(</span><span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">정형돈</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">대리</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">emp_list</span><span class="p">.</span><span class="n">add_employee</span><span class="p">(</span><span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">길</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">인턴</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">emp_list</span><span class="p">.</span><span class="n">print_employee_info</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 비록 Employee<span class='font-italic'> 가 가리키고 있음에도 불구하고 Manager 면 Manager 의 함수를, Employee 면 Employee 의 함수를 잘 호출하고 있음을 알 수 있습니다. 물론 바뀐 것은 단 두 단어. virtual 키워들을 Employee 의 함수들 앞에 추가해놓은 것 뿐이지요.</p><pre class="chroma">
<span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">print_info</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="n">total_pay</span> <span class="o">+</span><span class="o">=</span> <span class="n">employee_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">calculate_pay</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>이 두 부분은 employee<span class='font-italic'>list[i] 가 Employee 냐 Manager 에 따라서 다르게 동작하게 됩니다. 이렇게 같은 print</span>info 함수를 호출했음에도 불구하고 어떤 경우는 Employee 의 것이, 어떤 경우는 Manager 의 것이 호출되는 일; 즉 하나의 메소드를 호출했음에도 불구하고 여러가지 다른 작업들을 하는 것을바로다형성(polymorphism) 이라고 부릅니다.</p><p>참고로, 다형성을 뜻하는 영어 단어인polymorphism 은,여러개를 의미하는 그리스어 'poly' 와, 모습, 모양을 뜻하는 그리스어 'morphism' 에서 온 단어로 '여러가지 형태' 라는 의미 입니다.</p><p>자 그러면 이번 강좌는 여기에서 마치도록 하겠습니다. 아마도 virtual 키워드를 처음 접했더라면 머가 어떻게 되는지 많이 헷갈릴 수 있는데 꼭 여러번 테스트 프로그램을 만들어보아서 확실히 이해하고 넘어가도록 합시다 :)</p><p>생각해보기</p><ol><li><p> 그렇다면 프로그램 내부적으로 virtual 함수들은 어떻게 처리될까요? 즉, 이 포인터가 어떠한 객체를 가리키는지 어떻게 알 수 있을까요? (난이도 : 上)</p></li></ol><pre class="chroma">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면꼭 댓글을 남겨주시기 바랍니다. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요.

현재 여러분이 보신 강좌는&lt;&lt;씹어먹는 C++ - &lt;6 - 2.  가상(virtual) 함수와 다형성&gt;&gt;&gt; 입니다. 이번 강좌의모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전까지 다음 강좌로 넘어가지 말아주세요

다음 강좌 보러가기

</pre><p>공감sns신고저작자표시	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">		<Work rdf:about="">			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />		</Work>		<License rdf:about="http://creativecommons.org/licenses/by-fr/">			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>			<requires rdf:resource="http://web.resource.org/cc/Notice"/>			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>		</License>	</rdf:RDF>'C++' 카테고리의 다른 글씹어먹는 C++ - <7 - 1. C++ 에서의 입출력 (istream, ostream)>(35)2015.05.04씹어먹는 C++ - <6 - 3. 가상함수와 상속에 관련한 잡다한 내용들>(14)2014.04.13씹어먹는 C++ - <6 - 2.  가상(virtual) 함수와 다형성>(35)2014.03.31씹어먹는 C++ - <6 - 1. C++ 표준 문자열 & 부모의 것을 물려쓰자 - 상속>(10)2014.03.30씹어먹는 C++ - <5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열>(24)2013.09.04씹어먹는 C++ - <5 - 2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩>(5)2013.08.29</p><style>/* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%; }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }
</style>