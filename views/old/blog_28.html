<p>이번 강좌에서는</p><ul><li><p> 더블 포인터 인자</p></li><li><p> <code class='inline-code'>2</code> 차원 배열 인 2 차원 배열 인자</p></li><li><p> 상수 인자</p></li><li><p> 함수 포인터</p></li></ul><p>에 대해서 배웁니다.</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1335B00C4B3086EA02598B' alt=''><p>  와.. 드디어, 함수만 세번째 강의입니다. 아마 이전 강좌에서 배운 내용들 중 어려운 것은 없으리라 생각됩니다. 물론, 이번 강좌의 내용도 이전까지의 내용을 잘 숙지 하셨더라면 무난하게 넘어갈 수 있으리라 생각됩니다.</p><h3><p>  지난번 내용을 상기해보며</p></h3><p>  지난번 내용은 잘 기억하고 있는지요?다시 한 번 요약해 보자면,"어떠한 함수가 특정한 타입의 변수/배열의 값을 바꾸려면 함수의 인자는 반드시 타입을 가리키는 포인터 형을 이용해야 한다!" 였습니다.사실, 이 문장이 이해가 잘 되지 않았던 분들이 있으리라 생각됩니다. 하지만, 이번 강좌를 보고 난다면 이 문장의 의미를 정확하게 파악할 수 있을 것입니다.</p><pre class="chroma"><span class="cm">/* 눈 돌아가는 예제. 포인터가 가리키는 변수를 서로 바꾼다. */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pswap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="o">*</span><span class="n">pa</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="o">*</span><span class="n">pb</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">pa</span><span class="p">,</span> <span class="o">*</span><span class="n">pb</span><span class="p">;</span>

  <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
  <span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pa 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pa 의 주소값 : %x </span><span class="se">\n</span><span class="s"> </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pb 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pb</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pb 의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pb</span><span class="p">)</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s"> ------------- 호출 -------------- </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">pswap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pa</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pb</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s"> ------------- 호출끝 -------------- </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pa 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pa 의 주소값 : %x </span><span class="se">\n</span><span class="s"> </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pb 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pb</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pb 의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pb</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">pswap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="o">*</span><span class="n">ppa</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="o">*</span><span class="n">ppb</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppa</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">ppa 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ppa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">ppb 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ppb</span><span class="p">)</span><span class="p">;</span>

  <span class="o">*</span><span class="n">ppa</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppb</span><span class="p">;</span>
  <span class="o">*</span><span class="n">ppb</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  성공적으로 컴파일 하면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F114B5C164B2CAA6E6CA90F' alt=''><p>여러분의 출력결과는 위 사진과 다를 수 있습니다.  일단, 붉은색으로 박스 친 부분을 잘 살펴보기 바랍니다. <code class='inline-code'>pa</code> 가 가리키는 변수의 주소값은 (즉, <code class='inline-code'>pa</code> 의 값이지요) <code class='inline-code'>31FBCC</code> 였습니다. 물론, 여러분이 실행했을 때 에는 결과가 다르게 나올 것입니다. (거의 <code class='inline-code'>99%</code> 확률로 다르게 나옵니다) <code class='inline-code'>pb</code> 가 가리키는 변수의 주소값은 <code class='inline-code'>31FBC0</code> 이였습니다. 그런데 말이죠. <code class='inline-code'>pswap</code> 함수를 호출하고 나니, <code class='inline-code'>pa</code> 가 가리키는 변수의 주소값은 <code class='inline-code'>31FBC0</code> 이 되고, <code class='inline-code'>pb</code> 가 가리키는 변수의 주소값은 <code class='inline-code'>31FBCC</code> 가 되었습니다. 즉, 두 포인터가 가리키는 변수가 서로 뒤바뀐 것이지요.</p><p>  이 때, 우리는 이와 같은 함수를 만들기 위해서, 인자를 어떤 형식으로 취해야 될까요? 앞서 말했듯이, 특정한 타입의 변수의 값을 바꾸려면, 특정한 타입을 가리키는 포인터로 인자를 취해야 된다고 했습니다. 그런데, 이 예제의 경우, 특정한 타입은 <code class='inline-code'>int*</code> 타입입니다. 그렇다면 <code class='inline-code'>int*</code> 타입을 가리키는 포인터의 타입은? 음. 강좌를 잘 복습하였다면 <code class='inline-code'>int**</code> 타입 이라고 말할 수 있겠지요. (잘 모르겠다면 <a href='http://itguru.tistory.com/25'>12-3 강, 포인터는 영희이다!</a><span class='font-weight-bold'> 를 보세요)</p><p>  따라서, 우리는 위 이야기를 토대로 아래와 같이 함수를 정의하였습니다.</p><pre class="chroma"><span class="kt">int</span> <span class="n">pswap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="o">*</span><span class="n">ppa</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="o">*</span><span class="n">ppb</span><span class="p">)</span>
</pre><p>  상당히, 잘한 것이지요. 이제, 함수의 몸체를 봐봅시다.</p><pre class="chroma"><span class="kt">int</span> <span class="nf">pswap</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="o">*</span><span class="n">ppa</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="o">*</span><span class="n">ppb</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppa</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">ppa 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ppa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">ppb 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ppb</span><span class="p">)</span><span class="p">;</span>

  <span class="o">*</span><span class="n">ppa</span> <span class="o">=</span> <span class="o">*</span><span class="n">ppb</span><span class="p">;</span>
  <span class="o">*</span><span class="n">ppb</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  일단, <code class='inline-code'>int*</code> 형의 <code class='inline-code'>temp</code> 변수를 만들어서 <code class='inline-code'>*ppa</code> 의 값을 저장하고 있습니다. 그런데, <code class='inline-code'>*ppa</code> 의 값은 무엇일까요? 만일 우리가 위 예제 처럼 <code class='inline-code'>pswap</code> 함수를 호출하였다고 하면, <code class='inline-code'>ppa</code> 는 <code class='inline-code'>pa</code> 를 가리키고 있고, <code class='inline-code'>ppb</code> 는 <code class='inline-code'>pb</code> 를 가리키고 있겠지요. 따라서, <code class='inline-code'>*ppa</code> 라 하면 <code class='inline-code'>pa</code> 의 값을 이야기 합니다. 그런데, <code class='inline-code'>pa</code> 는 <code class='inline-code'>int*</code> 형이므로, <code class='inline-code'>pa</code> 의 값을 보관하는 변수는 반드시 <code class='inline-code'>int*</code> 이여야 되겠지요. 따라서, 우리는 <code class='inline-code'>int*</code> 형의 <code class='inline-code'>temp</code> 변수를 정의하였습니다. 그 아래의 내용은 이전에 만들어 보았던 <code class='inline-code'>swap</code> 함수와 동일합니다.</p><pre class="chroma"><span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">ppa 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ppa</span><span class="p">)</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">ppb 가 가리키는 변수의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ppb</span><span class="p">)</span><span class="p">;</span>
</pre><p>  그렇다면 우리는 위 두개의 <code class='inline-code'>printf</code> 문장에서 어떤 결과가 출력될 지 예측 가능합니다. 위 예제에서 <code class='inline-code'>ppa</code> 가 <code class='inline-code'>pa</code> 를 가리키고 있으므로 <code class='inline-code'>ppa</code> 의 값을 출력하면 <code class='inline-code'>pa</code> 의 주소값이 나오고, <code class='inline-code'>ppb</code> 도 마찬가지로 나오겠죠. 위 출력결과에서 실제로 같다는 것을 확인할 수 있습니다. 어때요. <code class='inline-code'>pswap</code> 함수가 이해가 되나요?</p><p>  위 과정을 그림으로 표현하면 아래와 같습니다.</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F146B111F4B2CB12B40F6C1' alt=''><p>  그렇다면, 이번에는 이차원 배열을 인자로 받는 함수에 대해서 생각해 보도록 합시다.</p><pre class="chroma"><span class="cm">/* 2 차원 배열의 각 원소를 1 씩 증가시키는 함수 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cm">/* 열의 개수가 2 개인 이차원 배열과, 총 행의 수를 인자로 받는다. */</span>
<span class="kt">int</span> <span class="nf">add1_element</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">scanf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">%d</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">add1_element</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">arr[%d][%d] : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">add1_element</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1739B8224B2CB4F71E3A75' alt=''><p>역시 잘 실행되는군요. 일단, 함수의 정의부분 부터 살펴봅시다.</p><pre class="chroma"><span class="kt">int</span> <span class="nf">add1_element</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  이 함수는 인자를 두 개 받고 있는데 하나는 열의 개수가 2 개인 이차원 배열을 가리키는 포인터 이고<code class='inline-code'>,</code> 하나는 함수의 행의 수를 받는 인자입니다.</p><pre class="chroma"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p> 우리는 <code class='inline-code'>row</code> 를 통해 이 이차원배열의 행의 개수를 알 수 있고, 열의 개수는 이미 알고 있으므로 (배열 포인터에서) 각 원소를 1 씩 증가시키는 작업을 시행할 수 있게됩니다. 위와 같이 말이죠. 우리는 포인터를 잘 배워서 헷깔릴 문제는 없지만 많은 사람들에게 다음과 같이 인자를 받는것이 어렵게 느껴집니다.</p><pre class="chroma"><span class="kt">int</span> <span class="n">add1_element</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">)</span>
</pre><p>  그래서, 오직 함수의 인자의 경우에서만 위 형태의 인자를 다음과 같이도 표현할 수 있습니다.</p><pre class="chroma"><span class="kt">int</span> <span class="n">add1_element</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="p">]</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">)</span>
</pre><p>  이는 오직 함수의 인자에서만 적용되는 것입니다. 만일</p><pre class="chroma"><span class="kt">int</span> <span class="n">parr</span><span class="p">[</span><span class="p">]</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
</pre><p> 와 같은 문장을 이용했더라면 컴퓨터는 <code class='inline-code'>parr</code> 을 '열의 개수가 3 개이고 행의 개수는 정해지지 않는 배열' 이라 생각해서 오류를 내게 됩니다. (만일 행의 개수를 생략했다면 배열을 정의시 초기화도 해주어야 되는데는 위는 그러지 않으므로) 암튼, 함수의 인자에서만 가능한 형태라는 것을 기억해 주시기 바랍니다.</p><p>  덧붙여서 응용력을 살짝 이용하면 다차원 배열의 인자도 정의할 수 있습니다. 예를 들어서</p><pre class="chroma"><span class="kt">int</span> <span class="nf">multi</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  혹은</p><pre class="chroma"><span class="kt">int</span> <span class="nf">multi</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="p">]</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  로 하면 됩니다.</p><h3><p>  상수인 인자</p></h3><pre class="chroma"><span class="cm">/* 상수를 인자로 받아들이기 */</span>

<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;int read_val(const int val);int main(){ int a; scanf(&#34;%d&#34;, &amp;a); read_val(a); return 0;}int read_val(const int val){ val = 5;  // 허용되지 않는다. return 0;}</span><span class="cp">
</span><span class="cp"></span></pre><p>  컴파일 하게 되면 아래와 같은 오류를 만나게 됩니다.</p><pre class='warning'>error C2166 : l - value가 const 개체를 지정합니다.
</pre><p>  흠.. 이건 우리가 이전에 상수의 값을 변경하려고 했었을 때 만났던 오류 인것 같습니다. 맞습니다. 우리가 <code class='inline-code'>val</code> 을 <code class='inline-code'>const int</code> 로 선언하였기 때문에 함수를 호출 할 때, <code class='inline-code'>val</code> 의 값은 인자로 전달된 값으로 초기화 되고 결코 바뀌지 않습니다. 즉, <code class='inline-code'>val</code> 은 <code class='inline-code'>a</code> 의 값으로 상수로 초기화 된 것입니다. 따라서, 함수 내부에서 <code class='inline-code'>val = 5</code> 와 같이 <code class='inline-code'>val</code> 의 값을 바꾸려 한다면 오류가 나겠지요. 왜냐하면 <code class='inline-code'>val</code> 은 상수이니까요.</p><p>  상수로 인자를 받아들이는 경우 대부분은 함수를 호출 해도 그 인자의 값이 바뀌지 않는 경우에 자주 사용합니다만, 자세한 내용은 나중에 좀더 다루도록 하겠습니다.</p><h3><p>  함수 포인터</p></h3><p>  아마, '함수 포인터' 라는 말을 들었을 때는 조금 의아하는 감이 있지 않을까 합니다. 함수 포인터라니, 함수를 가리킨다는 것인가? 그럼, 함수가 메모리 상에 있다는 거야? 네. 맞습니다. 사실, 프로그램의 코드 자체가 메모리 상에 존재합니다. 우리는 이전에 컴파일러가 하는 작업이 바로 우리가 '인간에 친숙한 언어' 로 쓰여진 프로그램 코드를 '컴퓨터에 친숙한 언어, 즉 수 데이터들' 로 바꿔주어 실행 파일을 생성한다고 배웠습니다. 이렇게, 바뀐 실행 파일을 실행하게 되면 프로그램의 수 코드가 메모리 상에 올라가게 됩니다. 다시말해, 메모리 상에 함수의 코드가 들어간다는 것입니다. 이 때, 변수를 가리키는 포인터 처럼 함수 포인터는 메모리 상에 올라간 함수의 시작 주소를 가리키는 역할을 하게 됩니다.</p><p>  그렇다면, 함수 포인터가 함수를 가리키기 위해서는 그 함수의 시작 주소값을 알아야 합니다. 그런데, 배열과 마찬가지로 함수의 이름이 바로 함수의 시작 주소값을 나타냅니다.</p><pre class="chroma"><span class="cm">/* 함수 포인터 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pmax</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="p">;</span>
  <span class="n">pmax</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

  <span class="n">scanf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">%d %d</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">max(a,b) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pmax(a,b) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  성공적으로 컴파일 했다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F177417244B3072794C0316' alt=''><p>  역시 우리가 예상했던 데로 잘 흘러가는 것 같습니다. 함수 포인터는 어떻게 정의하는지 살펴봅시다.</p><pre class="chroma"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pmax</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="p">;</span>
</pre><p>  일단, 위는 함수 포인터 <code class='inline-code'>pmax</code> 의 정의 입니다. 위 정의를 보고 다음과 같은 사실을 알 수 있습니다. '이 함수 포인터 <code class='inline-code'>pmax</code> 는 함수의 리턴값이 <code class='inline-code'>int</code> 형이고, 인자 두 개가 각각 <code class='inline-code'>int</code> 인 함수를 가리키는구나!'. 따라서, 우리는 <code class='inline-code'>pmax</code> 함수 포인터로 특정한 함수를 가리킬 때, 그 함수는 반드시 <code class='inline-code'>pmax</code> 의 정의와 일치해야 합니다. 함수 포인터의 일반적인 정의는 다음과 같습니다.</p><pre class='info'>(함수의 리턴형) (*포인터 이름)(첫번째 인자 타입, 두번째 인자 타입, ....)
    // 만일 인자가 없다면 그냥 괄호 안을 비워두면 된다. 즉, int (*a)() 와 같이
    // 하면 된다
</pre><p>  이제 <code class='inline-code'>pmax</code> 가 <code class='inline-code'>max</code> 를 가리키게 되는 부분을 봅시다.</p><pre class="chroma"><span class="n">pmax</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
</pre><p>  <code class='inline-code'>max</code> 함수를 살펴보면 <code class='inline-code'>pmax</code> 의 정의와 일치하므로, <code class='inline-code'>max</code> 함수의 시작 주소값을 <code class='inline-code'>pmax</code> 에 대입할 수 있게 됩니다. 이 때, 앞에서도 말했듯이 특정한 함수의 시작 주소값을 알려면 그냥 함수 이름을 넣어주면 됩니다. <code class='inline-code'>pmax = &max</code> 와 같은 형식은틀린<span class='font-weight-bold'> 것입니다.</p><pre class="chroma"><span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">max(a,b) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pmax(a,b) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>  <code class='inline-code'>pmax</code> 는 이제 <code class='inline-code'>max</code> 함수를 가리키므로 <code class='inline-code'>pmax</code> 를 통해 <code class='inline-code'>max</code> 함수가 할 수 있었던 모든 작업들을 할 수 있게 됩니다. 이때도 역시 그냥 <code class='inline-code'>pmax</code> 를 <code class='inline-code'>max</code> 처럼 이용하면 됩니다. 이는 배열에서</p><pre class="chroma"><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>

<span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">;</span>  <span class="c1">// p[2] 와 정확히 일치
</span><span class="c1"></span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="p">;</span>
</pre><p>  와 같이 <code class='inline-code'>arr[2]</code> 와 <code class='inline-code'>p[2]</code> 가 동일한 것과 같습니다. 아무튼 <code class='inline-code'>max(a,b)</code> 를 하나 <code class='inline-code'>pmax(a,b)</code> 를 하나 결과는 똑같이 나오게 됩니다.</p><pre class="chroma"><span class="cm">/* 함수 포인터 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">donothing</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pfunc</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="p">;</span>
  <span class="n">pfunc</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

  <span class="n">scanf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">%d %d</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">max(a,b) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pfunc(a,b) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

  <span class="n">pfunc</span> <span class="o">=</span> <span class="n">donothing</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">donothing(1,1) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">donothing</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pfunc(1,1) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pfunc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">donothing</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</pre><p>  성공적으로 컴파일 했다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1427D7224B3075AA319947' alt=''><p>  일단, 우리는 이전의 예제와 동일한 형태의 함수 포인터 <code class='inline-code'>pfunc</code> 을 정의하였습니다.</p><pre class="chroma"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pfunc</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="p">;</span>
</pre><p>  이는 '리턴형이 <code class='inline-code'>int</code> 이고 두 개의 인자 각각의 포인터 형이 <code class='inline-code'>int</code> 인 함수를 가리킵니다. 그런데, <code class='inline-code'>donothing</code> 함수와 <code class='inline-code'>max</code> 함수 모두 이 조건을 만족하고 있습니다. 즉, 이들은 인자의 변수들도 다루고 하는 일도 다르지만 리턴값이 <code class='inline-code'>int</code> 로 같고 두 개의 인자 모두 <code class='inline-code'>int</code> 이므로 <code class='inline-code'>pfunc</code> 이 이 두개의 함수를 가리킬 수 있는 것입니다.</p><pre class="chroma"><span class="n">pfunc</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>

<span class="n">scanf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">%d %d</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">max(a,b) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pfunc(a,b) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pfunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

<span class="n">pfunc</span> <span class="o">=</span> <span class="n">donothing</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">donothing(1,1) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">donothing</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pfunc(1,1) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pfunc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>  따라서, 위와 같이 했을 때 <code class='inline-code'>pfunc</code> 이, 자기가 가리키는 함수의 역할을 제대로 하고 있다는 것을 알 수 있습니다. 그런데 말이죠. 함수 포인터를 만들 때, 인자의 형이 무엇인지 알기 힘든 경우가 종종 있습니다. 예를 들어 아래와 같은 함수의 원형을 봅시다.</p><pre class="chroma"><span class="kt">int</span> <span class="n">increase</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">)</span>
</pre><p>  흠... 두 번째 인자의 형은 <code class='inline-code'>int</code> 라는 것은 알겠는데 첫번째 인자의 형은 도대체 뭘까요? 사실, 간단합니다. 특정한 타입의 인자를 판별하는 일은 단순히변수의 이름만을 빼버리면 됩니다. 따라서, 첫번째 인자의 형은 <code class='inline-code'>int (*)[3]</code> 입니다. 즉, <code class='inline-code'>increase</code> 함수를 가리키는 함수 포인터의 원형은 아래와 같습니다.</p><pre class="chroma"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pfunc</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="p">;</span>
</pre><p>  간단하지요? 이것을 이전에 이차원 배열을 인자로 받았던 함수에 적용시켜 보면 정확히 작동한다는 것을 알 수 있습니다.</p><p>그럼, 이번 강좌는 여기에서 끝을 내도록 하겠습니다. 함수에 관한 강좌는 여기서 막을 내리게 됩니다. 사실, 아직까지도 C 언어를 배우면서 정말로 무언가 할 수 있는 실용적인 프로그램을 만들지 못해서 안타깝습니다. 그래서 이번에 생각해보기로 여러 재미있는 과제들을 내보도록 하죠.</p><p>생각해보기</p><p><code class='inline-code'>1.</code> 사용자로 부터 5 명의 학생의 수학, 국어, 영어 점수를 입력 받아서 평균이 가장 높은 사람 부터 평균이 가장 낮은 사람까지 정렬되어 출력하도록 하세요. 특히, 평균을 기준으로 평균 이상인 사람 옆에는 '합격', 아닌 사람은 '불합격' 을 출력하게 해보세요 (난이도 : 中上).</p><p><code class='inline-code'>2.</code>유클리도 호제법을 이용해서 <code class='inline-code'>N</code> 개의 수들의 최대공약수를 구하는 함수를 만들어보세요. 유클리드 호제법이 무엇인지 모르신다면, 인터넷 검색을 활용하는 것을 추천합니다. (댓글을 달아도 돼요 <code class='inline-code'>) (</code>난이도 : 中上<code class='inline-code'>)</code></p><p><code class='inline-code'>3.</code> 자기 자신을 호출하는 함수를 이용해서 1 부터 특정한 수까지의 곱을 구하는 프로그램을 만들어보세요. (난이도 : 下)</p><p><code class='inline-code'>4.</code> 계산기를 만들어보세요. 사용자가 1 을 누르면 <code class='inline-code'>+, 2</code> 를 누르면 <code class='inline-code'>-</code> 와 같은 방식으로 해서 만들면 됩니다. 물론 이전의 계산 결과는 계속 누적되어야 하고, 지우기 기능도 있어야 합니다. (물론 하나의 함수에 구현하는 것이 아니라 여러개의 함수로 분할해서 만들어야겠죠?)  (난이도 : 中)</p><p><code class='inline-code'>5. N</code> 진법에서 <code class='inline-code'>M</code> 진법으로 변환하는 프로그램을 만들어보세요. (난이도 : 中)</p><p><code class='inline-code'>6.</code> 에라토스테네스의 체를 이용해서 1 부터 <code class='inline-code'>N</code> 까지의 소수를 구하는 프로그램을 만들어보세요. (난이도 : 中)</p><p><code class='inline-code'>7. 1000</code> 자리의 수들의 덧셈, 뺄셈, 곱셈, 나눗셈을 수행하는 프로그램을 만들어보세요. 나눗셈의 경우 소수 부분을 잘라버리세요. 물론, 소수 부도 1000 자리로 구현해도 됩니다. 1000 자리 수들의 연산 수행 시간은 1 초 미만이여야 합니다. (난이도 : 上)</p><pre class='warning'>강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면꼭 댓글을 남겨주시기 바랍니다. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요.

현재 여러분이 보신 강좌는 <<씹어먹는 C 언어 - <13 - 3. 마술 상자 함수 3 (function)>>> 입니다. 이번 강좌의모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전까지 다음 강좌로 넘어가지 말아주세요


[다음 강좌 보러가기](http://itguru.tistory.com/notice/15)
</pre>