<p>이번 강좌에서는<span class='font-italic'> C++ 템플릿 (template) 도입</p><ul><li><p> 클래스 템플릿과 함수 템플릿</p></li><li><p> 템플릿 인스턴스화와 템플릿 특수화</p></li><li><p> 함수 객체 (Functor)</p></li></ul><p>에 대해서 배웁니다.!</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F2143F24558E6C84424FCCA' alt=''><p>안녕하세요 여러분! 지난번 강좌 생각해보기는 잘 해결 하셨나요? 뭐 해결 하지 못하고 넘어왔더라도 괜찮습니다. 이번 강좌에서는 여태까지 배워 왔던 것과 전혀 다른 새로운 세계를 탐험해 볼 것입니다. </p><p>지난번 강좌에서 벡터와 스택 자료형을 만드셨던 것을 기억 하시나요? 벡터(vector) 는 쉽게 생각하면 가변 길이 배열로 사용자가 배열 처럼 사용하는데 크기를 마음대로 줄이고 늘일 수 있는 편리한 자료형입니다. 스택(stack)의 경우 나중에 들어간 것이 먼저 나온다(LIFO - last in first out) 형태의 자료형으로 pop 과 push 를 통해서 여러가지 작업들을 처리할 수 있습니다. </p><p>하지만 한 가지 문제는 우리가 담으려고 하는 데이터 타입이 바뀔 때 마다 다른 벡터를 만들어주어야 한다는 점이 있습니다. 예를 들어서 아래의 Vector 클래스를 살펴봅시다.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">string</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 생성자
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">string</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
  <span class="n">string</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>위 Vector 클래스의 경우 string 데이터 밖에 저장할 수 없습니다. 만일 사용자가 int 를 원한다면 어떨까요? 혹은 char 데이터를 담고 싶다면 어떻게 할까요? 물론, 각각의 경우에서 코드만 살짝 살짝 바꿔주면 될 것입니다. 예를 들어서 char 을 담는 Vector 의 경우</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 생성자
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">char</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
  <span class="kt">char</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>위와 같이 string 부분만 살짝 char 로 바꿔주면 됩니다. 하지만 이는 큰 낭비가 아닐 수 없습니다. 위 char 을 보관하는 vector 와 string 을 보관하는 vector 의 코드는 단순히 string 부분이 char 로 바뀐 차이 밖에 없습니다. 나머지 부분은 정확히 일치합니다. </p><p>쉽게 말해서 우리가 T 라는 타입의 객체들을 보관하는 vector 를 만들고 싶을 경우</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 생성자
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
  <span class="n">T</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>만약에 우리가 int 를 담는 vector 가 필요할 경우 T 를 int 로 바뀌면 되고, string 을 담는 것이 필요하다면 T 가 string 으로 바뀌면 됩니다. 쉽게 말해 컴파일러가 T 부분에 우리가 원하는 타입으로 채워서 코드를 생성해주면 엄청 편할 것입니다. </p><p>마치 어떠한 틀에 타입을 집어넣으면 원하는 코드가 딱딱 튀어 나오는 틀 같이 말이죠. </p><h3><p>  C++ 템플릿(template)</p></h3><p>놀랍게도, 우리가 원하는 작업을 C++ 에서는 template 이라는 이름으로 지원하고 있습니다. 영어 단어 template 의 뜻을 찾아보자면, '형판' 이라고 나옵니다. 쉽게 말해 어떠한 물건을 찍어내는 틀 이라고 생각하면 됩니다. C++ 에서도 정확히 같은 의미로 사용되고 있습니다. 사용자 (프로그래머)가 원하는 타입을 넣어주면 딱딱 알아서 코드를 찍어내는 틀 이라고 생각하면 됩니다. </p><pre class="chroma">
<span class="c1">// 템플릿 첫 활용
</span><span class="c1"></span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 생성자
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
  <span class="n">T</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>

<span class="p">{</span>
  <span class="c1">// int 를 보관하는 벡터를 만든다.
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_vec</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-------- int vector ----------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">첫번째 원소 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">두번째 원소 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">str_vec</span><span class="p">;</span>

  <span class="n">str_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">hello</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">str_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">world</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-------- string vector -------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">첫번째 원소 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">str_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">두번째 원소 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">str_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F256BAA3958E4332F1E0C9C' alt=''><p>와 같이 나옵니다.</p><p>일단 클래스 상단에 템플릿이 정의된 부분을 살펴봅시다.</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

<span class="c1">// ...
</span><span class="c1"></span></pre><p>맨 위에 </p><pre class='info'>
template <typename T>
</pre><p>는 아래에 정의되는 클래스에 대해 템플릿을 정의하고, 템플릿 인자로 T 를 받게 되며, T 는 반드시 어떠한 타입의 이름임을 명시하고 있습니다. 위 경우 템플릿 문장 아래 오는 것이 class Vector 이므로 이 Vector 클래스에 대한 템플릿을 명시하는데, 만약에 밑에 오는 것이 함수일 경우 함수에 대한 템플릿이 됩니다. (밑에 함수 템플릿에 대해서도 설명하겠습니다). </p><p>참고로, 간혹</p><pre class='info'>
template <class T>
</pre><p>라고 쓰는 경우도 있는데, 이는 정확히 typename T 와 동일한 것 입니다. class T 라고 해서 T 자리에 꼭 클래스가 와야 하는 것이 아닙니다. 똑같이 int, char 등이 올 수 있습니다. 다시말해;</p><pre class='info'>
template <typename T>
와 template <class T>
는 같습니다.
</pre><p>왜 똑같은 템플릿에 두 개의 키워드를 정의하였냐였는지는 C++ 의 역사와 관련이 있습니다. C++ 을 처음 만들었던 Bjarne Stroustrup 은 처음에 template 의 인자로 class 키워드를 사용하였는데, 굳이 새로운 키워드를 만들고 싶지 않아서 였기 때문입니다. 하지만, 시간이 흘러서 C++ 위원회는 이로 인한 혼동을 막기 위해 (왜냐하면 class T 라 하면 T 자리에 꼭 클래스만 와야 하는 것 처럼 느껴지니까) typename 이라는 이름을 사용하기로 하였습니다. 물론, 이전 코드와의 호환을 위해 class 는 그대로 남겨 놓았지요. (자세한 내막은 http://stackoverflow.com/questions/213121/use-class-or-typename-for-template-parameters 참조)</p><p>이렇게 정의한 템플릿의 인자에 값을 전달하기 위해서는</p><pre class="chroma">
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_vec</span><span class="p">;</span>
</pre><p>와 같이, <> 안에 전달하려는 것을 명시해주면 됩니다.  우리의 Vector 템플릿은 템플릿 인자로 타입을 받게 되는데, 위 경우 T 에 int 가 전달되게 됩니다. </p><p>여태까지는 인자로 특정한 '값' 혹은 '객체' 를 전달해왔지만 '타입' 그 자체를 전달한 적은 없었습니다. 하지만 템플릿을 통해 타입을 전달할 수 있게 됩니다. </p><pre class="chroma">
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>

    <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
</pre><p>위와 같이 Vector 의 템플릿의 인자에 타입을 전달하게 되면, 컴파일러는 이것을 보고 실제 코드를 생성하게 됩니다. 예를 들어서, Vector <int> 의 경우</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 어떤 타입을 보관하는지
</span><span class="c1"></span>
  <span class="n">typedefT</span> <span class="n">value_type</span><span class="p">;</span>

  <span class="c1">// 생성자
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
  <span class="n">intoperator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>T 가 정확히 int 로 치환된 위와 같은 코드를 찍어내겠지요. Vector<string> 의 경우 마찬가지로 T 가 string 으로 치환된 코드를 생성하게 됩니다. </p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F231FA84A58E4D77C0594AF' alt=''><p>위 사진 처럼, template 에 인자로 어떠한 타입을 전달하냐에 따라 int 를 저장하는 Vector 를 만들거나, string 을 저장하는 Vector 를 만들어낼 수 있는 것입니다. 마치 틀에 쇳물을 넣으면 쇠로 된 물건이 나오고, 구리물을 넣으면 구리로 된 물건이 나오는 것 처럼 말입니다.</p><pre class="chroma">
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_vec</span><span class="p">;</span>
</pre><p>따라서 위 코드는 Vector 의 T 가 int 로 치환된 클래스의 객체 int<span class='font-italic'>vec 을 생성하게 되는 것이지요. 위와 같이 클래스 템플릿에 인자를 전달해서 실제 코드를 생성하는 것을 클래스 템플릿 인스턴스화 (class template instantiation) 라고 합니다. </p><p>템플릿이 인스턴스화 되지 않고 덩그러니 있다면 컴파일 시에 아무런 코드로 변환되지 않습니다. 템플릿은 반드시 인스턴스화 되어야지만 비로소 컴파일러가 실제 코드를 생성하게 되지요. 마치 틀 자체로는 아무런 의미가 없지만, 그 틀에 채워넣어 나오는 물건에 관심이 있는 것 처럼 말이지요.</p><p>위와 같이 템플릿에 사용자가 원하는 타입을 템플릿 인자로 전달하면, 컴파일러는 그 인자를 바탕으로 코드를 생성하여 이를 컴파일 하게 됩니다. 하지만, 간혹 일부 타입에 대해서는 다른 방식으로 처리해야 할 경우가 있습니다. </p><p>예를 들어서 bool 데이터를 보관하는 벡터를 생각해봅시다.</p><pre class="chroma">
<span class="n">Vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">int_vec</span><span class="p">;</span>
</pre><p>사실 쉽게 생각해보면 그냥 위 처럼 템플릿 인자에 bool 을 전달하여 bool 을 저장하는 벡터로 사용할 수 도 있을 것입니다. 하지만 문제가 하나 있는데, C++ 에서 기본으로 처리하는 단위가 1 byte 라는 점입니다.</p><p>다시 말해 사실 bool 데이터 형은 1개 비트 만으로도 충분히 저장할 수 있지만, 8 비트를 사용해서 1개 bool 값을 저장해야 된다는 뜻이지요. 이는 엄청난 메모리 낭비가 아닐 수 없습니다. 따라서 우리는 Vector<bool> 에 대해서는 특별히 따로 처리해줘야만 합니다. '</p><h3><p>  템플릿 특수화 (template specialization)</p></h3><p>이와 같이 일부 경우에 대해서 따로 처리하는 것을 템플릿 특수화 라고 합니다. 템플릿 특수화는 다음과 같이 수행할 수 있습니다. 예를 들어서</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="p">,</span> <span class="k">typename</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">test</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>
</pre><p>위와 같은 클래스 템플릿이 정의되어 있을 때, "아 나는 A 가 int 고 C 가 double 일 때 따로 처리하고 싶어!" 면,</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>
</pre><p>와 같이 특수화 하고 싶은 부분에 원하는 타입을 전달하고 위에는 일반적인 템플릿을 쓰면 되겟지요. 만약에 B 조차도 특수화 하고 싶다면, </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>
</pre><p>와 같이 써주면 됩니다. 한 가지 중요한 점은, 전달하는 템플릿 인자가 없더라도 특수화 하고 싶다면 template<> 라도 남겨줘야 된다는 점입니다. 그렇다면 우리의 bool 벡터의 경우;</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">.</span><span class="p">.</span><span class="p">.</span>  <span class="c1">// 원하는 코드
</span><span class="c1"></span><span class="p">}</span>
</pre><p>와 같이 따로 처리해주면 되겠지요.</p><p>Vector<bool> 을 구현하기 위해서는 저는 평범한 int 배열을 이용할 것입니다. 1 개의 int 는 4 바이트 이므로, 32 개의 bool 데이터들을 한데 묶어서 저장할 수 있겠지요. 이를 통해서 원래 방식대로라면 bool 이 1 바이트로 저장되지만, 이렇게 하면 bool 을 1 비트로 정확히 표현할 수 있게 됩니다. </p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F26389B3958E4E2BB16AC95' alt=''><p>이렇게 한데 묶어서 저장하면 메모리 관련 측면에서는 효율이 매우 높아지지만, 이를 구현하는데는 조금 더 복잡해집니다. 왜냐하면 int 데이터에서 정확히 한 비트의 정보만 뽑아서 보여주어야 하기 때문이지요. 예를 들어서 N 번째 bool 데이터는 N / 32 번째 int 에 들어가 있고, 그 안에서 정확히 N % 32 번째 비트가 됩니다. </p><p>이와 같은 내용으로 구현을 하면 다음과 같습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 어떤 타입을 보관하는지
</span><span class="c1"></span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>

  <span class="c1">// 생성자
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
  <span class="n">T</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">typedefboolvalue_type</span><span class="p">;</span>

  <span class="c1">// 생성자
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
      <span class="o">:</span>

        <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">32</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="p">)</span><span class="p">,</span>

        <span class="n">capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">32</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="p">,</span>

        <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="kt">bool</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">length</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">|</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> <span class="o">!</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

      <span class="kt">int</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

      <span class="c1">// 만일 curr 위치에 있는 비트가 1 이라면
</span><span class="c1"></span>
      <span class="c1">// prev 위치에 있는 비트를 1 로 만든다.
</span><span class="c1"></span>
      <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">curr</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">curr</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">prev</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">|</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">prev</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

      <span class="p">}</span>

      <span class="c1">// 아니면 prev 위치에 있는 비트를 0 으로 지운다.
</span><span class="c1"></span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">all_ones_except_prev</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>

        <span class="n">all_ones_except_prev</span> <span class="o">^</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">prev</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

        <span class="n">data</span><span class="p">[</span><span class="n">prev</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span><span class="o">=</span> <span class="n">all_ones_except_prev</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>

<span class="p">{</span>
  <span class="c1">// int 를 보관하는 벡터를 만든다.
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_vec</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-------- int vector ----------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">첫번째 원소 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">두번째 원소 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">Vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">str_vec</span><span class="p">;</span>

  <span class="n">str_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">hello</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">str_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">world</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-------- string vector -------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">첫번째 원소 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">str_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">두번째 원소 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">str_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">bool_vec</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="p">;</span>

  <span class="n">bool_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-------- bool vector ---------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bool_vec</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">bool_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F232DED3658E4D77B3029B9' alt=''><p>와 같이 나옵니다. </p><pre class="chroma">
<span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
</pre><p>먼저 Vector<bool> 의 멤버 변수들 부터 살펴봅시다. 일단, int 배열로 unsigned int 를 사용하기로 하였습니다. 굳이 unsigned int 를 사용한 이유는 그냥 int 를 사용했을 때 shift 연산 시에 귀찮은 문제가 발생할 수 도 있기 때문입니다. </p><p>capacity 는 생성된 data 배열의 크기를 의미하고 length 는 실제 bool 데이터의 길이를 의미합니다. 즉 1 capacity 에 32 개의 bool 이 들어갈 수 있게 되는 것이지요. (int 가 32 비트라 생각하면)</p><pre class="chroma">
<span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="kt">bool</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

    <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">[</span><span class="n">length</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">|</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>다음으로 push<span class='font-italic'>back 함수를 살펴보도록 합시다. 일단 윗 부분은 동일합니다. 만일 현재 길이가 capacity 를 초과하게 되면 현재 크기의 2 배로 새로 배열을 만들어서 복사하게 됩니다. 그리고 기본적으로 배열 전체를 0 으로 초기화 하기 때문에 기본적으로 false 로 설정되어 있다고 보시면 됩니다.</p><pre class="chroma">
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">data</span><span class="p">[</span><span class="n">length</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">|</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">length</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>따라서 위 처럼 만일 true 를 추가하였을 때에만 해당 비트를 true 로 바꿔주면 됩니다. 어떤 비트에 1 을 OR 연산하게 되면 그 비트는 무조건 1 이 됩니다. 그리고 0 을 OR 연산하게 되면 그 비트의 값은 그대로 보존이 되지요. 따라서 OR 연산은 특정 비트에만 선택적으로 1로 바꾸는데 매우 좋은 연산입니다. 아래 그림을 보면 이해가 잘 되실 것입니다. 주변 나머지 비트들의 값은 보존하면서 특정 비트만 1 로 바꿔줍니다. </p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2240364758E4EA821BE62F' alt=''><p>위 경우에도 1 << (length % 32) 을 통해서 정확히 length % 32 번째 비트만 1 로 바꾼 뒤, OR 연산을 해서 해당 int 의 자리를 true 로 만들어 줄 수 있습니다. </p><pre class="chroma">
<span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> <span class="o">!</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</pre><p>그렇다면 임의의 위치에 접근하는 것은 어떨까요.</p><p>이번에는 거꾸로 AND 연산을 통해 해당 값을 가져올 수 있습니다. 어떤 비트에 0 을 AND 하게 되면 그 비트는 무조건 0 이 되고, 1 을 AND 연산 하게 되면 해당 비트가 1 이여야지만 1 이 됩니다. 즉, 1 을 AND 하게 되면 해당 비트의 값이 무엇인지 알아낼 수 있는 것입니다. 아래 그림을 보면 더 이해하기 쉽습니다. </p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2407FE3C58E4F2C91ACF15' alt=''><pre class="chroma">
<span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span>
</pre><p>따라서 위 작업을 수행하게 되면 해당 위치에 있는 비트가 1 일 때 에만 저 값이 0 이 아니게 되고 0 이면 저 값 전체가 0 이 됩니다. </p><pre class="chroma">
<span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
<span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

    <span class="c1">// 만일 curr 위치에 있는 비트가 1 이라면
</span><span class="c1"></span>
    <span class="c1">// prev 위치에 있는 비트를 1 로 만든다.
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">curr</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">curr</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">prev</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">|</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">prev</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

    <span class="p">}</span>

    <span class="c1">// 아니면 prev 위치에 있는 비트를 0 으로 지운다.
</span><span class="c1"></span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">all_ones_except_prev</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>

      <span class="n">all_ones_except_prev</span> <span class="o">^</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">prev</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

      <span class="n">data</span><span class="p">[</span><span class="n">prev</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span><span class="o">=</span> <span class="n">all_ones_except_prev</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>마지막으로 remove 함수를 살펴봅시다. </p><p>사실 이전 버전에서는 그냥 오른쪽 원소를 왼쪽으로 쭈르륵 덮어 씌어나가는 방식으로 간단히 만들 수 있었지만 이 bool 버전의 경우 그 '왼쪽' 과 '오른쪽' 원소를 읽어내는거 자체가 꽤나 복잡하므로 간단하게는 구현하기 힘듧니다.</p><pre class="chroma">
<span class="c1">// 만일 curr 위치에 있는 비트가 1 이라면
</span><span class="c1"></span>
<span class="c1">// prev 위치에 있는 비트를 1 로 만든다.
</span><span class="c1"></span>
<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">curr</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">curr</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">data</span><span class="p">[</span><span class="n">prev</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">|</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">prev</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>그래도 일단 특정 비트를 1 로 만드는 것은 간단합니다. 이전에도 하였듯이,  OR 을 수행해주면 됩니다.</p><pre class="chroma">
<span class="c1">// 아니면 prev 위치에 있는 비트를 0 으로 지운다.
</span><span class="c1"></span>
<span class="k">else</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">all_ones_except_prev</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>

  <span class="n">all_ones_except_prev</span> <span class="o">^</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">prev</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

  <span class="n">data</span><span class="p">[</span><span class="n">prev</span> <span class="o">/</span> <span class="mi">32</span><span class="p">]</span> <span class="o">&amp;</span><span class="o">=</span> <span class="n">all_ones_except_prev</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>그렇다면 오른쪽 비트가 0 일 때 왼쪽 비트를 0 으로 만드는 작업은 어떻게 할까요? 앞서 AND 연산의 경우 1 을 AND 하게 되면 원래 비트가 보존되고, 0 을 AND 하면 0 이 된다고 하였습니다. 따라서, 우리가 해야할 일은 원하는 자리의 비트만 0 이고 나머지는 1 인 것을 AND 해주면 됩니다. 그 과정을 수행하는 부분이 아래와 같습니다.</p><pre class="chroma">
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">all_ones_except_prev</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>

<span class="n">all_ones_except_prev</span> <span class="o">^</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">prev</span> <span class="o">%</span> <span class="mi">32</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>all<span class='font-italic'>ones</span>except<span class='font-italic'>prev 는 0 으로 지우려고 하는 위치만 0 이고 나머지 부분은 1 인 값 입니다. 참고로 기억하는지는 모르겠지만, ^ 는 XOR 연산자로, 두 비트가 같으면 0, 다르면 1 이되는 연산 입니다 (덧셈을 생각하시면 됩니다). 따라서 0xFFFFFFFF 는 모든 비트가 1 인 int 인데, XOR 연산을 통해서 해당 비트만 0 으로 바꿔줍니다. </p><p>그 후에 AND 연산을 하게 되면 해당 비트만 0 으로 지워버릴 수 있게 되지요.</p><p>실제로, C++ 표준 라이브러리에서 vector 를 지원을 하는데, 그 구현을 살펴보면 위 처럼 bool 일 때만 따로 특수화 시켜서 처리하고 있습니다. C++ 표준 라이브러리의 vector 는 나중 강좌에서 다루도록 하겠습니다.</p><p>템플릿 특수화를 통해 템플릿 인자의 값이 특정 값일 때 따로 처리하는 방식에 대해 알아보았습니다. </p><h3><p>  함수 템플릿 (Function template)</p></h3><p>이번에는 클래스 템플릿이 아닌 함수 템플릿에 대해 알아보도록 하겠습니다. </p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>

<span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Max (</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">,</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">b</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">) ? : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">hello</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">world</span><span class="s">&#34;</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Max (</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">,</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">t</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">) ? : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F26380B3E58E573D731A5E5' alt=''><p>와 같이 나옵니다. </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>

<span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>위 부분에서 템플릿 함수를 정의하고 있습니다. 클래스 템플릿과 마찬가지로, 위 함수도 인스턴스화 되기 전 까지는 컴파일 시에 아무런 코드로 변환되지 않습니다. </p><pre class="chroma">
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Max (</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">,</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">b</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">) ? : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>실제로 위 템플릿 함수가 인스턴스화 되는 부분은 바로 위 코드에서 max(a, b) 가 호출되는 부분입니다. 신기하게도, 클래스를 인스턴스화 했을 때 와는 다르게 <> 하는 부분이 없습니다. 원래 대로라면</p><pre class="chroma">
<span class="n">max</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre><p>이렇게 했었겠지요. 하지만 C++ 컴파일러는 생각보다 똑똑해서, a 와 b 의 타입을 보고 알아서 max (a, b) 를 max<int>(a, b) 로 인스턴스화 해줍니다. </p><pre class="chroma">
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Max (</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">s</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">,</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">t</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">) ? : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>string 의 경우도 마찬가지 입니다. C++ 컴파일러가 알아서 max<string>(s, t) 로 생각해서 인스턴스화 해줍니다. </p><p>그렇다면 다음 함수를 살펴봅시다.</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="o">&gt;</span>

<span class="kt">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cont</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p>위 함수는 임의의 컨테이너를 받아서 이를 정렬해 주는 함수 입니다 (사실 위 함수는 소위 말하는 거품 정렬 (버블소트) 방식을 사용하는데 매우 느립니다. 여러분들이 더 빠른 정렬 알고리즘(퀵소트, 등등)으로 구현해보세요!). 컨테이너란 쉽게 생각해서 데이터를 보관하는 것이라 생각하면 되는데, 앞서 소개하였던 Vector 도 하나의 예가 될 수 있습니다. </p><p>물론, 저 함수가 작동을 하려면 컨테이너에 size 함수와, swap 함수, 그리고 [ ] 연산자가 정의되어 있어야 겠지요. </p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 어떤 타입을 보관하는지
</span><span class="c1"></span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>

  <span class="c1">// 생성자
</span><span class="c1"></span>
  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>

      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>
  <span class="n">T</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// i 번째 원소와 j 번째 원소 위치를 바꾼다.
</span><span class="c1"></span>
  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>

    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">;</span>

    <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="o">&gt;</span>

<span class="kt">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cont</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_vec</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>

  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 이전 ---- </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 이후 ---- </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">bubble_sort</span><span class="p">(</span><span class="n">int_vec</span><span class="p">)</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F235F7B3358E5A6571B312A' alt=''><p>와 같이 나옵니다.</p><p>참고로 기존에 만들었던 Vector 에는 swap 함수가 없어서 새로 추가하였습니다. </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cont</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p>위 부분을 보면 정렬 함수를 템플릿으로 구현한 것을 볼 수 있습니다. </p><pre class="chroma">
<span class="n">bubble_sort</span><span class="p">(</span><span class="n">int_vec</span><span class="p">)</span><span class="p">;</span>
</pre><p>와 같이 위 함수를 호출한다면 컴파일러는 인자로 전달된 객체의 타입을 보고 알아서 인스턴스화 한 뒤에 컴파일 하게 되지요. 위 경우에 int<span class='font-italic'>vec 이 Vector<int> 타입 이므로, Cont 에 Vector<int> 가 전달 될 것입니다.</p><p>다만 한 가지 중요한 사실은,</p><pre class="chroma">
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
</pre><p>에서나,</p><pre class="chroma">
<span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cont</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="p">;</span>
</pre><p>에서 size(), operator[], swap() 등이 사용되었다는 것입니다. 만약에 Cont 로 전달된 타입에 저러한 것들이 정의가 되어 있지 않다면 어떨까요? 예를 들어서 </p><pre class='info'>
struct dummy {};

dummy a;
bubble_sort(a);
</pre><p>를 하게 된다면 </p><pre class='warning'>
error C2039 : 'size' : is not a member of 'dummy'
                       // 생략 ...
</pre><p>컴파일 시에, 위와 같은 저 클래스에서 멤버 함수나 변수들을 찾을 수 없다는 오류들을 뿜어내게 됩니다. 당연한 이야기지만 이와 같이 템플릿으로 발생되는 오류는 프로그램이 실행되었을 때가 아니라 컴파일 할 때 발생한 다는 사실입니다. 왜냐하면 컴파일 시에 모든 템플릿을 실제 코드로 변환하여 실행하기 때문이지요. </p><p>재미있게도, 이와 같이 컴파일 시에 모든 템플릿들이 인스턴스화 되다는 사실을 가지고 또 여러가지 흥미로운 코드를 짤 수 있는데 이러한 방식을 템플릿 메타프로그래밍 (template metaprogramming) 이라고 합니다. 자세한 내용은 나중 강좌들에서 다루도록 하겠습니다.</p><p>그런데 위 bubble<span class='font-italic'>sort 함수에서는 한 가지 부족한 점이 있습니다. 만약에, 정렬 순서를 역순으로 하고 싶다면 어떨까요? 위는 오름 차순으로 정렬하였지만, 간혹 내림 차순으로 정렬을 하고 싶을 수 도 있습니다. 아니면 아예 다른 기준으로 정렬을 할 수 도 있겠지요. 이를 위해서라면 크게 세 가지 방법이 있습니다.</p><ol><li><p> bubble<span class='font-italic'>sort2 를 만들어서 부등호 방향을 반대로 바꿔준다.</p></li><li><p> operator> 를 오버로딩해서 원하는 방식으로 만들어준다.</p></li><li><p> cont[i] 와 cont[j] 의 비교를 > 로 하지 말고 특정 함수에 넣어서 전달한다.</p></li></ol><p>첫번째 방법은 C 를 배우는 단계에서나 적합한 방법입니다. 여러분은 C++ 를 배우고 있으니 더 나은 방법을 생각해야겠지요?두번째 방법은 여러분들이 만든 객체를 사용할 때 적용할 수 있는 방법입니다. 예를 들어서, </p><pre class='info'>
struct customClass {
  // ..

  bool operator<(const customClass& c) {
    // Do something
  }
};

Vector<customClass> a;
bubble_sort(a);
</pre><p>와 같이 여러분이 직접 정의한 클래스에 대해 operator< 를 오버로딩 할 수 있다면 원하는 방식으로 정렬을 수행할 수 있겠지요. 하지만 위 처럼 기본적으로 operator< 를 오버로딩 할 수 없는 상황이라면 어떨까요? 예를 들어서 int 나 string 은 이미 내부적으로 operator< 가 정의되어 있기 때문에 이를 따로 오버로딩을 할 수 없습니다.</p><p>그렇다면 3 번째 방법은 어떨까요? </p><h3><p>  함수 객체(Function Object - Functor) 의 도입</p></h3><p>그럼 다음과 같은 함수를 생각해봅시다.</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Comp</span><span class="o">&gt;</span>

<span class="kt">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">,</span> <span class="n">Comp</span><span class="o">&amp;</span> <span class="n">comp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">comp</span><span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">,</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cont</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p>위 함수는 기존의 bubble<span class='font-italic'>sort 와는 달리 아예 Comp 라는 클래스를 템플릿 인자로 받고, 함수 자체도 Comp 객체를 따로 받습니다. 그렇다면 이 comp 객체가 무슨 일을 하냐면;</p><pre class="chroma">
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">comp</span><span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">,</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
</pre><p>이 if 문에서 마치 함수를 호출하는 것 처럼 사용되는데, cont[i] 와 cont[j] 를 받아서 내부적으로 크기 비교를 수행한 뒤에 그 결과를 리턴하고 있습니다. 한 가지 중요한 사실은 comp 는 함수가 아니라 객체 이고, Comp 클래스에서 () 연산자를 오버로딩한 버전입니다. 자세한 내용은 아래 전체 코드를 보면서 설명하겠습니다. </p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 어떤 타입을 보관하는지
</span><span class="c1"></span>  <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>

  <span class="c1">// 생성자
</span><span class="c1"></span>  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
      <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>  <span class="n">T</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// i 번째 원소와 j 번째 원소 위치를 바꾼다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">;</span>
    <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cont</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Comp</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">,</span> <span class="n">Comp</span><span class="o">&amp;</span> <span class="n">comp</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cont</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">comp</span><span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">,</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cont</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Comp1</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Comp2</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_vec</span><span class="p">;</span>
  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="p">;</span>
  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
  <span class="n">int_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 이전 ---- </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Comp1</span> <span class="n">comp1</span><span class="p">;</span>
  <span class="n">bubble_sort</span><span class="p">(</span><span class="n">int_vec</span><span class="p">,</span> <span class="n">comp1</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">내림차순 정렬 이후 ---- </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">Comp2</span> <span class="n">comp2</span><span class="p">;</span>
  <span class="n">bubble_sort</span><span class="p">(</span><span class="n">int_vec</span><span class="p">,</span> <span class="n">comp2</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">오름차순 정렬 이후 ---- </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">int_vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F27495C4458E6BF2C188F1C' alt=''><p>와 같이 나옵니다.</p><pre class="chroma">
<span class="k">struct</span> <span class="n">Comp1</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Comp2</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>일단 위 두 클래스를 살펴보도록 합시다. Comp1 과 Comp2 모두 아무 것도 하지 않고 단순히 operator() 만 정의하고 있습니다. 그리고 이 Comp1 과 Comp2 객체들은 bubble<span class='font-italic'>sort 함수 안에서 </p><pre class="chroma">
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">comp</span><span class="p">(</span><span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">,</span> <span class="n">cont</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
</pre><p>마치 함수인양 사용되지요. 이렇게, 함수는 아니지만 함수 인 척을 하는 객체를 함수 객체 (Function Object), 혹은 줄여서 Functor 라고 부릅니다. 이 Functor 덕분에, bubble<span class='font-italic'>sort 함수 내에서 두 객체간의 비교를 사용자가 원하는 대로 할 수 있게 되지요. </p><p>따라서 사용자들은 입맛에 맞게, 보통의 < 연산자로 비교를 수행하는 </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">)</span>
</pre><p>위 bubble<span class='font-italic'>sort 함수를 사용하거나;</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Cont</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Comp</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">bubble_sort</span><span class="p">(</span><span class="n">Cont</span><span class="o">&amp;</span> <span class="n">cont</span><span class="p">,</span> <span class="n">Comp</span><span class="o">&amp;</span> <span class="n">comp</span><span class="p">)</span>
</pre><p>특수한 경우에 따로 비교 하는 것을 직접 수행하고 싶은 경우에 Comp 객체를 받아서 비교를 수행하는 새로운 bubble<span class='font-italic'>sort 함수를 사용할 수 있습니다. </p><p>물론</p><pre class="chroma">
<span class="n">bubble_sort</span><span class="p">(</span><span class="n">int_vec</span><span class="p">,</span> <span class="n">comp1</span><span class="p">)</span><span class="p">;</span>
</pre><p>를 했다면 두 번째 버전으로 템플릿 인스턴스화 되서 함수가 호출되고,</p><pre class="chroma">
<span class="n">bubble_sort</span><span class="p">(</span><span class="n">int_vec</span><span class="p">)</span><span class="p">;</span>
</pre><p>그냥 위 처럼 한다면 첫 번째 버전으로 템플릿 인스턴스화 되서 함수가 호출되겠지요.</p><p>실제로, C++ 표준 라이브러리의 sort 함수를 살펴보아도 비교 클래스를 받지 않는</p><pre class='info'>
template <class RandomIt>
void sort(RandomIt first, RandomIt last);
</pre><p>와 </p><pre class='info'>
template <class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
</pre><p>비교 클래스를 받는 위 버전으로 구성되어 있습니다. (저 함수의 인자들에 대해서는 나중 강좌에서 자세히 다룰 테니 지금은 넘어가셔도 됩니다!)</p><p>이와 같이 비교 클래스를 받아서 원하는 비교 작업을 수행할 수 있게 됩니다. 만약에 C 였다면 위 sort 함수를 어떻게 만들었을 지 생각해봅시다. 일단 원하는 클래스를 받는 다는 생각 자체가 불가능하기 때문에 (template 이 없으니까) functor 는 꿈도 못 꾸었겠지요. 대신에, 비교 작업을 수행하는 함수의 포인터를 받아서 이를 처리하였을 것입니다.</p><p>그렇다면 뭐가 더 나은 방법일까요? Functor? 아니면 구닥다리 함수 포인터?</p><p>이미 예상하셨겠지만, Functor 를 사용하는것이 여러 모로 훨씬 편리한 점이 많습니다. 일단, 클래스 자체에 여러가지 내부 state 를 저장해서 비교 자체가 복잡한 경우에도 손쉽게 사용자가 원하는 방식으로 만들어낼 수 있습니다. 뿐만 아니라, 함수포인터로 함수를 받아서 처리한다면 컴파일러가 최적화를 할 수 없지만, Functor 를 넘기게 된다면 컴파일러가 operator() 자체를 인라인화 시켜서 매우 빠르게 작업을 수행할 수 있습니다.</p><p>(실제로 C 의 qsort 와 C++ 의 표준 sort 함수를 비교한다면 C++ 버전이 훨씬 빠르다고 합니다)</p><p>이상으로 C++ 템플릿 첫 번째 강좌를 마치도록 하겠습니다. 다음 강좌에서는 템플릿이 C++ 에게 하사한 새로운 패러다임의 세계로 떠나볼 것입니다.</p><h3><p>  생각 해보기</p></h3><ol><li><p> template 을 사용해서 이전에 만들어 놓았던 Excel 프로젝트 코드를 깔끔하게 만들어보세요. 아마 10 배는 깔끔해질 것입니다 :) (난이도 : 下)</p></li><li><p> 위 Vector 로 2차원, 3차원 배열 등을 똑같이 만들어낼 수 있을까요? (난이도 : 下)</p></li><li><p> 위에서 컴파일러가 마법 처럼 템플릿 인자에 타입을 정해준다고 하지만 사실은 어떤 타입으로 추측할지 결정하는 일련의 규칙들이 있습니다. 자세한 내용은 여기를 참고해주세요!</p></li></ol><pre class='warning'>강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 꼭 댓글을 남겨주시기
            바랍니다
                .그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관
                    없습니다.생각해 볼 문제도 정 모르겠다면 댓글을
                        달아주세요.현재 여러분이 보신 강좌는
        << 씹어먹는 C++ - <9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)>>>
    입니다.이번 강좌의 모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어
        보시기 전까지 다음 강좌로 넘어가지 말아주세요 다음 강좌 보러가기
</pre><p>공감5sns신고저작자표시</p><p>'C++' 카테고리의 다른 글씹어먹는 C++ - <9 - 3. 템플릿 메타 프로그래밍 2>(8)2017.07.02씹어먹는 C++ - <9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)>(2)2017.06.26씹어먹는 C++ - <9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)>(10)2017.04.07씹어먹는 C++ - <8 - 2. Excel 만들기 프로젝트 2부>(6)2016.07.19씹어먹는 C++ - <8 - 1. Excel 만들기 프로젝트 1부>(0)2016.07.18씹어먹는 C++ - <7 - 2. C++ 에서 파일 입출력 - ifstream. ofstream, stringstream>(13)2016.07.14</p>