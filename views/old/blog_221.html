<p>이번 강좌에서는<span class='font-italic'> 타입이 아닌 템플릿 인자</p><ul><li><p> 템플릿 메타 프로그래밍의 시작</p></li><li><p> using 키워드 사용</p></li></ul><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2154D04A5950B93618C72A' alt=''><p>안녕하세요 여러분! 지난번 강좌에서 template 을 처음으로 소개하였는데 어떠하셨나요? 템플릿을 통해서 프로그래밍이 좀 더 편해진 것 같나요? 이렇게 템플릿을 통해서 타입이 마치 인자 인것 처럼 사용하는 것을 바로 일반화 프로그래밍 (generic programming) 혹은 그냥 제너릭 프로그래밍 이라고 부릅니다. </p><p>앞선 강좌에서는 템플릿 인자로 타입들만 전달하였지만, 실제로는 일반적인 값들도 인자로 전달할 수 있습니다. 아래의 예제를 살펴보겠습니다. </p><pre class="chroma">
<span class="cm">/* 템플릿 인자로 값을 받기 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Array</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 배열을 받는 레퍼런스 arr
</span><span class="c1"></span>  <span class="n">Array</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">T</span><span class="o">*</span> <span class="n">get_array</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">N</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">print_all</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">, </span><span class="s">&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span><span class="p">;</span>

  <span class="c1">// 배열 wrapper 클래스
</span><span class="c1"></span>  <span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">arr_w</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="p">;</span>

  <span class="n">arr_w</span><span class="p">.</span><span class="n">print_all</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F27754F3B594C979F2AF4C4' alt=''><p>와 같이 나옵니다.</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</pre><p>템플릿 정의 부분을 살펴보면 바로 알겠지만, 템플릿 역시 마치 함수의 인자에 값을 받는 것 처럼 템플릿에도 값을 전달 할 수 있습니다. 다만 함수 처럼 임의의 객체를 인자로 받을 수 있는 것은 아니고, 위 처럼 정수 타입이나, 레퍼런스 혹은 포인터 만을 받을 수 있습니다. 그 이유는 잘 생각해보면 당연한데, 템플릿이 인스턴스화 되는 과정은 컴파일 시에 일어나는데, 만약에 객체를 직접 받는다면, 컴파일을 하기 전에 컴파일을 해야되는 모순적인 상황이 발생하게 되기 때문이지요. </p><p>아무튼, 템플릿 인자로는 단순한 정수타입이나, 레퍼런스, 포인터만 받을 수 있다고 생각하시면 됩니다. </p><pre class="chroma">
<span class="c1">// 배열 wrapper 클래스
</span><span class="c1"></span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">arr_w</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="p">;</span>
</pre><p>위와 같이 템플릿 인스턴스화를 하게 되면, 템플릿에 T 자리에는 int 가, N 자리에는 3 이 들어가겠지요. 그렇다면 컴파일러는</p><pre class="chroma">
<span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="p">;</span>
</pre><p>를</p><pre class="chroma">
<span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">;</span>
</pre><p>으로 대체해서 코드를 생성하게 되고, 마찬가지로</p><pre class="chroma">
<span class="c1">// 배열을 받는 레퍼런스 arr
</span><span class="c1"></span><span class="n">Array</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p>생성자 역시</p><pre class="chroma">
<span class="c1">// 배열을 받는 레퍼런스 arr
</span><span class="c1"></span><span class="n">Array</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p>로 아예 코드가 생성되어 실행됩니다. 참고로 이 처럼 배열을 감싸는 wrapper 클래스를 만들어서 마치 배열 처럼 사용한다면 (물론 그러기 위해서는 [] 연산자도 오버로드 해야겠죠?) 배열을 사용함으로써 발생하는 문제들을 많이 해결할 수 있게 됩니다. 예를 들어서, 일반 배열은 배열 범위가 넘어가도 알 수 없지만, 위 Array 클래스는 index 범위가 넘어가는 곳을 가리키면 뭔가 메세지를 띄우든 오류를 발생 시키든 해서 사용자에게 알려 줄 수 있습니다. </p><p>그런데, 과연 아래 두 개 클래스는 같은 클래스 일까요? 다른 클래스 일까요?</p><pre class="chroma">
<span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span>
</pre><p>간단히 아래 코드로 확인해 볼 수 있습니다.</p><pre class="chroma">
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=</span><span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span><span class="p">)</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>참고로 typeid 를 사용하려면 <typeinfo> 헤더파일을 추가해주시면 됩니다. 그 결과는 당연하게도</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F2649724B594CB13D2F1774' alt=''><p>와 같이 다르다고 나옵니다. 왜 다르냐면 당연히, 다른 템플릿 인자로 인스턴스화 되었기 때문이지요. 컴파일러는 Array<int, 5> 와 Array<int, 3> 를 위해 각기 다른 코드를 생성하며 다른 클래스의 객체들을 만들게 됩니다. </p><p>그렇다면 아래와 같이 정의된 Int 클래스를 생각해봅시다. </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>이 클래스는 템플릿 인자로 int 값을 받습니다. 참고로, 왜 static const 에 값을 저장하냐면, 첫 번째로 C++ 클래스 멤버 중에서 클래스 자체에서 저런 식으로 초기화를 할 수 있는 멤버의 타입은 static const 밖에 없고, 두 번째로 static const 야 말로 '이 클래스는 이 것이다' 라는 의미를 가장 잘 나타내기 때문입니다. 왜냐하면 static 타입 멤버의 특성 상, 이 클래스가 생성한 객체들 사이에서 공유되는 값이기 때문에 '이 타입이면 이 값을 나타낸다' 라고 볼 수 있습니다. 또한 const 이므로, 그 나타내는 값이 변하지 않게 됩니다. </p><p>따라서 아래 처럼 마치 객체를 생성하듯 타입들을 생성할 수 있습니다.  </p><pre class="chroma">
<span class="k">typedef</span> <span class="n">Int</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">one</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Int</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">two</span><span class="p">;</span>
</pre><p>그렇다면 저 one 타입과 two 타입은 1 과 2 의 값을 나타내는 타입이 됩니다. (one 과 two 는 객체가 아닙니다!)</p><p>그럼 이제 one 과 two 를 가지고 무엇을 할 수 있을까요? 재미있게도 마치 int 변수를 다루는 것 처럼 연산자를 만들 수 있습니다. 아래 예제를 살펴볼까요.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">add</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Int</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">+</span> <span class="n">U</span><span class="o">:</span><span class="o">:</span><span class="n">num</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Int</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">one</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Int</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">two</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="n">add</span><span class="o">&lt;</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span> <span class="n">three</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Addtion result : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">three</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F215FB037594F3E06197C17' alt=''><p>와 같이 실제 계산 결과가 잘 나오게 됩니다. </p><p>덧셈을 수행하는 템플릿 클래스를 살펴봅시다.</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">add</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Int</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">+</span> <span class="n">U</span><span class="o">:</span><span class="o">:</span><span class="n">num</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>위 add 클래스의 템플릿은 인자로 두 개의 타입을 받아서 그 타입의 num 멤버를 더해서 새로운 타입인 result 를 만들어 내게 됩니다. </p><pre class="chroma">
<span class="k">typedef</span> <span class="n">add</span><span class="o">&lt;</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span> <span class="n">three</span><span class="p">;</span>
</pre><p>위 부분은 실제 덧셈을 수행하는 부분입니다. add 클래스를 함수라고 생각한다면 그 계산 결과를 내부 result 타입으로 반환한다고 보면 됩니다. 아무튼 one 과 two 를 더한 것을 나타내는 타입이 result 로 정의되고, 이를 three 라고 부르겠습니다. </p><p>실제로, 그 결과를 보면 </p><pre class="chroma">
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Addtion result : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">three</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>를 통해서 3 이 잘 출력됨을 알 수 있습니다.  </p><p>한 가지 흥미로운 점은 저 3 이라는 값이 프로그램이 실행되면서 계산되는 것이 아니라는 점입니다. 컴파일 시에, 컴파일러가 three::num 을 3 으로 치환 해버립니다.</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile1.uf.tistory.com%2Fimage%2F23499834594F45E110436F' alt=''><p>실제로 마우스를 올려보면 저 값이 3 이란 사실을 알 수 있습니다. </p><p>다시 말해, 저 덧셈이 수행 되는 시기는 컴파일 타임이고, 런타임 시에는 단순히 그 결과를 보여주게 되는 것입니다. </p><h3><p>  템플릿 메타 프로그래밍 (Template Meta Programming - TMP)</p></h3><p>여태까지 타입은 어떠한 객체에 무엇을 저장하느냐를 지정하는데 사용해 왔지, 타입 자체가 어떠한 값을 가지지는 않았습니다. 하지만, 바로 위 예제를 통해서 알 수 있듯이, 템플릿을 사용하면 객체를 생성하지 않더라도, 타입에 어떠한 '값' 을 부여할 수 있고, 또 그 타입들을 가지고 '연산' 을 할 수 있다는 점 입니다. 또한 타입은 반드시 컴파일 타임에 확정되어야 하므로, 컴파일 타임에 모든 연산이 끝나게 됩니다. 이렇게 타입을 가지고 컴파일 타임에 생성되는 '코드'로 프로그래밍을 하는 것을 메타 프로그래밍(meta programming) 이라고 합니다. C++ 의 경우 템플릿을 가지고 이러한 작업을 하기 때문에 템플릿 메타 프로그래밍, 줄여서 TMP 라고 부릅니다. </p><pre class="chroma">
<span class="cm">/* 컴파일 타임 팩토리얼 계산 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Factorial</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">6! = 1*2*3*4*5*6 = </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면!</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F24481E4F595009FA13AE76' alt=''><p>와 같이 잘 나옵니다. </p><p>팩토리얼(factorial) 은 단순히 1 부터  n 까지 곱한 것이라 생각하면 됩니다. 예를 들어 3 팩토리얼 (3! 이라 씁니다) 은 1 <span class='font-italic'> 2 </span> 3 이라 생각하면 됩니다. 이 팩토리얼을 어떻게 하면 이전 예제와 같은 템플릿을 사용한 구조로 나타낼 수 있을까요? 사실 아래와 같이 매우 단순합니다. </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Factorial</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>만약에 저 Factorial 을 일반적인 함수로 구성하려고 했다면 아마 아래와 같은 재귀 함수 형태를 사용했겠지요. </p><pre class="chroma">
<span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>따라서 우리는 위 처럼 재귀 함수 호출이 끝나게 하기 위해선, n 이 1 일 때 따로 처리를 해주어야 합니다. 템플릿 역시 마찬가지로 n = 1 일 때 따로 처리할 수 있는데 바로 아래 처럼 템플릿 특수화를 이용해주면 됩니다. </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>컴파일러는 Factorial<1> 타입의 경우만 따로 result = 1 로 만들어주게 되어서 재귀적 구조가 끝날 수 있게 해줍니다.</p><p>위 예제에서 볼 수 있듯이, 저기서 실질적으로 값을 가지는 객체는 아무 것도 없습니다. 즉, '720' 이라는 값을 가지고 있는 변수는 메모리 상에서 없다는 뜻입니다 (물론 cout 에서 출력 할 때 빼고). 저 화면에 나타나는 720 이라는 값은, 단순히 컴파일러가 만들어낸 Factorial<6> 이라는 타입을 나타내고 있을 뿐입니다. </p><p>사실 여러분 한테 factorial 을 계산하라는 함수를 만들라고 이야기 했다면 십중팔구 그냥 단순히 for 문으로 구현을 하였을 것입니다. 하지만 안타깝게도 템플릿으로는 for 문을 쓸 수 없기 때문에 위와 같은 재귀적 구조를 사용하였습니다. 한 가지 다행인 소식은 for 문으로 구현할 수 있는 모든 코드는 똑같이 템플릿 메타 프로그래밍을 이용해서 구현할 수 있습니다. </p><p>더군다나 위에서 보셨듯이 if 문 역시 템플릿 메타 프로그래밍으로 구현할 수 있습니다. 위 팩토리얼 예제에서도 알 수 있듯이, if 문 부분은 템플릿 특수화로 처리 가능합니다. </p><h3><p>  TMP 를 왜 쓰는가?</p></h3><p>한 가지 재미있는 사실은 어떠한 C++ 코드도 템플릿 메타 프로그래밍 코드로 변환할 수 있다는 점입니다 (물론 엄청나게 코드가 길어지겠지만요). 게다가 템플릿 메타 프로그래밍으로 작성된 코드는 모두 컴파일 타임에 모든 연산이 끝나기 때문에 프로그램 실행 속도를 향상 시킬 수 있다는 장점이 있습니다 (당연히도 컴파일 시간은 엄청 늘어나게 됩니다). 하지만 그렇다고 해서 템플릿 메타 프로그래밍으로 프로그램 전체를 구현하는 일은 없습니다. 일단 템플릿 메타 프로그래밍은 매우 복잡합니다. 물론 위 Factorial 예제는 꽤 간단하였지만 아래 좀 더 복잡한 예제를 다루면서 왜 템플릿 메타 프로그래밍이 힘든 것인지 이야기 하겠습니다. 그 뿐만이 아니라, 템플릿 메타 프로그래밍으로 작성된 코드는 버그를 찾는 것이 매우 힘듭니다. 일단 기본적으로 '컴파일' 타임에 연산하는 것이기 때문에 디버깅이 불가능 하고, C++ 컴파일러에 특성 상 템플릿 오류 시에 엄청난 길이의 오류를 내뿜게 됩니다. 따라서 TMP 를 이용하는 경우는 꽤나 제한적이지만, 많은 C++ 라이브러리들이 TMP 를 이용해서 구현되었고 (Boost 라이브러리), TMP 를 통해서 컴파일 타임에 여러 오류들을 잡아낼 수 도 있고 (Ex. 단위나 통화 일치 여부등등) 속도가 매우 중요한 프로그램의 경우 TMP 를 통해서 런타임 속도도 향상 시킬 수 있습니다. 아래에서 좀 더 복잡한 예제를 가지고 그렇다면 TMP 를 어떻게 사용할 지에 대해서 자세히 알아보도록 하겠습니다. 컴퓨터 상에서 두 수의 최대공약수를 구하기 위해선 보통 유클리드 호제법을 이용합니다. 이는 매우 간단한데, 이 알고리즘을 일반적인 함수로 나타내자면 아래와 같습니다. </p><pre class="chroma">
<span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>따라서 이를 그대로 TMP 로 바꿔보면 아래와 같습니다. (여러분도 직접 해보세요!)</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">GCD</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">GCD</span><span class="o">&lt;</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">%</span> <span class="n">Y</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">GCD</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">gcd (36, 24) :: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">GCD</span><span class="o">&lt;</span><span class="mi">36</span><span class="p">,</span> <span class="mi">24</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">value</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23373A49595058531B9B43' alt=''><p>와 같이 잘 계산됩니다. </p><p>이 최대 공약수 계산 클래스를 만든 이유는, 바로 Ratio 클래스를 만들기 위함입니다. Ratio 클래스는 유리수(p/q 꼴로 쓸 수 있는 수) 를 오차 없이 표현해 주는 클래스 입니다. 물론 TMP 를 사용하지 않고 간단하게 클래스를 사용해서도 만들 수 있습니다. 하지만 일단 연습 삼아서 한 번 TMP 를 사용해서 만들어 보겠습니다. </p><pre class="chroma">

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Ratio</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>먼저 Ratio 클래스는 위 처럼 정의할 수 있겠습니다. 위 처럼 분자와 분모를 템플릿 인자로 받고, 타입을 나타내게 됩니다. 참고로 편의상 </p><pre class="chroma">
<span class="k">typedef</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
</pre><p>typedef 로 '자기 자신을 가리키는 타입' 을 넣어 주었습니다. 이는 마치 클래스에서의 this 와 비슷한 역할입니다. </p><p>그렇다면 이 Ratio 로 덧셈을 수행하는 템플릿을 만들어보겠습니다. 상당히 직관적입니다. </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">_Ratio_add</span> <span class="p">{</span>
  <span class="n">typedefRatio</span><span class="o">&lt;</span><span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">+</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="p">,</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>두 분수의 더한 결과를 Ratio 에 분자 분모로 전달하면 알아서 기약분수로 만들어줍니다. </p><pre class="chroma">
<span class="n">typedefRatio</span><span class="o">&lt;</span><span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">+</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="p">,</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
</pre><p>그 후에, 그 덧셈 결과를 type 로 나타내게 됩니다. 따라서 덧셈을 수행하기 위해서는 </p><pre class="chroma">
<span class="k">typedef</span> <span class="n">_Ratio_add</span><span class="o">&lt;</span><span class="n">rat</span><span class="p">,</span> <span class="n">rat2</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">type</span> <span class="n">result</span><span class="p">;</span>
</pre><p>이런 식으로 사용하면 되겠지요. 하지만 한 발 더 나아가서, 귀찮게 ::type 를 치고 싶지 않다고 해 봅시다. 다시 말해 Ratio<span class='font-italic'>add 를 하면 그 자체로 두 Ratio 가 더해진 타입이 되는 것이지요. 이는 아래와 같이 구현할 수 있습니다. </p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Ratio_add</span> <span class="p">:</span> <span class="n">_Ratio_add</span><span class="o">&lt;</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">type</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>
</pre><p>바로 <span class='font-italic'>Ratio</span>add<R1, R2>::type 를 상속 받는 Ratio<span class='font-italic'>add 클래스를 만들어 버리는 것입니다! 상당히 재미있는 아이디어입니다. 따라서 Ratio</span>add 는 마치 Ratio 타입 처럼 사용할 수 있게 됩니다. 전체 코드를 살펴 보자면 아래와 같습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">GCD</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">GCD</span><span class="o">&lt;</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">%</span> <span class="n">Y</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">GCD</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Ratio</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>  <span class="c1">// 분자
</span><span class="c1"></span>  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="n">D</span><span class="p">;</span>  <span class="c1">// 분모
</span><span class="c1"></span><span class="p">}</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">_Ratio_add</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">+</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="p">,</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Ratio_add</span> <span class="p">:</span> <span class="n">_Ratio_add</span><span class="o">&lt;</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">type</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">rat</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">rat2</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Ratio_add</span><span class="o">&lt;</span><span class="n">rat</span><span class="p">,</span> <span class="n">rat2</span><span class="o">&gt;</span> <span class="n">rat3</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">rat3</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> / </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">rat3</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F2776165059506A812E3256' alt=''><p>와 같이 잘 계산되서 나옵니다. </p><p>참고로 C++11 부터 typedef 대신에 좀 더 직관적인 using 이라는 키워드를 사용할 수 있습니다. </p><pre class="chroma">
<span class="k">typedef</span> <span class="n">Ratio_add</span><span class="o">&lt;</span><span class="n">rat</span><span class="p">,</span> <span class="n">rat2</span><span class="o">&gt;</span> <span class="n">rat3</span><span class="p">;</span>
<span class="k">using</span> <span class="n">rat3</span> <span class="o">=</span> <span class="n">Ratio_add</span><span class="o">&lt;</span><span class="n">rat</span><span class="p">,</span> <span class="n">rat2</span><span class="o">&gt;</span><span class="p">;</span>
</pre><p>위 두 문장 모두 동일한 의미를 가집니다. 다만 using 을 사용하였을 경우 typedef 보다 좀 더 이해하기가 쉽습니다. 특히, 함수 포인터의 경우 만일 void 를 리턴하고 int, int 를 인자로 받는 함수의 포인터의 타입을 func 라고 정의하기 위해서는 typedef 로 </p><pre class="chroma">
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="p">;</span>
</pre><p>위와 같이 사용해야 했지만 (놀랍게도 func 이 새로 정의된 타입 이름이 됩니다) using 키워드를 사용하면</p><pre class="chroma">
<span class="k">using</span> <span class="n">func</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="p">;</span>
</pre><p>아래와 같이 매우 직관적으로 나타낼 수 있습니다. 따라서 위의 코드를 수정하자면;</p><pre class="chroma">
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">rat</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">rat2</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">rat3</span> <span class="o">=</span> <span class="n">Ratio_add</span><span class="o">&lt;</span><span class="n">rat</span><span class="p">,</span> <span class="n">rat2</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">rat3</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> / </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">rat3</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>로 간단하고 좀 더 직관적으로 나타낼 수 있습니다. 다시 한 번 말하지만, 마치 Ratio 클래스의 객체를 생성한 것 같지만, 실제로 생성된 객체는 한 개도 없고, 단순히 타입들을 컴파일러가 만들어낸 것 뿐입니다. </p><p>마찬가지 방법으로 모든 사칙연산들을 구현하자면 아래와 같습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Y</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">GCD</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">GCD</span><span class="o">&lt;</span><span class="n">Y</span><span class="p">,</span> <span class="n">X</span> <span class="o">%</span> <span class="n">Y</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">X</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">GCD</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">D</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Ratio</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="k">const</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">_gcd</span> <span class="o">=</span> <span class="n">GCD</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">value</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="k">typedef</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">/</span> <span class="n">_gcd</span><span class="p">,</span> <span class="n">D</span> <span class="o">/</span> <span class="n">_gcd</span><span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="n">_gcd</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="n">D</span> <span class="o">/</span> <span class="n">_gcd</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">_Ratio_add</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">+</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="p">,</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Ratio_add</span> <span class="p">:</span> <span class="n">_Ratio_add</span><span class="o">&lt;</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">type</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">_Ratio_subtract</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">-</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="p">,</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Ratio_subtract</span> <span class="p">:</span> <span class="n">_Ratio_subtract</span><span class="o">&lt;</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">type</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">_Ratio_multiply</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">num</span><span class="p">,</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Ratio_multiply</span> <span class="p">:</span> <span class="n">_Ratio_multiply</span><span class="o">&lt;</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">type</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">_Ratio_divide</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">den</span><span class="p">,</span> <span class="n">R1</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">*</span> <span class="n">R2</span><span class="o">:</span><span class="o">:</span><span class="n">num</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">R1</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">R2</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">Ratio_divide</span> <span class="p">:</span> <span class="n">_Ratio_divide</span><span class="o">&lt;</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">type</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">Ratio</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">Ratio_add</span><span class="o">&lt;</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">2/3 + 3/2 = </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">r3</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> / </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">r3</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">r4</span> <span class="o">=</span> <span class="n">Ratio_multiply</span><span class="o">&lt;</span><span class="n">r1</span><span class="p">,</span> <span class="n">r3</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">13 / 6 * 2 /3 = </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">r4</span><span class="o">:</span><span class="o">:</span><span class="n">num</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> / </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">r4</span><span class="o">:</span><span class="o">:</span><span class="n">den</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F237B10405950A66E12890D' alt=''><p>와 같이 나옵니다.</p><p>자 여기까지 따라 오셨다면 한 가지 궁금증이 들 것입니다. </p><p>"음 그래. Ratio 로 이용해서 재미있는 것을 할 수 있는거 같애. 컴파일 타임에 유리수 사칙 연산을 계산할 수 있다는 것도 좋아. 근데 도대체 저게 왜 필요하지?" </p><p>바로 다음 강좌에서 알아 보도록 하겠습니다!</p><h3><p>  생각 해보기</p></h3><ol><li><p> N 번째 피보나치 수를 나타내는 TMP 를 만들어보세요. 참고로 피보나치 수는, N 번째 항이 N - 1 번째 항과 N - 2 번째 항의 합으로 정의되는 수 입니다. 참고로 1, 1, 2, 3, 5, ... 로 진행됩니다. (난이도 : 하)</p></li></ol><pre class="chroma">
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">5 번째 피보나치 수 :: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">fib</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 5
</span><span class="c1"></span><span class="p">}</span>
</pre><ol><li><p> TMP 를 사용해서 어떤 수가 소수인지 아닌지를 판별하는 프로그램을 만들어보세요. (난이도 : 상) 참고로 이 문제는 다음 강좌에서 다룰 예정입니다!</p></li></ol><pre class="chroma">
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">boolalpha</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Is prime ? :: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">is_prime</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>   <span class="c1">// true
</span><span class="c1"></span>  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Is prime ? :: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">is_prime</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// false
</span><span class="c1"></span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Is prime ? :: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">is_prime</span><span class="o">&lt;</span><span class="mi">11</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// true
</span><span class="c1"></span>  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">Is prime ? :: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">is_prime</span><span class="o">&lt;</span><span class="mi">61</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">result</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// true
</span><span class="c1"></span><span class="p">}</span>
</pre><pre class='warning'>강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 꼭 댓글을 남겨주시기
            바랍니다
                .그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관
                    없습니다.생각해 볼 문제도 정 모르겠다면 댓글을
                        달아주세요.현재 여러분이 보신 강좌는
        << 씹어먹는 C++ -
               <9 - 2. 템플릿 메타 프로그래밍(Template Meta programming)>>>
    입니다.이번 강좌의 모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어
        보시기 전까지 다음 강좌로 넘어가지 말아주세요 다음 강좌 보러가기
</pre><p>공감1sns신고저작자표시</p><p>'C++' 카테고리의 다른 글씹어먹는 C++ - <10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)>(2)2017.07.04씹어먹는 C++ - <9 - 3. 템플릿 메타 프로그래밍 2>(8)2017.07.02씹어먹는 C++ - <9 - 2. 템플릿 메타 프로그래밍 (Template Meta programming)>(2)2017.06.26씹어먹는 C++ - <9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)>(10)2017.04.07씹어먹는 C++ - <8 - 2. Excel 만들기 프로젝트 2부>(6)2016.07.19씹어먹는 C++ - <8 - 1. Excel 만들기 프로젝트 1부>(0)2016.07.18</p>