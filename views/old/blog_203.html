<p>이번 강좌에서는<span class='font-italic'> 멤버 함수가 아닌 연산자 함수 오버로딩</p><ul><li><p> 입출력 연산자 오버로딩 (정확히 보면 <code class='inline-code'>&lt;&lt;, &gt;&gt;</code> 연산자)</p></li><li><p> 첨자 연산자 <code class='inline-code'>[]</code> 오버로딩</p></li><li><p> 타입 변환 연산자 오버로딩</p></li><li><p> 증감 연산자 <code class='inline-code'>++, --</code> 오버로딩</p></li></ul><p>에 대해 다룹니다.</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F24418A45521E2A8F25D22A' alt=''><p>안녕하세요 여러분. 잘 지내셨나요? 올해 안으로 C++ 강좌를 끝내기 위한 노력의 일환으로 강좌를 열심히 업로드 하려고 노력중인 Psi 입니다. 그래도 강좌를 읽으시는 여러분들은 꼼꼼히 읽어보시고, 궁금하신 점들은 꼭 댓글로 남겨 주시거나 메일로 질문해 주시기 바랍니다 :)</p><p>지난 강좌에서, 마지막에 다음과 같은 문제점을 지적하였습니다.</p><pre class="chroma">
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-1.1 + i3.923</span><span class="s">&#34;</span><span class="p">;</span>  <span class="c1">// ①
</span><span class="c1"></span></pre><p>는 잘 컴파일 되서 실행되지만</p><pre class="chroma">
<span class="n">a</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-1.1 + i3.923</span><span class="s">&#34;</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// ②
</span><span class="c1"></span></pre><p>는 컴파일 되지 않습니다. 왜냐하면, ① 의 경우 a.operator+("i3.923"); 으로 변환될 수 있지만 ② 는 그렇지 못하기 때문이죠. 하지만, 원칙적으로  클래스를 사용하는 사용자의 입장에서① 이 된다면 당연히② 도 수행될 수 있어야 연산자 오버로딩을 하는 명분이 생깁니다. 다행 스럽게도, 사실 컴파일러는 이항 연산자 (피연산자를 두 개를 취하는 연산자 <code class='inline-code'>-</code> 예를 들어서 <code class='inline-code'>+, -, *, /, -&gt;, =</code> 등이 이항 연산자 이다) 를 다음과 같은 두 개의 방식으로 해석합니다.</p><p>어떤 임의의 연산자 @ 에 대해서, <code class='inline-code'>a</code> @ <code class='inline-code'>b</code> 는</p><pre class="chroma"><span class="o">*</span><span class="n">a</span><span class="p">.</span><span class="k">operator</span><span class="err">@</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="p">;</span>
<span class="o">*</span><span class="k">operator</span><span class="err">@</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="p">;</span>
</pre><p>두 가지 방법으로 해석됩니다.</p><p> (<code class='inline-code'>*</code> 참고로 이는 일부 연산자들에 대해서는 해당되지 않는데 대표적으로 <code class='inline-code'>[]</code> 연산자 (첨자), <code class='inline-code'>-&gt;</code> 연산자 (멤버 접근), 대입 연산자 (=), () 함수 호출 연산자들의 경우 멤버 함수로만 존재할 수 있습니다. 즉, 따로 멤버 함수가 아닌 전역 함수로 뺄 수 없다는 의미 입니다. 따라서 이들 함수를 오버로딩 할 때 주의하시기 바랍니다.<code class='inline-code'>)</code></p><p>즉, 컴파일 시에 둘 중 하나의 가장 가까운 것을 택해서 처리됩니다. a.operator@(b) 에서의 operator@ 는 <code class='inline-code'>a</code> 의 클래스의 멤버 변수로써 사용되는 것이고, operator@(a,b) 에서의 operator@ 는 그냥 일반적인 함수를 의미하게 됩니다. 따라서 이를 처리하기 위해 함수를 정의하여 봅시다.</p><pre class="chroma">
<span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">.</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>우리의 또 다른 <code class='inline-code'>operator+</code> 는 두 개의 <code class='inline-code'>const Complex&</code> 타입의 인자 <code class='inline-code'>a,b</code> 를 받게 됩니다. 앞에서도 말했지만 컴파일러는 정확히 일치 하지 않는 경우, 가장 가까운 '가능한' 오버로딩 되는 함수를 찾게 되는데, 마침 우리에게는 <code class='inline-code'>Complex(const char *)</code> 타입의 생성자가 있으므로,</p><pre class="chroma">
<span class="sa"></span><span class="s">&#34;</span><span class="s">-1.1 + i3.923</span><span class="s">&#34;</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
</pre><p>는</p><pre class="chroma">
<span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">Complex</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">-1.1 + i3.923</span><span class="s">&#34;</span><span class="p">)</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="p">;</span>
</pre><p>가 되어서 잘 실행되게 됩니다. 실제로 컴파일 해보면</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Complex</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">real</span><span class="p">,</span> <span class="n">img</span><span class="p">;</span>

  <span class="kt">double</span> <span class="nf">get_number</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">real</span><span class="p">,</span> <span class="kt">double</span> <span class="n">img</span><span class="p">)</span> <span class="o">:</span> <span class="n">real</span><span class="p">(</span><span class="n">real</span><span class="p">)</span><span class="p">,</span> <span class="n">img</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="n">Complex</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="n">real</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">img</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">Complex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">println</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">( </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">real</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> , </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">img</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> ) </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">.</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="n">Complex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
</span><span class="c1"></span>  <span class="c1">// 문자열의 꼴은 다음과 같습니다 &#34;[부호](실수부)(부호)i(허수부)&#34;
</span><span class="c1"></span>  <span class="c1">// 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">begin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="n">img</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="n">real</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="c1">// 먼저 가장 기준이 되는 &#39;i&#39; 의 위치를 찾는다.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">pos_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">i</span><span class="sc">&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pos_i</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 만일 &#39;i&#39; 가 없다면 이 수는 실수 뿐이다.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">pos_i</span> <span class="o">=</span><span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">get_number</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 만일 &#39;i&#39; 가 있다면, 실수부와 허수부를 나누어서 처리하면 된다.
</span><span class="c1"></span>  <span class="n">real</span> <span class="o">=</span> <span class="n">get_number</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">pos_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">img</span> <span class="o">=</span> <span class="n">get_number</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">pos_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pos_i</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">[</span><span class="n">pos_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">-</span><span class="sc">&#39;</span><span class="p">)</span> <span class="n">img</span> <span class="o">*</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="n">get_number</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">minus</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">-</span><span class="sc">&#39;</span><span class="p">)</span> <span class="n">minus</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">-</span><span class="sc">&#39;</span> <span class="o">|</span><span class="o">|</span> <span class="n">str</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">+</span><span class="sc">&#39;</span><span class="p">)</span> <span class="n">from</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">decimal</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">integer_part</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">to</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">integer_part</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">num</span> <span class="o">*</span><span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
      <span class="n">num</span> <span class="o">+</span><span class="o">=</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">0</span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">.</span><span class="sc">&#39;</span><span class="p">)</span>
      <span class="n">integer_part</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="o">!</span><span class="n">integer_part</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">decimal</span> <span class="o">/</span><span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
      <span class="n">num</span> <span class="o">+</span><span class="o">=</span> <span class="p">(</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">0</span><span class="sc">&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">decimal</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
      <span class="k">break</span><span class="p">;</span>  <span class="c1">// 그 이외의 이상한 문자들이 올 경우
</span><span class="c1"></span>  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">minus</span><span class="p">)</span> <span class="n">num</span> <span class="o">*</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">real</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">img</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">real</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">img</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">,</span> <span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span> <span class="o">+</span> <span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span>
      <span class="p">(</span><span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">,</span>
      <span class="p">(</span><span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">+</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">-</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">*</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">/</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">real</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
  <span class="n">img</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-1.1 + i3.923</span><span class="s">&#34;</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">a</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F2434EE495218CD59169D96' alt=''><p>와 같이 잘 실행됨을 알 수 있습니다. 그런데, 아마 <code class='inline-code'>operator+</code> 를 자세히 살펴보신 분들은 아마 다음과 같은 문제점을 확인할 수 있었을 것입니다.</p><pre class="chroma">
<span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">.</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>왜 굳이 귀찮게 <code class='inline-code'>temp</code> 라는 새로운 <code class='inline-code'>Complex</code> 객체를 정의하여서 <code class='inline-code'>temp</code> 와의 <code class='inline-code'>+</code> 연산을 리턴하느냐 입니다. 그냥 <code class='inline-code'>a + b</code> 할 것을 불필요 하게 복사 생성을 한 번 더 하게 되서 성능의 하락이 발생하게 됩니다. 하지만, 그냥 <code class='inline-code'>a + b</code> 를 하게 된다면;</p><pre class="chroma">
<span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">returna</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</pre><p>위 코드를 컴파일 시에 다음과 같은 경고 메세지를 볼 수 있을 것입니다.</p><pre class='warning'>
warning C4717 : 'operator+' : recursive on all control paths,
                              function will cause runtime stack overflow
</pre><p>즉, <code class='inline-code'>a + b</code> 에서 <code class='inline-code'>a.operator+(b)</code> 가 호출되는 것이 아니라, <code class='inline-code'>operator+(a,b)</code> 가 호출 되기 때문에 재귀적으로 무한히 많이 함수가 호출되어 오류가 발생한다는 것이지요. 실제로 실행해 보아도 프로그램이 강제로 종료되는 모습을 볼 수 있습니다. 따라서 이와 같은 문제를 방지하기 위해서 우리는 다음과 같이 강제로 멤버 함수 <code class='inline-code'>operator+</code> 를 호출하도록 지정하였습니다.</p><pre class="chroma">
<span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">returna</span><span class="p">.</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="p">;</span> <span class="p">}</span>
</pre><p>이 역시 컴파일 되지 않습니다. 아마 오류의 내용은 다음과 같을 것입니다.</p><pre class='warning'>
error C2662
    : 'Complex::operator +'
      : cannot convert 'this' pointer from 'const Complex' to 'Complex &'
</pre><p>이 말은 즉슨, <code class='inline-code'>a</code> 가 <code class='inline-code'>const Complex</code> 인데, 우리가 호출하고자 하는 멤버 함수 <code class='inline-code'>operator+</code> 는 <code class='inline-code'>const</code> 함수가 아니기 때문입니다. 상당히 골치아픈 문제가 아닐 수 없습니다. (참고로 <a href='http://itguru.tistory.com/197'>const 함수가 무엇인지 기억이 나지 않으시는 분들은 이 강좌</a>를 다시 읽어보시기 바랍니다)<code class='inline-code'>const</code> 객체는 언제나 값이 바뀔 수 없으며, 만일 <code class='inline-code'>const</code> 객체의 멤버 함수 호출 시에는 그 함수가 객체의 값을 바꾸지 않는 다고 보장할 수 있도록 <code class='inline-code'>const</code> 함수여야만 합니다. 하지만 멤버 함수 <code class='inline-code'>operator+</code> 는 <code class='inline-code'>const</code> 성이 없으므로, <code class='inline-code'>operator+</code> 를 호출하는 것은 불가능 해지지요.</p><p>이 문제를 해결할 수 있는 유일한 방법은<code class='inline-code'>Complex operator+(const Complex& a, const Complex& b)</code> 내부에서 다른 함수들을 호출하지 않고 직접 덧셈을 수행하면 됩니다. 다만 이 방법도 문제가 있지요. 멤버 함수가 아닌 외부 함수 <code class='inline-code'>operator+</code> 에서 객체의 <code class='inline-code'>private</code> 정보에 접근할 수 있어야만 하는데, 이 것이 불가능 하기 때문입니다. 하지만, 놀랍게도 C++ 에서는 이를 가능케 하는 키워드가 있습니다.</p><h3><p>  friend 는 모든 것을 공유한다.</p></h3><p>아마 이 글을 읽는 독자 여러분들은 자신의 모든 것을 아낌없이 털어놓을 수 있는 절친한 친구 한 두 명 쯤은 있을 것입니다. 그 친구와 나 사이에는 어떠한 정보도 열람할 수 있는 관계가 되지요.그런데 재미있는 사실에는 비슷한 역할을 하는 키워드가 C++ 에도 있다는 점입니다. 그 이름도 역시 'friend' 입니다.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Complex</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">real</span><span class="p">,</span> <span class="n">img</span><span class="p">;</span>

  <span class="kt">double</span> <span class="nf">get_number</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">real</span><span class="p">,</span> <span class="kt">double</span> <span class="n">img</span><span class="p">)</span> <span class="o">:</span> <span class="n">real</span><span class="p">(</span><span class="n">real</span><span class="p">)</span><span class="p">,</span> <span class="n">img</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="n">Complex</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="n">real</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">img</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">Complex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="k">friend</span> <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">println</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">( </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">real</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> , </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">img</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> ) </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>위와 같이 <code class='inline-code'>Complex</code> 클래스 안에서</p><pre class="chroma">
<span class="k">friend</span> <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span><span class="p">;</span>
</pre><p>라 같이 쓰면 우리의<code class='inline-code'>Complex operator+(const Complex& a, const Complex&</code> b);  함수는 이제 <code class='inline-code'>Complex</code> 의 <code class='inline-code'>friend</code> 가 됩니다. 즉, <code class='inline-code'>Complex</code> 클래스의 입장에서는 자신의 새로운 친구인 <code class='inline-code'>operator+</code> 에게 마음의 문을 열고 모든 정보에 접근할 수 있도록 허가하는 것입니다. <code class='inline-code'>private</code> 냐 <code class='inline-code'>public</code> 이냐에 관계 없이<code class='inline-code'>Complex operator+(const Complex& a, const Complex&</code> b); 함수는 이제 어떤 <code class='inline-code'>Complex</code> 객체라도 그 내부 정보에 접근할 수 있습니다.</p><p>따라서, 다음과 같은 코드를 사용하는 것도 가능하지요.</p><pre class="chroma">
<span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">img</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>이제 이 <code class='inline-code'>operator+</code> 함수는 마치 <code class='inline-code'>Complex</code> 클래스의 멤버 변수인양, 객체들의 정보에 접근할 수 있게 됩니다. <code class='inline-code'>real</code> 변수는 <code class='inline-code'>private</code> 이지만, <code class='inline-code'>a.real</code> 을 해도 무방하지요. 이렇게 된다면, 이전의 <code class='inline-code'>operator+</code> 에서 불필요하게 <code class='inline-code'>temp</code> 객체를 생성했던 것 과는 달리 필요한 것만 사용하면 됩니다.</p><p>한 가지 재미 있는 사실은 <code class='inline-code'>friend</code> 키워드는 함수에만 적용할 수 있는 것이 아니라, 다른 클래스 자체도 <code class='inline-code'>friend</code> 로 지정할 수 있습니다. 예를 들어서,</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">A</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

  <span class="k">friend</span> <span class="n">B</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">B</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>와 같이 할 경우, <code class='inline-code'>A</code> 는 <code class='inline-code'>B</code> 를 <code class='inline-code'>friend</code> 로 지정하게 된 것입니다. 한 가지 주의할 사실은, 우리가 흔히 생각하는 'friend' 관계와는 다르게, C++ 에서 friend 는 짝사랑과 비슷합니다. 즉, <code class='inline-code'>A</code> 는 자기 생각에 <code class='inline-code'>B</code> 가 <code class='inline-code'>friend</code> 라고 생각하는 것이므로, <code class='inline-code'>B</code> 에게 <code class='inline-code'>A</code> 의 모든 것을 공개합니다. 즉 클래스 <code class='inline-code'>B</code> 에서 <code class='inline-code'>A</code> 의 <code class='inline-code'>private</code> 변수인 <code class='inline-code'>x</code> 에 접근할 수 있게 됩니다. 하지만 <code class='inline-code'>B</code> 에는 <code class='inline-code'>A</code> 가 <code class='inline-code'>friend</code> 라고 지정하지 않았으므로, <code class='inline-code'>B</code> 의 입장에서는 <code class='inline-code'>A</code> 에게 어떠한 내용도 공개하지 않습니다 (public 변수들 빼고). 따라서 <code class='inline-code'>A</code> 는 <code class='inline-code'>B</code> 의 <code class='inline-code'>private</code> 변수인 <code class='inline-code'>int y</code> 에 접근할 수 없게 됩니다.</p><h3><p>  입출력 연산자 오버로딩 하기</p></h3><p>아마도, 눈치를 채신 분들이 있겠지만 우리가</p><pre class="chroma">
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">a</span><span class="p">;</span>
</pre><p>라고 하는 것은 사실 <code class='inline-code'>cout.operator&lt;&lt;(a)</code> 를 하는 것과 동일한 명령이었습니다. 즉, 어떤 <code class='inline-code'>cout</code> 이라는 객체에 멤버 함수 <code class='inline-code'>operator&lt;&lt;</code> 가 정의되어 있어서 <code class='inline-code'>a</code> 를 호출하게 되는 것이지요. 그런데, <code class='inline-code'>cout</code> 이 <code class='inline-code'>int</code> 나 <code class='inline-code'>double</code> 변수, 심지어 문자열 까지 자유 자재로 <code class='inline-code'>operator&lt;&lt;</code> 하나로 출력할 수 있었던 이유는 그 많은 수의 <code class='inline-code'>operator&lt;&lt;</code> 함수들이 오버로딩 되어 있다는 뜻입니다.</p><p>실제로 우리가 <code class='inline-code'>include</code> 하던 <code class='inline-code'>iostream</code> 의 헤더파일의 내용을 살펴보면 (실제로는 <code class='inline-code'>ostream</code> 에 정의되어 있습니다. 다만 <code class='inline-code'>iostream</code> 이 <code class='inline-code'>ostream</code> 을 <code class='inline-code'>include</code> 하고 있음) <code class='inline-code'>ostream</code> 클래스에</p><pre class="chroma">
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">bool</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">short</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">long</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">float</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">double</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">long</span> <span class="kt">double</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">val</span><span class="p">)</span><span class="p">;</span>
</pre><p>와 같이 엄청난 수의 <code class='inline-code'>operator&lt;&lt;</code> 가 정의되어 있는 것을 알 수 있습니다. 이들 덕분에 우리가 편하게 인자의 타입에 관계없이 손쉽게 출력을 사용할 수 있게 되는 것이지요.</p><p>그렇다면 한 번 우리의 <code class='inline-code'>Complex</code> 클래스에서 <code class='inline-code'>ostream</code> 클래스의 연산자 <code class='inline-code'>operator&lt;&lt;</code> 를 자유롭게 사용할 수 있으면 어떨까요. 예를 들어서</p><pre class="chroma">
<span class="n">Complex</span> <span class="n">c</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">c</span><span class="p">;</span>
</pre><p>를 하게 되면 마치</p><pre class="chroma">
<span class="n">Complex</span> <span class="n">c</span><span class="p">;</span>
<span class="n">c</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>을 한 것과 같은 효과를 내도록 말이지요. 당연하게도, <code class='inline-code'>ostream</code> 클래스에 <code class='inline-code'>operator&lt;&lt;</code> 멤버 함수를 새롭게 추가하는 것은 불가능 합니다. 이는 표준 헤더파일의 내용을 수정하는 것과 같기 때문이죠. 대부분의 경우 표준 헤더파일은 읽기만 가능이고, 원칙적으로 표준 라이브러리의 내용을 수정하는 것은 좋지 않습니다 (정확히 말하면 하면 안됩니다!). 따라서, 우리는 <code class='inline-code'>ostream</code> 클래스에 <code class='inline-code'>Complex</code> 객체를 오버로딩하는 operator<< 연산자 함수를 추가할 수는 없지요.</p><p>그 대신에, 여태 까지 배운 내용에 따르면 아예 <code class='inline-code'>operator&lt;&lt;</code> 전역 함수 하나를 정해서 <code class='inline-code'>Complex</code> 의 <code class='inline-code'>friend</code> 로 지정한 다음에 사용할 수 있습니다. 그 함수는 아마 다음과 같이 생겼겟지요.</p><pre class="chroma">
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">os</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">( </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> , </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> ) </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>여기서 왜 'cout' 이 아니고 'os' 라고 의문을 가질 수 도 있는데, <code class='inline-code'>cout</code> 자체가 <code class='inline-code'>iostream</code> 에서 하나 만들어 놓은 <code class='inline-code'>ostream</code> 객체 입니다. 따라서 <code class='inline-code'>ostream&</code> 타입으로 <code class='inline-code'>cout</code> 객체를 받아서 이를 출력하면 됩니다. 마찬가지로, <code class='inline-code'>Complex</code> 클래스 내부에서 <code class='inline-code'>friend</code> 선언을 해주시면 됩니다. 참고로 <code class='inline-code'>opreator&lt;&lt;</code> 에서 <code class='inline-code'>ostream&</code> 타입을 리턴하는 이유는 다음과 같은 문장을 처리할 수 있기 위해서입니다.</p><pre class="chroma">
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">a 의 값은 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> 이다. </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p><code class='inline-code'>&lt;&lt;</code> 연산자는 왼쪽 부터 오른쪽 순으로 실행되기 때문에 가장 먼저 cout.operator<<("a 의 값은?") 이 실행되고, 그 자리에 <code class='inline-code'>cout</code> 이 다시 리턴됩니다. 그 다음에는 cout.operator<<(a); 가 되서 쭉쭉 이어질 수 있도록 이와 같이 <code class='inline-code'>ostream&</code> 를 리턴하게 되는 것입니다. 참고로, <code class='inline-code'>Complex</code> 클래스 내부에는</p><pre class="chroma">
<span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
</pre><p>위와 같이 <code class='inline-code'>friend</code> 선언을 해주시면 됩니다. 비슷한 방법으로 <code class='inline-code'>Complex</code> 객체 <code class='inline-code'>c</code> 에 대해 <code class='inline-code'>cin &gt;&gt;</code> c; 와 같은 작업을 할 수 있습니다. 다만, 이번에는 <code class='inline-code'>cin</code> 은 <code class='inline-code'>istream</code> 객체이고, <code class='inline-code'>opreator&gt;&gt;</code> 를 오버로딩 해야 된다는 점이 다를 뿐이지요.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Complex</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">double</span> <span class="n">real</span><span class="p">,</span> <span class="n">img</span><span class="p">;</span>

  <span class="kt">double</span> <span class="nf">get_number</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">real</span><span class="p">,</span> <span class="kt">double</span> <span class="n">img</span><span class="p">)</span> <span class="o">:</span> <span class="n">real</span><span class="p">(</span><span class="n">real</span><span class="p">)</span><span class="p">,</span> <span class="n">img</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="n">Complex</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="n">real</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">img</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">Complex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="k">friend</span> <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span><span class="p">;</span>
  <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">println</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">( </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">real</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> , </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">img</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> ) </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">os</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">( </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> , </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> ) </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">img</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="n">Complex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 입력 받은 문자열을 분석하여 real 부분과 img 부분을 찾아야 한다.
</span><span class="c1"></span>  <span class="c1">// 문자열의 꼴은 다음과 같습니다 &#34;[부호](실수부)(부호)i(허수부)&#34;
</span><span class="c1"></span>  <span class="c1">// 이 때 맨 앞의 부호는 생략 가능합니다. (생략시 + 라 가정)
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">begin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="n">img</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="n">real</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="c1">// 먼저 가장 기준이 되는 &#39;i&#39; 의 위치를 찾는다.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">pos_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">i</span><span class="sc">&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pos_i</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 만일 &#39;i&#39; 가 없다면 이 수는 실수 뿐이다.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">pos_i</span> <span class="o">=</span><span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">get_number</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 만일 &#39;i&#39; 가 있다면, 실수부와 허수부를 나누어서 처리하면 된다.
</span><span class="c1"></span>  <span class="n">real</span> <span class="o">=</span> <span class="n">get_number</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">pos_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">img</span> <span class="o">=</span> <span class="n">get_number</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">pos_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pos_i</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">[</span><span class="n">pos_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">-</span><span class="sc">&#39;</span><span class="p">)</span> <span class="n">img</span> <span class="o">*</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="n">get_number</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from</span><span class="p">,</span> <span class="kt">int</span> <span class="n">to</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">minus</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">-</span><span class="sc">&#39;</span><span class="p">)</span> <span class="n">minus</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">-</span><span class="sc">&#39;</span> <span class="o">|</span><span class="o">|</span> <span class="n">str</span><span class="p">[</span><span class="n">from</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">+</span><span class="sc">&#39;</span><span class="p">)</span> <span class="n">from</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">decimal</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">integer_part</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">from</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">to</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">integer_part</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">num</span> <span class="o">*</span><span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
      <span class="n">num</span> <span class="o">+</span><span class="o">=</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">0</span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">.</span><span class="sc">&#39;</span><span class="p">)</span>
      <span class="n">integer_part</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="o">!</span><span class="n">integer_part</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">decimal</span> <span class="o">/</span><span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
      <span class="n">num</span> <span class="o">+</span><span class="o">=</span> <span class="p">(</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">0</span><span class="sc">&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">decimal</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
      <span class="k">break</span><span class="p">;</span>  <span class="c1">// 그 이외의 이상한 문자들이 올 경우
</span><span class="c1"></span>  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">minus</span><span class="p">)</span> <span class="n">num</span> <span class="o">*</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">real</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">img</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">real</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">,</span> <span class="n">img</span> <span class="o">-</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span><span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">,</span> <span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span> <span class="o">+</span> <span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">temp</span><span class="p">(</span>
      <span class="p">(</span><span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">,</span>
      <span class="p">(</span><span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span> <span class="o">*</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">+</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">-</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">*</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">/</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="o">/</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Complex</span><span class="o">&amp;</span> <span class="n">Complex</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">real</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">real</span><span class="p">;</span>
  <span class="n">img</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">img</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Complex</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">-1.1 + i3.923</span><span class="s">&#34;</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">a 의 값은 : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> 이다. </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2716843D521A1746343770' alt=''><p>와 같이 잘 실행됨을 알 수 있습니다.</p><h3><p>  첨자 연산자 (operator[])</p></h3><p>이번에는 배열에서 원소를 지정할 때 사용되는 첨자 연산자 <code class='inline-code'>[]</code> 를 오버로딩 해보도록 합시다. (참고로 왜 첨자 연산자라고 부르냐면, 배열의 원소를 지정할 때 <code class='inline-code'>[]</code> 안에 넣는 수를 첨자(subscript) 라고 부르기 때문입니다)우리가 전에 만들었던 <code class='inline-code'>MyString</code> 클래스에서 개개의 문자에 접근하기 위해 <code class='inline-code'>[]</code> 를 지원해주어야만 하는데요, <code class='inline-code'>[]</code> 를 이용해서 <code class='inline-code'>str[10]</code> 과 같이 10 번째 문자에 정확하게 접근할 수 있게 됩니다.여기서 그렇다면 <code class='inline-code'>MyString</code> 클래스의 <code class='inline-code'>operator[]</code> 를 추가해보도록 합시다. <code class='inline-code'>operator[]</code> 함수는 자명하게도 인자로 몇 번째 문자인지, <code class='inline-code'>int</code> 형 변수를 인덱스로 받게 됩니다. 따라서 <code class='inline-code'>operator[]</code> 는 다음과 같은 원형을 가집니다.</p><pre class="chroma">
<span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span><span class="p">;</span>
</pre><p><code class='inline-code'>index</code> 로 <code class='inline-code'>[]</code> 안에 들어가는 값을 받게 됩니다. 그리고 <code class='inline-code'>char&</code> 를 인자로 리턴하는 이유는</p><pre class="chroma">
<span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">c</span><span class="sc">&#39;</span><span class="p">;</span>
</pre><p>와 같은 명령을 수행하기 때문에, 그 원소의 레퍼런스를 리턴하게 되는 것이지요. 실제로 <code class='inline-code'>opreator[]</code> 의 구현은 아래와 같이 매우 단순합니다.</p><pre class="chroma">
<span class="kt">char</span><span class="o">&amp;</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">string_content</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>
</pre><p>위와 같이 <code class='inline-code'>index</code> 번째의 <code class='inline-code'>string_content</code> 를 리턴해서, <code class='inline-code'>operator[]</code> 를 사용하는 사용자가, 이의 레퍼런스를 가질 수 있게 되지요. 그렇다면, 전체 소스를 한 번 살펴보도록 합시다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">MyString</span> <span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">string_content</span><span class="p">;</span>  <span class="c1">// 문자열 데이터를 가리키는 포인터
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">string_length</span><span class="p">;</span>     <span class="c1">// 문자열 길이
</span><span class="c1"></span>
  <span class="kt">int</span> <span class="n">memory_capacity</span><span class="p">;</span>  <span class="c1">// 현재 할당된 용량
</span><span class="c1"></span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 문자 하나로 생성
</span><span class="c1"></span>  <span class="n">MyString</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 문자열로 부터 생성
</span><span class="c1"></span>  <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 복사 생성자
</span><span class="c1"></span>  <span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>

  <span class="o">~</span><span class="n">MyString</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">length</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">capacity</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">println</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">assign</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">assign</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">char</span> <span class="nf">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span><span class="p">;</span>

  <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">erase</span><span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">find_from</span><span class="p">,</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">find_from</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">find_from</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">compare</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">MyString</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string_content</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="p">;</span>
  <span class="n">string_content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">memory_capacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">string_length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="n">memory_capacity</span> <span class="o">=</span> <span class="n">string_length</span><span class="p">;</span>
  <span class="n">string_content</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">string_length</span><span class="p">]</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">MyString</span><span class="p">(</span><span class="k">const</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string_length</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span>
  <span class="n">string_content</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">string_length</span><span class="p">]</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span>
    <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="o">~</span><span class="n">MyString</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">string_content</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">length</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">string_length</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">print</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">println</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MyString</span><span class="o">&amp;</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">assign</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">string_length</span> <span class="o">&gt;</span> <span class="n">memory_capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 그러면 다시 할당을 해줘야만 한다.
</span><span class="c1"></span>    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">string_content</span><span class="p">;</span>

    <span class="n">string_content</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">]</span><span class="p">;</span>
    <span class="n">memory_capacity</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 그리고 굳이 str.string_length + 1 ~ string_length 부분은 초기화
</span><span class="c1"></span>  <span class="c1">// 시킬 필요는 없다. 왜냐하면 거기 까지는 읽어들이지 않기 때문이다.
</span><span class="c1"></span>
  <span class="n">string_length</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span>

  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">MyString</span><span class="o">&amp;</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">assign</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">str_length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">str_length</span> <span class="o">&gt;</span> <span class="n">memory_capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 그러면 다시 할당을 해줘야만 한다.
</span><span class="c1"></span>    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">string_content</span><span class="p">;</span>

    <span class="n">string_content</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">str_length</span><span class="p">]</span><span class="p">;</span>
    <span class="n">memory_capacity</span> <span class="o">=</span> <span class="n">str_length</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">str_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">string_length</span> <span class="o">=</span> <span class="n">str_length</span><span class="p">;</span>

  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">capacity</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">memory_capacity</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">reserve</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">memory_capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">prev_string_content</span> <span class="o">=</span> <span class="n">string_content</span><span class="p">;</span>

    <span class="n">string_content</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">size</span><span class="p">]</span><span class="p">;</span>
    <span class="n">memory_capacity</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!</span><span class="o">=</span> <span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span>
      <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>

    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">prev_string_content</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 만일 예약하려는 size 가 현재 capacity 보다 작다면
</span><span class="c1"></span>  <span class="c1">// 아무것도 안해도 된다.
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">char</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">string_length</span> <span class="o">|</span><span class="o">|</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">char</span><span class="o">&amp;</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">string_content</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>
<span class="n">MyString</span><span class="o">&amp;</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
</span><span class="c1"></span>  <span class="c1">// abc 라는 문자열에 insert(1, &#34;d&#34;) 를 하게 된다면 adbc 가 된다.
</span><span class="c1"></span>
  <span class="c1">// 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">loc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">|</span><span class="o">|</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="n">string_length</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">string_length</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span> <span class="o">&gt;</span> <span class="n">memory_capacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 이제 새롭게 동적으로 할당을 해야 한다.
</span><span class="c1"></span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memory_capacity</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">string_length</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">)</span>
      <span class="n">memory_capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">elsememory_capacity</span> <span class="o">=</span> <span class="n">string_length</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">prev_string_content</span> <span class="o">=</span> <span class="n">string_content</span><span class="p">;</span>
    <span class="n">string_content</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">memory_capacity</span><span class="p">]</span><span class="p">;</span>

    <span class="c1">// 일단 insert 되는 부분 직전까지의 내용을 복사한다.
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loc</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 그리고 새롭에 insert 되는 문자열을 넣는다.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">!</span><span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">string_content</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_content</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">string_content</span><span class="p">[</span><span class="n">str</span><span class="p">.</span><span class="n">string_length</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">prev_string_content</span><span class="p">;</span>

    <span class="n">string_length</span> <span class="o">=</span> <span class="n">string_length</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 만일 초과하지 않는 경우 굳이 동적할당을 할 필요가 없게 된다.
</span><span class="c1"></span>  <span class="c1">// 효율적으로 insert 하기 위해, 밀리는 부분을 먼저 뒤로 밀어버린다.
</span><span class="c1"></span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">string_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">loc</span><span class="p">;</span> <span class="n">i</span><span class="o">-</span><span class="o">-</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 뒤로 밀기. 이 때 원래의 문자열 데이터가 사라지지 않게 함
</span><span class="c1"></span>    <span class="n">string_content</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 그리고 insert 되는 문자 다시 집어넣기
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span>
    <span class="n">string_content</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">loc</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>

  <span class="n">string_length</span> <span class="o">=</span> <span class="n">string_length</span> <span class="o">+</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">MyString</span><span class="o">&amp;</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MyString</span> <span class="n">temp</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">MyString</span><span class="o">&amp;</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MyString</span> <span class="n">temp</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MyString</span><span class="o">&amp;</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">erase</span><span class="p">(</span><span class="kt">int</span> <span class="n">loc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// loc 의 앞 부터 시작해서 num 문자를 지운다.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">|</span><span class="o">|</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">|</span><span class="o">|</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="n">string_length</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

  <span class="c1">// 지운다는 것은 단순히 뒤의 문자들을 앞으로 끌고 온다고
</span><span class="c1"></span>  <span class="c1">// 생각하면 됩니다.
</span><span class="c1"></span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string_content</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">string_length</span> <span class="o">-</span><span class="o">=</span> <span class="n">num</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">find_from</span><span class="p">,</span> <span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">string_length</span> <span class="o">=</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">find_from</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">string_length</span> <span class="o">-</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">string_content</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">!</span><span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_content</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span><span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">)</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// 찾지 못했음
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">int</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">find_from</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MyString</span> <span class="n">temp</span><span class="p">(</span><span class="n">str</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">find_from</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">find_from</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MyString</span> <span class="n">temp</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">find</span><span class="p">(</span><span class="n">find_from</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">MyString</span><span class="o">:</span><span class="o">:</span><span class="n">compare</span><span class="p">(</span><span class="n">MyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// (*this) - (str) 을 수행해서 그 1, 0, -1 로 그 결과를 리턴한다
</span><span class="c1"></span>  <span class="c1">// 1 은 (*this) 가 사전식으로 더 뒤에 온다는 의미. 0 은 두 문자열
</span><span class="c1"></span>  <span class="c1">// 이 같다는 의미, -1 은 (*this) 사 사전식으러 더 앞에 온다는 의미이다.
</span><span class="c1"></span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">string_length</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">)</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">str</span><span class="p">.</span><span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span>
      <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">string_content</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 여기 까지 했는데 끝나지 않았다면 앞 부분 까지 모두 똑같은 것이 된다.
</span><span class="c1"></span>  <span class="c1">// 만일 문자열 길이가 같다면 두 문자열은 아예 같은 문자열이 된다.
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">string_length</span> <span class="o">=</span><span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 참고로 abc 와 abcd 의 크기 비교는 abcd 가 더 뒤에 오게 된다.
</span><span class="c1"></span>  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">string_length</span> <span class="o">&gt;</span> <span class="n">str</span><span class="p">.</span><span class="n">string_length</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MyString</span> <span class="n">str</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">abcdef</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
  <span class="n">str</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">c</span><span class="sc">&#39;</span><span class="p">;</span>

  <span class="n">str</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F214AAE41521E0EB60BE46C' alt=''><p>와 같이 제대로 <code class='inline-code'>str[3]</code> 의 'd' 를 'c' 로 잘 바꾸었음을 알 수 있습니다.</p><p>이 정도만 하면 <code class='inline-code'>MyString</code> 클래스는 거의 왠만한 문자열 클래스 뺨치게 완전한 모습을 갖추었다고 볼 수 있습니다. 문자열 삽입, 삭제, 대입 뿐만이 아니라 개개의 문자의 조작 까지 원활하게 수행할 수 있는 훌륭한 문자열 클래스라고 할 수 있지요.</p><h3><p>  int <code class='inline-code'>Wrapper</code> 클래스 <code class='inline-code'>-</code> 타입 변환 연산자</p></h3><p><code class='inline-code'>Wrapper</code> 라는 것은 원래 우리가 흔히 음식을 포장할 때 '랩(wrap)으로 싼다' 라고 하는 것 처럼, '포장지' 라는 의미의 단어 입니다. 즉 <code class='inline-code'>Wrapper</code> 클래스는 무언가를 포장하는 클래스라는 의미인데, C++ 에서 프로그래밍을 할 때 어떤 경우에 기본 자료형들을 객체로써 다루어야 할 때가 있습니다. 이럴 때, 기본 자료형들 (int, float 등등) 을 클래스로 포장해서 각각의 자료형을 객체로 사용하는 것을 <code class='inline-code'>Wrapper</code> 클래스를 이용한다는 뜻 입니다.즉, <code class='inline-code'>int</code> 자료형을 감싸는 int Wrapper 클래스 <code class='inline-code'>Int</code> 는 다음과 같이 구성할 수 있습니다.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Int</span>

<span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="c1">// some other data
</span><span class="c1"></span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Int</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="n">Int</span><span class="p">(</span><span class="k">const</span> <span class="n">Int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>위 <code class='inline-code'>Int</code> 클래스에 <code class='inline-code'>int</code> 형 자료형을 보관하는 <code class='inline-code'>data</code> 라는 변수를 정의해 놓았는데, 이렇게 한다면 <code class='inline-code'>int</code> 형 데이터를 저장하는 객체로 <code class='inline-code'>Int</code> 클래스를 사용할 수 있을 것입니다. 우리는 이 <code class='inline-code'>Int</code> 객체가 <code class='inline-code'>int</code> 의 <code class='inline-code'>Wrapper</code> 클래스의 객체인 만큼, <code class='inline-code'>int</code> 와 정확히 똑같이 작동하도록 만들고 싶습니다. 다시 말해서 다음과 같은 명령을 내려도 아무 하자 없이 잘 실행될 수 있도록 말이지요.</p><pre class="chroma">
<span class="n">Int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>      <span class="c1">// Wrapper 객체
</span><span class="c1"></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>  <span class="c1">// 그냥 평범한 int 형 변수 a
</span><span class="c1"></span></pre><p>이를 잘 수행하기 위해서라면, 여태까지 연산자 오버로딩을 열심히 배워오신 여러분 생각이라면</p><p>그렇다면 <code class='inline-code'>int</code> 변수에 사용되는 모든 연산자 함수들을 만들어주면 되겠군!</p><p>이라고 생각이 들 것입니다. 물론, 이렇게 해도 잘 작동하는 <code class='inline-code'>Wrapper</code> 클래스를 만들 수 있을 것입니다. 하지만, 그 수 많은 연산자들을 일일히 오버로딩을 하는 것은 정말로 고통스러운 일이 아닐 수 없습니다. 왜 이러한 일이 고통스러운 것이냐면, <code class='inline-code'>Complex</code> 클래스를 만들 때만 해도, <code class='inline-code'>Complex</code> 객체에서 + 나 <code class='inline-code'>-</code> 연산자가 하는 일 자체가 <code class='inline-code'>int</code> 변수 끼리 하는 일과 완전히 달랐기 때문에 반드시 <code class='inline-code'>operator+</code> 나 <code class='inline-code'>operator-</code> 등을 만들어주어야만 했을 것입니다. 하지만 이 <code class='inline-code'>int Wrapper</code> 클래스 객체끼리 하는 일은 그냥 단순히 <code class='inline-code'>int</code> 형 변수 끼리 하는 일과 정확히 똑같기 때문에 굳이 이미 제공하는 기능을 다시 만들어야 한다는 점이지요.</p><p>그렇다면, 그냥 이 <code class='inline-code'>Wrapper</code> 클래스의 객체를 마치 'int 형 변수' 라고 컴파일러가 생각할 수 는 없는 것일까요. 물론 가능합니다. 왜냐하면 우리에게는 타입 변환 연산자가 있기 때문이지요. 만일 컴파일러가 이 클래스의 객체를 <code class='inline-code'>int</code> 형 변수로 변환할 수 있다면, 비록 <code class='inline-code'>operator+</code> 등을 정의하지 않더라도 컴파일러가 가장 이 객체를 <code class='inline-code'>int</code> 형 변수로 변환 한 다음에 <code class='inline-code'>+</code> 를 수행할 수 있기 때문입니다.</p><p>타입 변환 연산자는 다음과 같이 정의합니다.</p><pre class='info'>
operator(변환 하고자 하는 타입)()
</pre><p>예를 들어 우리의 <code class='inline-code'>int Wrapper</code> 클래스의 경우 다음과 같은 타입 변환 연산자를 정의할 수 있지요.</p><pre class="chroma">
<span class="k">operator</span> <span class="kt">int</span><span class="p">(</span><span class="p">)</span>
</pre><p>한 가지 주의할 점은, 생성자 처럼 함수의 리턴 타입을 써주시면 안됩니다. 이는 C++ 에서 변환 연산자를 정의하기 위한 언어 상의 규칙이라고도 볼 수 있습니다. 그렇게 된다면, 우리의 <code class='inline-code'>int</code> 변환 연산자는 다음과 같이 간단하게 구성할 수 있겠지요.</p><pre class="chroma">
<span class="k">operator</span> <span class="nf">int</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
</pre><p>그냥 단순히 <code class='inline-code'>data</code> 를 리턴해주면 됩니다. 그렇게 된다면 우리의 <code class='inline-code'>Wrapper</code> 클래스의 객체를 '읽는' 데에는 아무런 문제가 없게 됩니다. 왜냐하면 컴파일러 입장에서 적절한 변환 연산자로 <code class='inline-code'>operator int</code> 를 찾아서 결국 <code class='inline-code'>int</code> 로 변환해서 처리하기 때문이지요. 다만 문제는 '대입' 시에 발생하는데, 다행이도 디폴트 대입 연산자가 이 역시 알아서 잘 처리할 것이기 때문에 걱정 안하셔도 됩니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Int</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
  <span class="c1">// some other data
</span><span class="c1"></span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Int</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="n">Int</span><span class="p">(</span><span class="k">const</span> <span class="n">Int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

  <span class="k">operator</span> <span class="kt">int</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>

  <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F23729548521E20860F2135' alt=''><p>와 같이 <code class='inline-code'>Int</code> 객체가 <code class='inline-code'>int</code> 변수 처럼 정확히 동일하게 작동되고 있음을 알 수 있습니다.</p><h3><p>  전위/후위 증감 연산자</p></h3><p>마지막으로 살펴볼 연산자로 우리가 흔히 <code class='inline-code'>++, --</code> 로 사용하는 전위/후위 증감 연산자들 입니다. 아마, 이 연산자를 오버로딩 하기 전에 한 가지 궁금증이 드셨을 텐데요, 과연 C++ 컴파일러는 전위/후위 증감을 구분 해서 오버로딩 시켜주냐 입니다. 다시 말해;</p><pre class="chroma">
<span class="n">a</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="o">+</span><span class="o">+</span><span class="n">a</span><span class="p">;</span>
</pre><p>위 두 <code class='inline-code'>++</code> 연산자들을 구분해서 오버로딩을 시켜주냐 이말이죠. 사실 우리가 흔히 생각하기에 <code class='inline-code'>++</code> 연산자는 그냥 1 증가 시켜주는 1 개의 연산자라고 볼 수 있겠지만 놀랍게도 C++ 에서는 <code class='inline-code'>++</code> 연산자를 전위와 후위를 구분해서 오버로딩 할 수 있도록 제공하고 있습니다. 그렇다면요, 이 둘을 도대체 어떻게 구분할 수 있을까요?</p><p><code class='inline-code'>C++</code> 언어에서는 다음과 같은 재미있는 방법으로 구분합니다. 일단 C++ 언어에서는 다음과 같은 재미있는 방법으로 구분합니다. 일단;</p><pre class="chroma">
<span class="k">operator</span><span class="o">+</span><span class="o">+</span><span class="p">(</span><span class="p">)</span> <span class="k">operator</span><span class="o">-</span><span class="o">-</span><span class="p">(</span><span class="p">)</span>
</pre><p>은 전위 증감 연산자 (++x, --x) 를 오버로딩 하게 됩니다. 그렇다면 후위 증감 연산자 (x ++, x--) 는 어떨까요. 바로</p><pre class="chroma">
<span class="k">operator</span><span class="o">+</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="k">operator</span><span class="o">-</span><span class="o">-</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</pre><p>로 구현하게 됩니다. 물론 인자 <code class='inline-code'>x</code> 에는 0 이 들어가게 됩니다. 즉 단순히 전위와 후위를 구별하기 위해 인자로 <code class='inline-code'>x</code> 를 넣어주는 것이지요. 실제로 <code class='inline-code'>++</code> 을 구현하면서 인자로 들어가는 값을 사용하는 경우는 없습니다. 한 가지 주목할 점은 많은 경우 전위 증감이 후위 증감 보다 더 빠르기 때문에 (물론, 엄청나게 빠르다는 것이 아니라 후위 증감 자체가 약간의 연산을 더 수행하게 됩니다) 후위/전위 증감 중 무엇을 사용하던 상관이 없는 경우 (예를 들어서 <code class='inline-code'>for</code> 문에서 <code class='inline-code'>i ++</code> 을 한 다던지) 되도록이면 전위 증감을 사용하는 것이 바람직 합니다만, 클래스를 사용하는 사용자의 입장에서는 두 개 모두 지원해야 하므로 우리는 둘 다 만들어야 하겠지요.</p><p>따라서 아래와 같은 테스트 클래스를 제작하였습니다.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Test</span>

<span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="n">Test</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+</span><span class="o">+</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">전위 증감 연산자</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Test</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">후위 증감 연산자</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>클래스 자체에는 별거 없지만 전위와 후위가 호출될 때를 구별하기 위해 메세지를 출력하도록 하였습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Test</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="n">Test</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+</span><span class="o">+</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">전위 증감 연산자</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Test</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">후위 증감 연산자</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Test</span> <span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>

  <span class="n">x</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="o">+</span><span class="o">+</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2775AA35521E26D0278F37' alt=''><p>와 같이 제대로 골라서 실행되고 있음을 알 수 있습니다.</p><h3><p>  정리</p></h3><p>연산자 오버로딩에 대해 다루면서 몇 가지 중요한 포인트 들만 따로 정리해보자면;<span class='font-italic'> 두 개의 동등한 객체 사이에서의 이항 연산자는 멤버 함수가 아닌외부 함수로 오버로딩 하는 것이 좋습니다. (예를 들어 <code class='inline-code'>Complex</code> 의 <code class='inline-code'>operator+(const Complex&, const Complex&)</code> 와 같이 말입니다. <code class='inline-code'>)</code></p><ul><li><p> 두 개의 객체 사이의 이항 연산자 이지만 한 객체만 값이 바뀐다던지 등의동등하지 않는 이항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다. (예를 들어서 <code class='inline-code'>operator+=</code> 는 이항 연산자 이지만 <code class='inline-code'>operator+=(const Complex&)</code> 가 낫다)</p></li><li><p> 단항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다 (예를 들어 <code class='inline-code'>operator++</code> 의 경우 멤버 함수로 오버로딩 합니다)</p></li><li><p> 일부 연산자들은 반드시 멤버 함수로만 오버로딩 해야 합니다 (강좌 앞 부분 참고)자, 이것으로 가장 많이 사용되는 연산자 함수들에 대해 알아보았습니다. 이제 슬슬 C++ 언어의 강력함이 느껴지시나요? 다음 강좌에서는 여태까지 배운 내용들을 총 망라하는 조그마한 프로젝트를 해볼려고 합니다. 그 프로젝트는 아래 '생각해보기'에 나와 있는데요, 다음 강좌를 보기 전 까지 아래 문제를 한 번 해결해 보시기 (해결은 못해도 최소한 노력은 하시기<code class='inline-code'>)</code> 바랍니다.</p></li></ul><h3><p>  생각해보기</p></h3><p><code class='inline-code'>1. N</code> 차원 배열을 제공하는 클래스를 만들어보세요. 이는 여러분이 여태까지 배운 내용을 시험할 것입니다. 참고로, 원소에 접근하기 위해서는 <code class='inline-code'>a[1][2][3]</code> 과 같은 방법으로 접근하겠지요. 다만 <code class='inline-code'>N</code> 차원 배열이기 때문에 (N은 객체 생성시에 사용자가 입력합니다) 2 차원 배열은 <code class='inline-code'>a[1][2], 3</code> 차원 배열은 <code class='inline-code'>a[1][2][3]</code> 과 같은 방식으로 접근할 것입니다. (난이도 : 最上)<code class='inline-code'>2.</code> 영어를 잘하시는 분들은 연산자 오버로딩에 관해 정리해 놓은 다음 글을 읽어보시기를 추천합니다. 참고로 이 글에서 다루지만 본 강좌에서는 다루지 않는 일부 내용들은 아직 배운 내용이 아니라 생략한 것이므로 너무 걱정하지 마시고 복습하는 느낌으로 천천히 읽어보시면 좋습니다. (난이도 : 中)<code class='inline-code'>&gt;&gt;</code> <a href='http://stackoverflow.com/questions/4421706/operator-overloading'>http://stackoverflow.com/questions/4421706/operator-overloading</a></p><pre class='warning'>강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면꼭 댓글을 남겨주시기 바랍니다. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요.

현재 여러분이 보신 강좌는<<씹어먹는 C++ - <5 - 2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩>>> 입니다. 이번 강좌의모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전까지 다음 강좌로 넘어가지 말아주세요


[다음 강좌 보러가기](http://itguru.tistory.com/135)
</pre>