<pre class='warning'>이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
</pre><pre class='info'>아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
</pre><p><code class='inline-code'>vector</code></p><p>벡터(vector) 는 헤더파일 <code class='inline-code'>&lt;vector&gt;</code> 에 정의되어 있는 는 순차 컨테이너의 한 종류로, 각각의 원소들이 선형으로 배열되어 있다.</p><p>  벡터 컨테이너는 동적 배열로 구현되는데, 보통의 배열 처럼 벡터 컨테이너들도 각각의 원소들이 메모리 상에서 연속적으로 존재하게 된다. 이 때문에 벡터 컨테이너의 원소를 참조할 때 반복자(iterator) 을 이용해서 순차적으로 참조할 수 있고, 처음 원소의 부터의 상대적인 거리를 이용하여 접근할 수 도 있다.</p><p>  하지만, 보통의 배열과는 달리 벡터 컨테이너는 스스로 공간을 할당하고, 크기를 확장할 수 있고, 또 줄일 수 도 있다.</p><p>  벡터 컨테이너는 아래와 같은 장점을 가지고 있다.</p><ul><li><p>  각각의 원소를 원소의 인덱스(index) 값으로 바로 참조 가능하다 (상수 시간이 소요)</p></li><li><p>  원소들을 임의의 순서로 접근할 수 있다. (선형 시간 소요)</p></li><li><p>  벡터 끝에 새로운 원소를 추가하거나 제거하기 (상수 시간 소요 <code class='inline-code'>- constant amortized time</code><a href='#footnote_175_1'>[각주:</a><code class='inline-code'>1 1</code>]<span class='font-weight-bold'>)</p></li></ul><p>  벡터는 배열이 제공하는 거의 모든 기능을 다 가지고 있다. 게다가, 벡터 컨테이너의 크기는 쉽게 조정될 수 있기 때문에 매우 용이하다. 하지만 이러한 장점들 때문에 보통의 배열보다 더 많은 메모리 공간을 필요로 한다는 단점이 있다.  다른 표준 순차 컨테이너 ( <a href='http://itguru.tistory.com/176'>deque</a><code class='inline-code'>,</code> <a href='http://itguru.tistory.com/177'>list</a><code class='inline-code'>)</code> 와 비교해 볼 때, 벡터는 원소에 접근하는 시간이나, 컨테이너의 끝에 새로운 원소를 삽입/삭제 하는데 매우 효율적이다. 반면에 끝이 아닌 중간에 새로운 원소를 삽입하는 작업은 <a href='http://itguru.tistory.com/176'>deque</a>나 <a href='http://itguru.tistory.com/177'>list</a>에 비해 느리다.</p><p>  벡터 컨테이너는 내부적으로 공간을 관리하기 위해 두 개의 변수를 사용한다. 하나는 <code class='inline-code'>size</code> 로 vector::size 함수를 통해서 그 값을 얻을 수 있는데, 이는 현재 벡터에 보관되어 있는 원소의 개수를 의미한다. 다른 하나는 <code class='inline-code'>capacity</code> 로 vector::capacity 함수를 통해서 그 값을 얻을 수 있는데, 이는 벡터에 할당된 공간의 크기를 의미한다. 따라서 당연하게도, <code class='inline-code'>capacity</code> 의 크기는 항상 <code class='inline-code'>size</code> 보다 크게 조정되며, 만일 원소를 추가해서 <code class='inline-code'>size</code> 의 크기가 <code class='inline-code'>capacity</code> 를 넘어가 버리면 벡터 내부적으로 추가적인 공간을 할당하게 된다. 이 때 추가적으로 할당되는 공간은 많은 경우 현재 벡터 <code class='inline-code'>capacity</code> 만큼 할당되어서 (즉, 전체 할당 크기가 이전의 두 배가 됨) 메모리 할당을 빈번하게 하는 경우를 최대한 줄이고, 사용하는 메모리 양도 줄이도록 최적화되어 있다.</p><p>  벡터의 <code class='inline-code'>capacity</code> 를 확장하는 작업은 꽤 많은 시간을 필요로 하는 작업이기 때문에 (왜냐하면 일단 메모리를 새로 할당해야 하고, 벡터의 내용을 새로운 장소에 복사해야 하기 때문이다) 만일 최적화가 필요한 경우 사용자는 직접 vector::reserve 함수를 이용해서 <code class='inline-code'>capacity</code> 를 미리 크게 할당해 놓을 수 있다.</p><p>  C++ 표준 템플릿 라이브러리 (STL) 에서는 벡터를 다음과 같이 두 개의 템플릿 인자를 가지도록 구현하였다.</p><pre class="chroma"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">Allocator</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">vector</span><span class="p">;</span>
</pre><p>  이 때 각각의 템플릿 인자는 다음을 의미한다.</p><ul><li><p> <code class='inline-code'>T</code> : (보관하려는) 원소의 타입</p></li><li><p> <code class='inline-code'>Allocator</code> : 어떠한 방식으로 메모리를 할당할지에 관련한 할당자(allocator) 타입을 나타낸다. 기본값으로 <code class='inline-code'>T</code> 의 할당자 클래스 템플릿을 사용하며, <code class='inline-code'>Heap</code> 에 할당하게 된다. 많은 경우 인자를 생략한다.</p></li></ul><h3><p>  벡터의 멤버 함수</p></h3><ul><li><p>  <a href='http://itguru.tistory.com/178'>생성자</a><span class='font-weight-bold'> : 벡터를 생성한다.</p></li><li><p> 소멸자 : 벡터를 소멸한다.</p></li><li><p> <code class='inline-code'>operator=</code> : 벡터의 내용을 복사한다.</p></li></ul><p>반복자 (Iterators)</p><ul><li><p> <code class='inline-code'>begin</code> : 시작 부분 (벡터의 첫번째 원소) 을 가리키는 반복자를 리턴한다.</p></li><li><p> <code class='inline-code'>end</code> : 끝 부분 (벡터의 마지막 원소 바로 다음) 을 가리키는 반복자를 리턴한다.</p></li><li><p> <code class='inline-code'>rbegin</code> : 역순으로 첫번째 (즉, 벡터의 마지막 원소) 를 가리키는 반복자를 리턴한다.</p></li><li><p> <code class='inline-code'>rend</code> : 역순으로 끝 부분 (즉, 벡터의 첫번째 원소 바로 이전) 을 가리키는 반복자를 리턴한다.</p></li></ul><p>할당 관련</p><ul><li><p> <code class='inline-code'>size</code> : 벡터의 <code class='inline-code'>size</code> 를 리턴한다 (현재 원소의 개수)</p></li><li><p> <code class='inline-code'>max_size</code> : 벡터 최대 크기를 리턴한다.</p></li><li><p> <code class='inline-code'>resize</code> : 벡터가 <code class='inline-code'>size</code> 개의 원소를 포함하도록 변경한다.</p></li><li><p> <code class='inline-code'>capacity</code> : 벡터에 할당된 전체 크기를 리턴한다.</p></li><li><p> <code class='inline-code'>empty</code> : 벡터가 비었는지 체크한다.</p></li><li><p> <code class='inline-code'>reserve</code> : 벡터에 할당된 크기를 변경한다.</p></li></ul><p>원소 접근 관련</p><ul><li><p> <code class='inline-code'>operator[]</code> : 원소에 접근한다.</p></li><li><p> <code class='inline-code'>at</code> : 원소에 접근한다.</p></li><li><p> <code class='inline-code'>front</code> : 첫번째 원소에 접근한다.</p></li><li><p> <code class='inline-code'>back</code> : 마지막 원소에 접근한다.</p></li></ul><p>수정자 (Modifier)</p><ul><li><p>  <a href='http://itguru.tistory.com/183'>assign</a><span class='font-weight-bold'> : 벡터의 원소를 집어넣는다.</p></li><li><p>  <a href='http://itguru.tistory.com/185'>push_back</a><span class='font-weight-bold'> : 벡터 끝에 원소를 집어 넣는다.</p></li><li><p> <code class='inline-code'>pop_back</code> : 마지막 원소를 제거한다.</p></li><li><p>  <a href='http://itguru.tistory.com/186'>insert</a><span class='font-weight-bold'> : 벡터 중간에 원소를 추가한다.</p></li><li><p> <code class='inline-code'>erase</code> : 원소를 제거한다.</p></li><li><p> <code class='inline-code'>swap</code> : 다른 벡터와 원소를 바꿔치기 한다.</p></li><li><p> <code class='inline-code'>clear</code> : 원소를 모두 제거한다.</p></li></ul><p>할당자</p><ul><li><p> <code class='inline-code'>get_allocator</code> : 할당자(allocator) 을 얻는다.</p></li></ul><h3><p>  멤버 변수들</p></h3><ul><li><p> <code class='inline-code'>reference</code> : Allocator::reference</p></li><li><p> <code class='inline-code'>const_reference</code> :  Allocator::const<span class='font-italic'>reference</p></li><li><p> <code class='inline-code'>iterator</code> :  임의 접근 반복자(random <code class='inline-code'>access iterator)</code></p></li><li><p> <code class='inline-code'>const_iterator</code> : 상수 임의 접근 반복자 (즉, 접근하는 원소의 내용을 수정 못함)</p></li><li><p> <code class='inline-code'>size_type</code> : 벡터 <code class='inline-code'>size</code> 를 나타내는 타입 (많은 경우 <code class='inline-code'>size_t</code> 와 타입이 같으며 부호없는 정수이다)</p></li><li><p> <code class='inline-code'>difference_type</code> : 벡터 내의 두 원소 사이의 거리를 나타내는 타입 (많은 경우 <code class='inline-code'>ptfdiff_t</code> 와 타입이 같으며 부호있는 정수)</p></li><li><p> <code class='inline-code'>value_type</code> : 원소 타입 (T)</p></li><li><p> <code class='inline-code'>allocator_type</code> : 할당자</p></li><li><p> <code class='inline-code'>pointer</code> : 포인터 (Allocator::pointer)</p></li><li><p> <code class='inline-code'>const_pointer</code> : 상수 포인터 (Allocator::const<span class='font-italic'>pointer)</p></li><li><p> <code class='inline-code'>reverse_iterator</code> :  역 반복자 (끝에서 부터 참조해나간다) <code class='inline-code'>reverse_iterator&lt;iterator&gt;</code></p></li><li><p> <code class='inline-code'>const_reverse_iterator</code> :  상수 역 반복자 (reverse<span class='font-italic'>iterator<const</span>iterator>)</p></li></ul><h3><p>  템플릿 특수화 (template specialization)</p></h3><p>  벡터 템플릿 클래스는 특별히 <code class='inline-code'>bool</code> 타입에 대한 템플릿 특수화(specialization)를 가지고 있다.</p><p>  <code class='inline-code'>bool</code> 만 특별하게 특수화 시킨 이유는 메모리 공간을 최적화 하기 위해 <code class='inline-code'>bool</code> 원소가 한 개의 비트만 사용하도록 설계하였기 때문이다. (C++ 에서 최소 자료형의 크기는 8 비트 이다 - 즉 실제 bool 객체는 8 비트를 차지한다. ) 따라서 <code class='inline-code'>bool</code> 원소의 레퍼런스는 <code class='inline-code'>bool&</code> 가 아니라, 아래와 같이 <code class='inline-code'>vector&lt;bool&gt;</code> 에 특별히 정의되어 있는 멤버 변수를 통해 <code class='inline-code'>vector&lt;bool&gt;</code> 의 단일 비트에 대한 조작을 수행할 수 있게 된다.</p><pre class="chroma"><span class="k">class</span><span class="err"> </span><span class="nc">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">reference</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span><span class="err"> </span><span class="nc">vector</span><span class="p">;</span>
  <span class="n">reference</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// public 생성자가 아니다
</span><span class="c1"></span> <span class="k">public</span><span class="o">:</span>
  <span class="o">~</span><span class="n">reference</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">operator</span> <span class="nf">bool</span><span class="p">(</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>                     <span class="c1">// bool 로 캐스팅 한다.
</span><span class="c1"></span>  <span class="n">reference</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kt">bool</span> <span class="n">x</span><span class="p">)</span><span class="p">;</span>        <span class="c1">// bool 을 대입
</span><span class="c1"></span>  <span class="n">reference</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">reference</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// 비트로 대입
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">flip</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// 비트값 반전 (0 -&gt; 1, 1 -&gt; 0)
</span><span class="c1"></span><span class="p">}</span>
</pre><p>   이와 비슷한 컨테이너로 <code class='inline-code'>bitset</code> 이 있다.</p><ol><li><p> 동적 배열 끝에 새로운 원소를 추가하는 경우를 생각해보자. 만일 이미 공간 자체가 할당되어 있으면 새로운 원소를 추가하는 일은 <code class='inline-code'>O(1)</code> 일 것이다. 하지만, 공간이 할당되어 있지 않다면, 보통 2 배의 공간으로 다시 할당하게 되는데 이 때 시간이 <code class='inline-code'>O(n)</code> 정도 들어가게 된다. 따라서 전체 평균적으로 볼 때 <code class='inline-code'>O(1)</code> 정도의 상수 시간이 걸린다고 볼 수 있고 이러한 형태의 소요 시간을 <code class='inline-code'>constant amortized time</code> 이라고 부른다.[[본문으로]](#footnote<span class='font-italic'>link</span>175<span class='font-italic'>1)</p></li></ol>