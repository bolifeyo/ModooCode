<pre class='warning'>이 레퍼런스의 모든 내용은 [http://www.cplusplus.com/reference/iostream/](http://www.cplusplus.com/reference/iostream/) 의 내용을 기초로 하여, Microsoft 의 MSDN 과 Bjarne Stroustrup 의 책 <<The C++ Programming Language>> 를 참고로 하여 만들어졌습니다. 이는 또한 저의 개인적인 C++ 능력 향상과 ' [저의 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를 위해 모든 이들에게 공개하도록 하겠습니다.
</pre><pre class='info'>아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
</pre><p>vector::insert</p><pre class='info'>
iterator insert(iterator position, const T& x);
void insert(iterator position, size_type n, const T& x);
template <class InputIterator>
void insert(iterator position, InputIterator first, InputIterator last);
</pre><p>원소를 추가한다.특정 위치에 원소를 추가함으로써 벡터가 확장된다.</p><p>이 함수는 벡터의 크기를 효과적으로 증가시키는데, 만일 새로운 벡터의 size 가 현재 벡터의 <code class='inline-code'>capacity</code> 보다 크다면 재할당을 하게 된다. 재할당 시, 벡터 컨테이너의 이전에 얻은 모든 반복자(iterator), 레퍼런스들은 무효화 된다.</p><p>벡터는 배열의 형태로 저장되기 때문에 벡터 끝이 아닌 임의의 위치에 원소를 삽입하게 되면 그 뒤에 있는 원소들을 뒤로 이동시키게 된다. 따라서벡터에서 원소들 중간에 새로운 원소들을 삽입하는 일은 그다시 효율적이지 못하다<code class='inline-code'>.</code> 따라서 이러한 작업을 많이 하게 된다면 다른 순차 컨테이너  . 따라서 이러한 작업을 많이 하게 된다면 다른 순차 컨테이너 ( <a href='http://itguru.tistory.com/176'>deque</a><code class='inline-code'>,</code> <a href='http://itguru.tistory.com/177'>list</a><code class='inline-code'>)</code> 를 참고하기 바란다.</p><h3><p>  인자</p></h3><p><code class='inline-code'>position</code>새로운 원소가 추가될 위치<code class='inline-code'>iterator</code> 은 멤버 타입으로 임의 접근 반복자 타입(random <code class='inline-code'>access iterator</code> type) 이다.<code class='inline-code'>x</code>삽입할 원소의 값으로 <code class='inline-code'>T</code> 형이다. (T 는 벡터에 삽입되는 원소들의 타입)<code class='inline-code'>n</code>삽입할 원소의 수. 각 원소들은 같은 값 <code class='inline-code'>x</code> 로 초기화된다.멤버 타입 <code class='inline-code'>size_type</code> 은 부호 없는 정수 이다.<code class='inline-code'>first, last</code>특정 범위의 원소들을 지칭하는 반복자이다. <code class='inline-code'>first</code> 에서 <code class='inline-code'>last</code> 전 까지의 원소들을 <code class='inline-code'>position</code> 에 삽입하게 된다. 한 가지 주의할 것은 <code class='inline-code'>first</code> 에서 <code class='inline-code'>last</code> 까지가 아닌 <code class='inline-code'>last</code> 직전 까지의 원소들이다. 즉 <code class='inline-code'>last</code> 번째의 원소는 삽입되지 않는다.</p><h3><p>  리턴값</p></h3><p><code class='inline-code'>iterator insert ( iterator position, const T& x );</code> 함수만 리턴값이 있는데 이는 새롭게 추가된 원소를 가리키는 반복자를 리턴한다.만일 재할당이 일어나게 되면 Allocator::allocate() 를 이용해서 할당을 하게 되는데 성공적으로 할당이 되지 않았을 경우 예외를 던지(throw) 게 된다. 디폴트 할당자의 경우 <code class='inline-code'>bad_alloc</code> 을 던진다.</p><h3><p>  실행 예제</p></h3><pre class="chroma">
<span class="cm">/*
</span><span class="cm">
</span><span class="cm">
</span><span class="cm">이 예제는
</span><span class="cm">[http://www.cplusplus.com/reference/stl/vector/insert/](http://www.cplusplus.com/reference/stl/vector/insert/)
</span><span class="cm">에서 가져왔습니다
</span><span class="cm">
</span><span class="cm">
</span><span class="cm">*/</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvector</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">iterator</span> <span class="n">it</span><span class="p">;</span>

  <span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span><span class="p">;</span>

  <span class="n">myvector</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// &#34;it&#34; no longer valid, get a new one:
</span><span class="c1"></span>  <span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">anothervector</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span><span class="p">;</span>
  <span class="n">myvector</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">anothervector</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">anothervector</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">myarray</span><span class="p">[</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">501</span><span class="p">,</span> <span class="mi">502</span><span class="p">,</span> <span class="mi">503</span><span class="p">}</span><span class="p">;</span>
  <span class="n">myvector</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">myarray</span><span class="p">,</span> <span class="n">myarray</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">myvector contains:</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">it</span> <span class="o">&lt;</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">it</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>실행 결과</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1243AE4F501DDDF2111AAA' alt=''><h3><p>  시간 복잡도</p></h3><p>삽입 이후의 벡터의 크기가 삽입 이전에 결정될 수 있다면 입력되는 원소의 개수와 (복사 생성) 삽입 위치 뒤에 있는 원소들의 개수 (이동 연산) 의 합에 선형으로 비례한다.만일 삽입 이후의 벡터의 크기가 결정될 수 없다면 삽입 이전에 결정되지 않는다면 (이는<code class='inline-code'>void insert ( iterator position, InputIterator first, InputIterator last );</code> 함수에서 <code class='inline-code'>InputIterator</code> 가 순방향, 양방향, 임의 접근 반복자 모두가 아닐 경우) 삽입되는 원소의 수와 삽입 위치 뒤에 있는 원소의 개수의 곱에 비례한다.</p><h3><p>  연관된 함수</p></h3><ul><li><p>  <a href='http://itguru.tistory.com/185'>vector::push_back</a><span class='font-weight-bold'> : 벡터 끝에 원소를 추가한다.</p></li><li><p> vector::erase :원소를 삭제한다.</p></li></ul>