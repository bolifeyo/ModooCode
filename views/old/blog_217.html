<p>이번 강좌에서는<span class='font-italic'> Excel 만들기 프로젝트의 1번째 문제를 해결할 것입니다.</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F23028D4E578CB8DE297D47' alt=''><p>안녕하세요 여러분! 이번 강좌에서는 여태 까지 배운 내용들을 바탕으로 하나의 작은 C++ 프로젝트를 진행해볼 예정입니다. 지난번 강좌의 생각해보기에서 공지하기는 했지만, 바로 콘솔로 Excel 을 만드는 것입니다. 물론 마이크로소프트의 그것 처럼 거대하게 만들 수 는 없지만, 그래도 기본적인 것들은 지원 할 수 있는 형태로 만들어 볼 예정입니다. </p><p>본격적으로 Excel 을 구현하기에 앞서서, 몇 가지 자료 구조를 만들 것입니다. 자료구조라고 함은, 컴퓨터에서 데이터를 저장하는 방식이라 할 수 있는데, 그 구현에 따라서 장단점이 각각 있습니다. (장점만을 가진 자료 구조는 없습니다. 항상 무언가를 위해서 다른 무언가를 포기해야 되는 법이지요)</p><p>이 Excel 프로그램에서 사용할 자료구조는 크게 Vector 와 Stack 입니다. 참고로 이들은 수식을 분석하기 위해, 즉 ExprCell 객체의 to<span class='font-italic'>numeric 함수 내에서 사용될 예정입니다. </p><p>각 자료구조들은 다음과 같은 특징을 가지고 있습니다.<span class='font-italic'> 벡터 (Vector) : 수학의 그 벡터와는 살짝 다른 느낌인데, 그냥 배열의 크기를 맘대로 조절할 수 있는 가변길이 배열이라 보시면 됩니다. 즉, 배열 처럼 [] 연산자로 임의의 위치에 있는 원소에 마음대로 접근할 수 있고 또 임의의 위치에 원소를 추가하거나 뺄 수 있습니다. 벡터를 만드는 방법은 이전에 문자열 클래스를 만들 때와 거의 비슷합니다. 문자열 역시 char 데이터를 담는 가변 길이 배열과 마찬가지 이기 때문이지요.</span> 스택 (Stack) : 벡터와는 다르게 임의의 위치에 있는 원소에 접근할 수 없고 항상 최 상단에 있는 데이터에만 접근할 수 있습니다. 그리고 새로운 데이터를 추가하면 최상단에 오게 됩니다. 쉽게 말해서 설거지 용으로 쌓아 놓는 접시들이라 보면 됩니다. 새로운 설거지 거리가 오면 쌓여 있는 접시 맨 위에 오게 되고(push). 설거지를 위해서 접시를 뺄 때 맨 위의 접시 부터 빼겠지요(pop). 물론 스택은 그냥 벡터를 활용해서 만들 수 있습니다. 하지만 이는 마치 소 잡는 칼을 닭 잡는 데 쓰는 것이라고나 할까요. 보통 스택의 경우 링크드 리스트(Linked List - http://itguru.tistory.com/100 의 Node 부분을 살펴보세요) 를 이용해서 구현을 합니다. 스택은 임의의 위치에 데이터에 접근할 필요가 없습니다. 단순히 최상위에 뭐가 있을 지 궁금하고 또 거기에 새로운 것을 추가하던지 빼기만 하면 되겠지요. 아래 스택을 간단히 어떻게 구현 할 지 그림으로 보여드리겠습니다.</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F2151894E5788A29118E8AB' alt=''><p>즉 스택의 경우 복잡하게 생각할 필요 없이 위와 같이 구성하면 됩니다.</p><p> 벡터 클래스 (Vector)</p><p>먼저 문자열을 보관하기 위한 벡터 부터 만들겠습니다. 우리의 벡터 클래스는 다음과 같이 구성되어 있습니다.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">string</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 생성자
</span><span class="c1"></span>  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>  <span class="n">string</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="nf">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>먼저 클래스 소스를 살펴보도록 합시다. </p><pre class="chroma">
<span class="n">string</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
</pre><p>Vector 클래스는 위와 같이 데이터를 보관하기 위한 data (문자열 배열로 만들 것입니다), 현재 할당되어 있는 크기를 알려주는 capacity, 그리고 현재 실제로 사용하는 양인 length 와 같은 변수로 구성되어 있습니다. </p><pre class="chroma">
<span class="c1">// 생성자
</span><span class="c1"></span><span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
</pre><p>한 가지 특이한 점은 생성자에서 인자가 저렇게 int n = 1 과 같이 지정되어 있다는 것입니다. 이는 무엇이냐면, 만일 사용자가 인자를 지정하지 않으면, 알아서 n = 1 이 되게 지정한다는 것입니다. 다시 말해서</p><pre class="chroma">
<span class="n">Vector</span> <span class="n">a</span><span class="p">(</span><span class="p">)</span> <span class="n">Vector</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre><p>은 동일한 작업입니다. 물론 사용자가 인자를 지정하면 해당 인자가 들어가겠지요. 이렇게 해당 인자의 기본 값을 지정해 놓은 것을 디폴트 인자 (Default argument) 라고 합니다. 이렇게 하면 사용자가 인자를 지정하지 않아도 디폴트 값이 들어가기 때문에 문제 없이 사용할 수 있습니다. </p><pre class="chroma">
<span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
</pre><p>Vector 의 생성자를 살펴보면 위와 같습니다. 한 가지 흥미로운 점은 여기서는 디폴트 인자가 명시되지 않은 점입니다. 이는 C++ 규칙이기도 한데, 클래스 내부 함수 선언에서 디폴드 인자를 명시하였다면 함수 본체에서 명시하면 안되고, 반대로 함수 본체에서 명시하였다면 클래스 내부 함수 선언에 명시하면 안됩니다. 즉, 둘 중 한 곳에서만 표시해야 합니다. </p><pre class="chroma">
<span class="kt">void</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">push_back</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>

<span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p>간단히 위 처럼 Vector 클래스의 함수들을 만들어 보았습니다. 이 Vector 클래스는 일반적으로 다른 사람들이 사용할 것이 아니라 제가 이 프로젝트에서 간단히 사용하기 위해 만들어놓은 것이므로 몇 가지 문제점들이나 구현하지 않는 함수들 (보통 Vector 클래스에는 중간에 원소를 추가하는 insert 나 검색하는 find 함수들도 세트로 다닙니다) 이 있습니다. 물론 이렇게 한 이유는 이 정도로도 Excel 프로젝트에는 충분하기 때문에 문제 없습니다. </p><pre class="chroma">
<span class="kt">void</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">push_back</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>우리 Vector 클래스의 push<span class='font-italic'>back 함수는 배열 맨 끝에 원소를 집어넣는 클래스 입니다. 위 방법은 기존에 문자열 클래스에서 썼던 방법으로, 만일 배열이 다 차게 되면 1 칸을 더 늘리는 것이 아니라 현재 크기의 두 배 만큼을 새로 할당하고 새로 할당단 공간에 복사하는 것입니다. 이렇게 된다면 가장 효율적으로 공간과 시간을 활용할 수 있습니다. </p><p> 스택 클래스</p><p>이번에는 스택 클래스 입니다.  스택의 경우 위에서 말한 것 처럼 링크드 리스트를 사용하기 때문에 데이터를 보관하기 위해서 배열을 사용하는 것이 아니라 하나의 노드를 만들어서 노드들을 체인 처럼 엮을 것입니다. 이를 위해 아래와 같이 Stack 클래스 안에 Node 라는 구조체를 정의하였습니다. </p><pre class="chroma">
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">s</span><span class="p">;</span>

  <span class="n">Node</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">prev</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="p">,</span> <span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>Node 객체에는 자기 보다 하위 Node 를 가리키는 포인터(prev)와, 자신이 보관하는 데이터에 관한 값(s)을 보관하는 두 개의 변수로 구성되어 있습니다. 그냥 맨 위에 그려놓은 스택 구현 모습을 그대로 표현하였다고 생각하면 됩니다. 아래는 전체 Stack 클래스의 모습입니다.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Stack</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">Node</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">prev</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="p">,</span> <span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="p">}</span><span class="p">;</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">Node</span> <span class="n">start</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Stack</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 최상단에 새로운 원소를 추가한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 최상단의 원소를 제거하고 반환한다.
</span><span class="c1"></span>  <span class="n">string</span> <span class="nf">pop</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 최상단의 원소를 반환한다. (제거 안함)
</span><span class="c1"></span>  <span class="n">string</span> <span class="nf">peek</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 스택이 비어있는지의 유무를 반환한다.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">is_empty</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="o">~</span><span class="n">Stack</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>Node 들의 리스트를 정확하게 관리하기 위해서, current 와 start 를 만들어서 current 는 현재 최상위 노드를 가리키게 하고, start 는 맨 밑바닥을 이루는 노드, 즉 최하위 노드를 가리키게 하였습니다. start 노드를 둔 이유는, 마지막 노드에 도달하였을 때 그 여부를 알아야 하기 때문이지요. </p><pre class="chroma">
<span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">Stack</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">start</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">)</span> <span class="p">{</span> <span class="n">current</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">push</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>
  <span class="n">current</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">string</span> <span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">pop</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">=</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="k">return</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>

  <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">s</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">prev</span><span class="p">;</span>

  <span class="c1">// Delete popped node
</span><span class="c1"></span>  <span class="k">delete</span> <span class="n">prev</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">string</span> <span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">peek</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">s</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">is_empty</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">=</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="o">~</span><span class="n">Stack</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p>위와 같이 간단하게 Stack 을 구성하였습니다. 주의해야 할 점은, 소멸자에서 최상위 원소 부터 줄줄이 바닥에 도달할 때 까지 메모리에서 해제시켜야 완전히 Stack 객체를 소멸시킬 수 있습니다.</p><p>스택의 경우 위와 같이 문자열을 받는 것 말고도, 숫자 데이터를 보관하는 스택인 NumStack 클래스 또한 string 만 int 로 바꿔서 동일하게 만들었습니다. </p><p>최종적으로 아래는 우리가 만든 벡터와 스택 클래스의 헤더 파일인 utils.h 의 전체 내용입니다. </p><pre class="chroma">
<span class="cp">#</span><span class="cp">pragma once</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Vector</span> <span class="p">{</span>
  <span class="n">string</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 생성자
</span><span class="c1"></span>  <span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 맨 뒤에 새로운 원소를 추가한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 임의의 위치의 원소에 접근한다.
</span><span class="c1"></span>  <span class="n">string</span> <span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// x 번째 위치한 원소를 제거한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 현재 벡터의 크기를 구한다.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="nf">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">Stack</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">Node</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">prev</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="p">,</span> <span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="p">}</span><span class="p">;</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">Node</span> <span class="n">start</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Stack</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 최상단에 새로운 원소를 추가한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 최상단의 원소를 제거하고 반환한다.
</span><span class="c1"></span>  <span class="n">string</span> <span class="nf">pop</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 최상단의 원소를 반환한다. (제거 안함)
</span><span class="c1"></span>  <span class="n">string</span> <span class="nf">peek</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 스택이 비어있는지의 유무를 반환한다.
</span><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">is_empty</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="o">~</span><span class="n">Stack</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">NumStack</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">Node</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">prev</span><span class="p">,</span> <span class="kt">double</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">prev</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="p">,</span> <span class="n">s</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="p">}</span><span class="p">;</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">Node</span> <span class="n">start</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">NumStack</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">double</span> <span class="nf">pop</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">double</span> <span class="nf">peek</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="nf">is_empty</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="o">~</span><span class="n">NumStack</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>참고로 맨 위에 흥미로운 전처리기 하나가 있습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">pragma once</span><span class="cp">
</span><span class="cp"></span></pre><p>아직 C++ 표준에 정식으로 들어간 것은 아니지만, 그래도 대부분의 주요 컴파일러 Visual Studio, gcc, clang 등등에서 지원하고 있는 것으로 이 헤더파일이 중복되서 포함되지 않도록 합니다. 물론 기존에</p><pre class="chroma">
#ifndef A
#define A
// 헤더파일 내용
#endif
</pre><p>이런 형태로 사용하기도 하였지만 이를 위의 한 줄로 단순화 시킨 것입니다. #pragma once 를 명시하게 되면, 설사 다른 소스파일에서 이 헤더파일을 두 번 이상 include 해도 알아서 컴파일러 차원에서 한 번만 include 하게 해줍니다.</p><p>마찬가지로 아래는 해당 헤더파일 내용을 구현한 utility.cpp 입니다. </p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&#34;utils.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// default argument must go only once
</span><span class="c1"></span><span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">Vector</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="p">)</span><span class="p">,</span> <span class="n">capacity</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="p">,</span> <span class="n">length</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">push_back</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;</span><span class="o">=</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">[</span><span class="n">capacity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="n">capacity</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">length</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">string</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="k">operator</span><span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">remove</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">length</span><span class="o">-</span><span class="o">-</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">length</span><span class="p">;</span> <span class="p">}</span>
<span class="n">Vector</span><span class="o">:</span><span class="o">:</span><span class="o">~</span><span class="n">Vector</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">Stack</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">start</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">)</span> <span class="p">{</span> <span class="n">current</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">push</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>
  <span class="n">current</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">string</span> <span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">pop</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">=</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="k">return</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>

  <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">s</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">prev</span><span class="p">;</span>

  <span class="c1">// Delete popped node
</span><span class="c1"></span>  <span class="k">delete</span> <span class="n">prev</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">string</span> <span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">peek</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">s</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="n">is_empty</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">=</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Stack</span><span class="o">:</span><span class="o">:</span><span class="o">~</span><span class="n">Stack</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">NumStack</span><span class="o">:</span><span class="o">:</span><span class="n">NumStack</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">start</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">current</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">NumStack</span><span class="o">:</span><span class="o">:</span><span class="n">push</span><span class="p">(</span><span class="kt">double</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>
  <span class="n">current</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="n">NumStack</span><span class="o">:</span><span class="o">:</span><span class="n">pop</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">=</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">s</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">s</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
  <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">prev</span><span class="p">;</span>

  <span class="c1">// Delete popped node
</span><span class="c1"></span>  <span class="k">delete</span> <span class="n">prev</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">double</span> <span class="n">NumStack</span><span class="o">:</span><span class="o">:</span><span class="n">peek</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">s</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="n">NumStack</span><span class="o">:</span><span class="o">:</span><span class="n">is_empty</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">=</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">NumStack</span><span class="o">:</span><span class="o">:</span><span class="o">~</span><span class="n">NumStack</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-</span><span class="o">&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">prev</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p> 본격적인 Cell 과 Table 클래스</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Cell</span>

<span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">;</span>

  <span class="n">string</span> <span class="n">data</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="n">string</span> <span class="n">stringify</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">to_numeric</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="n">Cell</span><span class="p">(</span><span class="n">string</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>Cell 클래스는 큰 테이블에서 한 칸을 의미하는 객체로, 해당 내용을 보관하는 문자열 data 와 어느 테이블에 위치해 있는지에 관련한 정보를 가지고 있는 table 과 그 위치 x, y 로 구성되어 있습니다. </p><p>또한, 가상 함수로 해당 셀 값을 문자열로 변환하는 stringify 함수와, 정수 데이터로 변환하는 to<span class='font-italic'>numeric 함수도 선언되어 있습니다. 물론 문자열에 to</span>numeric 을 수행하게 되면 당연히 0 을 리턴하겠지만, 나중에 Cell 클래스를 NumberCell 과 같은 클래스들이 상속 받기 위한 큰 그림이라고 보시면 됩니다. </p><p>따라서 Cell 멤버 함수들의 정의는 아래와 같이 간단하게 나타낼 수 있습니다. </p><pre class="chroma">
<span class="n">Cell</span><span class="o">:</span><span class="o">:</span><span class="n">Cell</span><span class="p">(</span><span class="n">string</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Table</span><span class="o">*</span> <span class="n">table</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="p">,</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="p">,</span> <span class="n">table</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

<span class="n">string</span> <span class="n">Cell</span><span class="o">:</span><span class="o">:</span><span class="n">stringify</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">Cell</span><span class="o">:</span><span class="o">:</span><span class="n">to_numeric</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</pre><p>자 그럼 Table 클래스의 정의를 살펴보도록 하겠습니다. </p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">Table</span> <span class="p">{</span>
 <span class="k">protected</span><span class="o">:</span>
  <span class="c1">// 행 및 열의 최대 크기
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">max_row_size</span><span class="p">,</span> <span class="n">max_col_size</span><span class="p">;</span>

  <span class="c1">// 데이터를 보관하는 테이블
</span><span class="c1"></span>  <span class="c1">// Cell* 을 보관하는 2차원 배열이라 생각하면 편하다
</span><span class="c1"></span>  <span class="n">Cell</span><span class="o">*</span><span class="o">*</span><span class="o">*</span> <span class="n">data_table</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">Table</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_row_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_col_size</span><span class="p">)</span><span class="p">;</span>

  <span class="o">~</span><span class="n">Table</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 새로운 셀을 row 행 col 열에 등록한다.
</span><span class="c1"></span>  <span class="kt">void</span> <span class="nf">reg_cell</span><span class="p">(</span><span class="n">Cell</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 해당 셀의 정수값을 반환한다.
</span><span class="c1"></span>  <span class="c1">// s : 셀 이름 (Ex. A3, B6 과 같이)
</span><span class="c1"></span>  <span class="kt">int</span> <span class="nf">to_numeric</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 행 및 열 번호로 셀을 호출한다.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="nf">to_numeric</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 해당 셀의 문자열을 반환한다.
</span><span class="c1"></span>  <span class="n">string</span> <span class="nf">stringify</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span><span class="p">;</span>
  <span class="n">string</span> <span class="nf">stringify</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="n">string</span> <span class="nf">print_table</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>일단 Table 클래스는 Cell 객체들을 2 차원 배열로 보관하게 됩니다. 이 때, 객체 자체를 보관하는 것이 아니라, 객체는 필요할 대 마다 동적으로 생성하고, 그 객체에 대한 포인터를 2차원 배열로 보관하고 있게 됩니다. </p><pre class="chroma">
<span class="n">Table</span><span class="o">:</span><span class="o">:</span><span class="n">Table</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_row_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_col_size</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">max_row_size</span><span class="p">(</span><span class="n">max_row_size</span><span class="p">)</span><span class="p">,</span> <span class="n">max_col_size</span><span class="p">(</span><span class="n">max_col_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">data_table</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cell</span><span class="o">*</span><span class="o">*</span><span class="p">[</span><span class="n">max_row_size</span><span class="p">]</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_row_size</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cell</span><span class="o">*</span><span class="p">[</span><span class="n">max_col_size</span><span class="p">]</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre><p>따라서 Table 클래스의 생성자는 위와 같이 정의될 수 있습니다.</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F2409033B578C83591C4592' alt=''><p>위 그림을 보면 쉽게 이해할 수 있듯이, 동적 할당으로 Cell<span class='font-italic'> 배열을 생성한 후에, Cell 객체가 필요 할 때 마다 생성해서 배열의 원소들이 이를 가리킬 수 있게 하였습니다.</p><pre class="chroma">
<span class="n">Table</span><span class="o">:</span><span class="o">:</span><span class="o">~</span><span class="n">Table</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_row_size</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="k">delete</span> <span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_row_size</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">delete</span><span class="p">[</span><span class="p">]</span> <span class="n">data_table</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>Table 소멸자도 이와 비슷합니다. 일단, 동적으로 생성된 Cell 객체를 모두 지워야 하고 그 다음에 Cell 배열 (1차원) 을 지워야 하고 마지막으로 2차원 테이블 자체를 메모리에서 지워야 합니다. 3 단계에 걸쳐서 Cell 의 흔적으로 메모리에서 날려버릴 수 있습니다. </p><pre class="chroma">
<span class="kt">void</span> <span class="n">Table</span><span class="o">:</span><span class="o">:</span><span class="n">reg_cell</span><span class="p">(</span><span class="n">Cell</span><span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">max_row_size</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">)</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>위는 Table 의 셀을 등록하는 함수 입니다. 등록하고자 하는 위치를 인자로 받는데, 만일 해당 위치에 이미 다른 셀 객체가 등록되어 있다면 해당 객체를 delete 한 후에 등록시켜주면 됩니다. </p><pre class="chroma">
<span class="kt">int</span> <span class="n">Table</span><span class="o">:</span><span class="o">:</span><span class="n">to_numeric</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Cell 이름으로 받는다.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">A</span><span class="sc">&#39;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">(</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">max_row_size</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">to_numeric</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">Table</span><span class="o">:</span><span class="o">:</span><span class="n">to_numeric</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">max_row_size</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">max_col_size</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">to_numeric</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">string</span> <span class="n">Table</span><span class="o">:</span><span class="o">:</span><span class="n">stringify</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Cell 이름으로 받는다.
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">A</span><span class="sc">&#39;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">c_str</span><span class="p">(</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">max_row_size</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">stringify</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">string</span> <span class="n">Table</span><span class="o">:</span><span class="o">:</span><span class="n">stringify</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">max_row_size</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">max_col_size</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">data_table</span><span class="p">[</span><span class="n">row</span><span class="p">]</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">stringify</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="n">Table</span><span class="o">&amp;</span> <span class="n">table</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">o</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">table</span><span class="p">.</span><span class="n">print_table</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>마지막으로 해당하는 셀의 값을 반환하는 함수들로, 두 가지 형태로 구성되어 있는데 하나는 셀 이름(A1, B2 이렇게)을 받아서 해당하는 위치의 값을 리턴하는 함수와 행과 열 값을 받아서 해당 위치에 셀이 있으면 그 값을 리턴하는 함수들로 구성되어 있습니다. </p><p>또한 맨 마지막에 ostream 클래스의 << 연산자를 오버로딩하는 함수를 하나 만들어서 파일이나 표준 스트림(cout) 입출력에 쉽게 사용할 수 있도록 하였습니다. </p><p>하지만 이 Table 클래스의 객체는 생성할 수 없습니다. 왜냐하면 아래와 같은 순수 가상 함수가 포함되어 있기 때문이지요.</p><pre class="chroma">
<span class="k">virtual</span> <span class="n">string</span> <span class="nf">print_table</span><span class="p">(</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre><p>우리는 이 Table 클래스를 상속 받는 다른 클래스를 만들어서 이 함수를 구현해주어야만 합니다. </p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">TxtTable</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Table</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">repeat_char</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 숫자로 된 열 번호를 A, B, .... Z, AA, AB, ... 이런 순으로 매겨준다.
</span><span class="c1"></span>  <span class="n">string</span> <span class="nf">col_num_to_str</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">TxtTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span><span class="p">;</span>

  <span class="c1">// 텍스트로 표를 깨끗하게 출력해준다.
</span><span class="c1"></span>  <span class="n">string</span> <span class="nf">print_table</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>위는 Table 클래스를 상속 받는 TxtTable 클래스 입니다. 이 클래스는 Table 의 내용을 텍스트의 형태로 예쁘게 정리해서 출력해주는 역할을 하고 있습니다. </p><pre class="chroma">
<span class="n">TxtTable</span><span class="o">:</span><span class="o">:</span><span class="n">TxtTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="o">:</span> <span class="n">Table</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

<span class="c1">// 텍스트로 표를 깨끗하게 출력해준다.
</span><span class="c1"></span><span class="n">string</span> <span class="n">TxtTable</span><span class="o">:</span><span class="o">:</span><span class="n">print_table</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">total_table</span><span class="p">;</span>

  <span class="kt">int</span><span class="o">*</span> <span class="n">col_max_wide</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">max_col_size</span><span class="p">]</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_wide</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_row_size</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">data_table</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span><span class="o">&amp;</span>
          <span class="n">data_table</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">stringify</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_wide</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_wide</span> <span class="o">=</span> <span class="n">data_table</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">stringify</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">col_max_wide</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_wide</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// 맨 상단에 열 정보 표시
</span><span class="c1"></span>  <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">  </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">total_wide</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">col_max_wide</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">col_max_wide</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
      <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> | </span><span class="s">&#34;</span> <span class="o">+</span> <span class="n">col_num_to_str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="p">;</span>
      <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="n">repeat_char</span><span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="n">col_num_to_str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc"> </span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>

      <span class="n">total_wide</span> <span class="o">+</span><span class="o">=</span> <span class="p">(</span><span class="n">max_len</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="c1">// 일단 기본적으로 최대 9999 번째 행 까지 지원한다고 생각한다.
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_row_size</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="n">repeat_char</span><span class="p">(</span><span class="n">total_wide</span><span class="p">,</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">-</span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span> <span class="o">+</span> <span class="n">to_string</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
    <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="n">repeat_char</span><span class="p">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">to_string</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc"> </span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">col_max_wide</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">max_len</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">col_max_wide</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>

        <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">s</span> <span class="o">=</span> <span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">stringify</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> | </span><span class="s">&#34;</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="n">repeat_char</span><span class="p">(</span><span class="n">max_len</span> <span class="o">-</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc"> </span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">total_table</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">total_table</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">string</span> <span class="n">TxtTable</span><span class="o">:</span><span class="o">:</span><span class="n">repeat_char</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 숫자로 된 열 번호를 A, B, .... Z, AA, AB, ... 이런 순으로 매겨준다.
</span><span class="c1"></span><span class="n">string</span> <span class="n">TxtTable</span><span class="o">:</span><span class="o">:</span><span class="n">col_num_to_str</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">A</span><span class="sc">&#39;</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">first</span> <span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">A</span><span class="sc">&#39;</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">26</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">second</span> <span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">A</span><span class="sc">&#39;</span> <span class="o">+</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">26</span><span class="p">;</span>

    <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">second</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>위는 그 구현 입니다. repeat<span class='font-italic'>char 과 col</span>num<span class='font-italic'>to</span>str 함수는 단순히 print<span class='font-italic'>table 에서 사용할 부가적인 함수들 입니다. print</span>table 함수는 각 열의 최대 문자열 길이를 계산한 뒤에, 이를 바탕으로 각 열의 폭을 결정해서 표를 출력해줍니다. </p><p>참고로 이 구현 방식에서 한 가지 중요한 것이 빠졌는데, 셀의 문자열 데이터에서 개행 문자가 있는 경우(즉 특정 셀이 여러 줄이 될 때)를 고려하지 않았습니다. 즉, 모든 셀은 최대 1 줄로만 그려지게 됩니다.  따라서 실제로는 각 행의 최대 높이 역시 열과 마찬가지로 계산해서 그려야 합니다. (이는 여러분의 몫으로 남기겠습니다)</p><pre class="chroma">
<span class="c1">// 생략
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TxtTable</span> <span class="n">table</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="p">;</span>
  <span class="n">ofstream</span> <span class="n">out</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">test.txt</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">table</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Hello~</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">;</span>
  <span class="n">table</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">C++</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">table</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Programming</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">table</span><span class="p">;</span>
  <span class="n">out</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">table</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면 </p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F2730FA3A578C93C81EB1DF' alt=''><p>와 같이 잘 나오게 됩니다. </p><p>또한 test.txt 파일에도 역시 </p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F2506113B578C94130C2F95' alt=''><p>위와 같이 표가 잘 출력됩니다. </p><p>마찬가지로 저는 CSV 파일 형태와 HTML 형태로 데이터를 표현해주는 두 개의 클래스들을 더 만들었습니다. </p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">HtmlTable</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Table</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">HtmlTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span><span class="p">;</span>

  <span class="n">string</span> <span class="nf">print_table</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="k">class</span><span class="err"> </span><span class="nc">CSVTable</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Table</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">CSVTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span><span class="p">;</span>

  <span class="n">string</span> <span class="nf">print_table</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>딱히 특별한 것은 없고, HTML 파일 형식이나 CSV 파일 형식을 잘 알고 있다면 만드는데 큰 문제가 없을 것입니다. (HTML 표 : http://aboooks.tistory.com/59 , CSV 파일 형식 : https://en.wikipedia.org/wiki/Comma-separated<span class='font-italic'>values )</p><pre class="chroma">
<span class="c1">// 생략
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CSVTable</span> <span class="n">table</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="p">;</span>
  <span class="n">ofstream</span> <span class="n">out</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">test.csv</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">table</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Hello~</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">;</span>
  <span class="n">table</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">C++</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">table</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Programming</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">out</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">table</span><span class="p">;</span>

  <span class="n">HtmlTable</span> <span class="n">table2</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="p">;</span>
  <span class="n">ofstream</span> <span class="n">out2</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">test.html</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="n">table2</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Hello~</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="p">;</span>
  <span class="n">table2</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">C++</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">table2</span><span class="p">.</span><span class="n">reg_cell</span><span class="p">(</span><span class="k">new</span> <span class="n">Cell</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Programming</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">)</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">out2</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">table2</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>그리고 그 구현 내용은 다음과 같습니다. </p><pre class="chroma">
<span class="n">HtmlTable</span><span class="o">:</span><span class="o">:</span><span class="n">HtmlTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="o">:</span> <span class="n">Table</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

<span class="n">string</span> <span class="n">HtmlTable</span><span class="o">:</span><span class="o">:</span><span class="n">print_table</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&lt;table border=&#39;1&#39; cellpadding=&#39;10&#39;&gt;</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_row_size</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&lt;tr&gt;</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&lt;td&gt;</span><span class="s">&#34;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">stringify</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
      <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&lt;/td&gt;</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&lt;/tr&gt;</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&lt;/table&gt;</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">CSVTable</span><span class="o">:</span><span class="o">:</span><span class="n">CSVTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="o">:</span> <span class="n">Table</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>

<span class="n">string</span> <span class="n">CSVTable</span><span class="o">:</span><span class="o">:</span><span class="n">print_table</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_row_size</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">max_col_size</span><span class="p">;</span> <span class="n">j</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">,</span><span class="s">&#34;</span><span class="p">;</span>
      <span class="c1">// CSV 파일 규칙에 따라 문자열에 큰따옴표가 포함되어 있다면 &#34;&#34; 로
</span><span class="c1"></span>      <span class="c1">// 치환하다.
</span><span class="c1"></span>      <span class="n">string</span> <span class="n">temp</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="p">)</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">data_table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="o">&gt;</span><span class="n">stringify</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">temp</span><span class="p">.</span><span class="n">length</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">k</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">&#34;</span><span class="sc">&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// k 의 위치에 &#34; 를 한 개 더 집어넣는다.
</span><span class="c1"></span>          <span class="n">temp</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">&#34;</span><span class="sc">&#39;</span><span class="p">)</span><span class="p">;</span>

          <span class="c1">// 이미 추가된 &#34; 를 다시 확인하는 일이 없게 하기 위해
</span><span class="c1"></span>          <span class="c1">// k 를 한 칸 더 이동시킨다.
</span><span class="c1"></span>          <span class="n">k</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">temp</span> <span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">&#34;</span><span class="sc">&#39;</span> <span class="o">+</span> <span class="n">temp</span> <span class="o">+</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">&#34;</span><span class="sc">&#39;</span><span class="p">;</span>
      <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span> <span class="o">+</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">\n</span><span class="sc">&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile29.uf.tistory.com%2Fimage%2F271F803B578C9B0A1CF30F' alt=''><p>CSV 파일의 경우 위와 같이 (실제) 엑셀에서 잘 열리고 </p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F212FFA3B578C9B0A0A770A' alt=''><p>HTML 파일로 변환한 경우 위와 같이 브라우저 상에서 잘 표현됨을 알 수 있습니다. </p><p>이상으로 간단히 엑셀 만들기 프로젝트 1 부를 마치도록 하겠습니다. 다음 강좌에서는 Cell 을 상속 받는 클래스들을 만들어서 마치 실제 엑셀 처럼 작동하는 엑셀을 만들어 보도록 하겠습니다. </p><pre class="chroma">강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면 꼭 댓글을 남겨주시기
            바랍니다
                .그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관
                    없습니다.생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요.

        현재 여러분이 보신 강좌는
        &lt;&lt; 씹어먹는 C++ - &lt;8 - 1. Excel 만들기 프로젝트 1부&gt;&gt;&gt;
    입니다.이번 강좌의 모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어
        보시기 전까지 다음 강좌로 넘어가지 말아주세요

            다음 강좌 보러가기
</pre><p>공감8sns신고저작자표시'C++' 카테고리의 다른 글씹어먹는 C++ - <9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)>(10)2017.04.07씹어먹는 C++ - <8 - 2. Excel 만들기 프로젝트 2부>(6)2016.07.19씹어먹는 C++ - <8 - 1. Excel 만들기 프로젝트 1부>(0)2016.07.18씹어먹는 C++ - <7 - 2. C++ 에서 파일 입출력 - ifstream. ofstream, stringstream>(13)2016.07.14씹어먹는 C++ - <7 - 1. C++ 에서의 입출력 (istream, ostream)>(35)2015.05.04씹어먹는 C++ - <6 - 3. 가상함수와 상속에 관련한 잡다한 내용들>(14)2014.04.13</p><style>/* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%; }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }
</style>