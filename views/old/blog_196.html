<pre class='warning'>이 글은 http:  // ciere.com/cppnow12/lambda.pdf 에서 가져왔고 한국말로
               // 번역되었습니다. 또한 저의 개인적인 C++ 능력 향상과 ' [저의
               // 모토인 지식 전파](http://itguru.tistory.com/notice/107)'를
               // 위해 모든 이들에게 공개하도록 하겠습니다.
</pre><pre class='info'>이 글을 이해하기 위해서는 초보 이상의 C++ 지식이 필요합니다.
아직 C++ 에 친숙하지 않다면 [씹어먹는 C++ 강좌](http://itguru.tistory.com/135)는 어때요?
</pre><p>안녕하세요? 이 글은 지난번에 우측값 레퍼런스에 관련한 글에 이어서 두 번째로 쓰는 C++ 토막글 입니다. C++ 토막글에서는 주로 C++ 11 에 추가된 최신 기술들을 다루고 있는데요, 아직 국내에 자료가 많이 부족하다 보니 체계적으로 쓰인 외국 자료들을 번역하는 형태로 제공하고 있습니다. 이 글은 http://ciere.com/cppnow12/lambda.pdf 에 올라온 <code class='inline-code'>pdf</code> 자료를 바탕으로 번역된 글입니다. 사실 이 <code class='inline-code'>pdf</code> 는 내용은 없고 소스만 있는 발표 자료이지만, 제가 발표자가 되었다고 가정해서 내용을 소개해보고자 합니다. 이 글이 C++ 11 의 강력한 기술인 <code class='inline-code'>Lambda</code> 를 이해하는데 많은 도움이 되기를 바라겠습니다 :)</p><h3><p>  서론</p></h3><p>어떤 벡터의 원소들의 모든 곱을 계산하는 코드를 구성한다고 생각해봅시다. 아마 가장 초보적으로 이 코드를 구성하는 방법은 아마 아래와 같을 것입니다.</p><pre class="chroma">
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">const_iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">cardinal</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">const_iterator</span> <span class="n">iter_end</span> <span class="o">=</span> <span class="n">cardinal</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">total_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!</span><span class="o">=</span> <span class="n">iter_end</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">total_elements</span> <span class="o">*</span><span class="o">=</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
  <span class="o">+</span><span class="o">+</span><span class="n">iter</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>위는 반복자(iterator) 를 이용해서 <code class='inline-code'>cardinal</code> 이라는 <code class='inline-code'>vector&lt;int&gt;</code> 의 각 원소들을 순차적으로 참조해가며 <code class='inline-code'>total_elements</code> 에 곱해나가는 코드입니다. 아주 직관적이고 단순하지만, C++ 을 처음 배우는, 아직 C++ 의 기능을 전부 접해보지 못한 초보자 수준의 코드이겠죠?</p><p>만일 "나는 C++ 쫌 해" 정도 되는 사람이라는 <code class='inline-code'>Functor</code> 를 이용해서 아래와 같은 코드를 짜냈을 것입니다.</p><pre class="chroma">
<span class="kt">int</span> <span class="n">total_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">cardinal</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">cardinal</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">product</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">total_elements</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">product</span> <span class="p">{</span>
  <span class="n">product</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">storage</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">V</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="n">V</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">*</span><span class="o">=</span> <span class="n">v</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>위 코드는 C++ 고수 답게 <code class='inline-code'>for_each</code> 와 Functor 를 이용한 코드를 짜냈습니다. <code class='inline-code'>for_each</code> 를 사용해서 이전 코드의 <code class='inline-code'>while</code> 문 부분을 싸그리 없앨 수 있지만, 이를 위해 필요한 <code class='inline-code'>Functor</code> 를 구성하는 코드가 훨씬 깁니다. 마치 배보다 배꼽이 더 큰 격이군요. 물론 전체적인 코드의 질이 높아졌다고 볼 수 있지만, <code class='inline-code'>Functor</code> 을 이용하기 위해 <code class='inline-code'>product</code> 라는 구조체를 생성하면서 구질구질하게 생성자도 만들고, 또 <code class='inline-code'>void operator()</code> 도 정의해주어야겠죠. 상당히 귀찮은 일이 아닐 수 없습니다.</p><pre class="chroma">
<span class="kt">int</span> <span class="n">total_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">cardinal</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">cardinal</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
         <span class="p">[</span><span class="o">&amp;</span><span class="n">total_elements</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">total_elements</span> <span class="o">*</span><span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
</pre><p>자. 그럼 위 코드를 한번 봅시다. 짧고 간결하며, 무엇 보다도 <code class='inline-code'>while</code> 문이나 <code class='inline-code'>functor</code> 와 같은 구질구질한 코드 없이 깔끔하게 <code class='inline-code'>for_each</code> 의 특징을 그대로 살려주었다고 볼 수 있습니다. 즉 <code class='inline-code'>Functor</code> 에 들어갈 내용을 <code class='inline-code'>product</code> 라는 구조체를 정의하면서 쭉 써내려갈 내용을 한 번에 깔끔하게 정리해놓은 것이지요. 이것이 바로 <code class='inline-code'>Lambda</code> 의 위력입니다.</p><p>간단히 <code class='inline-code'>Functor</code> 를 이용한 코드와 <code class='inline-code'>Lambda</code> 를 이용한 코드를 비교해 보아도 그 차이를 실감할 수 있을 것입니다.</p><pre class="chroma">
<span class="c1">// Functor 사용
</span><span class="c1"></span>
<span class="k">struct</span> <span class="n">mod</span> <span class="p">{</span>
  <span class="n">mod</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="o">:</span> <span class="n">modulus</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="kt">int</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">%</span> <span class="n">modulus</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">modulus</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">my_mod</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">transform</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">in</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">out</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">mod</span><span class="p">(</span><span class="n">my_mod</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><pre class="chroma">
<span class="c1">// Lambda 사용
</span><span class="c1"></span><span class="kt">int</span> <span class="n">my_mod</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">transform</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">in</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">out</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
          <span class="p">[</span><span class="n">my_mod</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">%</span> <span class="n">my_mod</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
</pre><h3><p>  람다(Lambda) 의 구성</p></h3><p>자 그럼 <code class='inline-code'>Lambda</code> 를 사용하기 위해 <code class='inline-code'>Lambda</code> 를 어떻게 C++ 에서 정의하는지 살펴보도록 합시다.!</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F1152175050EB03B514EB55' alt=''><p>람다는 위 그림과 같이 4 개의 부분으로 구성되어 있습니다. 그 4 개의 부분은 각각 개시자 (introducer), 인자(parameters), 반환 타입 (return type), 그리고 함수의 몸통 (statement) 라 합니다. 일단, 람다 맨 처음에 나타나는 <code class='inline-code'>[]</code> 는 개시자로, 그 안에 어떤 외부 변수를 써 넣는다면 람다 함수가 이를 <code class='inline-code'>Capture</code> 해서, 이 변수를 람다 내부에서 이용할 수 있게 됩니다 (이에 대한 이야기는 뒤에서...) 위 경우 <code class='inline-code'>my_mod</code> 라는 변수를 람다 내부에서 이용할 수 있게 됩니다.그 다음의 () 는 람다가 실행시 받을 인자들을 써 넣습니다. 위 람다는 <code class='inline-code'>int</code> 형의 <code class='inline-code'>v_</code> 를 인자로 받는 군요. 여기는 그냥 실제로 함수에서 사용하는 인자 리스트와 동일하게 적어주면 됩니다. 이제, 그 옆으로 보면 <code class='inline-code'>-&gt;</code> 가 있고 반환 타입을 적어주시면 됩니다. 위 람다의 경우 <code class='inline-code'>int</code> 를 리턴합니다. 마지막으로 람다 내부에서 실행할 내용을 적어주면 되는데, 위 람다의 경우 <code class='inline-code'>v_</code> 와 <code class='inline-code'>my_mod</code> 를 모듈러 연산해서 그 결과를 리턴하네요.만일 우리가</p><pre class="chroma">
<span class="p">[</span><span class="n">my_mod</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">v_</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v_</span> <span class="o">%</span> <span class="n">my_mod</span><span class="p">;</span> <span class="p">}</span>
</pre><p>위와 같이 코드 상에 <code class='inline-code'>Lambda</code> 를 썼다고 해봅시다. 그러면 런타임시 이름은 없지만, 메모리 상에<span class='font-weight-bold'> 임시적으로 존재하는 클로져 (Closure) 객체가 생성됩니다. 이 클로져 객체는함수 객체(function <code class='inline-code'>object)</code></span> 처럼 행동합니다. (이러한 연유로 람다를 람다 함수라고 부르는 경우가 있습니다 <code class='inline-code'>-</code> 사실 엄밀히 말하면 클로져 객체지 함수는 아닙니다)</p><p>그렇다면</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">foo</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span><span class="p">(</span><span class="p">)</span>
</pre><p>를 실행하였을 때 어떠한 결과가 나올까요? 일단</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">foo</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</pre><p>로 임시적인 클로져 객체가 생성되었는데 () 를 붙여서 바로 이 임시 클로져 객체를 실행시켜 버리지요. 위 람다는 <code class='inline-code'>Capture</code> 하는 변수들도 없고, 인자로 받는 것도 없고 리턴 타입도 없고 (참고로 리턴 타입이 <code class='inline-code'>void</code> 일 경우 <code class='inline-code'>-&gt;</code> 를 생각 가능합니다) 함수 몸통만 덜렁 있기에 특별히 생각할 것도 없이 함수 몸통만 덜렁 실행되서</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F21748B4950EB08B1045CC5' alt=''><p>라고 나오게 됩니다.</p><p>그러면 조금 더 복잡한 예제를 살펴볼까요?</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">v</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">*6=</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">v</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="p">;</span>
</pre><p>는 어떨까요.</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">v</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">*6=</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">v</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</pre><p>부분에서 인자로 <code class='inline-code'>v</code> 를 받는 클로져가 생성되었는데, (7) 로 이 클로져에 인자로 7 을 전달시키면서 실행시켜버립니다. 따라서 모두가 예상 하였던 결과인</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F2018AC3850EB090B0AB195' alt=''><p>가 나오겠네요.</p><p>람다 자체가 함수 처럼 자유롭게 사용할 수 있는 것이기 때문에 인자로 (당연히) 레퍼런스 들도 전달 가능합니다. 예를 들어</p><pre class="chroma">
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span> <span class="o">*</span><span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="p">}</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">the correct value is: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>를 실행해보면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1809903350EB09F003B36C' alt=''><p>가 나옵니다.</p><p>참고로 받는 인자가 없을 경우, 예컨대</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">foo</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</pre><p>의 경우 인자 () 를 생략 할 수 있습니다. 즉,</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">foo</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</pre><p>도 동일한 의미입니다. (하지만 <code class='inline-code'>[]</code> 는 지울 수 없습니다! <code class='inline-code'>)</code></p><h3><p>  Capture</p></h3><p>사실 많은 경우 우리의 람다 안에서 람다 밖에 있는 변수들에게 접근하고 싶을 때가 있을 것입니다. 물론 "그렇다면 그 변수들을 그냥 인자로 받아버리면 되자나!" 라고 반문할 수 도 있겠지만, <code class='inline-code'>for_each</code> 나 <code class='inline-code'>fill, transform</code> 등의 C++ 의 파워풀한 <code class='inline-code'>STL</code> 을 수행하기 위해서는 인자들을 맞추어 주어야 하는데 이 때문에 함수 내부로 전하고 싶어도 전달하지 못하는 인자들이 있기 마련 입니다.따라서 이를 방지하기 위해, 람다 내부와 소통할 수 있는 또다른 문, <code class='inline-code'>Capture</code> 를 제공하고 있습니다. <code class='inline-code'>Capture</code> 하고자 하는 내용은 앞에서 말했듯이 <code class='inline-code'>[]</code> 안에 들어오게 되는데, 대표적으로 아래의 4 개의 형태들이 있습니다.</p><ol><li><p> <code class='inline-code'>[&]() { . . . }</code> 외부의 모든 변수들을 레퍼런스로 가져온다. (함수의 <code class='inline-code'>Call - by - reference</code> 를 생각)</p></li><li><p> <code class='inline-code'>[=]() { . . . }</code> 외부의 모든 변수들을 값으로 가져온다. (함수의 <code class='inline-code'>Call - by - value</code> 를 생각)</p></li><li><p> <code class='inline-code'>[=, &x, &y] { . . .</code> }, [&, <code class='inline-code'>x, y] { . . .</code> } 외부의 모든 변수들을 값/레퍼런스로 가져오되, <code class='inline-code'>x</code> 와 <code class='inline-code'>y</code> 만 레퍼런스/값으로 가져온다</p></li><li><p> <code class='inline-code'>[x, &y, &z] { . . . }</code> 지정한 변수들을 지정한 바에 따라 가져온다.</p></li></ol><p>그렇다면 한 번 예제를 살펴볼까요.</p><pre class="chroma">
<span class="kt">int</span> <span class="n">total_elements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cardinal</span><span class="p">;</span>

<span class="n">cardinal</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">cardinal</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">cardinal</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>
<span class="n">cardinal</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="p">;</span>

<span class="n">for_each</span><span class="p">(</span><span class="n">cardinal</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">cardinal</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">total_elements</span> <span class="o">*</span><span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>

<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">total elements : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">total_elements</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>위 코드에서 <code class='inline-code'>cardinal</code> 에는 <code class='inline-code'>1, 2, 4, 8</code> 이라는 원소들이 들어있고 그것을 <code class='inline-code'>for_each</code> 를 통해 순회하면서 <code class='inline-code'>total_elements</code> 에 곱하게 됩니다. 이 때 <code class='inline-code'>Capture</code> 는 <code class='inline-code'>&</code> 로 이므로 <code class='inline-code'>total_elements</code> 를 <code class='inline-code'>Capture</code> 할 수 있고, 람다 외부 변수인 <code class='inline-code'>total_elements</code> 를 성공적으로 바꿀 수 있었던 것이죠. 위 코드를 실행하면 예상하던대로</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F225BF04D50EB0D6502D937' alt=''><p>가 나오게 됩니다.</p><p>이번에는 조금 더 복잡한 예제를 살펴보도록 합시다.</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">fill</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stuff</span><span class="p">;</span>
<span class="n">fill</span><span class="p">(</span><span class="n">stuff</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">stuff</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>

<span class="n">for_each</span><span class="p">(</span><span class="n">stuff</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">stuff</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
</pre><p>참고로 클로져 객체는 분명 특정 타입의 객체 이므로 위와 같이 <code class='inline-code'>template</code> 에서 <code class='inline-code'>typename T</code> 로 받을 수 있습니다. 위의 <code class='inline-code'>fill</code> 함수는 특정 타입 <code class='inline-code'>T</code> 의 변수 <code class='inline-code'>done</code> 으로 클로져 객체를 받았습니다. 이 때, 클로져 객체 자체는 이미 <code class='inline-code'>stuff</code> 를 <code class='inline-code'>Capture</code> 해서 <code class='inline-code'>stuff</code> 에 대한 레퍼런스를 계속 가지고 있는 상태이고, <code class='inline-code'>fill</code> 의 <code class='inline-code'>while</code> 문에서 돌면서 <code class='inline-code'>stuff</code> 의 크기가 8 이하 일 때 까지 수행되게 됩니다. 따라서</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F1707A94C50EB0EA003B06B' alt=''><p>로 출력됩니다.</p><pre class="chroma">
<span class="kt">void</span> <span class="nf">fill</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">done</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stuff</span><span class="p">;</span>

<span class="n">fill</span><span class="p">(</span><span class="n">stuff</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">for_each</span><span class="p">(</span><span class="n">stuff</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">stuff</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">sum</span> <span class="o">+</span><span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">sum</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">stuff</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">stuff</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
</pre><p>머리를 쫌만 굴려보면, 현재 <code class='inline-code'>stuff</code> 의 원소 합이 10 이하일 때 까지 <code class='inline-code'>stuff</code> 의 원소를 추가하는 람다라고 볼 수 있습니다.당연히 그 결과는!</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1306BC4C50EB0FDD05EF5B' alt=''><p> 한 가지 흥미로운 점은 <code class='inline-code'>Capture</code> 를 레퍼런스가 아닌 값으로 할 때 언제 <code class='inline-code'>Capture</code> 가 되냐는 것입니다.</p><pre class="chroma">
<span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">v</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">func</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>과연 위 소스에서 <code class='inline-code'>v</code> 는 <code class='inline-code'>func</code> 이 처음 정의될 때, 즉 클로져 객체가 생성될 때 <code class='inline-code'>Capture</code> 될까요, 아니면 <code class='inline-code'>func</code> 이 실행될 때 일까요? 만일 전자라면 42 가 출력될 것이고 후자라면 8 이 출력될 것입니다.</p><p>과연!!</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F1907E73550EB10780D78B0' alt=''><p>흥미롭게도 람다는 클로져 객체가 처음 생성될때 변수들의 값을 <code class='inline-code'>Capture</code> 합니다.</p><p><code class='inline-code'>Capture</code> 를 값으로 할 때 주의점은 그 변수들에는 자동으로 <code class='inline-code'>const</code> 속성이 붙는 다는 것입니다. 즉 값으로 <code class='inline-code'>Capture</code> 시 그 변수들의 내용을 바꿀 수 없습니다. 따라서 아래와 같은 코드는</p><pre class="chroma">
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">two_i</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">2i:</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">two_i</span><span class="p">(</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> i:</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>컴파일 오류 "'i': <code class='inline-code'>a by-value capture cannot be modified in a non-mutable lambda</code><span class='font-weight-bold'> " 가 나게 됩니다. 위 코드에서 <code class='inline-code'>i</code> 는 분명히 값으로 받았으므로 <code class='inline-code'>const</code> 인데, <code class='inline-code'>i *= 2</code> 를 통해 <code class='inline-code'>i</code> 의 값을 바꾸려 하고 있으니 오류가 발생한 것입니다. 하지만, 함수 내부에서 <code class='inline-code'>i</code> 의 값을 바꾸고자 하면 어떨까요? (물론 실제 외부의 <code class='inline-code'>i</code> 의 값은 바뀌지 않습니다... 함수 내부에서만 <code class='inline-code'>-</code> 마치 지역 변수처럼 말이죠)</p><p>답은 간단합니다. 람다에 <code class='inline-code'>mutable</code> 속성을 추가해주면 됩니다.</p><pre class="chroma">
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">two_i</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="k">mutable</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">*</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">2i:</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">two_i</span><span class="p">(</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> i:</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>이로써 람다 내부에서 <code class='inline-code'>i</code> 의 값을 변경할 수 있습니다. 물론, 다시 말하지만 외부의 <code class='inline-code'>i</code> 의 값이 바뀌는 것이 아닙니다. 오직 람다 함수 내에서  '어떤 다른 <code class='inline-code'>i</code> ' 의 값이 두 배가 되는 것이지요. 그 결과</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F2464234B50EB12140C1189' alt=''><p>로 나타남을 알 수 있습니다.</p><p>이제 그럼 조금 복잡한 코드를 살펴볼까요.</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">gorp</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">values</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">m_</span><span class="p">;</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">gorp</span><span class="p">(</span><span class="kt">int</span> <span class="n">mod</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="n">gorp</span><span class="o">&amp;</span> <span class="n">put</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">extras</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">values</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
             <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">count</span> <span class="o">+</span><span class="o">=</span> <span class="n">v</span> <span class="o">%</span> <span class="n">m_</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="n">gorp</span> <span class="nf">g</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>
<span class="n">g</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">extras: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">extras</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>사실 위 코드는 상당히 재미있는 코드입니다. <code class='inline-code'>extras</code> 함수를 호출하면 람다가 각 원소를 4 로 나눈 나머지들의 합을 구해서 더해주는데요, 한 가지 궁금한점! 과연 람다에서 어떻게 <code class='inline-code'>m_</code> 을 <code class='inline-code'>capture</code> 할 수 있었을까요? 람다는 여기서 암묵적으로 (implicit) 클래스의 <code class='inline-code'>this</code> 를 Capture 했기 때문에 <code class='inline-code'>m_</code> 을 접근할 수 있었던 것입니다.</p><p>따라서 위 코드는</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F027A864E50EB146609F056' alt=''><p>으로 성공적인 결과를 보여줍니다.</p><p>이렇게 <code class='inline-code'>this</code> 를 암묵적으로 <code class='inline-code'>Capture</code> 할 수 있기에 아래와 같은 놀라운 일도 발생할 수 있습니다.</p><pre class="chroma">
<span class="k">struct</span> <span class="n">foo</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>
  <span class="kt">void</span> <span class="n">amazing</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="p">}</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">foo</span> <span class="n">f</span><span class="p">;</span>
<span class="n">f</span><span class="p">.</span><span class="n">amazing</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">f.i : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
</pre><p>위 코드를 언뜻 보면 <code class='inline-code'>i</code> 를 값으로 <code class='inline-code'>capture</code> 햇는데 어떻게 8 을 대입할 수 있냐고 물을 수 있는데, 사실 <code class='inline-code'>this</code> 를 Capture 해서 <code class='inline-code'>this.i = 8</code> 을 통해 <code class='inline-code'>mutable</code> 없이도 값을 바꿀 수 있습니다. 왜냐하면 분명 this.i <code class='inline-code'>= 8</code> 에서 상수인 <code class='inline-code'>this</code> 를 변경한 것은 아니기 때문이죠.</p><h3><p>  Capture 의 범위</p></h3><p><code class='inline-code'>Capture</code> 되는 개체들은 모두 람다가 정의된 위치에서 접근 가능해야만 합니다. 예를 들어</p><pre class="chroma">
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">/</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
  <span class="n">f</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>의 코드는 람다의 위치에서 <code class='inline-code'>i, j</code> 모두 접근 가능하기 때문에 Capture 가능하므로 정상적으로</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728' alt=''><p>가 나옵니다.</p><p>그렇다면 아래 코드는 어떨까요?</p><pre class="chroma">
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">/</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
  <span class="n">m</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>바깥의 람다에서 <code class='inline-code'>i</code> 를 <code class='inline-code'>Capture</code> 하였기에, 바깥의 람다 몸통 안에서 <code class='inline-code'>i</code> 를 사용할 수 있겠지요. 따라서 내부의 람다는 <code class='inline-code'>i</code> 를 <code class='inline-code'>Capture</code> 할 수 있게 됩니다. 그렇기에, 위와 동일한 결과인</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F187C4C3650EB825320E728' alt=''><p>가 나오게 됩니다. 하지만, 만일 바깥의 람다에서 <code class='inline-code'>i</code> 를 <code class='inline-code'>Capture</code> 하지 않았다면 어떨까요.</p><pre class="chroma">
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">/</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
  <span class="n">m</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</pre><p>그러면 예상했던 대로 컴파일 오류 error C3493: 'i' <code class='inline-code'>cannot be implicitly captured because no default capture mode has been specified</code><span class='font-weight-bold'> 가 나오게 됩니다.</p><p>조금 더 복잡한 예로 아래의 코드를 살펴봅시다.</p><pre class="chroma">
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="n">i</span> <span class="o">/</span><span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
  <span class="n">m</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">inner: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="n">f</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> outer: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span>
</pre><p>일단 바깥의 람다는 <code class='inline-code'>i</code> 를 값으로 <code class='inline-code'>Capture</code> 하였기 때문에 바깥의 람다(f) 몸통에서는 <code class='inline-code'>i</code> 에 <code class='inline-code'>const</code> 속성이 붙습니다. 그런데, 내부의 람다(m) 가 그 <code class='inline-code'>i</code> 를 레퍼런스로 <code class='inline-code'>Capture</code> 해서 값을 변경하려고 했습니다. 그렇다면, 당연히 오류가 나겠지요. 실제로 컴파일 오류 'i': <code class='inline-code'>a by-value capture cannot be modified in a non-mutable lambda</code>가 발생하게 됩니다.</p><p>이를 해결하려면, 당연히도 <code class='inline-code'>mutable</code> 속성을 붙여주면 됩니다.</p><pre class="chroma">
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span> <span class="n">i</span> <span class="o">/</span><span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
  <span class="n">m</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">inner: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">f</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> outer: </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span>
</pre><p><code class='inline-code'>i</code> 자체가 값으로 입력 되었기 때문에 <code class='inline-code'>outer i</code> 의 값은 바뀌지 않고 8 로 남아 있고, 값으로 받은 <code class='inline-code'>i</code> 가 <code class='inline-code'>m</code> 에 의해서 2 로 나눠지므로 4 가 됩니다. 따라서, 그 결과</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F131AC44150EB84D7352A7C' alt=''><p>로 나오게 되죠.</p><h3><p>  클로져 객체의 복사 생성자와 소멸자</p></h3><p>모든 클로져 객체들은 암묵적으로 정의된 복사 생성자(copy constructor)와 소멸자(destructor)를 가지고 있습니다. 이 때 클로져 객체가 복사 생성 될 때 값으로 <code class='inline-code'>Capture</code> 된 것들의 복사 생성이 일어나겠지요. 아래의 예를 한번 보도록 하겠습니다.일단</p><pre class="chroma">
<span class="k">struct</span> <span class="n">trace</span> <span class="p">{</span>
  <span class="n">trace</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">construct</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">trace</span><span class="p">(</span><span class="n">trace</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">copy construct</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
  <span class="o">~</span><span class="n">trace</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">destroy</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">trace</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">trace</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">assign</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>와 같이 생성, 복사 생성, 소멸, 그리고 대입 연산을 확인할 수 있는 <code class='inline-code'>trace</code> 라는 구조체를 정의해놓고</p><pre class="chroma">
<span class="n">trace</span> <span class="n">t</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
</pre><p>를 한다면 어떻게 나올까요? <code class='inline-code'>f</code> 에서 <code class='inline-code'>t</code> 를 사용하지 않았으므로, <code class='inline-code'>t</code> 를 <code class='inline-code'>Capture</code> 하지 않게 됩니다. 따라서 그냥</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F261D453650EB88920DF3B7' alt=''><p>이 나오게 됩니다.</p><p>그렇다면 아래의 예는 어떨까요</p><pre class="chroma">
<span class="n">trace</span> <span class="n">t</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">m1</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">i</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>

<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> --- make copy --- </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span><span class="p">;</span>
</pre><p>먼저 <code class='inline-code'>m1</code> 을 생성하면서, 람다가 <code class='inline-code'>t</code> 를 <code class='inline-code'>Capture</code> 하였으므로 <code class='inline-code'>t</code> 의 복사 생성자가 호출되게 됩니다. 왜냐하면 값으로 받았기 때문이지요. 만일 레퍼런스로 받았다면 복사 생성자가 호출되지 않았을 것입니다 (확인해보세요!) 그리고 아래의 <code class='inline-code'>auto m2 =</code> m1; 에서 클로져 객체의 복사 생성이 일어나는데, 이 때, 클로져 객체의 복사 생성자가 값으로 <code class='inline-code'>Capture</code> 된 객체들을 똑같이 복사 생성 해주게 됩니다. 따라서 또 한번 <code class='inline-code'>t</code> 의 복사 생성자가 호출되겠지요. 그 결과 아래와 같이 출력됩니다.</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F197BFB3C50EB898B363D62' alt=''><h3><p>  람다의 전달 및 저장</p></h3><p>람다를 저장 및 전달하는 방식으로 앞에서 두 가지 방법을 보았습니다. 바로</p><pre class="chroma">
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">f</span><span class="p">)</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>
</pre><p>이지요. 우리가 만들어낸 클로져 객체의 타입이 정확히 무엇인지 몰라도 위와 같은 방법으로 성공적으로 처리할 수 있습니다.</p><p>또 다른 방법으로는 함수 포인터를 이용하는 방법이 있는데요, 이 경우 람다가 <code class='inline-code'>Capture</code> 하는 것이 없어야만 합니다.</p><pre class="chroma">
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f_type</span><span class="p">)</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="p">;</span>
<span class="n">f_type</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">f</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="p">;</span>
</pre><p>(참고로 위 기능은 <code class='inline-code'>Visual Studio 2010</code> 에서 지원되지 않습니다 <code class='inline-code'>-</code> 그 후의 버전에서만 가능합니다)</p><p>위 역시 성공적으로 28 을 출력함을 알 수 있습니다.</p><p>그런데, C++ 11 에서는 클로져 객체를 전달하고 또 저장할 수 있는 막강한 기능이 제공됩니다. 바로 std::function 인데요, 그 어떤 클로져 객체나 함수 등을 모두 보관할 수 있는 만능 저장소 입니다. (참고로 std::function 은 <code class='inline-code'>Visual Studio 2010</code> 에서 <code class='inline-code'>&lt;functional&gt;</code> 을 <code class='inline-code'>include</code> 해야 합니다)</p><pre class="chroma">
<span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
<span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">http://itguru.tistory.com</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">size</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>std::function 은 위와 같이 std::function <code class='inline-code'>&lt;</code> 반환 타입 ( 인자 ) <code class='inline-code'>&gt;</code> 와 같은 형태로 쓰며, <code class='inline-code'>Capture</code> 가 있어도 상관이 없습니다. 물론 위 코드는 실행하면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F1921313750EB9004276F3E' alt=''><p>와 같이 잘 나오지요.</p><p>이 std::function 을 통해 아래와 같이 재밌는 코드도 짤 수 있습니다.</p><pre class="chroma">
<span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f1</span><span class="p">;</span>
<span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">f1</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">f1</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">i</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">f2</span><span class="p">(</span><span class="o">+</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">f1</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="p">;</span>
</pre><p>이것이 가능한 이유는 만일 <code class='inline-code'>auto</code> 를 이용하였더라면 <code class='inline-code'>auto f1</code> 을 한 시점에서 <code class='inline-code'>f1</code> 이 명확히 구현이 되어야 컴파일러에서 타입을 추정할 수 있는데, 위와 같은 경우 <code class='inline-code'>f1</code> 을 구현하려면 <code class='inline-code'>f2</code> 를 먼저 구현해야 하고, 또 <code class='inline-code'>f2</code> 를 구현하려면 다시 <code class='inline-code'>f1</code> 을 먼저 구현해야 하는 순환적인 논리 딜레마에 빠지게 됩니다. 따라서 <code class='inline-code'>function</code> 을 이용해서 <code class='inline-code'>f1</code> 을 선언만 해 놓은 뒤, <code class='inline-code'>f2</code> 를 구현하고, 다시 <code class='inline-code'>f1</code> 을 구현하면 됩니다.</p><p>위 코드를 실행하면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1507053350EB90CD276602' alt=''><p>와 같이 잘 나옴을 알 수 있습니다.</p><p>마찬가지로 아래와 같은 재귀 호출 함수도 구현할 수 있습니다.</p><pre class="chroma">
<span class="n">std</span><span class="o">:</span><span class="o">:</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">fact</span><span class="p">;</span>
<span class="n">fact</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">fact</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">=</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">factorial(4) : </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">fact</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre><p>이 역시 <code class='inline-code'>auto</code> 를 이용했더라면, 처음 <code class='inline-code'>Capture</code> 부분에서 <code class='inline-code'>Capture</code> 하는 대상의 타입이 명확히 정해지지 않은 상태이므로 컴파일러가 타입을 추정할 수 없게 됩니다. 하지만 <code class='inline-code'>function</code> 을 이용해서 성공적으로 구현할 수 있습니다. 위 계산 결과는 당연히</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile5.uf.tistory.com%2Fimage%2F1309CB3950EB91601B0E2A' alt=''><p>가 나오겠지요.</p><h3><p>  마치며</p></h3><p><code class='inline-code'>C++</code> 에 새롭게 추가된 람다는 기존의 C++ 과 전혀 다른 새로운 개념 입니다. 하지만 람다를 이용하면 수십줄의 코드도 한 두 줄로 간추릴 수 있는, 엄청난 기능이 아닐 수 없습니다 C++ 에 새롭게 추가된 람다는 기존의 C++ 과 전혀 다른 새로운 개념 입니다. 하지만 람다를 이용하면 수십줄의 코드도 한 두 줄로 간추릴 수 있는, 엄청난 기능이 아닐 수 없습니다.이제 여러분들 손에는 람다라는 막강한 도구가 주어졌습니다. 이를 어떻게 사용하느냐는 여러분의 몫이지요 :)그리고 이런 훌륭한 강의를 제공해주신 <code class='inline-code'>Michael Caisse</code> 님에게 감사의 말을 전합니다.</p>