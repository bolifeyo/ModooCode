<p>이번 강좌에서는</p><ul><li><p> 상수 포인터(const <code class='inline-code'>int*, int* const)</code></p></li><li><p> 포인터의 덧셈, 뺄셈</p></li><li><p> 배열과 포인터와의 관계</p></li><li><p> <code class='inline-code'>[]</code> 연산자</p></li></ul><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F137907014AFE246AA02DDE' alt='신나는 씹어먹는 C 언어!'><p>  안녕하세요 여러분! 지난 시간에 포인터의 기본 중의 기본이라 할 수 있는 것 들에 배워보았습니다. 다시 정리해 보자면 포인터는 특정한 데이터의 메모리 상의 (시작) 주소값을 보관하는 변수 입니다.</p><p>  제가 C 언어를 배우면서 포인터를 배울 때 가장 많이 든 생각은</p><p>"근데 말야. 이거왜<span class='font-weight-bold'> 배워?"</p><p>  이였습니다. 맞아요. 여러분들도 위와 같은 생각이 머리속에 끊임없이 맴돌 것 입니다. <code class='inline-code'>int</code> a; 와 <code class='inline-code'>int</code> <span class='font-italic'>p; 가 있을 때 <code class='inline-code'>p</code> 가 <code class='inline-code'>a</code> 를 가리킨다고 하면 <code class='inline-code'>a =</code> 3; 이라 하지 <code class='inline-code'>*p =</code> 3; 과 같이 귀찮게 할 필요가 없잖아요. 하지만 나중에 가면 알겠지만포인터는 C 언어에서 정말로 중요한 역할을 담당하게 될 것입니다. 포인터의 중요한 역할에 대해 지금 이야기 하는 것은 무리라고 생각합니다. 일단, 포인터가 뭔지만 알아 놓고 이걸 도대체 왜 배우는지에 대해선 나중에 이야기 하도록 합시다.</p><h3><p>  상수 포인터</p></h3><p>  이전에 <code class='inline-code'>11-1</code> 강에서 상수에 대해 잠깐 언급한 것이 기억이 나시나요? 그 때 저는 어떠한 데이터를 상수로 만들기 위해 그 앞에 'const' 키워드를 붙여주면 된다고 했습니다. 예를 들어서</p><p><code class='inline-code'>const int a =</code> 3;</p><p>  과 같이 값이 3 인 <code class='inline-code'>int</code> 변수 <code class='inline-code'>a</code> 를 상수로 정의할 수 있습니다. <code class='inline-code'>const</code> 는 단순히 말해서 '이 데이터의 내용은 절대로 바뀔 수 없다' 라는 의미의 키워드 입니다. 따라서, 위 문장의 의미는 '이 <code class='inline-code'>int</code> 변수 <code class='inline-code'>a</code> 의 값은 절대로 바뀌면 안된다!!!' 가 됩니다. 위와 같이 정의한 상수 <code class='inline-code'>a</code> 를 아래 문장에</p><pre class="chroma"><span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</pre><p>  와 같이 하려고 해도 컴파일 시에 오류가 발생하게 됩니다. 왜냐하면 <code class='inline-code'>a</code> 는 상수로 선언이 되어 있으므로 값이 절대로 변경될 수 없기 때문이죠. 심지어 '값이 변경될 가능성이 있는 문장' 조차 허용되지 않습니다. 예를 들어</p><pre class="chroma"><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</pre><p>  이라고 한다면, <code class='inline-code'>a</code> 의 값은 이미 3 이므로 <code class='inline-code'>a</code> 의 값은 바뀌지 않습니다. 그런데 왠일? 컴파일 해보면 오류가 출력됩니다. 왜냐하면 위 문장은 <code class='inline-code'>a</code> 의 값이 바뀔 '가능성' 이 있기 때문이죠. 즉, 컴파일러는 <code class='inline-code'>a</code> 에 무슨 값이 들어가 있는지 신경 쓰지 않습니다. 그냥 무조건 가능성이 있다면 오류를 출력합니다.</p><p>  여러분은 도대체 왜 상수를 사용하는지 의문을 가질 것 입니다. 하지만 상수는 프로그래밍 상에서 프로그래머들의 실수를 줄여주고, 실수를 했다고 해도 실수를 잡아내는데 중요한 역할을 하고 있습니다. 예를 들어 아래와 같은 문장을 봅시다.</p><pre class="chroma"><span class="k">const</span> <span class="kt">double</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.141592</span><span class="p">;</span>
</pre><p>  즉 <code class='inline-code'>double</code> 형 변수 <code class='inline-code'>PI</code> 를 <code class='inline-code'>3.141592</code> 라는 값을 가지게 선언하였습니다. 왜 이렇게 해도 되냐면 실제로 <code class='inline-code'>PI</code> 값은 절대로 바뀌지 않는 상수 이기 때문이죠. 따라서, 프로그래머가 밤에 졸면서 코딩을 하다가 아래와 같이</p><pre class="chroma"><span class="n">PI</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre><p>  <code class='inline-code'>PI</code> 의 값을 문장을 집어 넣었다고 해도 컴파일 시 오류가 발생하여 프로그래머는 이를 고칠 수 있게 됩니다. 반면에 <code class='inline-code'>PI</code> 를 그냥 <code class='inline-code'>double</code> 형 변수로 선언했다고 해봅시다.</p><pre class="chroma"><span class="kt">double</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.141592</span><span class="p">;</span>
</pre><p>  그렇다면 프로그래머가 아래와 같은 코드를 잠결에 집어 넣었다면</p><pre class="chroma"><span class="n">PI</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</pre><p>  컴파일러는 이를 오류로 처리하지 않습니다. 이는 엄청나게 큰일이 아닐 수 없죠. 만일 고객들에게 원의 넓이를 계산하는 프로그램을 만들어 주었는데 잘못해서 이상한 값이 나오면 어떻겠습니까? 물론 위와 같이 간단한 오류는 잡아내기 쉽지만 프로그램이 커지만 커질 수록 위와 같은 오류를 잡아내는 것은 여간 힘든 일이 아닙니다. 따라서, 우리는 '절대로 바뀌지 않을 것 같은 값에는 무조건 <code class='inline-code'>const</code> 키워드를 붙여주는 습관' 을 기르는 것이 중요합니다.</p><p>  아무튼. 이번에는 포인터에도 <code class='inline-code'>const</code> 를 붙일 수 있는지 생각해 봅시다.</p><pre class="chroma"><span class="cm">/* 상수 포인터? */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

  <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 올바르지 않은 문장
</span><span class="c1"></span>  <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>  <span class="c1">// 올바른 문장
</span><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>컴파일 해보면 오류가 발생합니다.</p><pre class='warning'>error C2166 : l - value가 const 개체를 지정합니다.
</pre><p>일단, 위 오류가 왜 발생하였는지에 대해 이야기 하기 앞서서 아래 문장이 무슨 의미를 가지는지 살펴 봅시다.</p><pre class="chroma"><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pa</span> <span class="o">=</span>
    <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>  <span class="c1">// int* pa 와 같이 정의해도 int *pa 와 같다는 사실은 다 알고 있죠?
</span><span class="c1"></span></pre><p> 여러분은 위 문장을 보면 다음과 같은 생각이 떠오를 것입니다. "저 포인터는 <code class='inline-code'>const int</code> 형을 가리키는 포인터인데, 어떻게 <code class='inline-code'>int</code> 형 변수 <code class='inline-code'>a</code> 의 주소값이 대입 될 수 있지? 그러면 안되는 거 아니야?". 하지만, 제가 앞에서 누누히 강조해 왔듯이 'const' 라는 키워드는 '이 데이터의 값은 절대로 바뀌면 안된다' 라고 일러주는 키워드라고 하였습니다. 다시 말해, <code class='inline-code'>const int a</code> 라는 변수는 그냥 <code class='inline-code'>int</code> 형 변수 <code class='inline-code'>a</code> 인데 값이 절대로 바뀌면 안되는 변수일 뿐입니다. 따라서, <code class='inline-code'>const int a</code> 변수도 그냥 <code class='inline-code'>int</code> 형이라 말할 수 있습니다. (다만 '변'수가 아닐 뿐)</p><p>  따라서 <code class='inline-code'>const int*</code> 의 의미는 <code class='inline-code'>const int</code> 형 변수를 가리킨다는 것이 아닙니다. <code class='inline-code'>int</code> 형 변수를 가리키는데 '그 값을 절대로 바꾸지 말라' 라는 의미이죠. 즉, <code class='inline-code'>pa</code> 는 어떠한 <code class='inline-code'>int</code> 형 변수를 가리키고 있습니다. 그런데 <code class='inline-code'>const</code> 가 붙었으므로<code class='inline-code'>pa</code> 가가리키는 변수의 값은 절대로 바뀌면 안되게 됩니다. 여기서 'pa 가' 라는 부분을 강조한 이유는 <code class='inline-code'>a</code> 자체는 변수 이므로 값이 자유롭게 변경될 수 있기 때문입니다. 하지만 <code class='inline-code'>pa</code> 를 통해서 <code class='inline-code'>a</code> 를 간접적으로 가리킬 때 에는 컴퓨터가 '아, 내가 <code class='inline-code'>const</code> 인 변수를 가리키고 있구나' 로 생각하기 때문에(const <code class='inline-code'>int*</code> 로 포인터를 정의하였으므로) 값을 바꿀 수 없게 됩니다.</p><p>  결과적으로 아래의 문장은 오류를 출력합니다.</p><pre class='info'>*pa = 3;  // 올바르지 않은 문장
</pre><p>물론 <code class='inline-code'>a =</code> 3; 과 같은 문장은 오류를 출려하지 않습니다. 앞에서도 말했듯이 변수 <code class='inline-code'>a</code> 자체는 <code class='inline-code'>const</code> 가 아니기 때문이죠.</p><pre class="chroma"><span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>  <span class="c1">// 올바른 문장
</span><span class="c1"></span></pre><p>그렇다면 위 문장은 옳은 문장 입니다. 왜 일까요? (아마 당연하다고 생각하면 여러분은 훌륭한 학생들 입니다) 이는 아래 예제와 함께 설명하도록 하겠습니다.</p><pre class="chroma"><span class="cm">/* 상수 포인터? */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

  <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 올바른 문장
</span><span class="c1"></span>  <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>  <span class="c1">// 올바르지 않은 문장
</span><span class="c1"></span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>역시 컴파일 해보면</p><pre class='warning'>error C2166 : l - value가 const 개체를 지정합니다.
</pre><p>앞서 보았던 오류와 동일한 오류가 뜹니다. 그런데 위치가 다릅니다. 앞에서는 위 문장에서 오류가 발생했는데 이번엔 아래에서 발생합니다. 일단, 포인터의 정의 부분 부터 이야기 해봅시다.</p><pre class="chroma"><span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</pre><p>차근차근 봐 보면, 우리는 <code class='inline-code'>int*</code> 를 가리키는 <code class='inline-code'>pa</code> 라는 포인터를 정의하였습니다. 그런데 이번에는 <code class='inline-code'>const</code> 키워드가 <code class='inline-code'>int*</code> 앞에 있는 것이 아니라 <code class='inline-code'>int*</code> 와 <code class='inline-code'>pa</code> 사이에 놓이고 있습니다. 뭐지? 하지만 이 것은 <code class='inline-code'>const</code> 키워드의 의미를 그대로 생각해 보면 간단합니다. <code class='inline-code'>pa</code> 의 값이 바뀐 안된다는 것이지요. 그런데 제일 처음에 포인터를 배울 때 강조했듯이, 포인터에는 가리키는 데이터의 주소값, 즉 위 경우 <code class='inline-code'>a</code> 의 주소값이 <code class='inline-code'>pa</code> 저장되는 것이지요. 따라서, 이 <code class='inline-code'>pa</code> 가 <code class='inline-code'>const</code> 라는 의미는 <code class='inline-code'>pa</code> 의 값이 절대로 바뀔 수 없다는 것인데, <code class='inline-code'>pa</code> 는 포인터가 가리키는 변수의 주소값이 들어 있으므로 결과적으로 <code class='inline-code'>pa</code> 가 처음에 가리키는 것 (a) 말고 다른 것은 절대로 건드릴 수 없다는 것 입니다.</p><pre class='info'>pa = &b;  // 올바르지 않은 문장
</pre><p>결론적으로 위 문장은 오류를 뿜게 됩니다. 왜냐하면 <code class='inline-code'>pa</code> 가 다른 변수를 가리키기 때문이죠 (즉 <code class='inline-code'>pa</code> 에 저장된 주소값을 바꾸므로) 반면에 위의 예제에서 오류가 났던 문장은 올바르게 돌아갑니다.</p><pre class="chroma"><span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 올바른 문장
</span><span class="c1"></span></pre><p>왜냐하면 <code class='inline-code'>pa</code> 가 가리키는 값을 바꾸면 안된다는 말은 안했기 때문이죠. (그냥 <code class='inline-code'>int* )</code></p><p>한 번 위에 나와있던 것을 모두 합쳐 보면</p><pre class="chroma"><span class="cm">/* 상수 포인터? */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

  <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 올바르지 않은 문장
</span><span class="c1"></span>  <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>  <span class="c1">// 올바르지 않은 문장
</span><span class="c1"></span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>와 같이 되겠지요. 어때요? 쉽죠?</p><h3><p>  포인터의 덧셈</p></h3><p>  이번에는 포인터의 덧셈과 뺄셈에 대해서 다루어 보도록 하겠습니다. 앞에서도 강조하였지만 지금 하는 작업들이 무의미해 보이고 쓸모 없어 보이지만 나중에 정말로 중요하게 다루어 집니다. 조금만 힘내세요 (아마도 C 언어에서 가장 재미 없는 부분일듯.)</p><pre class="chroma"><span class="cm">/* 포인터의 덧셈 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">pa</span><span class="p">;</span>
  <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pa 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">(pa + 1) 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 해보면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F2070331E4AFBD5CC1E3BA4' alt=''><p>여러분의 출력 결과는 위에 나온 결과와 다를 수 있습니다. 다만, 두 수의 차이는 4 일 것입니다.  아마 여러분은 출력된 결과를 보면서 깜짝 놀랐을 것입니다. 우리는 분명히</p><pre class="chroma"><span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">(pa + 1) 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
</pre><p>에서 <code class='inline-code'>pa + 1</code> 의 값을 출력하라고 명시하였습니다. 제가 앞에서도 이야기 하였듯이 <code class='inline-code'>pa</code> 에는 자신이 가리키는 변수의 주소값이 들어갑니다. 따라서, <code class='inline-code'>pa + 1</code> 을 하면 1244812 에 1 이 더해진 1244813 가 아니라, 4 가 더해진 1244816 이 출력되었습니다. 이게 도대체 무슨 일입니까? <code class='inline-code'>1244812 + 1 = 1244816</code> 이라고요?</p><p>  위 해괴한 계산 결과를 해결하기 앞서, 우리는 포인터의 형이 <code class='inline-code'>int*</code> 라는 것을 알 수 있었습니다. 그런데, <code class='inline-code'>int</code> 가 4 바이트 이니까.... 설마?</p><p>  일단, 위 추측을 확인해보기 위해 int  포인터 말고도 크기가 다른 <code class='inline-code'>char</code> 이다 <code class='inline-code'>double</code> 등에 대해서도 해봅시다.</p><pre class="chroma"><span class="cm">/* 과연? */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">c</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
  <span class="kt">double</span><span class="o">*</span> <span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pa 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">(pa + 1) 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pb 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pb</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">(pb + 1) 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pc 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pc</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">(pc + 1) 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 후 실행해 보면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1201521B4AFBD7BE1B72CC' alt=''><p>여러분의 출력 결과는 위에 나온 결과와 다를 수 있습니다.  우왕.  우리의 예상과 정확하게 맞아 떨어졌습니다. <code class='inline-code'>pb</code> 의 경우 1 이 더해졌고, <code class='inline-code'>pc</code> 의 경우 8 이 더해졌습니다. 그런데, <code class='inline-code'>char</code> 은 1 바이트, <code class='inline-code'>double</code> 은 8 바이트 이므로 모두 우리가 예상한 결과와 일치합니다. 놀랍군요. 하지만 머리 한 켠에는 또다른 의문이 남습니다. 왜 하라는 대로 안하고 포인터가 가리키는 형의 크기 만큼 더할까요. 사실 이에 대한 해답은 대략 2 분 31 초 뒤에 나옵니다.</p><p> 훌륭한 학생이라면 여러가지 모험을 해볼 것 입니다. 예를 들어 '포인터의 뺄셈은 허용되는지, 포인터 끼리 더해도 되는지 등등..' 말이죠. 우리도 한 번 궁금증을 해결해 봅시다.</p><p>  일단 직관적으로 포인터의<span class='font-weight-bold'> 뺄셈은 허용될 것 같습니다. 왜냐하면 뺄셈은 본질적으로 덧셈과 다를 바 없기 때문이죠. (1 - 1 = 1 + (-1) <code class='inline-code'>)</code> 아무튼 해 보면 덧셈과 유사한 결과가 나타납니다.</p><pre class="chroma"><span class="cm">/* 포인터 뺄셈 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pa 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">(pa - 1) 의 값 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pa</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 후 실행 해보면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F1416491A4AFBD968037E07' alt=''><p>여러분의 출력 결과는 위에 나온 결과와 다를 수 있습니다.  역시 우리의 예상대로 4 가 빼졌습니다.</p><pre class="chroma"><span class="cm">/* 포인터끼리의 덧셈 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">+</span> <span class="n">pb</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>아마 컴파일 해보면 아래와 같은 오류를 만날 수 있습니다.</p><pre class='warning'>error C2110 : '+' : 두 포인터를 더할 수 없습니다.
</pre><p>왜 C 에서는 두 포인터끼리의 덧셈을 허용하지 않는 것일까요? 사실, 포인터끼리의 덧셈은 아무런 의미가 없을 뿐더러 필요 하지도 않습니다. 두 변수의 메모리 주소를 더해서 나오는 값은 이전에 포인터들이 가리키던 두 개의 변수와 아무런 관련이 없는 메모리 속의 임의의 지점 입니다. 아무런 의미가 없는 프로그램 상에 상관없는 지점을 말이죠. 무언가, 설명이 불충분한 느낌이 들지만 아무튼 포인터 끼리의 덧셈은 아무런 의미가 없기 때문에 C 언어에선 수행할 수 없습니다. 그렇다면, 포인터에 정수를 더하는 것은 왜 되는 것일까요. 아까도 말했듯이 이에 대해선 아래에서 설명해드리겠습니다. (이제 1분 정도 남았군요.)</p><p>  그런데 한 가지 놀라운 점은 포인터끼리의 뺄셈은 가능하다는 것입니다. 왜 그런지에 대한 설명은 나중에 합시다.</p><pre class="chroma"><span class="cm">/* 포인터의 대입 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">pb</span><span class="p">;</span>

  <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">pb</span> <span class="o">=</span> <span class="n">pa</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pa 가 가리키고 있는 것 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">pb 가 가리키고 있는 것 : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">pb</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 해보면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F1818381A4AFBDBD9037769' alt=''><p>와 같이 나옵니다. 뭐 당연한 일이지요.</p><pre class="chroma"><span class="n">pb</span> <span class="o">=</span> <span class="n">pa</span><span class="p">;</span>
</pre><p>부분에서 <code class='inline-code'>pa</code> 에 저장되어 있는 값 (즉, <code class='inline-code'>pa</code> 가 가리키고 있는 변수의 주소값) 을 <code class='inline-code'>pb</code> 에 대입하였습니다. 따라서 <code class='inline-code'>pb</code> 도 <code class='inline-code'>pa</code> 가 가리키던 것의 주소값을 가지게 되는 것이지요. 결과적으로 <code class='inline-code'>pb</code> 와 <code class='inline-code'>pa</code> 모두 <code class='inline-code'>a</code> 를 가리키게 됩니다. 주의해야 될 점은 <code class='inline-code'>pa</code> 와 <code class='inline-code'>pb</code> 가 형이 같아야 한다는 점 입니다. 다시 말해 <code class='inline-code'>pa</code> 가 <code class='inline-code'>int*</code> 면 <code class='inline-code'>pb</code> 도 <code class='inline-code'>int*</code> 여야 합니다. 만일 형이 다르다면 형변환을 해주어야 하는데 이에 대한 이야기는 나중에 합시다.</p><h3><p>  배열과 포인터</p></h3><pre class='warning'>아마 이 단원을 읽다 보면 쇼크를 받을 지도 모르므로 심장이 약하신 분들은 의사와
    함께 하십시오.(참고로 저의 경우 많이 놀라서 잠을 잘 못잤습니다)
</pre><p>  제가 C 언어를 배우면서 가장 감탄하고도 쇼킹했던 부분이 바로 여기였습니다. 물론, 모든 사람들이 그다지 놀라워 하는 것은 아니지만 저한테는 신선한 충격이였습니다. 아마 이 단원을 배운다면 앞서 '포인터의 연산은 왜 이따구로 하는 거야!' 에 대한 답안을 찾을 수 있을 것 입니다.</p><p>  이전 강좌에서 (11 강) 저는 여러분에게 배열에 대해 이야기 했었습니다. 그 때, 배열은 '변수가 여러개 모인 것으로 생각할 수 있다' 라고 이야기 했었지요. 그런데 말이죠. 또다른 놀라운 특징이 있습니다. 바로 배열들의 각 원소는 메모리 상에 연속되게 놓인 다는 점입니다. 뭐, 놀랍지 않다면 말고요. 어쨋든,</p><pre class="chroma"><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span><span class="p">;</span>
</pre><p>  이라는 배열을 정의한다면 메모리 상에서 다음과 같이 나타납니다.</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F152460454D5FA71108EA6F' alt='10 개의 방이 있고 각 방에 1 부터 10 까지 들어가 있습니다. 물론 각 방의 주소값은 다 있죠'><p>  즉, 위와 같이 메모리 상에 연속된 형태로 나타난다는 점이지요. 한 개의 원소는 <code class='inline-code'>int</code> 형 변수이기 때문에 4 바이트를 차지하게 됩니다. 물론, 위 사실을 믿지 못하시는 분들은 아래와 같이 컴퓨터를 통해 직접 확인해 볼 수 있습니다.</p><pre class="chroma"><span class="cm">/* 배열의 존재 상태? */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">arr[%d] 의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  성공적으로 컴파일 하면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile27.uf.tistory.com%2Fimage%2F1639F7274AFD1D74023A3F' alt=''><p> 와 같이 나타납니다. 여러분의 결과와 주소값은 약간 다를 수 있지만, 어쨋든 4 씩 증가하면 된 것입니다.</p><p> 아마 여기쯤 왔다면 여러분의 머리를 스쳐지나가는 생각이 들 것입니다! 아! 포인터로도 배열의 원소에 쉽게 접근이 가능하겠구나! (이 생각이 떠오르지 않는 사람은 아마 이 글을 다시 처음부터 읽으셔야 합니다.) 배열의 시작 부분을 가리키는 포인터를 정의한 뒤에 포인터에 1 을 더하면 그 다음 원소를 가리키겠군! 그리고 2 를 더한 그 다음 다음 원소를 가리킨다!!</p><p> 위와 같은 일이 가능한 이유는 포인터는 자신이 가리키는 데이타의 '형' 의 크기를 곱한 만큼 덧셈을 수행하기 때문이죠. 즉 <code class='inline-code'>p</code> 라는 포인터가 <code class='inline-code'>int</code> a; 를 가리킨다면 <code class='inline-code'>p + 1</code> 을 할 때 <code class='inline-code'>p</code> 의 주소값에 사실은 <code class='inline-code'>1*4</code> 가 더해지고, <code class='inline-code'>p + 3</code> 을 하면 <code class='inline-code'>p</code> 의 주소값에 <code class='inline-code'>3*4</code> 인 12 가 더해진다는 것입니다.</p><p> 한 번 이 아이디어를 적용시켜서 배열의 원소를 가리키는 포인터를 만들어봅시다.</p><pre class="chroma"><span class="cm">/* 과연? */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">parr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">parr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">arr[%d] 의 주소값 : %x </span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">(parr + %d) 의 값 : %x </span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">parr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span><span class="o">=</span> <span class="p">(</span><span class="n">parr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* 만일 (parr + i) 가 성공적으로 arr[i] 를 가리킨다면 */</span>
      <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s"> --&gt; 일치 </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">--&gt; 불일치</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  성공적으로 컴파일 하였다면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile22.uf.tistory.com%2Fimage%2F143FB70D4AFD20946EB9D0' alt=''><p> 정확히 모두 일치가 나옵니다. 위 소스코드가 이해가 안되는 분들이 있을 까봐 살짝 설명을 드리기는 하겠습니다.</p><pre class="chroma"><span class="n">parr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span>
</pre><p> parr 이라는 <code class='inline-code'>int</code> 형을 가리키는 포인터는 <code class='inline-code'>arr[0]</code> 이라는 <code class='inline-code'>int</code> 형 변수를 가리킵니다. (배열의 각 원소는 하나의 변수로 생각할 수 있다는 사실은 까먹지 않았죠? <code class='inline-code'>)</code></p><pre class="chroma"><span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">arr[%d] 의 주소값 : %x </span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">(parr + %d) 의 값 : %x </span><span class="s">&#34;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">parr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p><span class='font-weight-bold'> 이제, <code class='inline-code'>arr[i]</code> 의 주소값과 (parr + i) 의 값을 출력해봅니다. 만일 <code class='inline-code'>parr + i</code> 의 값이 <code class='inline-code'>arr[i]</code> 의 주소값과 같다면 하단의 <code class='inline-code'>if-else</code> 에서'일치' 가 출력되고 다르다면 '불일치' 가 출력되게 됩니다. 그런데, 이미 예상하고 있던 바이지만 <code class='inline-code'>parr</code> 이 <code class='inline-code'>int</code> 형이므로 <code class='inline-code'>+ i</code> 를 하면 주소값에는 사실상 <code class='inline-code'>4*i</code> 가 더해지게 되는 것이지요. 이 때 <code class='inline-code'>arr[i]</code> 의 주소값도 <code class='inline-code'>i</code> 가 하나씩 커질 때 마다 4 씩 증가하므로 (int 형 배열이므로) 결과적으로 모든 결과가 일치하게 되는 것 입니다.</p><p> 이렇게 포인터에 정수를 더하는 것 만으로도 배열의 각 원소를 가리킬 수 있습니다. 그렇다면 <code class='inline-code'>*</code> 를 이용하여 원소들과 똑같은 역할을 할 수 있게 되겠군요. 마치 아래 예제 처럼 말이지요.</p><pre class="chroma"><span class="cm">/* 우왕 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">parr</span><span class="p">;</span>

  <span class="n">parr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">arr[3] = %d , *(parr + 3) = %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">parr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  성공적으로 컴파일 하였다면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile26.uf.tistory.com%2Fimage%2F195AB3284AFD2335290679' alt=''><p>  와 같이 동일하게 접근할 수 있게 됩니다.</p><p>  즉 <code class='inline-code'>parr + 3</code> 을 수행하면, <code class='inline-code'>arr[3]</code> 의 주소값이 되고, 거기에 <code class='inline-code'>*</code> 를 붙여주면 <code class='inline-code'>*</code> 의 연산자의 역할이 '그 주소값에 해당하는 데이터를 의미해라!' 라는 뜻이므로 <code class='inline-code'>*(parr + 3)</code> 은 <code class='inline-code'>arr[3]</code> 과 동일하게 된다는 것입니다. 어때요? 놀랍지요. 포인터의 덧셈이 왜 그렇게 수행되는지 속 시원하게 해결되는 것 같나요?</p><h3><p>  배열의 이름의 비밀</p></h3><p>  아마 여러분들 중 대다수는 배열을 처음 배울 때 다음과 같은 실수를 하신 경험이 있을 것 입니다. (나만 그런가?)</p><pre class='info'>#include <stdio.h>
int main() {
  int arr[3] = {1, 2, 3};

  printf("%d", arr);
}
</pre><p>  그러곤 1 도, 2 도, 3 도, 아닌 이상한 값이 나오는 것을 보고 당황하셨겠죠.. 그런데, 놀랍게도 그 때 출력되는 값은 아래와 같습니다.</p><pre class="chroma"><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">arr 의 정체 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">arr[0] 의 주소값 : %x </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F162074184AFD528647BF6B' alt=''><p>출력 결과는 여러분과 다를 수 있으나 두 값이 같다는 점에 주목하세요와 같이 나옵니다. 와우~ 놀랍게도 <code class='inline-code'>arr</code> 과 <code class='inline-code'>arr[0]</code> 의 주소값이 동일합니다.</p><p>따라서 배열에서 배열의 이름은 배열의 시작 주소값을 지칭하고 있다는 사실을 알 수 있습니다. 다시 말해, 배열의 이름은 배열의 시작 주소를 가리키는 포인터라고 생각할 수 있겠군요. 그렇다면 다음과 같은 연산이 가능할까요?</p><pre class="chroma"><span class="cm">/* 될까? */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">brr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span><span class="p">;</span>

  <span class="n">arr</span> <span class="o">=</span> <span class="n">brr</span><span class="p">;</span>  <span class="c1">// 안됨
</span><span class="c1"></span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  컴파일 해보면 아래와 같은 오류가 뜹니다.</p><pre class='warning'>error C2106 : '=' : 왼쪽 피연산자는 l - value이어야 합니다.
</pre><p>  <code class='inline-code'>arr</code> 을 다른 배열을 가리키게 주소값을 바꿀 수 없다는 뜻이군요... 여러분들은 왜 그래야만 하는지 이해가 가나요? 사실 <code class='inline-code'>arr</code> 은 포인터 상수 형태로 되어 있습니다. 이 경우에는 <code class='inline-code'>int* const</code> 꼴의 포인터가 되지요. 사실 이러한 이유는 컴퓨터 메모리의 구조와 밀접한 관련이 있지만 여기서는 그 이야기는 하지 않도록 하겠습니다.</p><h3><p>  [] 연산자의 역할</p></h3><p>  여러분들 중에서 많은 분들은 <code class='inline-code'>[]</code> 가 연산자였다는 사실을 보고 깜짝 놀랐을 것 입니다. 그런데, 제가 사실 오래 전에 암묵적으로 알려 주었었죠.. 다음 그림은 4 강에서 연산 순위에 대해 이야기 하였을 때 가져왔던 그림입니다.</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile8.uf.tistory.com%2Fimage%2F110BAC254AFD485D293EC3' alt=''><p><code class='inline-code'>* www.winapi.com</code> 에서 가져온 자료 입니다.  위의 표에서 아는 연산자가 별로 없다고 걱정하지는 마세요!우리는 앞으로 C 언어를 공부하면서 위의 거의 모든 연산자들을 다 배울 것 입니다. 표 최상단을 보면 <code class='inline-code'>[ ]</code> 라 생긴 것이 보일 것 입니다. 아무튼.. <code class='inline-code'>[]</code> 도 연산자였습니다. 우리는 막연히 배열을 처음에 배우면서 "아, 배열의 <code class='inline-code'>n</code> 번째 원소를 지정하려면 <code class='inline-code'>[n-1]</code> 이라고 해야 되는 구나!" 라고 생각하였는데 <code class='inline-code'>[ ]</code> 도 <code class='inline-code'>+ , -</code> 와 같은 특정한 역할을 하는 연산자였던 것입니다.</p><p> 그런데, 우리는 앞서 포인터와 배열의 놀라운 관계를 배웠기 때문에 <code class='inline-code'>[ ]</code> 연산자의 역할을 대충 짐작할 수 있습니다.</p><pre class="chroma"><span class="cm">/* [] 연산자 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">a[3] : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">*(a+3) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p> 성공적으로 컴파일 했다면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile23.uf.tistory.com%2Fimage%2F147786034AFE0DAB5D0053' alt=''><p>  음... 이미 앞에서 다룬 내용을 모두 이해했더라면 위 정도쯤은 쉽게 이해할 수 있을 것입니다. 사실 컴퓨터는 C 에서 <code class='inline-code'>[]</code> 라는 연산자가 쓰이면 자동적으로 위 처럼 포인터 형태로 바꾸어서 처리하게 됩니다. 즉, 우리가 <code class='inline-code'>arr[3]</code> 이라 사용한 것은 사실 <code class='inline-code'>*(arr + 3)</code> 으로 바뀌어서 처리가 된다는 뜻이지요.</p><p>  따라서 다음과 같이 신기한 연산도 가능합니다.</p><pre class="chroma"><span class="cm">/* 신기한 [] 사용 */</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">3[arr] : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">[</span><span class="n">arr</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">*(3+a) : %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>  성공적으로 컴파일 하면</p><img class='content-img' src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile4.uf.tistory.com%2Fimage%2F12363D234AFE10DA5943D8' alt=''><p>  <code class='inline-code'>3[arr]</code> 은 무언가 조금 '깨는' 표현 입니다. 사실 이렇게 사용한다면 가독성도 떨어지고 한 번에 이해도 되지 않기에 <code class='inline-code'>99.9999%</code> 의 프로그래머들은 <code class='inline-code'>arr[3]</code> 으로 사용할 것입니다. 하지만, 앞에서도 <code class='inline-code'>[]</code> 는 연산자로 <code class='inline-code'>3[arr]</code> 을 <code class='inline-code'>*(3+arr)</code> 로 바꿔주기 때문에 <code class='inline-code'>arr[3]</code> 과 동일한 결과를 출력할 수 있게 되지요.</p><h3><p>  포인터의 정의</p></h3><p>  앞에서 말하기를 <code class='inline-code'>int</code> 를 가리키는 포인터를 정의하기 위해 다음의 두 문장을 모두 사용할 수 있다고 했습니다.</p><pre class="chroma"><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
</pre><p>  그런데 말이죠. 제 강좌 말도 다른 곳에서 C 언어를 공부했던 사람들이라면 아래와 같은 형식을 훨씬 많이 쓴다는 사실을 알 수 있었을 것입니다.</p><pre class="chroma"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</pre><p>  왜 일까요? 우리가 <code class='inline-code'>int</code> 형 변수를 여러개 한 번에 선언하려 했을 때 <code class='inline-code'>int</code> a,b,c,d; 라 하잖아요. 포인터 변수를 여러개 선언 하려면 아래와 같이 해야 합니다.</p><pre class="chroma"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
</pre><p>  물론</p><pre class="chroma"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>
</pre><p>  게 해도 됩니다. 다만,</p><pre class="chroma"><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
</pre><p>  꼴로 한다면 다음과 같이 실수 할 확률이 매우 커지게 됩니다. 왜냐하면 아래와 같이 한다면</p><pre class="chroma"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
</pre><p> p 만 <code class='inline-code'>int</code> 를 가리키는 포인터 이고, <code class='inline-code'>q, r</code> 은 평범한 <code class='inline-code'>int</code> 형 변수가 됩니다. 따라서, 앞으로 저는 제 강좌에서 모든 포인터들은</p><pre class="chroma"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</pre><p>꼴로 선언 하도록 하겠습니다.</p><p>생각해 볼 문제</p><p><code class='inline-code'>int</code> arr[3][3]; 과 같은 배열은 내부적으로 어떻게 처리되는지 생각해보세요 (난이도 : 中)</p><p><code class='inline-code'>int*</code> arr[3]; 과 같은 배열이 가지는 의미는 무엇일까요? (난이도 : 中)</p><pre class='warning'>강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면꼭 댓글을 남겨주시기 바랍니다. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요.

현재 여러분이 보신 강좌는 <<씹어먹는 C 언어 - <12 - 2. 포인터는 영희이다! (포인터)>>> 입니다. 이번 강좌의모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전까지 다음 강좌로 넘어가지 말아주세요


[다음 강좌 보러가기](http://itguru.tistory.com/notice/15)
</pre>