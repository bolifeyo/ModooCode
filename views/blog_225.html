<p>itguru Top itguru Top</p><p>이번 강좌에서는</p><ul><li><p> 람다 함수(lambda function)</p></li><li><p> 정렬 알고리즘</p></li><li><p> 원소 삭제 알고리즘</p></li><li><p> 원소 탐색 알고리즘</p></li></ul><p>등등에 대해 다룹니다.</p><p>안녕하세요 여러분! 이번 강좌에서는 STL 의 알고리즘(algorithm) 라이브러리에 대해서 알아보도록 하겠습니다. 알고리즘 라이브러리는 앞선 강좌에서 이야기 했었던 대로, 컨테이너에 반복자들을 가지고 이런 저런 작업을 쉽게 수행할 수 있도록 도와주는 라이브러리 입니다.</p><p>여기서 말하는 이런 저런 작업이란, 정렬이나 검색과 같이 단순한 작업들 말고도, '이런 조건이 만족하면 컨테이너에서 지워줘' 나 '이런 조건이 만족하면 1 을 더해' 와 같은 복잡한 명령의 작업들도 알고리즘 라이브러리를 통해 수행할 수 있습니다.</p><p>우리는 알고리즘에 정의되어 있는 여러가지 함수들로 작업을 수행하게 됩니다. 이 때 이 함수들은 크게 아래와 같은 두 개의 형태를 가지고 있습니다.</p><pre class="chroma">
template &lt;typename Iter&gt;
void do_something (Iter begin, Iter end);
</pre><p>거나</p><pre class="chroma">
template &lt;typename Iter, typename Pred&gt;
void do_something (Iter begin, Iter end, Pred pred)
</pre><p>와 같은 꼴을 따르고 있습니다. 전자의 경우, 알고리즘을 수행할 반복자의 시작점과 끝점 바로 뒤를 받고, 후자의 경우 반복자는 동일하게 받되, '특정한 조건' 을 추가 인자로 받게 됩니다. 이러한 '특정한 조건'을 서술자(Predicate) 이라고 부르며 저기 Pred 에는 보통 bool 을 리턴하는 함수 객체(Functor) 를 전달하게 됩니다. (이번 강좌에서 함수 객체를 매우 편리하게 만들어주는 람다 함수에 대해 다룰 것입니다!)</p><p> 정렬 (sort, stable<span class='font-italic'>sort, partial</span>sort)</p><p>첫번째로 알고리즘 라이브러리에서 지원하는 정렬(sort) 에 대해서 알아보도록 하겠습니다. 사실 정렬이라 하면 한 가지 밖에 없을 것 같은데 정렬 알고리즘에서는 무려 3 가지 종류의 함수를 지원하고 있습니다. 이를 살펴보자면 각각 다음과 같습니다.</p><ul><li><p> sort : 일반적인 정렬 함수라 생각하시면 됩니다.</p></li><li><p> stable<span class='font-italic'>sort : 정렬을 하되 원소들 간의 순서를 보존합니다. 이 말이 무슨 말이냐면, 만약에 벡터에 [a, b] 순으로 있었는데, a 와 b 가 크기가 같다면 정렬을 [a,b] 혹은 [b,a] 로 할 수 있습니다. sort 의 경우 그 순서가 랜덤으로 정해집니다. 하지만 stable</span>sort 의 경우 그 순서를 반드시 보존합니다. 즉 컨테이너 상에서 [a,b] 순으로 있엇다면 정렬 시에도 (크기가 같다면) [a,b] 순으로 나오게 됩니다. 이 때문에 sort 보다 좀 더 느립니다.</p></li><li><p> partial<span class='font-italic'>sort : 배열의 일부분만 정렬합니다 (아래 자세히 설명하겠습니다)</p></li></ul><p>그렇다면 각각의 함수들을 사용해보도록 하겠습니다!</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 전 ----</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 후 ----</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>위와 같이 잘 정렬되서 나옴을 알 수 있습니다.</p><pre class="chroma">
<span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>sort 함수는 위와 같이 정렬할 원소의 시작 위치와, 마지막 위치 바로 뒤를 반복자로 받습니다. 참고로 sort 에 들어가는 반복자의 경우 반드시 임의접근 반복자(RandomAccessIterator) 타입을 만족해야 하므로, 우리가 봐왔던 컨테이너들 중에서 벡터와 데크만 가능하고 나머지 컨테이너는 sort 함수를 적용할 수 었습니다. (예를 들어 리스트의 경우 반복자 타입이 양방향 반복자(BidirectionalIterator) 이므로 안됩니다)</p><pre class="chroma">
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">l</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>만약에 위 처럼 리스트를 정렬하려고 했다간;</p><pre class="chroma">
ErrorC2784&#39;unknown-type std::operator -(const std::move_iterator&lt;_RanIt&gt; &amp;,const std::move_iterator&lt;_RanIt2&gt; &amp;)&#39;: could not deduce template argument for &#39;const std::move_iterator&lt;_RanIt&gt; &amp;&#39; from &#39;std::_List_unchecked_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;int&gt;&gt;&#39;
</pre><p>위와 같은 무지막지한 컴파일 오류를 맛보게 될 것입니다!</p><p>sort 함수는 기본적으로 오름차순으로 정렬을 해줍니다. 그렇다면 만약에 내림 차순으로 정렬하고 싶다면 어떻게 할까요? 만약에 여러분이 직접 만든 타입이였다면 단순히 operator< 를 반대로 바꿔준다면 오름차순에서 내림차순이 되었겠지만, 이 경우 int 이기 때문에 이는 불가능 합니다.</p><p>하지만 앞서 대부분의 알고리즘은 3 번째 인자로 특정한 조건을 전달한다고 하였는데, 여기에 우리가 비교를 어떻게 수행할 것인지에 대해 알려주면 됩니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">int_compare</span> <span class="p">{</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="k">const</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 전 ----</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">int_compare</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 후 ----</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 내림 차순으로 정렬되서 나옵니다.</p><pre class="chroma">
<span class="k">struct</span> <span class="n">int_compare</span> <span class="p">{</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="k">const</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>일단 위와 같이 함수 객체를 위한 구조체를 정의해주시고, 그 안에 operator() 함수를 만들어주면 함수 객체 준비는 땡입니다.</p><pre class="chroma">
<span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">int_compare</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>그리고 위와 같이 생성된 함수 객체를 전달하면 됩니다. 그런데 말입니다. 사실 int 나 string 과 같은 기본 타입들은 모두 < 혹은 > 연산자들이 기본으로 내장되어 있습니다. 그렇다면 굳이 그렇게 귀찮게 함수 객체를 만들 필요는 없을 것 같습니다. 템플릿도 배운 마당에 그냥</p><pre class="chroma">
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">greater_comp</span> <span class="p">{</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="k">const</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>요런게 있어서 굳이 귀찮게 int 따로 string 따로 만들 필요가 없을 것 같습니다. 다행이도 functional 해더에 다음과 같은 템플릿 클래스가 존재합니다.</p><pre class="chroma">
<span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>저 greater 에 우리가 사용하고자 하는 타입을 넣게 되면 위와 같은 함수 객체를 자동으로 만들어줍니다. 물론 그 해당하는 타입의 > 연산자가 존재해야겠지요. int 의 경우 기본 타입이기 때문에 당연히 존재합니다.</p><p>다음으로 살펴볼 함수는 partial<span class='font-italic'>sort 함수 입니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 전 ----</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">partial_sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 후 ----</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 나옵니다. 앞서 partial<span class='font-italic'>sort 함수는 일부만 정렬하는 함수라고 하였습니다. partial</span>sort 는 인자를 아래와 같이 3 개를 기본으로 받습니다.</p><pre class="chroma">
<span class="n">partial_sort</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
</pre><p>이 때 정렬을 [stard, end) 전체 원소들 중에서 [start, middle) 까지 원소들이 전체 원소들 중에서 제일 작은애들 순으로 정렬 시킵니다. 예를 들어서 위 경우</p><pre class="chroma">
<span class="n">partial_sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>위와 같이 vec.begin() 부터 vec.end() 까지 (즉 벡터 전체에서) 원소들 중에서, vec.begin() 부터 vec.begin() + 3 까지에 전체에서 가장 작은 애들만 순서대로 저장하고 나머지 위치는 상관 없다! 이런 식입니다. 따라서 위와 같이</p><pre class="chroma">
5 3 1 6 4 7 2
</pre><p>에서 가장 작은 3개 원소인 1, 2, 3 만이 정렬되어서</p><pre class="chroma">
1 2 3 6 5 7 4
</pre><p>앞에 나타나게 되고 나머지 원소들은 그냥 랜덤하게 남아있게 됩니다. 전체 원소의 개수가 N 개이고, 정렬하려는 부분의 크기가 M 이라면 partial<span class='font-italic'>sort 의 복잡도는 O(N log M) 가 됩니다.</p><p>만약에 우리가 전체 배열을 정렬할 필요가 없을 경우, 예를 들어서 100 명의 학생 중에서 상위 10 명의 학생의 성적순을 보고 싶다, 이런 식이면 굳이 sort 로 전체를 정렬 할 필요 없이 partial<span class='font-italic'>sort 로 10 개만 정렬 하는 것이 더 빠르게 됩니다.</p><p>마지막으로 stable<span class='font-italic'>sort 에 대해 살펴보도록 하겠습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">User</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>


<span class="n">User</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
<span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="p">,</span> <span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>


<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>


<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;</span><span class="o">&lt;</span> <span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
<span class="n">o</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">u</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> , </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">u</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
<span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
<span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">name</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">a</span><span class="sc">&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">26</span><span class="p">)</span><span class="p">;</span>
<span class="n">name</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">a</span><span class="sc">&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">26</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>




<span class="n">vector</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">vec2</span> <span class="o">=</span> <span class="n">vec</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 전 ----</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">정렬 후 ----</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">stable_sort 의 경우 ---</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">stable_sort</span><span class="p">(</span><span class="n">vec2</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec2</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec2</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec2</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 나옵니다.</p><p>앞서 stable<span class='font-italic'>sort 는 원소가 삽입되어 있는 순서를 보존하는 정렬 방식이라고 하였습니다. stable</span>sort 가 확실히 어떻게 sort 와 다른지 보여주기 위해서 다음과 같은 클래스를 만들었습니다.</p><pre class="chroma">
<span class="k">struct</span> <span class="n">User</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>


<span class="n">User</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">)</span>
<span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="p">,</span> <span class="n">age</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>


<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>이 User 클래스는 name 과 age 를 멤버로 갖는데, 크기 비교는 이름과 관계없이 모두 age 로 하게 됩니다. 즉 age 가 같다면 크기가 같다고 볼 수 있습니다.</p><pre class="chroma">
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
<span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">name</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">a</span><span class="sc">&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="mi">26</span><span class="p">)</span><span class="p">;</span>
<span class="n">name</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">a</span><span class="sc">&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">26</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>처음에 벡터에 원소들을 쭈르륵 삽입하는 부분인데, 이름은 aa, ab, ac, ... 순으로 하되 age 의 경우 0 부터 10 사이의 랜덤한 값을 부여하였습니다. 즉 name 의 경우 string 순서대로 되어있고, age 의 경우 랜덤한 순서로 되어 있습니다.</p><p>앞서 말했듯이 stable<span class='font-italic'>sort 는 삽입되어 있던 원소들 간의 순서를 보존한다고 하였습니다. 따라서 같은 age 라면 반드시 삽입된 순서, 즉 name 순으로 나올 것입니다. (왜냐하면 애초에 name 순으로 넣었기 때문!)</p><p>그 결과를 살펴보면 확연히 다름을 알 수 있습니다. 먼저 sort 의 경우</p><pre class="chroma">
dh, ck, cx, ad, cw, cu, co
</pre><p>순으로 나와 있고 (age 가 0 일 때) stable<span class='font-italic'>sort 의 경우 age 가 0 일 때</p><pre class="chroma">
ad, ck, co, cu, cw, cx, dh
</pre><p>순으로 나오게 됩니다. 다시 말해 sort 함수의 경우 정렬 과정에서 원소들 간의 상대적 위치를 랜덤하게 바꿔버리지만 stable<span class='font-italic'>sort 의 경우 그 순서를 처음에 넣었던 상태 그대로 유지함을 알 수 있습니다.</p><p>당연히도 이러한 제약 조건 때문에 stable<span class='font-italic'>sort 는 그냥 sort 보다 좀 더 오래걸립니다. C++ 표준에 따르면 sort 함수는 최악의 경우에서도 O(n log n) 이 보장되지만 stable</span>sort 의 경우 최악의 경우에서 O(n (log n)^2) 으로 작동하게 됩니다. 조금 더 느린 편이지요.</p><p> 원소 제거 (remove, remove<span class='font-italic'>if)</p><p>다음으로 살펴볼 함수는 원소를 제거하는 함수 입니다. 사실 이미 대부분의 컨테이너에서는 원소를 제거하는 함수를 지원하고 있습니다. 예를 들어서,</p><pre class="chroma">
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="c1">// ....
</span><span class="c1"></span><span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="p">;</span>
</pre><p>을 하게 되면, vec[3] 에 해당하는 원소를 제거하게 됩니다.</p><p>그런데 사실 이 함수 하나로는 많은 작업들을 처리하기에 부족합니다. 예를 들어서 벡터에서 값이 3 인 원소를 제거하려면 어떻게 해야 할까요? 이전 강좌에서 다루었지만 아마 아래와 같이 할 수 있을 것입니다.</p><pre class="chroma">
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="o">:</span><span class="o">:</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>


<span class="k">for</span> <span class="p">(</span><span class="p">;</span> <span class="n">itr</span> <span class="o">!</span><span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="n">itr</span> <span class="o">+</span><span class="o">+</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">itr</span> <span class="o">=</span><span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">itr</span><span class="p">)</span><span class="p">;</span>
<span class="n">itr</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre><p>이렇게 했던 이유는 바로 원소가 제거될 때 마다 기존에 제거하였던 반복자들이 초기화 되기 때문입니다. 따라서 해당 위치를 가리키는 반복자를 다시 가져와야 되지요. 물론 굳이 반복자를 쓰지 않고 그냥 일반 변수를 이용해서 배열을 다루듯이 처리할 수 도 있겠지만 '원소 접근은 반복자로 수행한다' 에 따른 약속에는 충실한 방법이 아닙니다.</p><p>그렇다면 어떻게 이를 해결할 수 있을까요?</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">처음 vec 상태 ------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">벡터에서 값이 3 인 원소 제거 ---</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 나옵니다.</p><p>위 코드가 어떻게 작동하는지 설명하기에 앞서 erase 함수를 살펴보도록 합시다. 벡터의 erase 함수는 2 가지 형태가 있는데, 하나는 우리가 잘 알고 있는</p><pre class="chroma">
<span class="n">Iterator</span> <span class="nf">erase</span> <span class="p">(</span><span class="n">Iterator</span> <span class="n">pos</span><span class="p">)</span><span class="p">;</span>
</pre><p>와 같은 형태가 있고, 다른 하나는</p><pre class="chroma">
<span class="n">Iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span><span class="p">;</span>
</pre><p>와 같은 형태가 있습니다. 전자의 경우 그냥 pos 가 가리키는 원소를 벡터에서 지우지만 후자의 경우 first 부터 last 사이에 있는 모든 원소들을 지우는 형태 입니다. 물론 이 두 함수 모두 우리의 목표인 '값이 3 인 원소 제거' 를 수행하는데 부족함이 있습니다. 물론 후자의 함수를 사용하면 좋겠지만, 값이 3 인 원소들이 벡터에서 연속적으로 존재하지 않기 때문이지요.</p><p>하지만 어떤 편리한 함수가 있어서 값이 3 인 원소들을 벡터에서 연속적으로 존재할 수 있게 해주면 어떨까요?</p><p>위와 같이, 만일 값이 3 인 원소를 만나면 그 뒤에 있는 원소들로 쭈르륵 쉬프트 해주게 됩니다. 따라서, 자연스럽게 알고리즘이 끝나게 되면은 해당하는 위치에서 전 까지 3 이 제외된 원소들로 쭈르륵 채워지게 되겠지요.</p><p>다시말해, 반복이 끝나는 위치 부터 벡터 맨 뒤 까지 제거해버리면 3 이 싹 제거된 벡터만 남게 되지요. remove 함수는 원소의 이동만을 수행하지 실제로 원소를 삭제하는 연산을 수행하지는 않습니다. 따라서 벡터에서 실제로 원소를 지우기 위해서는 반드시 erase 함수를 호출하여 실제로 원소를 지워줘야만 합니다.</p><p>vec.erase(remove(vec.begin(), vec.end(), 3), vec.end());</p><p>따라서 위 처럼 remove 함수를 이용해서 값이 3 인 원소들을 뒤로 보내버리고, 그 원소들을 벡터에서 삭제해버리게 됩니다.</p><p>참고로 말하자면 remove 함수의 경우 반복자의 타입이 ForwardIterator 입니다. 즉, 벡터 뿐만이 아니라, 리스트, 혹은 셋이나 맵에서도 모두 사용할 수 있습니다!</p><p>그렇다면 이번에는 값이 딱 얼마로 정해진 것이 아니라 특정한 조건을 만족하는 원소들을 제거하려면 어떻게 해야 할까요? 당연히도 이 원소가 그 조건을 만족하는지 아닌지를 판단할 함수를 전달해야 됩니다. 이를 위해선 remove<span class='font-italic'>if 함수를 사용해야 합니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">is_odd</span> <span class="p">{</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">처음 vec 상태 ------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">벡터에서 홀수 인 원소 제거 ---</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">is_odd</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 나옵니다.</p><pre class="chroma">
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">is_odd</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>remove<span class='font-italic'>if 함수는 세번째 인자로 조건을 설명할 함수 객체를 전달받습니다.</p><pre class="chroma">
<span class="k">struct</span> <span class="n">is_odd</span> <span class="p">{</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>위와 같이 is<span class='font-italic'>odd 구조체에 operator() 를 만들어서 함수 객체를 전달하시면 됩니다. 당연히도, 함수 객체로 실제 함수를 전달할 수 도 있습니다. 이 경우</p><pre class="chroma">
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Pred</span><span class="o">&gt;</span>
<span class="n">remove_if</span><span class="p">(</span><span class="n">Iter</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">last</span><span class="p">,</span> <span class="n">Pred</span> <span class="n">pred</span><span class="p">)</span>
</pre><p>에서 Pred 가 함수 포인터 타입이 되겠지요.</p><pre class="chroma">
<span class="kt">bool</span> <span class="nf">odd</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">처음 vec 상태 ------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">벡터에서 홀수 인 원소 제거 ---</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">odd</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>위와 같이 실제 함수를 전달한다면 앞서 만들었던 함수 객체와 정확히 동일하게 동작합니다. 그렇다면 굳이 귀찮게 위와 같이 함수 객체를 사용할 이유가 있을까요? 물론 있습니다.</p><p>예를 들어서 홀수인 원소들을 삭제하되 처음 2개만 삭제한다고 해봅시다. 함수 객체의 경우 사실 클래스의 객체이기 때문에 멤버 변수를 생각할 수 있습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="n">is_odd</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">num_delete</span><span class="p">;</span>


<span class="n">is_odd</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">num_delete</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>


<span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_delete</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>


<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">num_delete</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">처음 vec 상태 ------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">벡터에서 홀수인 원소 앞의 2개 제거 ---</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">is_odd</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 나옵니다.</p><pre class="chroma">
<span class="k">struct</span> <span class="n">is_odd</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">num_delete</span><span class="p">;</span>


<span class="n">is_odd</span><span class="p">(</span><span class="p">)</span> <span class="o">:</span> <span class="n">num_delete</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span>


<span class="kt">bool</span> <span class="k">operator</span><span class="p">(</span><span class="p">)</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_delete</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>


<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">num_delete</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>이것이 가능한 이유는 위 처럼 num<span class='font-italic'>delete 라는 멤버 변수를 만들어서 몇 개를 지웠는지 카운트 하기 때문이지요. 물론 함수의 경우에도 static 변수를 이용하면 위와 같은 효과를 낼 수 있습니다. 하지만 여러개의 벡터에 저 작업을 하게 된다면 꽤나 골치아프겠지요. (호출할 때 마다 static 변수의 값을 0 으로 초기화 해줘야 합니다)</p><p>하지만 함수 객체를 이용하면 위 처럼 함수만으로는 쉽게 하지 못했던 일들을 손쉽게 처리할 수 있게 됩니다.</p><p>그런데 한 가지 안좋은 점은 이렇게 STL 을 사용할 때 마다 외부에 클래스나 함수를 하나 씩 만들어줘야 된다는 점입니다. 물론 프로젝트의 크기가 작다면 크게 문제가 되지는 않겠지만 프로젝트의 크기가 커진다면, 만약 다른 사람이 코드를 읽을 때 '이 클래스는 뭐하는 거지?' 혹은 '이 함수는 뭐하는 거지?' 와 같은 궁금증이 생길 수 도 있고 심지어 잘못 사용할 수 도 있습니다.</p><p>따라서 가장 이상적인 방법은 STL 알고리즘을 사용할 때 그 안에 직접 써놓는 것입니다. 마치</p><pre class="chroma">
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">is_odd</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>뭐 이런 식으로 말이지요. 문제는 위 문법이 C++ 에서 허용되지 않다는 점입니다. 하지만 놀랍게도 C++ 11 부터 위 문제를 해결할 방법이 나타났습니다.</p><p> 람다 함수(lambda function)</p><p>람다 함수는 C++ 에서는 C++ 11 에서 처음으로 도입되었습니다. 람다 함수를 통해 쉽게 이름이 없는 함수 객체를 만들수 없게 되었습니다. 그렇습니다.익명의 함수 객체 말입니다!</p><p>람다 함수를 사용한 예제 부터 먼저 살펴보겠습니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">처음 vec 상태 ------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">벡터에서 홀수인 원소 제거 ---</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 나옵니다.</p><p>람다 함수를 정의한 부분부터 살펴보도록 합시다.</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</pre><p>람다 함수는 위와 같은 꼴로 정의됩니다. 일반적인 꼴을 살펴보자면</p><pre class="chroma">
[capture list] (받는 인자) -&gt; 리턴 타입 { 함수 본체 }
</pre><p>와 같은 형태 입니다. capture<span class='font-italic'>list 가 뭔지는 아래에서 설명하도록 하고, 위 함수 꼴을 살펴보자면 인자로 int i 를 받고, bool 을 리턴하는 람다 함수를 정의한 것입니다. 리턴 타입을 생략한다면 컴파일러가 알아서 함수 본체에서 return 문을 보고 리턴 타입을 추측해줍니다. (만약에 return 경로가 여러군데여서 추측할 수 없다면 컴파일 오류가 발생하지요)</p><p>리턴 타입을 생략할 경우</p><pre class="chroma">
[capture list] ( 받는 인자) {함수 본체}
</pre><p>이런 식으로 더 간단히 쓸 수 있습니다. 위 예제의 경우</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</pre><p>로 쓴다면 알아서 "아 bool 타입을 리턴하는 함수구나" 라고 컴파일러가 만들어줍니다.</p><p>앞서 람다 함수가 이름이 없는 함수라 했는데 실제로 위를 보면 함수에 이름이 붙어 있지 않습니다! 즉 임시적으로 함수를 생성한 것이지요. 만약에 이 함수를 사용하고 싶다면</p><pre class="chroma">
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span> <span class="c1">// true
</span><span class="c1"></span></pre><p>와 같이 그냥 바로 호출할 수 도 있고</p><pre class="chroma">
<span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="p">;</span>
<span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span> <span class="c1">// false;
</span><span class="c1"></span></pre><p>람다 함수로 func 이라는 함수 객체를 생성한 후에 호출할 수 도 있지요.</p><p>하지만 람다 함수도 말 그대로 함수 이기 때문에 자기 자신만의 스코프를 가집니다. 따라서 일반적인 상황이라면 함수 외부에서 정의된 변수들을 사용할 수 없겠지요. 예를 들어서 최대 2 개 원소만 지우고 싶은 경우</p><pre class="chroma">
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">벡터에서 홀수인 원소 최대 2 개 제거 ---</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num_erased</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
<span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_erased</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">num_erased</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>위와 같이 람다 함수 외부에 몇 개를 지웠는지 변수를 정의한 뒤에 사용해야만 하는데 (함수 안에 정의하면 함수 호출될 때 마다 새로 생성되니까요!) 문제는 그 변수에 접근할 수 없다는 점입니다. 하지만 놀랍게도 람다 함수의 경우 그 변수에 접근할 수 있습니다. 바로 캡쳐 목록(capture<span class='font-italic'>list)을 사용하는 것입니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">처음 vec 상태 ------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">벡터에서 홀수인 원소 ---</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num_erased</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span>
<span class="p">[</span><span class="o">&amp;</span><span class="n">num_erased</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_erased</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">num_erased</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 잘 됨을 알 수 있습니다.</p><pre class="chroma">
 <span class="p">[</span><span class="o">&amp;</span><span class="n">num_erased</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_erased</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">num_erased</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span>
</pre><p>위와 같이 캡쳐 목록에는 어떤 변수를 캡쳐할 지 써주면 됩니다. 위 경우 num<span class='font-italic'>erased 를 캡쳐하였습니다. 즉 람다 함수 내에서 num</span>erased 를 마치 같은 스코프 안에 있는 것 처럼 사용할 수 있게 됩니다.</p><p>이 때 num<span class='font-italic'>erased 앞에 & 가 붙어있는데 이는 실제 num</span>erased 의 레퍼런스를 캡쳐한다는 의미입니다. 즉 함수 내부에서 num<span class='font-italic'>erased 의 값을 바꿀 수 있게 되지요. 만약에 아래처럼</p><pre class="chroma">
<span class="p">[</span><span class="n">num_erased</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_erased</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">num_erased</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span>
</pre><p>& 를 앞에 붙이지 않는다면 num<span class='font-italic'>erased 의 복사본을 얻게 되는데, 그 복사본의 형태는 const 입니다. 따라서 위 처럼 함수 내부에서 num</span>erased 의 값을 바꿀 수 없게 되지요. 그렇다면 클래스의 멤버 함수 안에서 람다를 사용할 때 멤버 변수들을 참조하려면 어떻게 해야 할까요?</p><pre class="chroma">
<span class="k">class</span><span class="err"> </span><span class="nc">SomeClass</span> <span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>


<span class="kt">int</span> <span class="n">num_erased</span><span class="p">;</span>


<span class="k">public</span><span class="o">:</span>
<span class="n">SomeClass</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


<span class="n">num_erased</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>


<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">num_erased</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="n">num_erased</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="n">num_erased</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span><span class="p">;</span>
</pre><p>예를 들어 위와 같은 예제를 생각해봅시다. 쉽게 생각해보면 그냥 똑같이 num<span class='font-italic'>erased 를 & 로 캡쳐해서 람다 함수 안에서 사용할 수 있을 것 같지만 실제로는 컴파일 되지 않습니다. 왜냐하면 num</span>erased 가 일반 변수가 아니라 객체에 종속되어 있는 멤버 변수 이기 때문이지요. 즉 람다 함수는 num<span class='font-italic'>erased 를 캡쳐해! 라고 하면 이 num</span>erased 가 이 객체의 멤버 변수가 아니라 그냥 일반 변수라고 생각하게 됩니다.</p><p>이를 해결하기 위해선 직접 멤버 변수를 전달하기 보다는 this 를 전달해주면 됩니다.</p><pre class="chroma">
<span class="n">num_erased</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


<span class="n">vec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove_if</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-</span><span class="o">&gt;</span><span class="n">num_erased</span> <span class="o">&gt;</span><span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">=</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="k">this</span><span class="o">-</span><span class="o">&gt;</span><span class="n">num_erased</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</pre><p>위와 같이 this 를 복사본으로 전달해서 (참고로 this 는 레퍼런스로 전달할 수 없습니다) 함수 안에서 this 를 이용해서 멤버 변수들을 참조해서 사용하면 됩니다.</p><p>위에 설명한 경우 말고도 캡쳐 리스트의 사용 방법은 꽤나 많은데 아래 간단히 정리해보도록 하겠습니다.</p><ul><li><p> [] : 아무것도 캡쳐 안함</p></li><li><p> [&a, b] : a 는 레퍼런스로 캡쳐하고 b 는 (변경 불가능한) 복사본으로 캡쳐</p></li><li><p> [&] : 외부의 모든 변수들을 레퍼런스로 캡쳐</p></li><li><p> [=] : 외부의 모든 변수들을 복사본으로 캡쳐와 같이 되겠습니다.</p></li></ul><p> 원소 수정하기 (transform)</p><p>다음으로 살펴볼 함수는 원소들을 수정하는 함수들 입니다. 많은 경우 컨테이너 전체 혹은 일부를 순회하면서 값들을 수정하는 작업을 많이 할 것입니다. 예를 들어서 벡터의 모든 원소에 1 씩 더한다던지와 같은 작업들을 말이지요. 이러한 작업을 도와주는 함수는 바로 transform 함수 입니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>




<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">처음 vec 상태 ------</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>


<span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">벡터 전체에 1 을 더한다</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
<span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였다면</p><p>와 같이 나옵니다.</p><p>transform 함수는 다음과 같은 꼴로 생겼습니다.</p><pre class="chroma">
transform (시작 반복자, 끝 반복자, 결과를 저장할 컨테이너의 시작 반복자, Pred)
</pre><p>우리가 사용한 예의 경우</p><pre class="chroma">
<span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
</pre><p>로 하였으므로 vec 의 시작(begin) 부터 끝(end) 까지 각 원소에 [] (int i) {return i + 1} 함수를 적용시킨 결과를 vec.begin() 부터 저장하게 됩니다. 즉 결과적으로 각 원소에 1 을 더한 결과로 덮어 씌우게 되는 것이지요. 상당히 간단합니다. 한 가지 주의할 점은 값을 저장하는 컨테이너의 크기가 원래의 컨테이너보다 최소한 같거나 커야 된다는 점입니다. 예를 들어서 단순하게</p><pre class="chroma">
<span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>



<span class="err">이</span><span class="err">렇</span><span class="err">게</span> <span class="err">썻</span><span class="err">다</span><span class="err">고</span> <span class="err">해</span><span class="err">봅</span><span class="err">시</span><span class="err">다</span><span class="p">.</span> <span class="n">transform</span> <span class="err">함</span><span class="err">수</span><span class="err">는</span> <span class="n">vec</span> <span class="err">의</span> <span class="err">처</span><span class="err">음</span> <span class="err">부</span><span class="err">터</span> <span class="err">끝</span><span class="err">까</span><span class="err">지</span> <span class="err">쭈</span><span class="err">르</span><span class="err">륵</span> <span class="err">순</span><span class="err">회</span><span class="err">하</span><span class="err">지</span><span class="err">만</span> <span class="err">저</span><span class="err">장</span><span class="err">하</span><span class="err">는</span> <span class="err">쪽</span><span class="err">의</span> <span class="err">반</span><span class="err">복</span><span class="err">자</span><span class="err">는</span> <span class="n">vec</span> <span class="err">의</span> <span class="err">두</span> <span class="err">번</span><span class="err">째</span> <span class="err">원</span><span class="err">소</span> <span class="err">부</span><span class="err">터</span> <span class="err">저</span><span class="err">장</span><span class="err">하</span><span class="err">기</span> <span class="err">때</span><span class="err">문</span><span class="err">에</span> <span class="err">결</span><span class="err">과</span><span class="err">적</span><span class="err">으</span><span class="err">로</span> <span class="err">마</span><span class="err">지</span><span class="err">막</span><span class="err">에</span> <span class="err">한</span> <span class="err">칸</span><span class="err">이</span> <span class="err">모</span><span class="err">잘</span><span class="err">라</span><span class="err">서</span>





<span class="err">위</span><span class="err">와</span> <span class="err">같</span><span class="err">은</span> <span class="err">오</span><span class="err">류</span><span class="err">를</span> <span class="err">발</span><span class="err">생</span><span class="err">하</span><span class="err">게</span> <span class="err">됩</span><span class="err">니</span><span class="err">다</span><span class="p">.</span>

</pre><p>cpp</p><p>#include <iostream>#include <vector>#include <algorithm>#include <functional>#include <string>using namespace std;</p><p>template<typename Iter>void print(Iter begin, Iter end){while (begin != end) {cout << "[" << <span class='font-italic'>begin << "] ";begin++;}cout << endl;}</p><p>int main(){vector<int> vec;vec.push<span class='font-italic'>back(5);vec.push</span>back(3);vec.push<span class='font-italic'>back(1);vec.push</span>back(2);vec.push<span class='font-italic'>back(3);vec.push</span>back(4);</p><p>// vec2 에는 6 개의 0 으로 초기화 한다.vector<int> vec2(6, 0);</p><p>cout << "처음 vec 과 vec2 상태 ------" << endl;print(vec.begin(), vec.end());print(vec2.begin(), vec2.end());</p><p>cout << "vec 전체에 1 을 더한 것을 vec2 에 저장 -- " << endl;transform(vec.begin(), vec.end(), vec2.begin(), <a href='int i'></a> { return i + 1; });print(vec.begin(), vec.end());print(vec2.begin(), vec2.end());}성공적으로 컴파일 하였으면</p><p>와 같이 나옵니다.</p><pre class="chroma">
<span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec2</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
</pre><p>위와 같이 vec 의 처음 부터 끝 까지 읽으면서 1 씩 더한 결과를 vec2 에 저장하게 됩니다. 간단하지요! 물론 저 transform 함수 하나 덕분에 귀찮에 for 문을 쓸 필요도 없어질 뿐더러, 내가 이 코드에서 무슨 일을 하는지 더 간단 명료하게 나타낼 수 도 있습니다.</p><p> 원소를 탐색하는 함수(find, find<span class='font-italic'>if, any</span>of, all<span class='font-italic'>of 등등)</p><p>마지막으로 살펴볼 함수들은 원소들을 탐색하는 계열의 함수들 입니다.</p><pre class="chroma">
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span>
    <span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>


  <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">3 은 </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">distance</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> 번째 원소</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>성공적으로 컴파일 하였으면</p><p>와 같이 나옵니다.</p><p>find 함수는 단순히</p><pre class="chroma">
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="err"> </span><span class="nc">InputIt</span><span class="p">,</span> <span class="k">class</span><span class="err"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">InputIt</span> <span class="n">find</span><span class="p">(</span><span class="n">InputIt</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIt</span> <span class="n">last</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>

</pre><p>와 같이 생겼는데, first 부터 last 까지 쭈르륵 순회하면서 value 와 같은 원소가 있는지 확인하고 있으면 이를 가리키는 반복자를 리턴합니다.  위 경우</p><pre class="chroma"><span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="p">;</span>
</pre><p>vec 에서 값이 3 과 같은 원소를 찾아서 리턴하게 되지요. 반복자에 따라서 forward<span class='font-italic'>iterator 면 앞에서 부터 찾고, reverse</span>iterator 이면 뒤에서 부터 거꾸로 찾게 됩니다. 물론 컨테이너에 중복되는 값이 있더라도 가장 먼저 찾은 것을 리턴합니다. 만약에 위 vec 에서 모든 3 을 찾고 싶다면 아래와 같이 하면 됩니다.</p><pre class="chroma"><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;</span><span class="cp">
</span><span class="cp"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span><span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span><span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span><span class="p">}</span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="p">;</span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">current</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">;</span><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span><span class="n">current</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="p">;</span><span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">=</span><span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">3 은 </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">distance</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s"> 번째 원소</span><span class="s">&#34;</span><span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="n">current</span><span class="o">+</span><span class="o">+</span><span class="p">;</span><span class="p">}</span><span class="p">}</span>

<span class="err">성</span><span class="err">공</span><span class="err">적</span><span class="err">으</span><span class="err">로</span> <span class="err">컴</span><span class="err">파</span><span class="err">일</span> <span class="err">하</span><span class="err">였</span><span class="err">다</span><span class="err">면</span>


<span class="err">위</span><span class="err">와</span> <span class="err">같</span><span class="err">이</span> <span class="err">나</span><span class="err">옵</span><span class="err">니</span><span class="err">다</span><span class="p">.</span>

</pre><p>cpp</p><p>current = find(current, vec.end(), 3);</p><pre class="chroma">
위 처럼 마지막으로 찾은 위치 바로 다음 부터 계속 순차적으로 탐색해 나간다면 컨테이너에서 값이 3 인 원소들을 모두 찾을 수 있게 됩니다.
다만 find 계열의 함수들을 사용할 때 한 가지 주의해야 할 점은, 만약에 컨테이너에서 기본적으로 find 함수를 지원한다면 이를 사용하는 것이 훨씬 빠릅니다. 왜냐하면 알고리즘 라이브러리에서의 find 함수는 그 컨테이너가 어떠한 구조를 가지고 있는지에 대한 정보가 하나도 없기 때문입니다.

예를 들어 set 의 경우, set 에서 사용하는 find 함수의 경우 O(log n) 으로 수행될 수 있는데 그 이유는 셋 내부에서 원소들이 정렬되어 있기 때문입니다. 또 unordered_set 의 경우 find 함수가 O(1) 로 수행될 수 있는데 그 이유는 unordered_set 내부에서 자체적으로 해시 테이블을 이용해서 원소들을 빠르게 탐색해 나갈 수 있기 때문입니다.
하지만 그냥 알고리즘 라이브러리의 find 함수의 경우 이러한 추가 정보가 있는 것을 하나도 모른채 우직하게 처음 부터 하나 씩 확인해 나가므로 평범한 O(n) 으로 처리됩니다. 따라서 알고리즘 라이브러리의 find 함수를 사용할 경우 벡터와 같이 기본적으로 find 함수를 지원하지 않는 컨테이너에 사용하시기 바랍니다!
</pre><p>cpp</p><p>#include <algorithm>#include <functional>#include <iostream>#include <string>#include <vector>using namespace std;template <typename Iter>void print(Iter begin, Iter end) {while (begin != end) {cout << "[" << <span class='font-italic'>begin << "] ";begin++;}cout << endl;}int main() {vector<int> vec;vec.push</span>back(5);vec.push<span class='font-italic'>back(3);vec.push</span>back(1);vec.push<span class='font-italic'>back(2);vec.push</span>back(3);vec.push<span class='font-italic'>back(4);auto current = vec.begin();while (true) {current = find</span>if(current, vec.end(), <a href='int i'></a> { return i % 3 == 2; });if (current == vec.end()) break;cout << "3 으로 나눈 나머지가 2 인 원소는 : " << <span class='font-italic'>current << " 이다 "<< endl;current++;}}성공적으로 컴파일 하였다면</p><p>와 같이 나옵니다.</p><pre class="chroma"><span class="n">current</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="p">[</span><span class="p">]</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">=</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
</pre><p>find 함수가 단순한 값을 받았다면 find<span class='font-italic'>if 함수의 경우 함수 객체를 인자로 받아서 그 결과가 참인 원소들을 찾게 됩니다. 위 경우 3 으로 나눈 나머지가 2 인 원소들을 컨테이너에서 탐색하였습니다. 람다 함수로 사용하니 엄청 간결하지요?</p><pre class="chroma"><span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;</span><span class="cp">
</span><span class="cp"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iter</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span><span class="k">while</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!</span><span class="o">=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">[</span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="o">*</span><span class="n">begin</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">] </span><span class="s">&#34;</span><span class="p">;</span><span class="n">begin</span><span class="o">+</span><span class="o">+</span><span class="p">;</span><span class="p">}</span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="k">struct</span> <span class="n">User</span> <span class="p">{</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span><span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
<span class="n">User</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="p">,</span> <span class="n">level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span><span class="p">}</span><span class="kt">bool</span> <span class="k">operator</span><span class="o">=</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">User</span><span class="o">&amp;</span> <span class="n">user</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">=</span><span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">level</span> <span class="o">=</span><span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="n">level</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="p">}</span><span class="p">}</span><span class="p">;</span>
<span class="k">class</span><span class="err"> </span><span class="nc">Party</span> <span class="p">{</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span><span class="p">;</span><span class="k">public</span><span class="o">:</span><span class="kt">bool</span> <span class="n">add_user</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span><span class="n">User</span> <span class="n">new_user</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span><span class="p">;</span><span class="k">if</span> <span class="p">(</span><span class="n">find</span><span class="p">(</span><span class="n">users</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">users</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span> <span class="n">new_user</span><span class="p">)</span><span class="o">!</span><span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span><span class="p">}</span><span class="n">users</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_user</span><span class="p">)</span><span class="p">;</span><span class="k">return</span> <span class="nb">true</span><span class="p">;</span><span class="p">}</span>
<span class="c1">// 파티원 모두가 15 레벨 이상이여야지 던전 입장 가능bool can_join_dungeon() {return all_of(users.begin(), users.end(), [](User&amp; user) {return user.level &gt;= 15;});}
</span><span class="c1"></span><span class="c1">// 파티원 중 한명 이라도 19렙 이상이면 특별 아이템 사용 가능bool can_use_special_item() {return any_of(users.begin(), users.end(), [](User&amp; user) {return user.level &gt;= 19;});}};int main() {Party party;party.add_user(&#34;철수&#34;, 15);party.add_user(&#34;영희&#34;, 18);party.add_user(&#34;민수&#34;, 12);party.add_user(&#34;수빈&#34;, 19);
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">boolalpha</span><span class="p">;</span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">던전 입장 가능 ? </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">party</span><span class="p">.</span><span class="n">can_join_dungeon</span><span class="p">(</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="n">cout</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">특별 아이템 사용 가능 ? </span><span class="s">&#34;</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">party</span><span class="p">.</span><span class="n">can_use_special_item</span><span class="p">(</span><span class="p">)</span> <span class="o">&lt;</span><span class="o">&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="p">}</span>
<span class="err">성</span><span class="err">공</span><span class="err">적</span><span class="err">으</span><span class="err">로</span> <span class="err">컴</span><span class="err">파</span><span class="err">일</span> <span class="err">하</span><span class="err">였</span><span class="err">다</span><span class="err">면</span>



<span class="err">와</span> <span class="err">같</span><span class="err">이</span> <span class="err">나</span><span class="err">옵</span><span class="err">니</span><span class="err">다</span><span class="p">.</span>
<span class="err">마</span><span class="err">지</span><span class="err">막</span><span class="err">으</span><span class="err">로</span> <span class="err">살</span><span class="err">펴</span><span class="err">볼</span> <span class="err">함</span><span class="err">수</span><span class="err">들</span><span class="err">은</span> <span class="n">any_of</span> <span class="err">와</span> <span class="n">all_of</span> <span class="err">입</span><span class="err">니</span><span class="err">다</span><span class="p">.</span> <span class="n">any_of</span> <span class="err">는</span> <span class="err">인</span><span class="err">자</span><span class="err">로</span> <span class="err">받</span><span class="err">은</span> <span class="err">범</span><span class="err">위</span><span class="err">안</span><span class="err">의</span> <span class="err">모</span><span class="err">든</span> <span class="err">원</span><span class="err">소</span><span class="err">들</span> <span class="err">중</span><span class="err">에</span><span class="err">서</span> <span class="err">조</span><span class="err">건</span><span class="err">을</span> <span class="err">하</span><span class="err">나</span><span class="err">라</span><span class="err">도</span> <span class="err">충</span><span class="err">족</span><span class="err">하</span><span class="err">는</span> <span class="err">것</span><span class="err">이</span> <span class="err">있</span><span class="err">다</span><span class="err">면</span> <span class="nb">true</span> <span class="err">를</span> <span class="err">리</span><span class="err">턴</span><span class="err">하</span><span class="err">고</span> <span class="n">all_of</span> <span class="err">의</span> <span class="err">경</span><span class="err">우</span> <span class="err">모</span><span class="err">든</span> <span class="err">원</span><span class="err">소</span><span class="err">들</span><span class="err">이</span> <span class="err">전</span><span class="err">부</span> <span class="err">조</span><span class="err">건</span><span class="err">을</span> <span class="err">충</span><span class="err">족</span><span class="err">해</span><span class="err">야</span> <span class="nb">true</span> <span class="err">를</span> <span class="err">리</span><span class="err">턴</span><span class="err">합</span><span class="err">니</span><span class="err">다</span><span class="p">.</span> <span class="err">즉</span> <span class="n">any_of</span> <span class="err">는</span> <span class="n">OR</span> <span class="err">연</span><span class="err">산</span><span class="err">과</span> <span class="err">비</span><span class="err">슷</span><span class="err">하</span><span class="err">고</span> <span class="n">any_of</span> <span class="err">는</span> <span class="n">AND</span> <span class="err">연</span><span class="err">산</span><span class="err">과</span> <span class="err">비</span><span class="err">슷</span><span class="err">하</span><span class="err">다</span><span class="err">고</span> <span class="err">볼</span> <span class="err">수</span> <span class="err">있</span><span class="err">지</span><span class="err">요</span><span class="p">.</span>
</pre><p>cpp</p><p>bool add<span class='font-italic'>user(string name, int level) {User new</span>user(name, level);if (find(users.begin(), users.end(), new<span class='font-italic'>user)!= users.end()) {return false;}users.push</span>back(new<span class='font-italic'>user);return true;}먼저 간단히 유저들의 정보를 담고 있는 User 구조체를 정의하였고, 그 User 들이 파티를 이룰 때 만들어지는 Party 클래스를 정의하였습니다. 그리고 위 add</span>user 함수를 사용하면 파티원을 추가할 수 있지요. 물론 중복되는 파티원이 없도록 벡터에 원소를 추가하기 전에 확인합니다.</p><pre class="chroma"><span class="c1">// 파티원 모두가 15 레벨 이상이여야지 던전 입장 가능bool can_join_dungeon() {return all_of(users.begin(), users.end(), [](User&amp; user) {return user.level &gt;= 15;});}
</span><span class="c1"></span><span class="err">따</span><span class="err">라</span><span class="err">서</span> <span class="err">이</span> <span class="err">파</span><span class="err">티</span><span class="err">가</span> <span class="err">어</span><span class="err">떤</span> <span class="err">던</span><span class="err">전</span><span class="err">에</span> <span class="err">참</span><span class="err">가</span><span class="err">하</span><span class="err">고</span> <span class="err">싶</span><span class="err">은</span> <span class="err">경</span><span class="err">우</span> <span class="err">모</span><span class="err">든</span> <span class="err">파</span><span class="err">티</span><span class="err">원</span><span class="err">의</span> <span class="err">레</span><span class="err">벨</span><span class="err">이</span> <span class="mi">15</span> <span class="err">이</span><span class="err">상</span> <span class="err">이</span><span class="err">어</span><span class="err">야</span> <span class="err">하</span><span class="err">므</span><span class="err">로</span> <span class="err">위</span><span class="err">와</span> <span class="err">같</span><span class="err">이</span> <span class="n">all_of</span> <span class="err">함</span><span class="err">수</span><span class="err">를</span> <span class="err">사</span><span class="err">용</span><span class="err">해</span><span class="err">서</span> <span class="err">모</span><span class="err">든</span> <span class="err">원</span><span class="err">소</span><span class="err">들</span><span class="err">이</span> <span class="err">조</span><span class="err">건</span><span class="err">에</span> <span class="err">만</span><span class="err">족</span><span class="err">하</span><span class="err">는</span><span class="err">지</span> <span class="err">확</span><span class="err">인</span><span class="err">할</span> <span class="err">수</span> <span class="err">있</span><span class="err">습</span><span class="err">니</span><span class="err">다</span><span class="p">.</span> <span class="err">위</span> <span class="err">경</span><span class="err">우</span> <span class="err">민</span><span class="err">수</span><span class="err">가</span> <span class="mi">12</span> <span class="err">레</span><span class="err">벨</span><span class="err">이</span><span class="err">여</span><span class="err">서</span> <span class="nb">false</span> <span class="err">가</span> <span class="err">리</span><span class="err">턴</span><span class="err">되</span><span class="err">겠</span><span class="err">지</span><span class="err">요</span><span class="p">.</span>
</pre><p>cpp</p><p>// 파티원 중 한명 이라도 19렙 이상이면 특별 아이템 사용 가능bool can<span class='font-italic'>use</span>special<span class='font-italic'>item() {return any</span>of(users.begin(), users.end(), <a href='User& user'></a> {return user.level >= 19;});}비슷하게도 한 명만 조건을 만족해도 되는 경우 위와 같이 any<span class='font-italic'>of 함수를 사용하면 간단히 처리할 수 있습니다.자 그러면 이번 강좌는 여기서 마치도록 하겠습니다. 사실 알고리즘 라이브러리를  살펴보면 이것 보다도 훨씬 많은 수의 여러가지 유용한 함수들이 정의되어 있습니다. 하지만 이 모든 함수들을 강좌에서 다루기에는 조금 무리가 있고, 이 정도 함수들만 알아놓아도 매우 편리하게 사용하실 수 있을 것이라 생각합니다!</p><pre class="chroma">
강좌를 보다가 조금이라도 궁금한 것이나 이상한 점이 있다면꼭 댓글을 남겨주시기 바랍니다. 그 외에도 강좌에 관련된 것이라면 어떠한 것도 질문해 주셔도 상관 없습니다. 생각해 볼 문제도 정 모르겠다면 댓글을 달아주세요.

현재 여러분이 보신 강좌는&lt;&lt;씹어먹는 C++ - &lt;10 - 3. C++ STL - 알고리즘(algorithm)&gt;&gt;&gt; 입니다. 이번 강좌의모든 예제들의 코드를 보지 않고 짤 수준까지 강좌를 읽어 보시기 전까지 다음 강좌로 넘어가지 말아주세요

다음 강좌 보러가기

</pre><p>공감sns신고저작자표시	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">		<Work rdf:about="">			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />		</Work>		<License rdf:about="http://creativecommons.org/licenses/by-fr/">			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>			<requires rdf:resource="http://web.resource.org/cc/Notice"/>			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>		</License>	</rdf:RDF>'C++' 카테고리의 다른 글씹어먹는 C++ - <11 - 2. Move 문법 (move semantics) 과 완벽한 전달 (perfect forwarding)>(7)2018.03.27씹어먹는 C++ - <11 - 1. 우측값 레퍼런스와 이동 생성자>(0)2018.03.24씹어먹는 C++ - <10 - 3. C++ STL - 알고리즘(algorithm)>(16)2017.07.09씹어먹는 C++ - <10 - 2. C++ STL - 셋(set), 맵(map), unordered<span class='font-italic'>set, unordered</span>map>(5)2017.07.08씹어먹는 C++ - <10 - 1. C++ STL - 벡터(vector), 리스트(list), 데크(deque)>(2)2017.07.04씹어먹는 C++ - <9 - 3. 템플릿 메타 프로그래밍 2>(8)2017.07.02</p><style>/* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%; }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }
</style>