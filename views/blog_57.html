<p>itguru Top itguru Top</p><pre class="chroma">아직 C 언어와 친숙하지 않다면,씹어먹는 C 언어 강좌를 보는 것이 어떻까요?

</pre><p>fflush</p><pre class="chroma">#include &lt;stdio.h&gt; // C++ 에서는 &lt;cstdio&gt;

int fflush ( FILE * stream );
</pre><p>스트림을 비운다(flush)만일 함수의 인자로 전달된 스트림이 쓰기 가능하고, 마지막 입출력 작업이 출력 작업이였다면 출력 버퍼에 쓰이지 않고 남아 있던 데이터들은 모두 파일에 쓰이게 된다.만일 함수의 인자로 전달된 스트림이 읽기 가능하고 마지막 입출력 작업이 입력 작업이였다면, 이 함수가 어떠한 작업을 할지에 대해선 라이브러리에 따라 다르다. 몇몇의 라이브러리에선 입력 버퍼를 비워버리지만(이 때 비운다는 것은 버퍼에 있는 데이터들을 모두 삭제한다는 뜻이다) 이는 표준으로 정해진 것이아니다.만일 인자가 널 포인터라면 모든 열린 스트림을 비운다.이 함수 호출 이후에도 스트림은 열려 있는 상태로 남아있다.만일 파일이fclose를 호출 하건 프로그램이 종료되건 어떤 연유에서 든지 닫히게 된다면 (close), 이 파일에 해당하는 모든 버퍼들은 자동적으로 비워지게 된다.</p><h3><p> 인자</p></h3><p>stream</p><p>작업을 수행할 buffered (스트림의 상태 중 하나로 fully buffered 와 line buffered 를 일컫는다. 자세한 내용은stdio.h 를 참조) 스트림의 파일 객체를 가리키는 포인터.</p><h3><p> 리턴값</p></h3><p>0 이 리턴되면 성공적으로 작동되었음을 의미한다.오류가 발생하면 EOF 가 리턴되고 오류 표시자가 설정된다 (feof 참조)</p><h3><p> 실행 예제</p></h3><pre class="chroma"><span class="cm">/*
</span><span class="cm">example.txt 파일을 &#34;r+&#34; 로 오픈하여 &#34;test&#34; 를 쓴 뒤 pFile 버퍼를 비우고 다시 파일로 부터 읽어온다.
</span><span class="cm">이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/fflush/
</span><span class="cm">에서 가져왔습니다.
</span><span class="cm">*/</span>
<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">char</span> <span class="n">mybuffer</span><span class="p">[</span><span class="mi">80</span><span class="p">]</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">FILE</span> <span class="o">*</span> <span class="n">pFile</span><span class="p">;</span>
    <span class="n">pFile</span> <span class="o">=</span> <span class="n">fopen</span> <span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">example.txt</span><span class="s">&#34;</span><span class="p">,</span><span class="sa"></span><span class="s">&#34;</span><span class="s">r+</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pFile</span> <span class="o">=</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">perror</span> <span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Error opening file</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

    <span class="k">else</span> <span class="p">{</span>
        <span class="n">fputs</span> <span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">test</span><span class="s">&#34;</span><span class="p">,</span><span class="n">pFile</span><span class="p">)</span><span class="p">;</span>
        <span class="n">fflush</span><span class="p">(</span><span class="n">pFile</span><span class="p">)</span><span class="p">;</span>
        <span class="n">fgets</span> <span class="p">(</span><span class="n">mybuffer</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="n">pFile</span><span class="p">)</span><span class="p">;</span>
        <span class="n">puts</span> <span class="p">(</span><span class="n">mybuffer</span><span class="p">)</span><span class="p">;</span>
        <span class="n">fclose</span> <span class="p">(</span><span class="n">pFile</span><span class="p">)</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre><p>실행 결과</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile10.uf.tistory.com%2Fimage%2F202412114B725620428B8C' alt=''><p>파일에 쓰여진 모습</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1560F8134B725637318657' alt=''><p>위 소스 코드가 어떻게 작동하는지 잠깐 설명하자면, 파일을 "r+" 형식으로 오픈했다면 한 개의 스트림을 이용하여 파일 쓰기와 읽기를 동시에 수행할 수 있다. 다만, C 표준에 따르면 "r+" 형식으로 오픈한 파일에서 파일을 읽은 다음에 쓰기를 하려면 파일 위치 표시자 설정 함수 (fseek,fsetpos,rewind) 들을 호출하거나 fflush 함수를 호출해야 한다. 그렇지 않을 경우 오류가 발생하게 된다. 마찬가지로 파일을 쓴 다음에 읽기를 하려면 위와 동일한 작업을 해야 한다. 위 예제의 경우 마찬가지로 파일을 "r+" 형식으로 오픈하였는데,fputs 로 "test" 를 쓴 후, 그 다음에fgets 로 파일에서 입력 받는다. 따라서 중간에 파일 위치 표시자 설정 함수를 호출하거나 fflush 함수를 호출해야 하는데 이 경우 fflush 함수를 호출하였다.참고로, 왜 실행 화면에 example.txt 로 부터 입력받은 것이 아무것도 없냐면, 파일 위치 표시자가 파일에서 test 문자열 다음 위치를 가리키고 있기 때문이다. (참고적으로 개행 문자가 출력된 것처럼 보이는데 사실puts 함수는 출력할 문자열 뒤에 자동으로 개행 문자를 붙여서 출력하기 때문에 실질적으로 출력된 것은 아무것도 없다)</p><h3><p> 연관된 함수</p></h3><ul><li><p> fclose  :  파일을 닫는다.</p></li><li><p> fopen   : 파일을 연다.</p></li><li><p> setbuf  : 스트림 버퍼를 지정한다.</p></li><li><p> setvbuf  :  스트림 버퍼링 모드를 설정한다.</p></li></ul><p>공감sns신고저작자표시	<rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">		<Work rdf:about="">			<license rdf:resource="http://creativecommons.org/licenses/by-fr/2.0/kr/" />		</Work>		<License rdf:about="http://creativecommons.org/licenses/by-fr/">			<permits rdf:resource="http://web.resource.org/cc/Reproduction"/>			<permits rdf:resource="http://web.resource.org/cc/Distribution"/>			<requires rdf:resource="http://web.resource.org/cc/Notice"/>			<requires rdf:resource="http://web.resource.org/cc/Attribution"/>			<permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/>		</License>	</rdf:RDF>'C Reference >stdio.h (cstdio)' 카테고리의 다른 글C 언어 레퍼런스 - freopen 함수(0)2010.02.13C 언어 레퍼런스 - fopen 함수(0)2010.02.11C 언어 레퍼런스 - fflush 함수(4)2010.02.10C 언어 레퍼런스 - fclose 함수(3)2010.02.08C 언어 레퍼런스 - perror 함수(0)2010.02.08C 언어 레퍼런스 - ferror 함수(1)2010.02.05</p><style>/* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%; }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }
</style>