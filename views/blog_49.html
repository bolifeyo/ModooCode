<pre class="chroma">아직 C 언어와 친숙하지 않다면, 씹어먹는 C 언어 강좌를 보는 것이 어떻까요 ?
</pre><p>ungetc</p><pre class="chroma">#include &lt;stdio.h&gt;  // C++ 에서는 &lt;cstdio&gt;

int ungetc(int character, FILE* stream);
</pre><p>스트림에 문자를 다시 집어 넣는다(unget)</p><p>스트림에 마지막으로 문자가 읽어들여졌던 자리에 문자(ungetc 함수에 인자로 전달된 character)가 말그대로 들어가고, 파일 위치 표시자가 감소하여 이전 위치를 가리키게 한다. 따라서, 다음 읽기 작업에서는 방금 스트림에 집어 넣어졌던 문자가 읽히기 된다. </p><p>예를 들면</p><pre class="chroma"><span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">a.txt</span><span class="s">&#34;</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">r</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

<span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

<span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="p">;</span>

<span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="p">;</span>

<span class="n">ungetc</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">a</span><span class="sc">&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span><span class="p">;</span>

<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="p">;</span>
</pre><p>을 한다면 a.txt 에 무엇이 들어 있던 간에 ch 에는 a 가 들어가게 된다. 왜냐하면 ungetc 를 실행하기 직전에 위치 표시자의 값은 2 였다. 그런데 ungetc 를 호출함으로써 위치 표시자의 값은 1 이 되고, 그 자리에 a 가 써지게 된다. 그 후 getc 함수를 호출하면 현재 파일 위치 표시자의 문자를 리턴하는데, 여기서 위치 표시자의 값은 1 이고 그 자리에 a 가 있으므로 결과적으로 ch 에는 a 가 들어간다. 물론, a 가 써진다는 말은 파일에 실질적으로 a 가 기록되는 것이 아니라 버퍼에 써지는 것이다. </p><p>unget 함수를 여러번 호출하게 되면 나중 읽기작업에서 호출된 역순으로 출력된다. 예를 들어</p><pre class="chroma"><span class="n">ungetc</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">a</span><span class="sc">&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span><span class="p">;</span>

<span class="n">ungetc</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">b</span><span class="sc">&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span><span class="p">;</span>

<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// ch 에는 b 가 들어간다.
</span><span class="c1"></span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// ch 에는 a 가 들어간다.
</span><span class="c1"></span></pre><p>주의할 점은 unget 함수를 여러번 호출하여서 중간에 파일 위치 표시자의 값이 0 이 된다면 그 이후에 호출된 unget 함수들은 모두 무시된다. 예를 들어</p><pre class="chroma"><span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">test.txt</span><span class="s">&#34;</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">r</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

<span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// 이 함수 호출 이후 위치 표시자의 값은 1
</span><span class="c1"></span>
<span class="n">ungetc</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">a</span><span class="sc">&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// 이 함수 호출 이후 값은 0
</span><span class="c1"></span>
<span class="n">ungetc</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">b</span><span class="sc">&#39;</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// 따라서 버퍼에 b 가 들어갈 수 없다.
</span><span class="c1"></span>
<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// ch 에는 a 가 들어간다.
</span><span class="c1"></span>
<span class="n">printf</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">%c</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span><span class="p">;</span>

<span class="n">ch</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span><span class="p">;</span>  <span class="c1">// ch 에는 test.txt 의 두 번째 문자가 들어간다.
</span><span class="c1"></span></pre><p>만일 EOF 표시자가 설정된 상태에서 이 함수를 호출하면 EOF 표시자는 초기화(clear) 된다.  </p><p>fseek 나 fsetpos 나 rewind 함수를 호출하면 이전에 unget 함수에 의해 들어갔었던 문자들이 모두 삭제된다. </p><p>만일 unget 함수의 character 인자로 전달된 값이 EOF 라면 입력 스트림에는 아무런 변화가 없게된다.</p><h3><p>  인자</p></h3><h3><p> character</p></h3><p>스트림에 집어 넣을 문자. 이 때, 문자는 int 로 형변환 되어 전달된다.</p><p>stream</p><p>문자를 넣을 입력 스트림의 FILE 객체를 가리키는 포인터. </p><h3><p>  리턴값</p></h3><h3><p> 성공적으로 문자가 들어간다면 들어갔던 문자가 리턴된다. </p></h3><p>실패한다면 EOF 가 리턴되고 스트림에는 아무런 변화가 없게 된다. </p><h3><p>  실행 예제</p></h3><h3><p> </p></h3><pre class="chroma"><span class="cm">/*
</span><span class="cm">
</span><span class="cm">myfile.txt 로 부터 각 문장을 입력 받되 # 로 시작하는 문장은 @ 로 대체해서
</span><span class="cm">입력받는다.
</span><span class="cm">
</span><span class="cm">이 예제는 http://www.cplusplus.com/reference/clibrary/cstdio/ungetc/
</span><span class="cm">
</span><span class="cm">에서 가져왔습니다.
</span><span class="cm">
</span><span class="cm">*/</span>

<span class="cp">#</span><span class="cp">include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">FILE</span><span class="o">*</span> <span class="n">pFile</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>

  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="p">;</span>

  <span class="n">pFile</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">myfile.txt</span><span class="s">&#34;</span><span class="p">,</span> <span class="sa"></span><span class="s">&#34;</span><span class="s">rt</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pFile</span> <span class="o">=</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">perror</span><span class="p">(</span><span class="sa"></span><span class="s">&#34;</span><span class="s">Error opening file</span><span class="s">&#34;</span><span class="p">)</span><span class="p">;</span>

  <span class="k">else</span>

  <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">pFile</span><span class="p">)</span><span class="p">)</span>

    <span class="p">{</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">pFile</span><span class="p">)</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">#</span><span class="sc">&#39;</span><span class="p">)</span>

        <span class="n">ungetc</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">@</span><span class="sc">&#39;</span><span class="p">,</span> <span class="n">pFile</span><span class="p">)</span><span class="p">;</span>

      <span class="k">else</span>

        <span class="n">ungetc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pFile</span><span class="p">)</span><span class="p">;</span>

      <span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">pFile</span><span class="p">)</span><span class="p">;</span>

      <span class="n">fputs</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">stdout</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre><p>myfile.txt 의 내용</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile2.uf.tistory.com%2Fimage%2F2040C2284B6ACA04A4744E' alt=''><p>실행 화면</p><img src='http://img1.daumcdn.net/thumb/R1920x0/?fname=http%3A%2F%2Fcfile25.uf.tistory.com%2Fimage%2F1205D2284B6ACA02032FD1' alt=''><p>위 프로그램 소스에 대해 간단히 설명을 하자면</p><pre class="chroma"><span class="n">c</span> <span class="o">=</span> <span class="n">getc</span><span class="p">(</span><span class="n">pFile</span><span class="p">)</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span><span class="o">=</span> <span class="sa"></span><span class="sc">&#39;</span><span class="sc">#</span><span class="sc">&#39;</span><span class="p">)</span>

  <span class="n">ungetc</span><span class="p">(</span><span class="sa"></span><span class="sc">&#39;</span><span class="sc">@</span><span class="sc">&#39;</span><span class="p">,</span> <span class="n">pFile</span><span class="p">)</span><span class="p">;</span>

<span class="k">else</span>

  <span class="nf">ungetc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pFile</span><span class="p">)</span><span class="p">;</span>
</pre><p>일단 getc 를 통해 pFile 에서 문장의 첫번째 문자를 읽어온다. (왜냐하면 밑의 fgets 를 통해 개행 문자가 있을 때 까지 읽어오기 때문에 getc 는 언제나 문장의 첫번째 문자를 읽어오게 된다) 이 때, 그 문자가 # 이라면 ungetc('@', pFile) 을 통해 버퍼에서 현재 '#' 가 들어 있는 위치에 @ 가 들어가게 된다. 따라서 </p><pre class="chroma"><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">pFile</span><span class="p">)</span><span class="p">;</span>

<span class="n">fputs</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">stdout</span><span class="p">)</span><span class="p">;</span>
</pre><p>를 하게 되면 buffer 에는 @ 부터 '\n' 이 나올 때 까지, 즉 한 문장의 끝까지 들어가게 된다. </p><p>이 때 주목할 점은 myfile.txt 의 내용은 전혀 바뀌지 않았다는 것이다. ungetc 함수는 단지 버퍼의 내용만을 조작하는 함수 이므로 myfile.txt 의 # 들은 결코 @ 로 바뀌지 않는다.</p><h3><p>  연관된 함수</p></h3><h3><p> </p></h3><ul><li><p> getc  :  스트림에서 문자를 받는다. fgetc :  스트림에서 문자를 받는다.putc  :  스트림에 문자를 쓴다. 공감sns신고저작자표시'C Reference > stdio.h (cstdio)' 카테고리의 다른 글C 언어 레퍼런스 - feof 함수(1)2010.02.05C 언어 레퍼런스 - clearerr 함수(0)2010.02.05C 언어 레퍼런스 - ungetc 함수(0)2010.02.04C 언어 레퍼런스 - puts 함수(0)2010.02.04C 언어 레퍼런스 - putchar 함수(0)2010.02.04C 언어 레퍼런스 - putc 함수(0)2010.02.04</p></li></ul><style>/* Background */ .chroma { background-color: #ffffff }
/* Error */ .chroma .err { color: #a61717; background-color: #e3d2d2 }
/* LineTableTD */ .chroma .lntd { vertical-align: top; padding: 0; margin: 0; border: 0; }
/* LineTable */ .chroma .lntable { border-spacing: 0; padding: 0; margin: 0; border: 0; width: auto; overflow: auto; display: block; }
/* LineHighlight */ .chroma .hl { display: block; width: 100%; }
/* LineNumbersTable */ .chroma .lnt { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* LineNumbers */ .chroma .ln { margin-right: 0.4em; padding: 0 0.4em 0 0.4em; }
/* Keyword */ .chroma .k { color: #000000; font-weight: bold }
/* KeywordConstant */ .chroma .kc { color: #000000; font-weight: bold }
/* KeywordDeclaration */ .chroma .kd { color: #000000; font-weight: bold }
/* KeywordNamespace */ .chroma .kn { color: #000000; font-weight: bold }
/* KeywordPseudo */ .chroma .kp { color: #000000; font-weight: bold }
/* KeywordReserved */ .chroma .kr { color: #000000; font-weight: bold }
/* KeywordType */ .chroma .kt { color: #445588; font-weight: bold }
/* NameAttribute */ .chroma .na { color: #008080 }
/* NameBuiltin */ .chroma .nb { color: #0086b3 }
/* NameBuiltinPseudo */ .chroma .bp { color: #999999 }
/* NameClass */ .chroma .nc { color: #445588; font-weight: bold }
/* NameConstant */ .chroma .no { color: #008080 }
/* NameDecorator */ .chroma .nd { color: #3c5d5d; font-weight: bold }
/* NameEntity */ .chroma .ni { color: #800080 }
/* NameException */ .chroma .ne { color: #990000; font-weight: bold }
/* NameFunction */ .chroma .nf { color: #990000; font-weight: bold }
/* NameLabel */ .chroma .nl { color: #990000; font-weight: bold }
/* NameNamespace */ .chroma .nn { color: #555555 }
/* NameTag */ .chroma .nt { color: #000080 }
/* NameVariable */ .chroma .nv { color: #008080 }
/* NameVariableClass */ .chroma .vc { color: #008080 }
/* NameVariableGlobal */ .chroma .vg { color: #008080 }
/* NameVariableInstance */ .chroma .vi { color: #008080 }
/* LiteralString */ .chroma .s { color: #dd1144 }
/* LiteralStringAffix */ .chroma .sa { color: #dd1144 }
/* LiteralStringBacktick */ .chroma .sb { color: #dd1144 }
/* LiteralStringChar */ .chroma .sc { color: #dd1144 }
/* LiteralStringDelimiter */ .chroma .dl { color: #dd1144 }
/* LiteralStringDoc */ .chroma .sd { color: #dd1144 }
/* LiteralStringDouble */ .chroma .s2 { color: #dd1144 }
/* LiteralStringEscape */ .chroma .se { color: #dd1144 }
/* LiteralStringHeredoc */ .chroma .sh { color: #dd1144 }
/* LiteralStringInterpol */ .chroma .si { color: #dd1144 }
/* LiteralStringOther */ .chroma .sx { color: #dd1144 }
/* LiteralStringRegex */ .chroma .sr { color: #009926 }
/* LiteralStringSingle */ .chroma .s1 { color: #dd1144 }
/* LiteralStringSymbol */ .chroma .ss { color: #990073 }
/* LiteralNumber */ .chroma .m { color: #009999 }
/* LiteralNumberBin */ .chroma .mb { color: #009999 }
/* LiteralNumberFloat */ .chroma .mf { color: #009999 }
/* LiteralNumberHex */ .chroma .mh { color: #009999 }
/* LiteralNumberInteger */ .chroma .mi { color: #009999 }
/* LiteralNumberIntegerLong */ .chroma .il { color: #009999 }
/* LiteralNumberOct */ .chroma .mo { color: #009999 }
/* Operator */ .chroma .o { color: #000000; font-weight: bold }
/* OperatorWord */ .chroma .ow { color: #000000; font-weight: bold }
/* Comment */ .chroma .c { color: #999988; font-style: italic }
/* CommentHashbang */ .chroma .ch { color: #999988; font-style: italic }
/* CommentMultiline */ .chroma .cm { color: #999988; font-style: italic }
/* CommentSingle */ .chroma .c1 { color: #999988; font-style: italic }
/* CommentSpecial */ .chroma .cs { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreproc */ .chroma .cp { color: #999999; font-weight: bold; font-style: italic }
/* CommentPreprocFile */ .chroma .cpf { color: #999999; font-weight: bold; font-style: italic }
/* GenericDeleted */ .chroma .gd { color: #000000; background-color: #ffdddd }
/* GenericEmph */ .chroma .ge { color: #000000; font-style: italic }
/* GenericError */ .chroma .gr { color: #aa0000 }
/* GenericHeading */ .chroma .gh { color: #999999 }
/* GenericInserted */ .chroma .gi { color: #000000; background-color: #ddffdd }
/* GenericOutput */ .chroma .go { color: #888888 }
/* GenericPrompt */ .chroma .gp { color: #555555 }
/* GenericStrong */ .chroma .gs { font-weight: bold }
/* GenericSubheading */ .chroma .gu { color: #aaaaaa }
/* GenericTraceback */ .chroma .gt { color: #aa0000 }
/* GenericUnderline */ .chroma .gl { text-decoration: underline }
/* TextWhitespace */ .chroma .w { color: #bbbbbb }
</style>