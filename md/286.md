-----------------
title : 씹어먹는 C++ - <16 - 1. C++ 유니폼 초기화(Uniform Initialization)>
cat_title : 16 - 1. C++ 유니폼 초기화(Uniform Initialization)
publish_date : 2019-05-23
is_published : false
tex_title : C++ Uniform Initialization
-----------------

안녕하세요 여러분! 이번 강좌에서는 C++ 11 에서 추가된 기능인 **Uniform Initialization** 에 대해 살펴보도록 하겠습니다. 아마도 여러분들은 아래와 같은 실수를 한 번쯤 하셨을 것이라 생각합니다.

```cpp
#include <iostream>

class A {
  public:
  A() {
    std::cout << "A 의 생성자 호출!" << std::endl;
  }
};

int main() {
  A a(); // ? 
}
```

성공적으로 컴파일 하였다면

```exec

```

놀랍게도 아무것도 출력되지 않습니다. 왜일까요?

```cpp
  A a(); // ? 
```

왜냐하면 사실은 위 코드가 A 의 객체 a 를 만든것이 아니라, A 를 리턴하고, 인자를 받지 않는 함수 a 를 정의한 것이기 때문입니다. 왜냐하면 C++ 의 컴파일러는 **함수의 정의처럼 보이는 것들은 모두 함수의 정의로 해석** 하기 때문입니다.

심지어 아래와 같은 코드는 더 헷갈립니다.

```cpp
#include <iostream>

class A {
 public:
  A() { std::cout << "A 의 생성자 호출!" << std::endl; }
};

class B {
 public:
  B(A a) { std::cout << "B 의 생성자 호출!" << std::endl; }
};

int main() {
  B b(A()); // 뭐가 출력될까요?
}

```

성공적으로 컴파일 하였다면

```exec
```

와 같이 아무 것도 출력되지 않습니다. 

사실 위 코드를 보면 마치 b 라는 클래스 B 의 객체를 생성하는 것 같이 보이지만, 사실은 **인자로 A 를 리턴하고 인자가 없는 함수를 받으며, 리턴 타입이 B 인 함수 b** 를 정의한 것입니다.

상당히 골치 아픈 일입니다. 이러한 문제가 발생하는 것은 () 가 함수의 인자들을 정의하는데도 사용되고, 그냥 일반적인 객체의 생성자를 호출하는데에도 사용되기 때문입니다. 

따라서 C++ 11 에서는 이러한 문제를 해결하기 위해 **균일한 초기화(Uniform Initialization)** 라는 것을 도입하였습니다.

### 균일한 초기화 (Uniform Initialization)

균일한 초기화 문법을 사용하기 위해서는 생성자를 호출하기 위해 () 를 사용하는 대신에 {} 를 사용하면 끝입니다.

```cpp
#include <iostream>

class A {
 public:
  A() { std::cout << "A 의 생성자 호출!" << std::endl; }
};

int main() {
  A a{};  // 균일한 초기화!
}
```

성공적으로 컴파일 하였다면

```exec 
A 의 생성자 호출!
```

위와 같이 제대로 생성자가 호출되었음을 알 수 있습니다. 

중괄호를 이용해서 생성자를 호출하는 문법은 동일합니다. 그냥 기존에 () 자리를 {} 로 바꿔주기만 하면 됩니다. 하지만, () 를 이용한 생성과 {} 를 이용한 생성의 경우 한 가지 큰 차이가 있는데 바로 일부 암시적 타입 변환들을 불허하고 있다는 점입니다.

예를 들어서 아래 코드를 살펴봅시다.

```cpp
#include <iostream>

class A {
 public:
  A(int x) { std::cout << "A 의 생성자 호출!" << std::endl; }
};

int main() {
  A a(3.5); // Narrow-conversion 가능
  A b{3.5}; // Narrow-conversion 불가
}
```

컴파일 하였다면 아래와 같은 오류가 발생합니다.

```compiler-warning
test.cc: In function ‘int main()’:
test.cc:10:10: error: narrowing conversion of ‘3.5e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]
   A b{3.5}; // Narrow-conversion 불가
          ^
A 의 생성자 호출!
```

보시다시피 

```cpp
  A a(3.5); // Narrow-conversion 가능
```

위 코드는 성공적으로 컴파일 되었고 x 에는 3.5 의 정수 캐스팅 버전이 3 이 전달됩니다. (한 번 아래 b 생성을 지워보고 실행해보세요.)

반면에 

```cpp
  A b{3.5}; // Narrow-conversion 불가
```

의 경우 위와 같이 `double` 인 3.5 를 `int` 로 변환할 수 없다는 오류가 발생하였습니다.

그 이유는 중괄호를 이용해서 생성자를 호출하는 경우 아래와 같은 암시적 타입 변환들이 불가능해집니다. 이들은 전부 **데이터 손실이 있는(Narrowing) 변환** 입니다.

* 부동 소수점 타입에서 정수 타입으로의 변환 (우리의 예시지요)
* `long double` 에서 double 혹은 float 으로의 변환, double 에서 float 으로의 변환.
* 정수 타입에서 부동 소수점 타입으로의 변환
  
등등이 있습니다. 자세한 예시들은 [여기](https://en.cppreference.com/w/cpp/language/list_initialization) 에서 확인할 수 있습니다.

따라서 {} 를 사용하게 된다면, 위와 같이 원하지 않는 타입 캐스팅을 방지해서 미연에 오류를 잡아낼 수 있습니다. 

{} 를 이용한 생성의 또 다른 쓰임새로 함수 리턴 시에 굳이 생성하는 객체의 타입을 다시 명시 하지 않아도 됩니다.

```cpp
#include <iostream>

class A {
 public:
   A(int x, double y) {
     std::cout << "A 생성자 호출" << std::endl;
   }
};

A func() {
  return {1, 2.3}; // A(1, 2.3) 과 동일
}

int main() {
  func();
}
```

성공적으로 컴파일 하였다면

```exec
A 생성자 호출
```

와 같이 잘 나옵니다. {} 를 이용해서 생성하지 않았더라면 A(1, 2.3) 과 같이 클래스를 명시해줘야만 했지만, {} 를 이용할 경우 컴파일러가 알아서 함수의 리턴타입을 보고 추론해줍니다.

{} 의 쓰임새는 이 뿐만이 아닙니다. 아래를 보시지요.

### 초기화자 리스트 (Initializer list)

배열을 정의할 때 우리는 다음과 같이 작성하였습니다.

```cpp
int arr[] = {1, 2, 3, 4};
```

그렇다면 중괄호를 이용해서 마찬가지 효과를 낼 수 없을까요? 예를 들면

```cpp
vector<int> v = {1, 2, 3, 4};
```

와 같이 말이지요. 근데, 놀랍게도 C++ 11 에서 부터 이와 같은 문법을 사용할 수 있게 되었습니다.

```cpp
#include <iostream>

class A {
 public:
   A(std::initializer_list<int> l) {
     for (auto itr = l.begin(); itr != l.end(); ++itr) {
       std::cout << *itr << std::endl;
     }
   }
};

int main() {
  A a = {1, 2, 3, 4, 5};
}
```

성공적으로 컴파일 하였다면

```exec
1
2
3
4
5
```

와 같이 나옵니다.

`initializer_list` 는 우리가 {} 를 이용해서 생성자를 호출할 때, 클래스의 생성자들 중에 `initializer_list` 를 인자로 받는 생성자가 있다면 전달됩니다.

`initializer_list` 를 이용하면 컨테이너들을 정의할 때 사용될 수 있습니다. 예를 들어서

```cpp
#include <iostream>
#include <map>
#include <string>
#include <vector>

template <typename T>
void print_vec(const std::vector<T>& vec) {
  std::cout << "[";
  for (const auto& e : vec) {
    std::cout << e << " ";
  }
  std::cout << "]" << std::endl;
}

template <typename K, typename V>
void print_map(const std::map<K, V>& m) {
  for (const auto& kv : m) {
    std::cout << kv.first << " : " << kv.second << std::endl;
  }
}

int main() {
  std::vector<int> v = {1, 2, 3, 4, 5};
  print_vec(v);

  std::cout << "----------------------" << std::endl;
  std::map<std::string, int> m = {
      {"abc", 1}, {"hi", 3}, {"hello", 5}, {"c++", 2}, {"java", 6}};
  print_map(m);
}
```

성공적으로 컴파일 하였다면

```exec
[1 2 3 4 5 ]
----------------------
abc : 1
c++ : 2
hello : 5
hi : 3
java : 6
```

와 같이 나옵니다. 

```cpp
  std::vector<int> v = {1, 2, 3, 4, 5};
```

vector 의 경우 생각했던대로, vector 의 원소들을 그냥 나열해주면 됩니다. 마치 이전에 배열을 정의할 때 처럼 말이지요.

```cpp
  std::map<std::string, int> m = {
      {"abc", 1}, {"hi", 3}, {"hello", 5}, {"c++", 2}, {"java", 6}};
```

map 의 경우도 비슷합니다. 