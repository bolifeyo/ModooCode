----------------
title : 씹어먹는 C++ - <20 - 3. 코드 부터 실행 파일 까지 - 링킹 (Linking)>
cat_title : 20 - 3. 코드 부터 실행 파일 까지 - 링킹 (Linking)
----------------

[앞선 강의](/320) 에서 링킹 과정에서 목적 코드들에 정의된 심볼들 (함수들이나 객체들) 의 위치를 확정 시킨다고 하였습니다.

이 때 C++ 에서 심볼들의 위치들을 정할 때 어떠한 방식으로 정할지 알려주는 키워들이 있는데 이들을 바로 *Storage class specifier* 라고 합니다. 굳이 번역하자면 **저장 방식 지정자** 라고 부르는 것이 좋을 것 같습니다.

### 저장 방식 지정자 (Storage class specifier)

C++ 에서 허용 하는 Storage class specifier 들은 아래와 같이 총 4 가지가 있습니다.

* static
* thread_local
* extern
* mutable (이 녀석의 경우 저장 기간과 링크 방식에 영향을 주지는 않습니다.)

이전에는 auto 와 register 지정자들도 있었는데 이들은 각각 C++ 11 과 C++ 17 에서 사라졌습니다.  이 키워드들을 통해 심볼들의 두 가지 중요한 정보들을 지정할 수 있습니다. 바로 저장 기간 (Storage duration) 과 링크 방식 (Linkage) 입니다. 각각이 무엇인지 아래에서 살펴보도록 하겠습니다.

### 저장 기간 (Storage duration)

프로그램에서의 모든 객체들의 경우 반드시 아래 넷 중에 한 가지 방식의 저장 기간을 가지게 됩니다.

#### 자동 (automatic) 저장 기간

여기에 해당하는 객체들의 경우 보통 `{}` 안에 정의된 녀석들로 코드 블록을 빠져나가게 되면 자동으로 소멸하게 됩니다. static, extern, thread_local 로 지정된 객체들 이외의 모든 지역 객체들이 바로 이 자동 저장 기간을 가지게 됩니다. 쉽게 말해 우리가 흔히 생각하는 **지역 변수**들이 여기에 해당됩니다.

```cpp-formatted
int func() {
  int a;
  SomeObject x;

  {
    std::string s;
  }

  static int not_automatic;
}
```

위 경우 a, x, s 모두 automatic 저장 기간을 가집니다. 반면에 not_automatic 는 아닙니다.

#### static 저장 기간

static 저장 기간에 해당하는 객체들의 경우 **프로그램이 시작할 때 할당** 되고, **프로그램이 끝날 때** 소멸되는 친구들입니다. 그리고 static 객체들은 프로그램에서 유일하게 존재합니다. 예를 들어서 지역 변수의 경우 만일 여러 쓰레드에서 같은 함수를 실행한다면 같은 지역 변수의 복사본들이 여러 군데 존재하겠지만 static 객체들은 이 경우에도 유일하게 존재합니다.

보통 함수 밖에 정의된 것들이나 (즉 namespace 단위에서 정의된 것들) static 혹은 extern 으로 정의된 객체들이 static 저장 기간을 가집니다. 참고로 `static` 키워드와 **static 저장 기간** 을 가진다는 것을 구분해야 합니다. `static` 키워드가 붙은 객체들이 static 저장 기간을 가지는 것은 맞지만, 다른 방식으로 정의된 것들도 static 저장 기간을 가질 수 있습니다. 

예를 들어서

```cpp
int a; // 전역 변수 static 저장 기간
namespace ss {
  int b; // static 저장 기간
}

extern int a; // static 저장 기간
int func() {
  static int x; // static 저장 기간
}
```

위와 같이 여러가지 방식으로 정의된 객체들이 `static` 저장 기간을 가지게 됩니다.

#### thread 저장 기간

thread 저장 기간에 해당하는 객체들의 경우 **쓰레드가 시작할 때** 할당 되고, **쓰레드가 종료될 때** 소멸되는 객체들입니다. 각 쓰레드들이 해당 객체들의 복사본들을 가지게 됩니다. thread_local 로 선언된 객체들이 이 thread 저장 기간을 가질 수 있습니다. 

```cpp
#include <iostream>
#include <thread>

thread_local int i = 0;

void g() {
  std::cout << i;
}

void threadFunc(int init) {
  i = init;
  g();
}

int main() {
  std::thread t1(threadFunc, 1);
  std::thread t2(threadFunc, 2);
  std::thread t3(threadFunc, 3);

  t1.join();
  t2.join();
  t3.join();

  std::cout << i ;
}
```

```exec
3120
```

예를 들어서 위 예제를 살펴봅시다. 아마 몇 번 실행하다보면 1230, 2130, 3120 등과 같은 결과를 볼 수 있을 것입니다. 그 이유는 thread_local 로 정의된 `i` 가 각 쓰레드에 유일하게 존재하기 때문이죠. 마치 정의는 전역 변수인 것 처럼 정의되어 있지만, 실제로는 각 쓰레드에 하나씩 복사본이 존재하게 되고, 각 쓰레드 안에서 해당 `i` 를 전역 변수인것마냥 참조할 수 있게 됩니다.

#### 동적 (Dynamic) 저장 기간

동적 저장 기간의 경우 동적 할당 함수를 통해서 할당 되고 해제되는 객체들을 의미 합니다. 대표적으로 new 와 delete 로 정의되는 객체들을 의미하지요.

### 링크 방식 (Linkage)

앞선 저장 방식이 **객체** 들에게만 해당되는 내용이였다면 링크 방식의 경우 C++ 의 모든 객체, 함수, 클래스, 템플릿, 이름 공간 등등을 지칭하는 이름들에 적용되는 내용입니다. C++ 에선 아래와 같은 링크 방식들을 제공합니다. 이 링크 방식에 따라서 어떤 이름이 어디에서 사용될 수 있는지 지정할 수 있습니다.

#### 링크 방식 없음 (No linkage)

블록 스코프 (`{}`) 안에 정의되어 있는 이름들이 이 경우에 해당합니다. (extern 으로 지정되지 않는 이상)

