-----------------
title : 씹어먹는 C++ - <17 - 3. 난수 생성(<random>)과 시간 관련 라이브러리(<chrono>) 소개>
cat_title : 17 - 3. 난수 생성(<random>)과 시간 관련 라이브러리(<chrono>) 소개
-----------------

안녕하세요 여러분! 이번 강좌에서는 C++ 11 에 추가된 난수(Random number)를 쉽게 생성할 수 있도록 도와주는 `<random>` 라이브러리와 시간 관련 데이터를 다룰 수 있게 도와주는 `<chrono>` 라이브러리를 살펴보도록 하겠습니다.

아무래도 C 언어를 먼저 접한 분들은 C++ 에서도 난수 생성이나 날짜 관련 계산을 위해 C 라이브러리 (`time.h` 이나 `stdlib.h`) 를 사용하는 경우가 종종 있는데 이번 기회에 왜 C++ 라이브러리를 사용해야만 하는지 짚고 넘어가도록 할 것입니다.

### C 스타일의 난수 생성의 문제점

아래는 C 스타일로 0 부터 99 까지의 난수를 생성하는 코드 입니다.

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
  srand(time(NULL));

  for (int i = 0; i < 5; i++) {
    printf("난수 : %d \n", rand() % 100);
  }
  return 0;
}
```

성공적으로 컴파일 하였다면

```exec
난수 : 75
난수 : 95
난수 : 20
난수 : 47
난수 : 41
```

와 같이 나옵니다. 참고로 위 코드는 엄밀히 말하자면 진짜 난수를 생성하는 것이 아니라 **마치 난수 처럼 보이는** 의사 난수 (pseudo random number) 을 생성하는 코드 입니다. 컴퓨터 상에서 완전한 무작위로 난수를 생성하는 것은 생각보다 어렵습니다. 그 대신에, 첫 번째 수 만 무작위로 정하고, 나머지 수들은 그 수를 기반으로 여러가지 수학적 방법을 통해서 마치 **난수 처럼 보이지만 실제로는 무작위로 생성된 것이 아닌** 수열들을 만들어내게 됩니다.

무작위로 정해진 첫 번째 수를 시드(seed) 라고 부르는데, C 의 경우 srand 를 통해 seed 를 설정할 수 있습니다. 우리의 경우 time(NULL) 을 통해 프로그램을 실행했던 초를 시드값으로 지정하였습니다. 그리고 rand() 는 호출 할 때 마다 시드값을 기반으로 무작위 처럼 보이는 수열을 생성하게 되죠.

하지만 위 코드는 여러가지 문제점들이 있습니다.

#### 시드값이 너무 천천히 변한다.

보시다시피 시드값으로 현재의 *초* 를 지정하였습니다. 이 말은 즉슨 같은 시간대에 시작된 프로그램의 경우 모두 같은 의사 난수 수열을 생성한다는 점입니다. 만일 여러가지 프로그램들이 같이 돌아가는 시스템에서 위 코드를 사용하였다면 아마 같은 난수열을 생성하는 프로그램이 생기게 될 것입니다.

#### 0 부터 99 까지 균등하게 난수를 생성하지 않는다.

위 코드에서 우리가 0 부터 99 까지 난수를 생성하기 위해서 

```cpp
    printf("난수 : %d \n", rand() % 100);
```

와 같이 하였습니다. 문제는 rand() 가 리턴하는 값이 0 부터 RAND_MAX 라는 점입니다. 물론 rand() 가 0 부터 RAND_MAX 까지의 모든 값들을 같은 확률로 난수를 생성하지만, 100 으로 나눈 나머지는 꼭 그러라는 법이 없습니다. 예를 들어서 RAND_MAX 가 128 이라고 합시다. 그렇다면 1 의 경우 rand() 가 리턴한 값이 1 이거나 101 일 때 생성되지만 50 의 경우 rand() 가 리턴한 값이 50 일 때만 생성됩니다. 따라서 1 이 뽑힐 확률이 50 이 뽑힐 확률 보다 2 배나 높게 됩니다.

#### rand() 자체도 별로 뛰어나지 않다.

무엇보다도 C 의 rand() 함수는 [선형 합동 생성기 (Linear congruential generator)](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95_%ED%95%A9%EB%8F%99_%EC%83%9D%EC%84%B1%EA%B8%B0) 이라는 알고리즘을 바탕으로 구현되어 있는데 이 알고리즘은 썩 좋은 품질의 난수열을 생성하지 못합니다. 더 깊게 설명하자면 생성되는 난수열들의 상관 관계가 높아서 일부 시뮬레이션에 사용하기에 적합하지 않습니다. 

결론적으로 말하자면

```warning
C++ 에서는 C 의 srand 와 rand 는 갖다 버리자!
```

### <random>

먼저 위 코드 처럼 0 부터 99 까지의 난수를 생성하는 코드를 C++ 의 <random> 라이브러리를 사용해서 어떻게 작성하는지 살펴보도록 하겠습니다.

```cpp
#include <iostream>
#include <random>

int main() {
  // 시드값을 얻기 위한 random_device 생성.
  std::random_device rd;

  // random_device 를 통해 난수 생성 엔진을 초기화 한다.
  std::mt19937 gen(rd());

  // 0 부터 99 까지 균등하게 나타나는 난수열을 생성하기 위해 균등 분포 정의.
  std::uniform_int_distribution<int> dis(0, 99);

  for (int i = 0; i < 5; i++) {
    std::cout << "난수 : " << dis(gen) << std::endl;
  }
}
```

성공적으로 컴파일 하였다면

```exec
난수 : 77
난수 : 11
난수 : 45
난수 : 72
난수 : 3
```

자 그렇다면 위 코드를 하나 하나씩 살펴보도록 하겠습니다.

```cpp
  // 시드값을 얻기 위한 random_device 생성.
  std::random_device rd;
```

앞서 C 의 경우 time(NULL) 을 통해서 시드값을 지정하였지만 이는 여러가지 문제점이 있었습니다. C++ 에서는 좀더 양질의 시드값을 얻기 위해 random_device 라는 것을 제공합니다.

대부분의 운영체제에는 진짜 난수값들을 얻어낼 수 있는 여러가지 방식들을 제공하고 있습니다. 예를 들어서 리눅스의 경우 /dev/random 나 /dev/urandom 을 통해서 난수값을 얻을 수 있습니다. 이 난수값은, 이전에 우리가 이야기 하였던 무슨 수학적 알고리즘을 통해 생성되는 가짜 난수가 아니라 정말로 컴퓨터가 실행하면서 마주치는 무작위적인 요소들 (예를 들어 장치 드라이버들의 noise) 을 기반으로한 진정한 난수를 제공합니다.

이 운영체제에서 제공하는 *진짜* 난수의 경우 컴퓨터가 주변의 환경과 무작위적으로 상호작용하면서 만들어지는 것이기 때문에 의사 난수보다 난수를 생성하는 속도가 매우 느립니다. 따라서 시드값처럼 난수 엔진을 초기화 하는데 사용하고, 그 이후의 난수열은 난수 엔진으로 생성하는 것이 적합합니다.

```cpp
  // random_device 를 통해 난수 생성 엔진을 초기화 한다.
  std::mt19937 gen(rd());
```

위와 같이 생성한 random_device 객체를 이용해서 난수 생성 엔진 객체를 정의할 수 있습니다. 만약에 random_device 대신에 그냥 여러분이 원하는 값을 시드값으로 넣어주고 싶다면 그냥

```cpp
  std::mt19937 gen(1234);
```

와 같이 해도 됩니다.

std::mt19937 는 C++ <random> 라이브러리에서 제공하는 난수 생성 엔진 중 하나로, [메르센 트위스터](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%A5%B4%EC%84%BC_%ED%8A%B8%EC%9C%84%EC%8A%A4%ED%84%B0) 라는 알고리즘을 사용합니다. 이 알고리즘은 기존에 rand 가 사용하였던 선형 합동 방식 보다 좀 더 양질의 난수열을 생성한다고 알려져있습니다. 무엇보다도 생성되는 난수들 간의 상관관계가 매우 작기 때문에 여러 시뮬레이션에서 사용할 수 있습니다.

참고적으로 <random> 라이브러리에는 위 메르센 트위스터 기반 엔진 말고도 기존의 rand 와 같이 선형 합동 알고리즘을 사용한 minstd_rand 외 여러가지 엔진들이 정의되어 있습니다. 물론 mt19937 이 훌륭한 난수를 생성하기에는 적합하지만 생각보다 객체 크기가 커서 (2KB 이상) 메모리가 부족한 시스템에서는 오히려 minstd_rand 가 적합할 수 있습니다. \sidenote{mt19937 를 생성한 이후에 난수를 생성하는 작업은 매우 빠릅니다.}

이처럼 난수 생성 엔진을 만들었지만 아직 바로 난수를 생성할 수 있는 것은 아닙니다. C++ 의 경우 어디에서 수들을 뽑아낼지 알려주는 **분포(distribution)** 을 정의해야 합니다.

앞서 우리의 경우 0 부터 99 까지 균등한 확률로 정수를 뽑아내고 싶다고 하였습니다. 따라서 이를 위해선 아래와 같이 균등 분포 (Uniform distribution) 객체를 정의해야 합니다.

```cpp
  // 0 부터 99 까지 균등하게 나타나는 난수열을 생성하기 위해 균등 분포 정의.
  std::uniform_int_distribution<int> dis(0, 99);
```

위와 같이 uniform_int_distribution<int> 의 생성자에 원하는 범위를 써넣으면 됩니다.

```cpp
  for (int i = 0; i < 5; i++) {
    std::cout << "난수 : " << dis(gen) << std::endl;
  }
```

그리고 마지막으로 균등 분포에 사용할 난수 엔진을 전달함으로써 균등 분포에서 무작위로 샘플을 뽑아낼 수 있습니다.

<random> 라이브러리에서는 균등 분포 말고도 여러가지 분포들을 제공하고 있습니다. 여기서는 다 일일히 소개하기 어렵지만 그 중 가장 많이 쓰이는 정규 분포 (Normal distribution) 만 간단히 살펴보겠습니다. (전체 목록은 [여기](https://en.cppreference.com/w/cpp/numeric/random)서 보세요.)

```cpp
#include <iomanip>
#include <iostream>
#include <map>
#include <random>

int main() {
  std::random_device rd;
  std::mt19937 gen(rd());
  std::normal_distribution<double> dist(/* 평균 = */ 0, /* 표준 편차 = */ 1);

  std::map<int, int> hist{};
  for (int n = 0; n < 10000; ++n) {
    ++hist[std::round(dist(gen))];
  }
  for (auto p : hist) {
    std::cout << std::setw(2) << p.first << ' '
              << std::string(p.second / 100, '*') << " " << p.second << '\n';
  }
}
```

성공적으로 컴파일 하였다면

```exec
-4  1
-3  38
-2 ****** 638
-1 ************************ 2407
 0 ************************************** 3821
 1 ************************ 2429
 2 ***** 595
 3  70
 4  1
```

코드를 보면 간단합니다.

```cpp
  std::normal_distribution<double> dist(/* 평균 = */ 0, /* 표준 편차 = */ 1);
```

이번에는 평균 0 이고 표준 편차가 1 인 정규 분포를 정의하였고, 

```cpp
  for (int n = 0; n < 10000; ++n) {
    ++hist[std::round(dist(gen))];
  }
```

이를 바탕으로 위와 같이 정규 분포에서 10000 개의 샘플을 무작위로 뽑아내게 됩니다. 실제로 위 그림 처럼 아름다은 정규 분포 곡선이 나옴을 확인할 수 있습니다.

자 그럼 이것으로 random 라이브러리 사용법을 간단히 알아보았습니다. 

이번에는 C++ 11 에 같이 추가된 시간 관련 데이터를 쉽게 계산할 수 있도록 도와주는 chrono 라이브러리를 살펴보도록 하겠습니다.

