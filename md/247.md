----------------
title : 모두의 알고리즘 - 2 - 1. 정렬 알고리즘의 시작
cat_title :  2 - 1. 정렬 알고리즘의 시작
path : /알고리즘
----------------

안녕하세요 여러분! 이제 부터 본격적으로 여러가지 알고리즘들에 대해 알아볼 것입니다.

이번 강좌에서는 컴퓨터에서 가장 많이 쓰인다고 볼 수 있는 **정렬(sorting)** 알고리즘에 대해 알아보겠습니다.

정렬이란, 어떠한 데이터를 순서대로 정리하는 작업을 말합니다. 여기서 데이터는, 수 데이터가 될 수 도 있고, 문자열이 될 수 도 있고, 아니면 심지어 대소 관계가 정의되어 있는 임의의 객체도 될 수 있습니다.

![caption=순서대로 정렬하는 것은 인간의 본능이다](/img/algorithm/organized.jpg)

정렬은 거의 모든 곳에서 사용 됩니다. 예컨대 수능을 보신 분들이라면 알겠지만, 성적표에 내 성적이 백분위 몇 % 인지 찍혀 있는 것을 알 수 있습니다. 이를 계산하기 위해서는, 전체 수험생의 성적을 순서대로 정렬한 뒤에, 내 성적이 몇 번째 인지만 안다면 백분위를 쉽게 알 수 있습니다.

혹은 아마존과 같은 온라인 쇼핑몰을 생각해본다면 물건들을 가격 순서대로 볼 수 도 있고, 아니면 평점 순으로도 볼 수 있을 것입니다. 이를 위해서라면, 가격 순으로 혹은 평점 순으로 정렬을 할 수 있어야겠지요.

![caption=아마존 웹사이트 예시; 가격 순, 평점 순 정렬이 가능하다](/img/algorithm/amazon.png)

게다가 정렬은 원하는 데이터를 빠른 속도로 찾을 수 있게 도와줍니다. 예컨대 사전에 있는 단어들이 무작위 순서로 나열되어 있다면 어떨까요? 우리가 원하는 단어를 찾기 위해서라면 사전의 처음 부터 끝까지 훑어 보아야될 것입니다. 이렇게 헛수고를 하지 않아도 되는 이유는 사전에 있는 단어들이 오름차순으로 정렬되어 있기 때문이지요.

실제로 컴퓨터에서도 정렬된 데이터에서의 탐색은 뒤에서 나올 **이진 탐색** 을 통해 정렬되지 않은 데이터에 비해 훨씬 빠르게 수행할 수 있습니다.

이와 같이 정렬은 수 많은 곳에서 사용되고 있습니다. 많은 컴퓨터 과학자들이 어떻게 하면 정렬을 빠르게 할 수 있을지에 대해 연구를 하였습니다.

그렇다면 어떻게 하면 정렬을 빨리 할 수 있을까요? 일단 가장 단순한 방법으로 어떻게 하면 정렬을 수행할 수 있을지 부터 생각해보도록 합시다.

### 버블 정렬 (Bubble sort)

기본적인 아이디어는 다음과 같습니다. (오름차순 - 커지는 순서대로 정렬하는 경우. 예를 들어서 3, 2, 1, 4 를 1, 2, 3, 4 로 정렬한다.)

> 가장 큰 원소를 배열 맨 뒤로 보내자!

그렇다면 이 아이디어를 바탕으로 코드를 짜면 바로 아래와 같습니다.

```py
def bubble_sort(data):
    for i in range(1, len(data)):
        for j in range(len(data) - i):
            if data[j] > data[j + 1]:
                data[j], data[j + 1] = data[j + 1], data[j]
    return data
```

```cpp
#include <vector>
#include <iostream>

using namespace std;

template <typename T>
void sort_list (vector<T>& data) {
    for (size_t i = 1; i < data.size(); i ++) {
        for (size_t j = 0; j < data.size() - i; j ++) {
            if (data[j] > data[j + 1]) {
                // data[j] 와 data[j + 1] 의 위치를 바꾼다
                T temp = std::move(data[j]);
                data[j] = std::move(data[j + 1]);
                data[j + 1] = std::move(temp);
            }
        }
    }
}

int main() {
    vector<int> s = {1, 9, 8, 5, 4, 6, 7, 3, 2, 10};
    sort_list(s);
    
    for (int num : s) {
        cout << num << " ";
    }
}
```

일단 첫 번째 loop 에서 i 의 값이 1 부터 len(data) - 1 까지 변합니다. 이 때 여기서 i 가 나타내는 값은 **뒤에서 부터 몇 번째 원소에 최대값을 가져다 놓으면 되냐**를 나타냅니다. 

즉 맨 처음에 i 가 1 일 때는 맨 뒤에 최대값 원소를 가져다 놓는다는 의미고, len(data) - 1 일 때에는, 맨 처음에서 두 번째 원소에 최대값 원소를 가져다 놓는다는 의미 입니다.

그리고 j 는 0 부터 최대값 원소를 가져다 놓을 위치 바로 직전까지 움직이면서, 왼쪽의 값이 오른쪽의 값 보다 크면 그 서로의 위치를 바꾸게 됩니다. 예를 들어서 1, 4, 2, 3 이라는 데이터를 정렬 하는 경우;

* **1, 4**, 3, 2 -> **1, 4**, 3, 2 
* 1, **4, 3**, 2 -> 1, **3, 4**, 3
* 1, 3, **4, 2** -> 1, 3, **2, 4**

처음에 위와 같은 과정을 거치게 됩니다. 한 가지 중요한 점은, 전체 배열에서 가장 큰 원소 (4) 가 맨 뒤로 왔다는 점입니다.

그 다음 pass 에서는 어차피 맨 뒤에는 가장 큰 원소가 자기 자리에 와있으므로, 앞의 3 개의 원소만 확인하면 됩니다. 그리고 그 3 개의 원소들 중에서 가장 큰 원소인 3 이 맨 뒤에서 두 번째 자리에 오게 되겠지요. 이 과정은 아래와 같습니다.

* **1, 3**, 2, 4 -> **1, 3**, 2, 4
* 1, **3, 2**, 4 -> 1, **2, 3**, 4

그리고 마지막으로 앞의 두 원소를 확인하며 위 정렬 알고리즘은 끝이 나게 됩니다.

그렇다면 위 알고리즘의 시간 복잡도는 어떨까요? 매우 간단합니다. 위 데이터의 수가 $$n$$ 이라 할 때 두 개의 for loop 이 각각 $$n$$ 과 $$n - 1$$ 번 돌아가므로, 총 $$n(n-1) = n^2 - n$$ 번의 연산을 수행한다고 볼 수 있습니다. 즉 Big-O 표기법으로 나타내자면, $$\mathcal{O}(n^2)$$ 이 되겠습니다.

### 병합 정렬 (Merge sort)

만약에 이미 정렬되어 있는 두 개의 데이터들이 있다고 생각해봅시다. 이 들을 어떻게 하면 쉽게 합칠 수 있을까요