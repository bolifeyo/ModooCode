----------------
title : 모두의 알고리즘 - 2 - 1. 정렬 알고리즘의 시작
cat_title :  2 - 1. 정렬 알고리즘의 시작
path : /알고리즘
----------------

안녕하세요 여러분! 이제 부터 본격적으로 여러가지 알고리즘들에 대해 알아볼 것입니다.

이번 강좌에서는 컴퓨터에서 가장 많이 쓰인다고 볼 수 있는 **정렬(sorting)** 알고리즘에 대해 알아보겠습니다.

정렬이란, 어떠한 데이터를 순서대로 정리한다는 의미를 가지고 있습니다. 여기서 데이터는, 수 데이터가 될 수 도 있고, 문자열이 될 수 도 있고, 아니면 심지어 임의의 객체도 될 수 있습니다. 물론 임의의 객체를 정렬을 하기 위해서는 두 객체의 대소 관계를 따로 정의해줘야 겠지만, 이를 정의하기만 하면 이 역시 정렬을 할 수 있게 됩니다.

![caption=순서대로 정렬하는 것은 인간의 본능이다](/img/organized.jpeg)

그렇다면 어떻게 하면 정렬을 빨리 할 수 있을까요? 일단 가장 단순한 방법으로 어떻게 하면 정렬을 수행할 수 있을지 부터 생각해보도록 합시다.

### 버블 정렬 (Bubble sort)

기본적인 아이디어는 다음과 같습니다. (오름차순 - 커지는 순서대로 정렬하는 경우. 예를 들어서 3, 2, 1, 4 를 1, 2, 3, 4 로 정렬한다.)

> 가장 큰 원소를 배열 맨 뒤로 보내자!

그렇다면 이 아이디어를 바탕으로 코드를 짜면 바로 아래와 같습니다.

```py
def bubble_sort(data):
    for i in range(1, len(data)):
        for j in range(len(data) - i):
            if data[j] > data[j + 1]:
                data[j], data[j + 1] = data[j + 1], data[j]
    return data
```

일단 첫 번째 loop 에서 i 의 값이 1 부터 len(data) - 1 까지 변합니다. 이 때 여기서 i 가 나타내는 값은 **뒤에서 부터 몇 번째 원소에 최대값을 가져다 놓으면 되냐**를 나타냅니다. 

즉 맨 처음에 i 가 1 일 때는 맨 뒤에 최대값 원소를 가져다 놓는다는 의미고, len(data) - 1 일 때에는, 맨 처음에서 두 번째 원소에 최대값 원소를 가져다 놓는다는 의미 입니다.

그리고 j 는 0 부터 최대값 원소를 가져다 놓을 위치 바로 직전까지 움직이면서, 왼쪽의 값이 오른쪽의 값 보다 크면 그 서로의 위치를 바꾸게 됩니다. 예를 들어서 1, 4, 2, 3 이라는 데이터를 정렬 하는 경우;

* **1, 4**, 3, 2 -> **1, 4**, 3, 2 
* 1, **4, 3**, 2 -> 1, **3, 4**, 3
* 1, 3, **4, 2** -> 1, 3, **2, 4**

처음에 위와 같은 과정을 거치게 됩니다. 한 가지 중요한 점은, 전체 배열에서 가장 큰 원소 (4) 가 맨 뒤로 왔다는 점입니다.

그 다음 pass 에서는 어차피 맨 뒤에는 가장 큰 원소가 자기 자리에 와있으므로, 앞의 3 개의 원소만 확인하면 됩니다. 그리고 그 3 개의 원소들 중에서 가장 큰 원소인 3 이 맨 뒤에서 두 번째 자리에 오게 되겠지요. 이 과정은 아래와 같습니다.

* **1, 3**, 2, 4 -> **1, 3**, 2, 4
* 1, **3, 2**, 4 -> 1, **2, 3**, 4

그리고 마지막으로 앞의 두 원소를 확인하며 위 정렬 알고리즘은 끝이 나게 됩니다.

그렇다면 위 알고리즘의 시간 복잡도는 어떨까요? 매우 간단합니다. 