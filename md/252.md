-----------------
title : 씹어먹는 C ++ - <13 - 2. 자원을 공유할 때 - shared_ptr 와 weak_ptr >>
cat_title : 13 - 2. 자원을 공유할 때 - shared_ptr 와 weak_ptr
path : /C++
-----------------

이번 강좌에서는
* shared_ptr
* weak_ptr

에 대해 다룹니다.

![](/img/ChewingCpplogo.png)

안녕하세요 여러분! 지난 강좌에서는 객체를 유일하게 소유하는 스마트 포인터인 unique_ptr 에 대해서 다루어 보았습니다. 대부분의 경우 하나의 자원은 한 개의 스마트 포인터에 의해 소유되는 것이 바람직 하고, 나머지 접근은 (소유가 아닌) 그냥 일반 포인터로 처리하면 됩니다. 

하지만, 때에 따라서는 여러 개의 스마트 포인터가 하나의 객체를 같이 소유 해야 하는 경우가 발생합니다. 예를 들어서 여러 객체에서 하나의 자원을 사용하고자 합니다. 후에 자원을 해제하기 위해서는 이 자원을 사용하는 모든 객체들이 소멸되야 하는데, 어떤 객체가 먼저 소멸되는지 알 수 없기 때문에 이 자원 역시 어느 타이밍에 해제 시켜야 할 지 알 수 없게 됩니다.

따라서 이 경우, 좀더 스마트 한 포인터가 있어서, 특정 자원을 **몇 개의 객체에서 가리키는지**를 추적한 다음에, 그 수가 0 이 되야만 비로소 해제를 시켜주는 방식의 포인터가 필요합니다. 

### shared_ptr

shared_ptr 은 앞서 이야기한 방식을 정확히 수행하는 스마트 포인터 입니다. 기존에 유일하게 객체를 소유하는 unique_ptr 와는 다르게, shared_ptr 로 객체를 가리킬 경우, 다른 shared_ptr 역시 그 객체를 가리킬 수 있습니다. 예를 들어서;

```cpp
shared_ptr<A> p1 (new A());
shared_ptr<A> p2(p1); // p2 역시 생성된 객체 A 를 가리킨다.

// 반면에 unique_ptr 의 경우
unique_ptr<A> p1 (new A());
unique_ptr<A> p2 (p1); // 컴파일 오류!
```

p1 과 p2 의 경우 같이 동일한 객체인 A() 를 가리키지만, unique_ptr 의 경우 유일한 소유권만 인정되므로 컴파일 오류가 발생하게 됩니다 (dlfmf )