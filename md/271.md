-----------------
title : 씹어먹는 C ++ - <15 - 3. C++ memory order 와 atomic>
cat_title : 15 - 3. C++ memory Order 와 atomic
published : false
-----------------

### atomic

우리가 뮤텍스를 사용하는 근본적인 이유는 CPU 가 어떤 코드를 처리할 때 여러 단계에 걸쳐서 처리하기 때문에, 중간에 다른 쓰레드가 끼어들게 된다면 제대로 처리할 수 없기 때문이였습니다.

하지만, CPU 가 한 명령으로 수행할 수 있는 것이라면 굳이 뮤텍스가 필요 없습니다. 왜냐하면 어차피  명령 1 개 이기 때문에 중간에 다른 쓰레드가 끼어들 여지가 전혀 없기 때문이죠. 이를 원자처럼 쪼갤 수 없다 해서 원자적(atomic) 이라고 합니다.

재미있게도 C++ 은 몇몇 타입들에 대한 연산을 원자적으로 만들 수 있는 도구를 제공하고 있습니다. 이를 사용하면 굳이 뮤텍스가 필요 없이도 연산을 수행할 수 있게 됩니다.

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
using namespace std;

void worker(atomic<int>& counter) {
  for (int i = 0; i < 10000; i++) {
    counter ++;
  }
}

int main() {
  atomic<int> counter (0);

  vector<thread> workers;
  for (int i = 0; i < 4; i++) {
    // 레퍼런스로 전달하려면 ref 함수로 감싸야 한다 (지난 강좌 bind 함수 참조)
    workers.push_back(thread(worker, ref(counter)));
  }

  for (int i = 0; i < 4; i++) {
    workers[i].join();
  }

  cout << "Counter 최종 값 : " << counter << endl;
}
```

성공적으로 컴파일 하였다면

```exec
Counter 최종 값 : 40000
```

와 같이 잘 나옴을 알 수 있습니다.

```cpp
  atomic<int> counter (0);
```

atomic 의 템플릿 인자로 원자적으로 만들고 싶은 타입을 전달하면 됩니다.