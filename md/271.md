-----------------
title : 씹어먹는 C ++ - <15 - 3. C++ memory order 와 atomic>
cat_title : 15 - 3. C++ memory Order 와 atomic
published : false
-----------------

안녕하세요 여러분!

지난 두 강좌를 통해 C++ 에서 멀티 쓰레딩을 위해 제공하는 기본적인 요소들인 쓰레드(thread), 뮤텍스(mutex), 조건변수(condtion variable) 들의 사용법에 대해 배웠습니다. 이번 강좌에서는 이러한 기본 요소들을 조금 더 세밀하게 컨트롤 할 수 있는 몇 가지 요소들에 대해 살펴볼 것입니다.

### 메모리는 엄청 느리다.

강좌를 진행하기 전에, 컴퓨터 메모리에 관련한 몇 가지 중요한 사실들을 짚고 넘어갈 것입니다.

![caption=CPU 와 RAM](/img/cpp/14.2.1.png)

기본적으로 CPU 와 컴퓨터 메모리인 RAM 은 물리적으로 떨어져 있습니다. 따라서 CPU 가 메모리에서 데이터를 읽어 오기 위해서는 꽤 많은 시간이 걸립니다. 실제로, 인텔의 i7-6700 CPU 의 경우 최소 42 사이클 정도 걸린다고 보시면 됩니다. CPU 에서 덧셈 한 번을 1 사이클에 끝낼 수 있는데, 메모리에서 데이터 오는 것을 기다리느라, 42 번 덧셈을 연산할 시간을 놓치게 되는 것입니다.

이는 CPU 입장에 굉장한 손해가 아닐 수 없습니다. 메모리에서 데이터 한 번 읽을 때 마다 42 사이클 동안 아무것도 못한다니 말입니다.

### 캐쉬

따라서 CPU 개발자들은, 이를 보완하기 위해 **캐쉬(Cache)** 라는 것을 도입하였습니다. 캐쉬란, CPU 칩 안에 있는 조그마한 메모리라고 보시면 됩니다. 여기서 중요한 점은 램과는 다르게 CPU 에서 연산을 수행하는 부분이랑 거의 붙어 있다 싶이 해서, 읽기 / 쓰기 속도가 매우 빠르다는 점입니다.

![caption=위 그림에서 L1, L2, L3 라 표시된 것이 모두 캐쉬 입니다. CPU 에서 연산 하는 부분 (Core) 보다 캐쉬가 더 큽니다.](/img/cpp/14.3.1.png)

캐쉬의 크기는 그렇게 크지 않습니다. 요즈음 컴퓨터 램 크기가 적어도 8GB 정도는 달고 나오는 데에 비해, 인텔의 하스웰 아키텍쳐인 i7-4770 CPU 의 경우, L1 캐쉬는 32KB, L2 캐쉬는 256 KB, L3 캐쉬는 8MB 정도 됩니다. 여러분이 다른 CPU 를 쓰고 있다 하더라도 아마 큰 차이는 없을 것입니다.

하지만, L1 읽기 쓰기의 경우 단 4 사이클이면 충분 하고, L2 캐쉬는 12 사이클, L3 캐쉬는 36 사이클 정도로 메모리를 왔다 갔다 하는 것 보다 훨씬 빠른 속도로 접근할 수 있게 됩니다. 

따라서, 실제로는 다음과 같이 작동합니다. CPU 에서 가장 많이 접근하는 메모리 영역은 L1 캐쉬에 가져다 놓게 되고, 그 다음으로, 자주 접근하는 부분은 L2, 마지막으로 L3 캐쉬 순으로 놓게 된다는 것이지요.

CPU 가 특정한 주소에 있는 데이터에 접근하려 한다면, 일단 캐쉬에 있는지 확인한 후, 캐쉬에 있다면 해당 값을 읽고, 없다면 메모리 까지 갔다 오는 방식으로 진행됩니다. 이렇게 캐쉬에 있는 데이터를 다시 요청해서 시간을 절약하는 것을 *Cache hit* 이라과 하며 반대로 캐쉬에 요청한 데이터가 없어서 메모리 까지 갔다 오는 것을 *Cache miss* 라고 부릅니다.

하지만 여기서 문제가 있습니다. CPU 가 어떻게 어느 영역의 메모리에 자주 접근할 지 어떻게 아는 것일까요? 답은 **알 수 없다** 입니다. 따라서 보통 CPU 에서 캐쉬가 작동하는 방식은 다음과 같습니다.

* 메모리를 읽으면 일단 캐쉬에 저장해놓는다.
* 만일 캐쉬가 다 찾다면 특정한 방식에 따라 처리한다.

이 때 여기서 말하는 **특정한 방식** 은 CPU 마다 다른데, 대표적인 예로 가장 이전에 쓴(LRU - Least Recently Used) 캐쉬를 날려버리고 그 자리에 새로운 캐쉬를 기록하는 방식이 있습니다. 이 LRU 방식의 가장 큰 특징으로는, 최근에 접근한 데이터를 자주 반복해서 접근한다면 매우 유리하다는 점이 있습니다.

예를 들어서 캐쉬 크기가 1KB 밖에 안되고 LRU 방식을 사용하는 CPU 가 있다고 했을 때 첫 번째 코드가 더 빠르게 작동할까요? 아니면 두 번째 코드가 더 빨리 작동할까요? 두 코드는 동일한 연산을 수행합니다.

```cpp
for (int i = 0; i < 1000; i ++) {
  for (int j = 0; j < 10000; j ++) {
    s += data[j];
  }
}
```

와

```cpp
for (int j = 0; j < 10000; i ++) {
  for (int i = 0; i < 10000; i ++) {
    s += data[j];
  }
}
```

답은 두 번째 방식입니다. 왜냐하면 첫 번째 경우에서 data[0] 를 접근하는 것을 생각해봅시다. 일단 첫 번째 루프에서 data[0] 는 캐쉬에 들어가게 됩니다. 하지만, CPU 캐쉬가 매우 작기 때문에 j = 256 이 되었을 때 data[0] 는 캐쉬에서 사라지게 되지요 (1KB = 1024 byte = int 256 개). 

따라서 i = 1 인 루프에서 data[0] 에 다시 접근했을 때 이미 data[0] 는 캐쉬에서 사라진 이후기에 Cache Miss 가 발생하게 됩니다. 따지고 보면 data 원소의 모든 접근이 Cache miss 가 되서 느리겠지요.

반면에 후자의 경우 data[0] 을 10000 번 연속으로 접근하므로, 처음에 접근할 때 빼고 나머지 9999 번 접근이 Cache hit 이 되어서 빠르게 덧셈을 수행할 수 있게 됩니다.

캐쉬에 대해서는 이 정도로 줄이겠습니다. 사실 캐쉬에 대해서만 이야기해도 한 보따리는 풀 수 있지만, 이는 나중에 컴퓨터 시스템에 관한 강좌를 하게 되면다면 더 깊게 다루도록 하겠습니다.

### 컴퓨터는 사실 시키는 대로 하지 않는다.

여태까지 여러분이 코드를 작성하면, 컴파일러가 그 코드를 그대로 기계어로 번역한 다음, CPU 가 해당 번역된 기계어를 그대로 실행시킨다고 생각하셨을 것입니다.

그런데 이게 사실이 아니라 한다면 여러분은 믿을 수 있으신가요?

```cpp
int a = 0;
int b = 0;

void foo() {
    a = b + 1;
    b = 1;
}
```

위 코드를 그대로 컴파일 하였을 때, 생성되는 어셈블리는 아래와 같습니다.

![caption=같은 색깔로 나타낸 부분이, 해당 부분의 코드가 어셈블리로 컴파일 된 결과 입니다](/img/cpp/14.3.3.png)

놀랍게도 `a = b + 1` 부분의 실행이 채 끝나기 전에 `b = 1` 이 먼저 실행이 끝나게 됩니다.

![caption=그런데 그것이 실제로 일어났습니다.](/img/cpp/14.3.2.jpg)

물론, 위 `foo` 함수의 입장에선 크게 문제는 없습니다. 왜냐하면, 최종적으로는 `a` 에는 1 이, `b` 도 1 이 들어 있을테니 말이지요. 

하지만, 만약에 다른 쓰레드가 있어서 `a` 와 `b` 의 값을 확인하였을 때, 코드가 순서대로 실행되었더라면 `b` 가 1 이면 `a` 도 1 이어야하지만, `a` 가 0 인데, `b` 가 1 일 수 있다는 말입니다!

그렇다면 컴파일러는 도대체 왜 위와 같이 명령어를 재배치 한 것일까요? 이는 현대의 CPU 한 번에 한 명령어씩 실행하는 것이 아니기 때문입니다.

#### CPU 파이프라이닝 (pipelining)

여러분이 빨래를 하는 과정을 생각해봅시다. 

먼저 빨래를 세탁기에 넣어야 하고, 세탁이 끝나면, 건조기에 넣어야 하고, 마지막으로 건조가 끝나면 빨래를 잘 개어야 겠지요. 위와 같이 빨래라는 과정은 여러 단계를 거쳐야 합니다.

![caption=비효율적으로 빨래를 하는 방법](/img/cpp/14.3.4.png)

그렇다면 여러 바구니의 빨래를 한다고 해봅시다. 한 가지 방법은 위 그림처럼 한 단계씩 차례대로 하는 방법입니다. 한 바구니 빨래를 세탁 - 건조 - 빨래 개기 한 후에, 다른 바구니의 빨래를 하는 것이지요.

하지만 위와 같은 방식은 효율적이지 않습니다. 왜냐하면 빨래를 건조기에 넣게 된다면, 세탁기가 비어 있으므로, 그 사이에 다른 빨래를 또 세탁할 수 있기 때문이지요! 따라서 효율적으로 빨래를 하는 방식은 아래와 같을 것입니다.

![caption=효율적으로 빨래를 하는 방법](/img/cpp/14.3.5.png)

위와 같이 모든 단계의 작업들을 쉬지 않고 계속 돌릴 수 있습니다. 즉, 이전의 방식은 효율이 33% 였다면, 새로운 방식의 경우 모든 단계를 100% 사용할 수 있게 되지요. 이와 같이, 한 작업 (세탁 - 건조 - 개기) 이 끝나기 전에, 다음 작업을 시작하는 방식으로 동시에 여러 개의 작업을 동시에 실행하는 것을 **파이프라이닝(pipelining)** 이라고 합니다.

CPU 도 마찬가지입니다. 실제 CPU 에서 명령어를 실행할 때 여러 단계를 거치게 됩니다. 명령어를 읽어야 하고 (fetch), 읽은 명령어가 무엇 인지 해석해야 하고 (decode), 해석된 명령어를 실행하고 (execute), 마지막으로 결과를 써야 하지요 (write).

CPU 역시 정확히 동일한 방법으로 명령어를 처리합니다.

![caption=CPU 의 파이프라이닝; 알고보면 빨래하는 것과 다를바가 없다.](/img/cpp/14.3.6.png)

위 그림에서는 각 단계의 실행 속도가 동일한 것 처럼 나타났지만, 실제로는 실행 부분의 실행 속도는 명령어마다 천차 만별입니다. 따라서, 만일 매우 실행 시간이 오래 걸리는 명령어가 있다면, 해당 작업 때문에 다른 명령어들이 쫙 밀리게 되겠지요.

예컨대, 세탁이나 빨래 개기는 30분 밖에 안걸리는데 건조가 3시간이 걸린다면, 건조기 기다리느라 빨래를 계속 할 수 없는 것과 마찬가지 입니다 (세탁이 끝난 빨래를 쌓아 놓을 수 없다는 전제하에)

따라서, 컴파일러는 우리가 어떠한 최대한 CPU 의 파이프라인을 효율적으로 활용할 수 있도록 명령어를 재배치하게 됩니다. 물론 전제 조건은 명령어를 재배치 하더라도 최종 결과물은 당연히도 달라지면 안되겠지요. 문제는 컴파일러가 명령어를 재배치 할 때, 다른 쓰레드들을 고려하지 않는다는 점입니다. 따라서 우리의 `foo` 함수 처럼, 멀티 쓰레드 환경에서는 예상치 못한 결과가 나올 수 도 있습니다.

#### 과연 컴파일러만 재배치를 할까?

한 가지 더 재미있는 점은, 꼭 컴파일러만이 명령어를 재배치하는게 아니라는 점입니다. 예를 들어서 다음과 같은 두 명령을 생각해봅시다.

```cpp
a = 1; // 캐쉬에 없음
b = 1; // 캐쉬에 있음
```

`a = 1` 의 경우 현재 `a` 가 캐쉬에 없으므로, 매우 오래 걸립니다. 반면에 `b = 1;` 의 경우 현재 `b` 가 캐쉬에 있기 때문에 빠르게 처리할 수 있겠지요. 따라서 

### 원자성(atomic)

우리가 뮤텍스를 사용하는 근본적인 이유는 CPU 가 어떤 코드를 처리할 때 여러 명령에 걸쳐서 처리하기 때문에, 중간에 다른 쓰레드가 끼어들게 된다면 제대로 처리할 수 없기 때문이였습니다.

하지만, CPU 가 단 한 번의 명령으로 수행할 수 있는 것이라면 굳이 뮤텍스가 필요 없습니다. 왜냐하면 어차피 명령 1 개 이기 때문에 중간에 다른 쓰레드가 끼어들 여지가 전혀 없기 때문이죠. 이를 원자처럼 쪼갤 수 없다 해서 원자적(atomic) 이라고 합니다.

재미있게도 C++ 은 몇몇 타입들에 대한 연산을 원자적으로 만들 수 있는 도구를 제공하고 있습니다. 이를 사용하면 굳이 뮤텍스가 필요 없이도 연산을 수행할 수 있게 됩니다.

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
using namespace std;

void worker(atomic<int>& counter) {
  for (int i = 0; i < 10000; i++) {
    counter ++;
  }
}

int main() {
  atomic<int> counter (0);

  vector<thread> workers;
  for (int i = 0; i < 4; i++) {
    // 레퍼런스로 전달하려면 ref 함수로 감싸야 한다 (지난 강좌 bind 함수 참조)
    workers.push_back(thread(worker, ref(counter)));
  }

  for (int i = 0; i < 4; i++) {
    workers[i].join();
  }

  cout << "Counter 최종 값 : " << counter << endl;
}
```

성공적으로 컴파일 하였다면

```exec
Counter 최종 값 : 40000
```

와 같이 잘 나옴을 알 수 있습니다.

```cpp
  atomic<int> counter (0);
```

atomic 의 템플릿 인자로 원자적으로 만들고 싶은 타입을 전달하면 됩니다.