-----------------
title : 씹어먹는 C++ - <17 - 1. type_traits 라이브러리 소개>
cat_title : 17 - 1. type_traits 라이브러리 소개
is_published : false
-----------------

안녕하세요 여러분! 이번 강좌에서는 C++ 에서 타입 관련 연산을 위한 **템플릿 메타 함수** 들을 제공해주는 type_traits 라이브러리에 대해서 알아보도록 하겠습니다. 

### 공포의 템플릿

아무래도 여기 까지 강좌를 보신 분들이라면 조금 복잡한 C++ 코드를 여러 경로에서 접해 보셨을 것입니다. 그렇다면 아마 아래와 같은 혐오스러운 템플릿 코드도 보셨을 테지요.

```cpp
template<class _CharT, class _Traits, class _Yp, class _Dp>
typename enable_if
<
    is_same<void, typename __void_t<decltype((declval<basic_ostream<_CharT, _Traits>&>() << declval<typename unique_ptr<_Yp, _Dp>::pointer>()))>::type>::value,
    basic_ostream<_CharT, _Traits>&
>::type
operator<<(basic_ostream<_CharT, _Traits>& __os, unique_ptr<_Yp, _Dp> const& __p)
{
    return __os << __p.get();
}
```

아마 위 코드를 보신 여러분들의 속마음은..

![caption=WTF](/img/cpp/wtf.jpg)

와 같겠죠. 아니 저게 도대체 뭐야!

위 코드는 libc++ 라이브러리에서 가져온 코드로, unique_ptr 의 basic_ostream 의 operator<< 연산자를 구현한 것입니다. 도대체 왜 C++ 개발자들은 저런 혐오스러운 코드를 작성하는 것일까요?

사실 type_traits 라이브러리들의 **템플릿 메타 함수 (template meta function)**들을 잘 이해만 한다면 위와 같은 코드는 무리없이 해석할 수 있습니다.

### 템플릿 메타 함수

템플릿 메타 함수란, 사실 함수는 아니지만 마치 함수 처럼 동작하는 탬플릿 클래스들을 이야기 합니다. 이들이 **메타** 함수인 이유는 보통의 함수들은 *값* 에 대해 연산을 수행하지만, 메타 함수는 *타입* 에 대해 연산을 수행한다는 점이 조금 다릅니다. 

예를 들어서 어떤 수가 음수인지 아닌지 판별하는 함수 `is_negative` 가 있다고 해봅시다. 그렇다면 이 함수는 아래 처럼 사용할겁니다.

```cpp
if (is_negative(x)) {
  // Do something...
}
```

템플릿 메타 함수도 매우 비슷합니다. 예를 들어서 어떤 타입이 void 인지 아닌지 판단하는 is_void 함수가 있다고 해봅시다. 그렇다면 이 함수는 아래와 같이 사용하게 됩니다.

```cpp
// 어떤 타입 T 가 있어서
if (is_void<T>::value) {
  // Do something
}
```

보시다시피 일반적인 함수와 몇 가지 차이점이 있습니다. 가장 중요한 점은 템플릿 메타 함수들은 실제론 **함수가 아니라는 점** 입니다. 만일 함수였다면 `()` 를 통해서 호출을 했겠지요. 하지만 is_void 는 그렇지 않습니다. 아래에서 살펴보겠지만 실제론 is_void 는 

그럼 이제 가장 핵심적인 템플릿 함수인 enable_if 부터 살펴보도록 하겠습니다.

### enable_if

여러분이 vector 클래스의 제작자라고 해봅시다. 그렇다면 vector 의 생성자로 아래 두 가지 형태를 제공할 것입니다.

```cpp
template <typename T>
class vector {
    public:
    // element 가 num 개 들어있는 vector 를 만든다.
    vector(size_t num, const T& element);

    // 반복자 start 부터 end 까지로 벡터 생성
    template <typename Iterator>
    vector(Iterator start, Iterator end);
};
```

첫 번째 생성자는 단순하게 원소가 num 개 들어있는 vector 를 만드는 생성자이고, 두 번째 생성자는 반복자 시작과 끝을 받는 생성자 입니다. 참고로 반복자의 경우, 딱히 클래스가 따로 정해져 있는 것이 아니라 그냥 start, end, ++ 함수만 들어있는 클래스라면 반복자 처럼 사용할 수 있습니다.

그렇다면 만약에 vector 클래스의 사용자가 아래와 같은 코드를 썼다면 어떤 식으로 해석되야 할까요?

```cpp
vector<int> v(10, 3);
```

당연히도 사용자는 첫 번째 오버로드인 3 이 10 개 들어있는 벡터를 생성하기를 원했을 것입니다. 그런데 말이죠, 실제로 컴파일 해보면 아래와 같이 나옵니다.

```cpp
#include <iostream>

template <typename T>
class vector {
  public:
  vector(size_t num, const T& element) {
    std::cout << element << " 를 " << num << " 개 만들기" << std::endl;
  }

  template <typename Iterator>
  vector(Iterator start, Iterator end) {
    std::cout << "반복자를 이용한 생성자 호출" << std::endl;
  }
};

int main() {
  vector<int> v(10, 3);
}
```

성공적으로 컴파일 하였다면

```exec
반복자를 이용한 생성자 호출
```

와 같이 나옵니다. 의외지요? 사실 이렇게 나온 이유는 간단합니다. 우리가 원했던 버전의 오버로딩은 

```cpp
  vector(size_t num, const T& element) {
```

와 같이 생겼습니다. 여기서 주목할 점은 num 의 타입이 size_t 라는 점입니다. size_t 는 부호가 없는 정수 타입이지요. 문제는 `v(10, 3)` 을 했을 때 10 은 부호가 **있는** 정수라는 점입니다. 물론, C++ 컴파일러는 똑똑하기 때문에 이정도는 알아서 캐스팅 해줘서 넘어갈 수 도 있었습니다. 다만 더 나은 후보가 없다는 가정 하에 말이죠.

```cpp
  template <typename Iterator>
  vector(Iterator start, Iterator end) {
```

문제는 이 친구가 Iterator 를 int 로 오버로딩 한다면 `v(10, 3)` 를 완벽하게 매칭 시킬 수 있다는 점입니다. 따라서 결과적으로 우리의 예상과는 다르게 반복자를 이용한 생성자 호출이 선택됩니다. 