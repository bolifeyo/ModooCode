----------------
title : 씹어먹는 C++ - <21. 표준 라이브러리에서 자주 쓰이는 패턴 모음>
cat_title : 21. 표준 라이브러리에서 자주 쓰이는 패턴 모음
is_published : false
----------------

안녕하세요 여러분. 이번 강의는 약간의 부록 형식으로 표준 라이브러리에서 자주 쓰이는 패턴들을 간단한 예제 코드들과 함께 정리해 놓은 글입니다. 시간이 날 때 마다 추가해보도록 하겠습니다.

### std::vector

#### 특정 원소로 벡터 초기화 하기

```cpp
// 0 을 10 개 가지는 벡터 생성
std::vector<int> vec(10, 0);
```

한국말로 생각하면 사실 인자의 순서가 헷갈릴 여지가 있는데 (저도 이 때문에 골치아픈 버그를 낸 적이 있습니다), 영어로 생각하면 편합니다. 예를 들어서 값이 0 인 원소 10 개로 초기화 하고 싶다면 "Ten zeros" 가 되므로 `(10, 0)` 순으로 쓰시면 됩니다.

#### 벡터 뒤에 원소 추가하기

간단히 push_back 을 사용하면 됩니다.

```cpp
std::vector<int> vec;
vec.push_back(3);
```

아래 처럼 push_back 에 객체를 생성하면서 전달해도 문제 없습니다. 

```cpp
std::vector<std::unique_ptr<A>> vec;
vec.push_back(std::make_unique<A>());
```

이 과정에서 불필요한 복사나 생성이 이루어지지 않습니다. 만약에 복사 생성이 불가능한 원소의 경우 벡터에 이동 시키면서 push_back 할 수 있습니다.

```cpp
std::vector<std::unique_ptr<A>> vec;
auto a = std::make_unique<A>();
vec.push_back(std::move(a));
```

참고로 emplace_back 을 사용하는 것은 비추입니다. 옛날에 emplace_back 이 추가된 이유가 완벽한 전달(perfect forwarding) 을 통해서 불필요한 복사나 이동을 막기 위함이였는데 요즘의 컴파일러는 최적화가 잘 되어 있기 때문에 거의 대부분 push_back 을 사용했을 경우나 emplace_back 을 사용했을 경우 동일한 코드를 생성합니다. 

그런데 emplace_back 의 가장 큰 문제점은 어떤 생성자가 호출되었는지 명확하지 않다는 점입니다. 

```cpp
  std::vector<std::vector<int>> vec;
  vec.push_back(2000000);
```

예를 들어서 프로그래머가 실수로 위와 같이 2 차원 벡터에 2000000 을 push_back 하려고 했다고 봅시다. 위 코드의 경우 push_back(2000000) 를 하면 아래와 같은 오류가 발생합니다.

```compiler-warning
test.cc: In function ‘int main()’:
test.cc:7:18: error: no matching function for call to ‘std::vector<std::vector<int> >::push_back(int)’
    7 |   vec.push_back(2);
      |                  ^
In file included from /usr/include/c++/10/vector:67,
                 from test.cc:2:
/usr/include/c++/10/bits/stl_vector.h:1187:7: note: candidate: ‘void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = std::vector<int>; _Alloc = std::allocator<std::vector<int> >; std::vector<_Tp, _Alloc>::value_type = std::vector<int>]’
 1187 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
/usr/include/c++/10/bits/stl_vector.h:1187:35: note:   no known conversion for argument 1 from ‘int’ to ‘const value_type&’ {aka ‘const std::vector<int>&’}
 1187 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
/usr/include/c++/10/bits/stl_vector.h:1203:7: note: candidate: ‘void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::vector<int>; _Alloc = std::allocator<std::vector<int> >; std::vector<_Tp, _Alloc>::value_type = std::vector<int>]’
 1203 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
/usr/include/c++/10/bits/stl_vector.h:1203:30: note:   no known conversion for argument 1 from ‘int’ to ‘std::vector<std::vector<int> >::value_type&&’ {aka ‘std::vector<int>&&’}
 1203 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
```

당연하게도 20000 을 std::vector<int> 로 변환할 수 없기에 발생하는 일이지요.

반면에 emplace_back 을 할 경우

```cpp
  std::vector<std::vector<int>> vec;
  vec.emplace_back(2000000);
```

위 코드는 아무런 문제 없이 실행됩니다. 그럼 무슨 일이 일어난 것일까요? 이는 emplace_back 이 암묵적으로 std::vector<int>(2000000) 을 만들어서 넣은 것입니다! 사용자의 의도는 아마 그냥 2000000 이란 원소를 추가하고 싶었겠지만 emplace_back 을 사용했을 경우 크기가 2000000 인 벡터가 생성되어 추가됩니다. 상당히 비직관적이죠.

#### 다른 컨테이너에서 벡터 생성하기

C++ 의 모든 컨테이너들은 반복자의 시작과 끝을 인자로 받습니다. 이를 이용해서 컨테이너 사이의 변환을 쉽게 수행할 수 있습니다. 

```cpp
std::unordered_set<int> s = {1, 2, 3, 4};

// s 의 원소를 가지고 벡터 생성
std::vector<int> vec(s.begin(), s.end());
```

참고로 위 경우 vec 에는 s 의 원소들이 **복사 생성** 됩니다. 만약에 복사가 불가능하고 이동 밖에 되지 않는 객체들은 어떨까요?


