-----------------
title : 씹어먹는 C ++ - <15 - 1. 동시에 실행을 시킨다고? - C++ 쓰레드(thread)>
cat_title : 15 - 1. 동시에 실행을 시킨다고? - C++ 쓰레드(thread)
published : false
-----------------

안녕하세요 여러분! 이번 강좌에서는 여태까지 작성하였던 프로그램과 차원이 다른 프로그램을 만들어볼 것입니다. 

### 멀티 쓰레드 프로그램

여러분은 **작업 관리자** 를 실행해 보신적이 있으신가요? 아마 실행했다면, 아래와 같은 화면을 보셨을 것입니다. 

![caption=윈도우에서 나오는 작업 관리자 모습](/img/cpp/14.1.2.png)

![caption=맥에서 나오는 작업 관리자 모습](/img/cpp/14.1.1.png)

한 가지 눈여겨 볼 점은, 막대한 개수의 프로세스의 개수입니다. 프로세스란, 운영체제에서 실행되는 프로그램의 최소 단위라고 보시면 됩니다. 즉, 우리가 1 개의 프로그램을 가리킬 때 보통 **1 개의 프로세스** 를 의미하는 경우가 많습니다. \sidenote{물론 구글 크롬 처럼 한 개의 탭이 한 개의 프로세스를 차지해서, 프로그램 자체가 여러개의 프로세스로 이루어진 경우도 있습니다.}

그렇다면 이 프로세스들은 어디에서 실행될까요? 바로 컴퓨터의 두뇌라 하는 CPU 의 코어 (연산하는 부분)에서 실행되고 있습니다. 옛날 (2005년 이전) 에는 서버용이 아닌 일반 소비자용 CPU 의 경우 1 개의 코어를 가지는 것이 대부분이였습니다. 대표적으로 펜티엄 4 가 있지요. 이 말은 즉슨, CPU 가 한 번에 한 개의 연산을 수행한다는 것입니다.

근데 CPU 가 한 번에 한 가지 연산 밖에 못한다면, 도대체 그 시절에는 인터넷을 하면서 음악을 듣고, 아니면 게임을 하는 등 여러가지 일들을 어떻게 한꺼번에 하였을까요? 분명히 제 기억에는 이러한 일들이 가능했던것 같기 때문이지요. 그 비밀은 **컨텍스트 스위칭(Context switching)** 이라는 기술에 숨어 있습니다.

컴퓨터에서 프로그램이 실행될 때 겉으로 보기에는 프로그램이 연속적으로 쭈르륵 작동하는 것 처럼 보이지만 실제로는 그렇지 않습니다. 아래 그림을 보면 CPU 코어 하나에서 프로그램들이 어떻게 실행되는지 알 수 있습니다.

![caption=코어 하나에서 프로그램들의 실행 모습](/img/cpp/14.1.4.png)

보시다시피, 프로그램 하나가 쭈르륵 작동하는 것이 아니라, 프로그램 하나가 잠시 실행되었다가, 다른 프로그램으로 스위칭 되는 것을 볼 수 있습니다. 즉, CPU 는 한 프로그램을 통째로 쭉 실행시키는 것이 아니라, 이 프로그램 조금, 저 프로그램 조금씩 골라서 차례를 돌며 실행시킨다는 것을 알 수 있습니다. 

정확히 말하자면, CPU 는 그냥 운영체제가 처리하라고 시키는 명령어들을 실행할 뿐, 어떤 프로그램을 실행시키고, 얼마 동안 실행 시키고, 또 다음에 무슨 프로그램으로 스위치 할지는 운영체제가 알아서 결정하게 됩니다.

#### 쓰레드

한 가지 중요한 점은, 이 CPU 코어에서 돌아가는 프로그램 단위를 **쓰레드 (thread)** 라고 부릅니다. 즉, CPU 의 코어 하나에서는 한 번에 한 개의 쓰레드의 명령을 실행시키게 됩니다. 

한 개의 프로세스는 최소 한 개 쓰레드로 이루어져 있으며, 여러 개의 쓰레드로 구성될 수 있게 됩니다. 이렇게 여러개의 쓰레드로 구성된 프로그램을 **멀티 쓰레드 (multithread) 프로그램** 이라 합니다.

쓰레드와 프로세스의 가장 큰 차이점은 프로세스들은 서로 메모리를 공유하지 않습니다. 다시 말해, 프로세스 1 과 프로세스 2 가 있을 때, 프로세스 1 은 프로세스 2 의 메모리에 접근할 수 없고, 마찬가지로 프로세스 2 도 프로세스 1 의 메모리에 접근할 수 없습니다. 

![caption=프로세스는 서로의 메모리를 접근할 수 없지만, 같은 프로세스 내에 쓰레드 끼리는 메모리를 공유한다](/img/cpp/14.1.6.png)

하지만 쓰레드의 경우는 다릅니다. 만일 **한 프로세스 안에 쓰레드 1 과 쓰레드 2 가 있다면, 서로 같은 메모리를 공유**하게 됩니다. 예컨대, 쓰레드 1 과 쓰레드 2 가 같은 변수에 값에 접근할 수 있습니다. 

여태까지 여러분이 작성 하였던 프로그램들은 모두 한 개의 쓰레드로 구성된 싱글 쓰레드 프로그램입니다. 하지만, 많은 프로그램들이 멀티쓰레드 프로그램으로 구성되어 있는데, 맥에서 나오는 작업관리자 사진의 우측 하단에, 현재 시스템의 쓰레드 개수와 프로세스에서도 알 수 있듯이, 프로세스 개수는 348 개 인데, 총 쓰레드 수는 1711 개로 써잇습니다. 대량 프로세스 하나당 5 개의 쓰레드 들로 구성되어 있다고 생각하면 되겠네요.

### CPU 의 코어는 한 개가 아니다.

요 근래 들어서는 CPU 의 발전 방향이 코어 하나의 동작 속도를 높이기 보다는, CPU 에 장착된 코어 개수를 늘려가는 식으로 발전해왔습니다.

예를 들어서 인텔의 i5 모델의 경우 4 개의 코어가 장착되어 있습니다. 제가 사용하는 AMD 의 라이젠 모델의 경우 아래 그림과 같이 8 개의 코어를 가지고 있습니다. 참고로 SMT 라는 기술을 통해서 마치 16 개의 코어인 것 처럼 보이지만 하단에 **Cores** 를 보면 실제로는 8 개의 코어만 있다는 점을 확인할 수 있습니다.

![caption=실제론 8 코어 CPU 이지만, SMT를 통해서 16개인 것 처럼 보입니다.](/img/cpp/14.1.3.png)

그렇다면 실제 이 8 개의 코어에서 프로그램이 실행되는 모습은 아래와 같을 것입니다.

![caption=여러 코어들에서 쓰레드들이 실행되는 모습](/img/cpp/14.1.5.png)

따라서 이전에 싱글 코어 CPU 에서 아무리 멀티 쓰레드 프로그램이라 하더라도 결국에는 한 번에 한 쓰레드만 실행할 수 있었겠지만, 멀티 코어 CPU 에서는 여러개의 코어에 각기 다른 쓰레드들이 들어가 동시에 여러개의 쓰레드들을 효율적으로 실행할 수 있습니다.

### 그래서 왜 멀티 쓰레드 인데?

앞서 현대의 CPU 가 여러개의 코어를 지원함으로써 여러개의 쓰레드를 동시에 실행시킬 수 있다고 하였습니다. 그렇다면 어떨 때 프로그램을 멀티 쓰레드로 만드는 것이 유리할까요? 이에 대해 크게 두 가지 이유를 생각할 수 있습니다.

#### 병렬 가능한 (Parallelizable) 작업들

예를 들어서 1 부터 10000 까지 더하는 작업을 생각해봅시다. 만약에 단일 쓰레드 프로그램으로 짠다면 단순히 for 문으로 1 부터 10000 까지 더하는 코드를 쓰면 됩니다. 

반면에 이를 쓰레드 10 개로 만든다면 어떨까요. 예를 들어서 쓰레드 1 에서 1 부터 1000 까지 더하고, 쓰레드 2 에서 1001 부터, 2000 까지 더하고, ... 쓰레도 10 에서 9001 부터 10000 까지 더하게 한다면 어떨까요? 모든 쓰레드의 작업이 완료된 후에, 각각의 결과를 합치는 식으로 말이지요. 

![caption=쓰레드 1 개를 사용할 때와 10 개를 사용할 때](/img/cpp/14.1.7.png)

CPU 코어에서 덧셈 한 번에 1 초가 걸린다고 가정해봅시다. 그렇다면 단일 쓰레드의 경우 10000 초가 걸리게 됩니다.

하지만, 멀티 쓰레드를 사용하였을 경우 CPU 에 코어가 10 개가 있어서 각 쓰레드들이 동시에 실행될 수 만 있다면, 각 쓰레드에서 덧셈은 1000 초가 걸리고, 마지막으로 다 합칠 때 10 초가 걸려서 총 1010 초가 걸리게 됩니다.

싱글 쓰레드의 경우보다 속도가 무려 10 배가 향상된 수치입니다!

이렇게, 어떠한 작업을 여러개의 다른 쓰레드를 이용해서 좀 더 빠르게 수행하는 것을 병렬화(Paralellize) 라고 합니다. 하지만 모든 작업들이 이렇게 병렬화가 가능한 것이 아닙니다. 예를 들어서 피보나치 수열을 계산하는 프로그램을 생각해봅시다. 아마 아래와 같이 작성할 것입니다.

```cpp
int main() {
  int bef = 1, cur = 1;

  // 물론 100 번째 피보나치 항을 구한다면, int 오버플로우가 나겠지만 일단 그 점은 여기서 무시하도록 합시다.
  for (int i = 0; i < 98; i ++) {
    int temp = cur;
    cur = cur + bef;
    bef = cur;
  }
  cout << "F100 : " << cur << endl;
}
```

위와 같은 프로그램을 여러 쓰레드를 사용하는 방식으로 실행 속도를 높일 수 있을까요?

피보나치의 $$n$$ 번째 항인 $$F_n$$ 을 계산하기 위해서는 $$F_{n-1}$$ 과 $$F_{n - 2}$$ 을 알아야 합니다. 다시 말해 $$F_3$$ 을 구하기 위해서는 $$F_1$$ 과 $$F_2$$ 를 알아야 하고, $$F_4$$ 를 구하기 위해서는 $$F_3$$ 과 $$F_2$$ 를 알아야 합니다. 

예를 들어서 $$F_{3}$$ 을 쓰레드 1, $$F_4$$ 를 쓰레드 2 에서 계산한다고 생각해봅시다. 쓰레드 2 가 값을 계산하기 위해서는 $$F_3$$ 의 값이 필요합니다. 그런데, $$F_3$$ 은 쓰레드 1 에서 계산되고 있으므로, 쓰레드 1 의 연산이 끝날 때 까지 쓰레드 2 가 기다려야 합니다. 따라서 최종 실행 속도는 그냥 쓰레드 1 에서 $$F_3$$ 과 $$F_4$$ 모두를 계산하는 것과 차이가 없게 됩니다.

결과적으로 이와 같은 방법으로 피보나치 수열을 계산하는 프로그램은 병렬화 하는 것이 매우 까다롭습니다. 이러한 문제가 발생하는 근본적인 이유는 **어떠한 연산 (연산 A) 을 수행하기 위해 다른 연산 (연산 B)의 결과가 필요하기 때문** 이라 볼 수 있습니다. 이와 같은 상황을 **A 가 B 에 의존(dependent)한다** 라고 합니다.

프로그램 논리 구조 상에서 연산들 간의 의존 관계가 많을 수 록 병렬화가 어려워지고, 반대로, 다른 연산의 결과와 관계없이 독립적으로 수행할 수 있는 구조가 많을 수 록 병렬화가 매우 쉬워집니다. 

#### 대기시간이 긴 작업들

인터넷에서 웹사이트들을 긁어 모으는 프로그램을 생각해봅시다. 아마 아래와 같이 구성할 수 있을 것입니다.

```cpp
int main() {
  // 다운 받으려는 웹사이트와 내용을 저장하는 맵
  map<string, string> url_and_content;
  for (auto itr = url_and_content.begin(); itr != url_and_content.end(); itr ++) {
    const string& url = itr->first;

    // download 함수는 인자로 전달받은 url 에 있는 사이트를 다운받아 리턴한다.
    itr->second = download(url);
  }
}
```

이 임의로 만든 download 함수는 인자로 전달한 url 에 위치한 웹사이트를 다운 받아서 리턴합니다.

문제는 우리의 CPU 의 처리 속도에 비해 인터넷은 매우 느리다는 점입니다. 

우리가 흔히 ping 이라고 부르는 것은, 내가 보낸 요청이 상대 서버에 도착해서 다시 나에게 돌아오는데 걸리는 시간을 의미 합니다. 보통 우리나라 안에서 웹사이트에 요청을 보낼 시에 ping 이 30 밀리초 정도 나오고, 해외의 경우 (예컨대 미국), 150 밀리초에서 멀면 300 밀리초 까지 걸리게 됩니다. \sidenote{이 시간은 웹사이트 전체를 다운 받는데 걸리는 시간을 말하는 것이 아닙니다. 내가 다운로드 요청을 보내서, 첫 번째 응답이 돌아올 때 까지 걸리는 시간을 말합니다.}

150 밀리초라 한다면 사람 기준에서 얼마 안되는 시간처럼 보입니다. 0.15초 이기 때문이지요. 하지만, 실제로 컴퓨터는 0.15 초 동안 정말 많은 일들을 할 수 있습니다. 보통의 CPU 는 1 초에 $$10^9$$ 번 연산을 할 수 있기 때문에 0.15 초 동안 응답을 단순히 기다리기만 한다면, $$1.5 \times 10^8$$ 번 연산을 수행할 수 있는 시간을 버리게 되는 것입니다. 즉 CPU 코어를 **비효율적으로** 사용하게 되는 셈이지요. 한창 일해야될 CPU 를 놀게 놔둔다니요!

![caption=쓰레드 1 개 만을 사용할 때](/img/cpp/14.1.8.png)

하지만 만일 download 함수를 호출하는 것을 여러 쓰레드에서 부르면 어떨까요? 

![caption=쓰레드 여러개 만을 사용할 때](/img/cpp/14.1.9.png)

위 그림은 같은 코어 안에서 쓰레드들이 컨텍스트 스위칭을 통해 기다리는 시간 없이 CPU 를 최대한으로 사용하는 것을 볼 수 있습니다. 초록색 쓰레드에서 웹사이트 1 에 요청을 보낸 후, 이전에는 웹사이트 1 에서 데이터를 다운로드를 시작하기 까지 기다려야 했지만, 이 경우 분홍색 쓰레드로 컨텍스트 스위칭 되어서, 기다리는 시간을 낭비하지 않고 바로 웹사이트 2 에 요청을 보내는 것을 볼 수 있습니다.

위와 같이 처리하게 된다면 CPU 시간을 낭비하지 않고 효율적으로 작업을 처리할 수 있게 됩니다.

### C++ 에서 쓰레드 생성하기

이전에는 C++ 표준에 쓰레드가 없어서, 각 플랫폼 마다 다른 구현을 사용해야만 했습니다. 하지만 C++ 11 에 들어와서 표준에 쓰레드가 추가되면서, 쓰레드 사용이 매우 편리해졌습니다.

