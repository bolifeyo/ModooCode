----------------
title : 모두의 알고리즘 - 2 - 4. k 번째 원소를 찾는 알고리즘 - QuickSelect
cat_title :  2 - 4. k 번째 원소를 찾는 알고리즘 - QuickSelect
is_published : false
--------------

안녕하세요 여러분. 이번 강좌에서는 지난 퀵 정렬 강좌에서 배운 분할 정복 기법을 활용해서 정렬했을 때 $$k$$ 번째 원소를 빠르게 찾는 알고리즘인 QuickSelect 와 이를 보완하는 알고리즘인 Medians of medians 라는 알고리즘을 소개하려고 합니다. 

### 왜 어려운가?

일반적인 $$k$$ 에 대해 어떻게 찾을지에 대해 생각하기 전에 먼저 몇몇 케이스들을 살펴보도록 하겠습니다. 전체 원소의 개수가 $$N$$ 이라고 생각할 때, $$k$$ 가 1 이나 $$N$$ 이면 어떨까요? 이 말은 즉슨, 원소들의 최대값과 최소값을 찾는 알고리즘 말합니다.

이 경우, 최대값과 최소값을 $$\mathcal{O}(N)$$ 으로 찾을 수 있습니다. 왜냐하면 예컨대 최대값을 찾는다면, 첫 번째 원소를 최대값이라 가정한 뒤에, 전체 원소들의 나열을 쭈르륵 스캔해가면서 현재 최대값 보다 큰 원소가 나타난다면 최대값을 해당 원소로 업데이트 하면 되기 때문이지요.

그렇다면 $$k$$ 가 2 나 $$N - 1$$ 일 경우는요? 두 번째로 크거나 작은 원소는 어떻게 찾을 까요? 이번에는 그냥 후보군을 2 개로 잡으면 됩니다. 맨 앞에서 부터 원소들을 쭈르륵 스캔하면서 현재 가장 크거나 작은 원소 두 개를 기록해나가면 되는 것이지요. 따라서 공간 복잡도 $$\mathcal{O}(2)$$ 로 $$\mathcal{O}(N)$$ 으로 찾을 수 있을 것입니다.

하지만 이 방법으로는 $$k$$ 가 $$N$$ 에 비례하게 된다면 더이상 $$\mathcal{O}(N)$$ 으로 수행할 수 없게 됩니다. 예를 들어 중간값의 경우 $$k$$ 가 $$\frac{N}{2}$$ 입니다. 따라서, 후보군의 크기도 $$\frac{N}{2}$$ 이 되어야 하기 때문에, 후보군 업데이트 과정이 더이상 위 처럼 상수 시간이 될 수 없게 되서 이 방식으로는 $$\mathcal{O}(N)$$ 으로 중간값을 찾을 수 없습니다.

따라서 모든 $$k$$ 에 대해서 $$\mathcal{O}(N)$$ 으로 찾고 싶다면 다른 방법을 강구해야 합니다.

### 퀵 정렬에서 아이디어를 따오자

그렇다면 잠시 이전 아이디어는 접어두고, 한 번 퀵 정렬 방식에서 아이디어를 따와봅시다. 퀵 정렬의 코드를 살펴보면 아래와 같이 간단하게 생각할 수 있습니다.

```cpp
void quicksort(vector<T>& data, size_t start, size_t end) {
  if (start >= end) {
    return;
  }

  // 피벗을 하나 고른 뒤에
  size_t pivot_pos = choose_pivot(data, start, end);

  // 피벗을 기준으로 파티션을 수행하고 (파티션 후에 피봇의 위치가 바뀌므로
  // 새로운 피벗 위치를 리턴한다.)
  pivot_pos = partition(data, start, end, pivot_pos);

  // 피벗의 왼쪽을 정렬하고
  quicksort(data, start, pivot_pos - 1);

  // 피벗의 오른쪽을 정렬합니다.
  quicksort(data, pivot_pos + 1, end);
}
```

그렇다면 $$k$$ 번째 원소 찾기는 어떨까요? $$k$$ 번째 원소라는 뜻은, 정렬 하였을 때 자신에 앞에 원소가 $$k - 1$$ 개가 있다는 뜻입니다. 그렇다면

```cpp
  // 피벗을 기준으로 파티션을 수행하고
  pivot_pos = partition(data, start, end, pivot_pos);
```

위 시점이 끝났을 때 피벗을 기준으로 왼쪽에는 피벗보다 작은애들, 오른쪽에는 피벗보다 큰 애들이 오게 됩니다.




### 좋은 피봇을 찾기 위해서면

이 알고리즘은 **Medians of medians** 라는 알고리즘인데, [1979 년에 5 명의 걸출한 컴퓨터 과학자들 (Blum, Floyd, Pratt, Rivest, Tarjan) 에 의해 발표되었습니다](http://people.csail.mit.edu/rivest/pubs/BFPRT73.pdf). \sidenote{참고로 이 5 명의 컴퓨터 과학자들 중 Pratt 을 제외한 4 명은 컴퓨터계의 노벨상이라 불리는 튜링상을 훗날 수상하였으며, 이들 모두 자신들의 이름을 딴 알고리즘들이 있습니다.}

